Args: clang (LLVM option parsing) -regalloc=basic -debug 
Args: clang 

Features:+64bit-mode,-32bit-mode,-16bit-mode,+sse2,+cx8,+fxsr,+mmx,+sse,+sse2,+x87
CPU:x86-64
TuneCPU:generic

Subtarget features: SSELevel 2, 3DNowLevel 1, 64bit 1
G_ADD (opcode 39): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SUB (opcode 40): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MUL (opcode 41): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIV (opcode 42): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UDIV (opcode 43): 1 type index, 0 imm indices
.. opcode 43 is aliased to 42
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SREM (opcode 44): 1 type index, 0 imm indices
.. opcode 44 is aliased to 42
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UREM (opcode 45): 1 type index, 0 imm indices
.. opcode 45 is aliased to 42
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_AND (opcode 46): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_OR (opcode 47): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_XOR (opcode 48): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_IMPLICIT_DEF (opcode 49): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PHI (opcode 50): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRAME_INDEX (opcode 51): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_GLOBAL_VALUE (opcode 52): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT (opcode 53): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 54): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT (opcode 55): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 56): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR (opcode 57): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR_TRUNC (opcode 58): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONCAT_VECTORS (opcode 59): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 60): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_INTTOPTR (opcode 61): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_BITCAST (opcode 62): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREEZE (opcode 63): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_TRUNC (opcode 64): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUND (opcode 65): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_LRINT (opcode 66): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUNDEVEN (opcode 67): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_READCYCLECOUNTER (opcode 68): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LOAD (opcode 69): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXTLOAD (opcode 70): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 71): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_LOAD (opcode 72): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_SEXTLOAD (opcode 73): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_ZEXTLOAD (opcode 74): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STORE (opcode 75): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_STORE (opcode 76): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 77): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 78): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 79): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 80): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 81): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 82): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 83): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 84): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 85): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 86): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 87): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 88): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 89): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FADD (opcode 90): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FSUB (opcode 91): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FENCE (opcode 92): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 93): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRINDIRECT (opcode 94): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 95): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 96): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 97): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_TRUNC (opcode 98): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 99): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCONSTANT (opcode 100): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VASTART (opcode 101): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VAARG (opcode 102): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT (opcode 103): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT_INREG (opcode 104): 1 type index, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_ZEXT (opcode 105): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHL (opcode 106): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_LSHR (opcode 107): 2 type indices, 0 imm indices
.. opcode 107 is aliased to 106
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_ASHR (opcode 108): 2 type indices, 0 imm indices
.. opcode 108 is aliased to 106
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FSHL (opcode 109): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSHR (opcode 110): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ICMP (opcode 111): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FCMP (opcode 112): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SELECT (opcode 113): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDO (opcode 114): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDE (opcode 115): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBO (opcode 116): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBE (opcode 117): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDO (opcode 118): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDE (opcode 119): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 120): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBE (opcode 121): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULO (opcode 122): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULO (opcode 123): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULH (opcode 124): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULH (opcode 125): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDSAT (opcode 126): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDSAT (opcode 127): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBSAT (opcode 128): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBSAT (opcode 129): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USHLSAT (opcode 130): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSHLSAT (opcode 131): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIX (opcode 132): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIX (opcode 133): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIXSAT (opcode 134): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIXSAT (opcode 135): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIX (opcode 136): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIX (opcode 137): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIXSAT (opcode 138): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIXSAT (opcode 139): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FADD (opcode 140): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSUB (opcode 141): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMUL (opcode 142): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMA (opcode 143): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAD (opcode 144): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FDIV (opcode 145): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREM (opcode 146): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOW (opcode 147): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOWI (opcode 148): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP (opcode 149): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 150): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG (opcode 151): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 152): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG10 (opcode 153): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEG (opcode 154): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 155): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTRUNC (opcode 156): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTOSI (opcode 157): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOUI (opcode 158): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SITOFP (opcode 159): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UITOFP (opcode 160): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FABS (opcode 161): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOPYSIGN (opcode 162): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCANONICALIZE (opcode 163): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM (opcode 164): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM (opcode 165): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM_IEEE (opcode 166): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM_IEEE (opcode 167): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINIMUM (opcode 168): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXIMUM (opcode 169): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTR_ADD (opcode 170): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRMASK (opcode 171): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMIN (opcode 172): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMAX (opcode 173): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMIN (opcode 174): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMAX (opcode 175): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ABS (opcode 176): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BR (opcode 177): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRJT (opcode 178): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 179): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 180): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 181): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ (opcode 182): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ_ZERO_UNDEF (opcode 183): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ (opcode 184): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ_ZERO_UNDEF (opcode 185): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTPOP (opcode 186): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 187): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BITREVERSE (opcode 188): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCEIL (opcode 189): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOS (opcode 190): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSIN (opcode 191): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSQRT (opcode 192): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FFLOOR (opcode 193): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRINT (opcode 194): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEARBYINT (opcode 195): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 196): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 197): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_JUMP_TABLE (opcode 198): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_DYN_STACKALLOC (opcode 199): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FADD (opcode 200): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSUB (opcode 201): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMUL (opcode 202): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FDIV (opcode 203): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FREM (opcode 204): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMA (opcode 205): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSQRT (opcode 206): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READ_REGISTER (opcode 207): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_WRITE_REGISTER (opcode 208): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY (opcode 209): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMMOVE (opcode 210): 3 type indices, 1 imm index
.. opcode 210 is aliased to 209
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMSET (opcode 211): 3 type indices, 1 imm index
.. opcode 211 is aliased to 209
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_VECREDUCE_SEQ_FADD (opcode 212): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FMUL (opcode 213): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FADD (opcode 214): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMUL (opcode 215): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMAX (opcode 216): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMIN (opcode 217): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_ADD (opcode 218): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_MUL (opcode 219): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_AND (opcode 220): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_OR (opcode 221): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_XOR (opcode 222): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMAX (opcode 223): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMIN (opcode 224): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMAX (opcode 225): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMIN (opcode 226): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
Looking to fold if.end into for.inc
Killing Trivial BB: 

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc
SROA function: _Z5solvev
SROA alloca:   %pi = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %pi = alloca double, align 8
  [0,8) slice #0
    used by:   store double %mul12, double* %pi, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %19 = load double, double* %pi, align 8, !tbaa !6
  [0,8) slice #2 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #5
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %pi = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %mul12, double* %pi, align 8, !tbaa !6
          to:   store double %mul12, double* %pi, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %19 = load double, double* %pi, align 8, !tbaa !6
          to:   %pi.0. = load double, double* %pi, align 8, !tbaa !6
  rewriting [0,8) slice #2 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %pi.0..sroa_cast)
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #5
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %pi.0..sroa_cast13)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #5
Deleting dead instruction:   %20 = bitcast double* %pi to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
Deleting dead instruction:   %6 = bitcast double* %pi to i8*
Deleting dead instruction:   %18 = load double, double* %pi, align 8, !tbaa !6
Deleting dead instruction:   store double %mul12, double* %pi, align 8, !tbaa !6
SROA alloca:   %max = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %max = alloca double, align 8
  [0,8) slice #0
    used by:   store double 0x41DFFFFFFFC00000, double* %max, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %8 = load double, double* %max, align 8, !tbaa !6
  [0,8) slice #2
    used by:   %9 = load double, double* %max, align 8, !tbaa !6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  [0,8) slice #4 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #5
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %max = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double 0x41DFFFFFFFC00000, double* %max, align 8, !tbaa !6
          to:   store double 0x41DFFFFFFFC00000, double* %max, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %8 = load double, double* %max, align 8, !tbaa !6
          to:   %max.0. = load double, double* %max, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   %9 = load double, double* %max, align 8, !tbaa !6
          to:   %max.0.14 = load double, double* %max, align 8, !tbaa !6
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %max.0..sroa_cast)
  rewriting [0,8) slice #4 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #5
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %max.0..sroa_cast15)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #5
Deleting dead instruction:   %18 = bitcast double* %max to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
Deleting dead instruction:   %5 = bitcast double* %max to i8*
Deleting dead instruction:   %8 = load double, double* %max, align 8, !tbaa !6
Deleting dead instruction:   %7 = load double, double* %max, align 8, !tbaa !6
Deleting dead instruction:   store double 0x41DFFFFFFFC00000, double* %max, align 8, !tbaa !6
SROA alloca:   %y = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %y = alloca double, align 8
  [0,8) slice #0
    used by:   store double %div5, double* %y, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %9 = load double, double* %y, align 8, !tbaa !6
  [0,8) slice #2
    used by:   %10 = load double, double* %y, align 8, !tbaa !6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
  [0,8) slice #4 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %y = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %div5, double* %y, align 8, !tbaa !6
          to:   store double %div5, double* %y, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %9 = load double, double* %y, align 8, !tbaa !6
          to:   %y.0. = load double, double* %y, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   %10 = load double, double* %y, align 8, !tbaa !6
          to:   %y.0.16 = load double, double* %y, align 8, !tbaa !6
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %y.0..sroa_cast)
  rewriting [0,8) slice #4 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %y.0..sroa_cast17)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
Deleting dead instruction:   %15 = bitcast double* %y to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
Deleting dead instruction:   %4 = bitcast double* %y to i8*
Deleting dead instruction:   %9 = load double, double* %y, align 8, !tbaa !6
Deleting dead instruction:   %8 = load double, double* %y, align 8, !tbaa !6
Deleting dead instruction:   store double %div5, double* %y, align 8, !tbaa !6
SROA alloca:   %x = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %x = alloca double, align 8
  [0,8) slice #0
    used by:   store double %div, double* %x, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %6 = load double, double* %x, align 8, !tbaa !6
  [0,8) slice #2
    used by:   %7 = load double, double* %x, align 8, !tbaa !6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  [0,8) slice #4 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %x = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %div, double* %x, align 8, !tbaa !6
          to:   store double %div, double* %x, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %6 = load double, double* %x, align 8, !tbaa !6
          to:   %x.0. = load double, double* %x, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   %7 = load double, double* %x, align 8, !tbaa !6
          to:   %x.0.18 = load double, double* %x, align 8, !tbaa !6
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %x.0..sroa_cast)
  rewriting [0,8) slice #4 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %x.0..sroa_cast19)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
Deleting dead instruction:   %12 = bitcast double* %x to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
Deleting dead instruction:   %3 = bitcast double* %x to i8*
Deleting dead instruction:   %6 = load double, double* %x, align 8, !tbaa !6
Deleting dead instruction:   %5 = load double, double* %x, align 8, !tbaa !6
Deleting dead instruction:   store double %div, double* %x, align 8, !tbaa !6
SROA alloca:   %Ni = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %Ni = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #5
  [0,4) slice #1 (splittable)
    used by:   store i32 0, i32* %Ni, align 4, !tbaa !2
  [0,4) slice #2 (splittable)
    used by:   %5 = load i32, i32* %Ni, align 4, !tbaa !2
  [0,4) slice #3 (splittable)
    used by:   store i32 %inc, i32* %Ni, align 4, !tbaa !2
  [0,4) slice #4 (splittable)
    used by:   %7 = load i32, i32* %Ni, align 4, !tbaa !2
  [0,4) slice #5 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #5
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %Ni = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #5
          to:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %Ni.0..sroa_cast)
  rewriting [0,4) slice #1 (splittable)
    original:   store i32 0, i32* %Ni, align 4, !tbaa !2
          to:   store i32 0, i32* %Ni, align 4, !tbaa !2
  rewriting [0,4) slice #2 (splittable)
    original:   %5 = load i32, i32* %Ni, align 4, !tbaa !2
          to:   %Ni.0.load = load i32, i32* %Ni, align 4
  rewriting [0,4) slice #3 (splittable)
    original:   store i32 %inc, i32* %Ni, align 4, !tbaa !2
          to:   store i32 %inc, i32* %Ni, align 4, !tbaa !2
  rewriting [0,4) slice #4 (splittable)
    original:   %7 = load i32, i32* %Ni, align 4, !tbaa !2
          to:   %Ni.0.load20 = load i32, i32* %Ni, align 4
  rewriting [0,4) slice #5 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #5
          to:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %Ni.0..sroa_cast21)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #5
Deleting dead instruction:   %9 = bitcast i32* %Ni to i8*
Deleting dead instruction:   %7 = load i32, i32* %Ni, align 4, !tbaa !2
Deleting dead instruction:   store i32 %inc, i32* %Ni, align 4, !tbaa !2
Deleting dead instruction:   %5 = load i32, i32* %Ni, align 4, !tbaa !2
Deleting dead instruction:   store i32 0, i32* %Ni, align 4, !tbaa !2
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #5
Deleting dead instruction:   %2 = bitcast i32* %Ni to i8*
SROA alloca:   %jmax = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %jmax = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #5
  [0,4) slice #1 (splittable)
    used by:   store i32 10000000, i32* %jmax, align 4, !tbaa !2
  [0,4) slice #2 (splittable)
    used by:   %3 = load i32, i32* %jmax, align 4, !tbaa !2
  [0,4) slice #3 (splittable)
    used by:   %5 = load i32, i32* %jmax, align 4, !tbaa !2
  [0,4) slice #4 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #5
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %jmax = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #5
          to:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %jmax.0..sroa_cast)
  rewriting [0,4) slice #1 (splittable)
    original:   store i32 10000000, i32* %jmax, align 4, !tbaa !2
          to:   store i32 10000000, i32* %jmax, align 4, !tbaa !2
  rewriting [0,4) slice #2 (splittable)
    original:   %3 = load i32, i32* %jmax, align 4, !tbaa !2
          to:   %jmax.0.load = load i32, i32* %jmax, align 4
  rewriting [0,4) slice #3 (splittable)
    original:   %5 = load i32, i32* %jmax, align 4, !tbaa !2
          to:   %jmax.0.load22 = load i32, i32* %jmax, align 4
  rewriting [0,4) slice #4 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #5
          to:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %jmax.0..sroa_cast23)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #5
Deleting dead instruction:   %6 = bitcast i32* %jmax to i8*
Deleting dead instruction:   %5 = load i32, i32* %jmax, align 4, !tbaa !2
Deleting dead instruction:   %3 = load i32, i32* %jmax, align 4, !tbaa !2
Deleting dead instruction:   store i32 10000000, i32* %jmax, align 4, !tbaa !2
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #5
Deleting dead instruction:   %1 = bitcast i32* %jmax to i8*
SROA alloca:   %j = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %j = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
  [0,4) slice #1 (splittable)
    used by:   store i32 0, i32* %j, align 4, !tbaa !2
  [0,4) slice #2 (splittable)
    used by:   %1 = load i32, i32* %j, align 4, !tbaa !2
  [0,4) slice #3 (splittable)
    used by:   %2 = load i32, i32* %j, align 4, !tbaa !2
  [0,4) slice #4 (splittable)
    used by:   store i32 %inc8, i32* %j, align 4, !tbaa !2
  [0,4) slice #5 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #5
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %j = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
          to:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %j.0..sroa_cast)
  rewriting [0,4) slice #1 (splittable)
    original:   store i32 0, i32* %j, align 4, !tbaa !2
          to:   store i32 0, i32* %j, align 4, !tbaa !2
  rewriting [0,4) slice #2 (splittable)
    original:   %1 = load i32, i32* %j, align 4, !tbaa !2
          to:   %j.0.load = load i32, i32* %j, align 4
  rewriting [0,4) slice #3 (splittable)
    original:   %2 = load i32, i32* %j, align 4, !tbaa !2
          to:   %j.0.load24 = load i32, i32* %j, align 4
  rewriting [0,4) slice #4 (splittable)
    original:   store i32 %inc8, i32* %j, align 4, !tbaa !2
          to:   store i32 %inc8, i32* %j, align 4, !tbaa !2
  rewriting [0,4) slice #5 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #5
          to:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %j.0..sroa_cast25)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #5
Deleting dead instruction:   %3 = bitcast i32* %j to i8*
Deleting dead instruction:   store i32 %inc8, i32* %j, align 4, !tbaa !2
Deleting dead instruction:   %2 = load i32, i32* %j, align 4, !tbaa !2
Deleting dead instruction:   %1 = load i32, i32* %j, align 4, !tbaa !2
Deleting dead instruction:   store i32 0, i32* %j, align 4, !tbaa !2
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
Deleting dead instruction:   %0 = bitcast i32* %j to i8*
Promoting allocas with mem2reg...
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in for.body
EarlyCSE CVP: Add conditional value for 'cmp7' as i1 true in if.then
EarlyCSE CVP: Add conditional value for 'cmp' as i1 false in for.end
EarlyCSE Simplify:   %conv10 = sitofp i32 10000000 to double  to: double 1.000000e+07
SROA function: main
SROA alloca:   %retval = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %retval = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 0, i32* %retval, align 4
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %retval = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 0, i32* %retval, align 4
          to:   store i32 0, i32* %retval, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   store i32 0, i32* %retval, align 4
Promoting allocas with mem2reg...
Visiting   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
Rename Stack is empty
Current DFS numbers are (1,10)
Rename Stack is empty
Current DFS numbers are (2,7)
Rename Stack Top DFS numbers are (2,7)
Current DFS numbers are (5,6)
Found replacement   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0) for   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ] in   %inc8 = add nsw i32 %j.0, 1
Rename Stack Top DFS numbers are (2,7)
Current DFS numbers are (8,9)
Marking Block Executable: entry
Marking Block Executable: entry

Popped off BBWL: 
entry:
  %call = call double @_Z5solvev()
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
  ret i32 0

Merged overdefined into   %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call) : overdefined
Merged constantrange<0, 1> into ; Function Attrs: norecurse uwtable mustprogress
define dso_local i32 @main() #3 {
entry:
  %call = call double @_Z5solvev()
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
  ret i32 0
}
 : constantrange<0, 1>

Popped off BBWL: 
entry:
  %call = call i64 @time(i64* null) #6
  %conv = trunc i64 %call to i32
  call void @srand(i32 %conv) #6
  br label %for.cond

Merged overdefined into   %call = call i64 @time(i64* null) #6 : overdefined
markOverdefined:   %conv = trunc i64 %call to i32
Marking Block Executable: for.cond

Popped off BBWL: 
for.cond:                                         ; preds = %for.inc, %entry
  %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
  %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %cmp = icmp slt i32 %j.0, 10000000
  %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0)
  br i1 %cmp, label %for.body, label %for.end

Merged constantrange<0, 1> into   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ] : constantrange<0, 1>
Merged constantrange<0, 1> into   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ] : constantrange<0, 1>
Merged constantrange<-1, 0> into   %cmp = icmp slt i32 %j.0, 10000000 : constantrange<-1, 0>
Merged constantrange incl. undef <0, 1> into   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0) : constantrange incl. undef <0, 1>
Marking Block Executable: for.body

Popped off BBWL: 
for.body:                                         ; preds = %for.cond
  %call1 = call i32 @rand() #6
  %conv2 = sitofp i32 %call1 to double
  %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  %call3 = call i32 @rand() #6
  %conv4 = sitofp i32 %call3 to double
  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
  %mul = fmul double %div, %div
  %mul6 = fmul double %div5, %div5
  %add = fadd double %mul, %mul6
  %cmp7 = fcmp ole double %add, 1.000000e+00
  br i1 %cmp7, label %if.then, label %for.inc

Merged overdefined into   %call1 = call i32 @rand() #6 : overdefined
markOverdefined:   %conv2 = sitofp i32 %call1 to double
markOverdefined:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
Merged overdefined into   %call3 = call i32 @rand() #6 : overdefined
markOverdefined:   %conv4 = sitofp i32 %call3 to double
markOverdefined:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
markOverdefined:   %mul = fmul double %div, %div
markOverdefined:   %mul6 = fmul double %div5, %div5
markOverdefined:   %add = fadd double %mul, %mul6
markOverdefined:   %cmp7 = fcmp ole double %add, 1.000000e+00
Marking Block Executable: if.then
Marking Block Executable: for.inc

Popped off BBWL: 
for.inc:                                          ; preds = %for.body, %if.then
  %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
  %inc8 = add nsw i32 %j.0.0, 1
  br label %for.cond, !llvm.loop !2

Merged constantrange<0, 1> into   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ] : constantrange<0, 1>
Merged constantrange<1, 2> into   %inc8 = add nsw i32 %j.0.0, 1 : constantrange<1, 2>
Marking Edge Executable: for.inc -> for.cond
Merged constantrange<0, 2> into   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ] : constantrange<0, 2>

Popped off BBWL: 
if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %Ni.0, 1
  br label %for.inc

Merged constantrange<1, 2> into   %inc = add nsw i32 %Ni.0, 1 : constantrange<1, 2>
Marking Edge Executable: if.then -> for.inc
Merged constantrange<0, 2> into   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ] : constantrange<0, 2>

Popped off OI-WL:   %cmp7 = fcmp ole double %add, 1.000000e+00

Popped off OI-WL:   %add = fadd double %mul, %mul6

Popped off OI-WL:   %mul6 = fmul double %div5, %div5

Popped off OI-WL:   %mul = fmul double %div, %div

Popped off OI-WL:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000

Popped off OI-WL:   %conv4 = sitofp i32 %call3 to double

Popped off OI-WL:   %call3 = call i32 @rand() #6

Popped off OI-WL:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000

Popped off OI-WL:   %conv2 = sitofp i32 %call1 to double

Popped off OI-WL:   %call1 = call i32 @rand() #6

Popped off OI-WL:   %conv = trunc i64 %call to i32

Popped off OI-WL:   %call = call i64 @time(i64* null) #6

Popped off OI-WL:   %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)

Popped off I-WL:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
Merged constantrange<0, 2> into   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ] : constantrange<0, 2>

Popped off I-WL:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
Merged constantrange<1, 3> into   %inc = add nsw i32 %Ni.0, 1 : constantrange<1, 3>

Popped off I-WL:   %inc = add nsw i32 %Ni.0, 1
Merged constantrange<0, 3> into   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ] : constantrange<0, 3>

Popped off I-WL:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
Merged constantrange<0, 3> into   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ] : overdefined

Popped off I-WL:   %inc = add nsw i32 %Ni.0, 1
Merged overdefined into   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ] : overdefined

Popped off I-WL:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
Merged constantrange incl. undef <0, 2> into   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0) : constantrange incl. undef <0, 2>

Popped off I-WL:   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0)
Merged constantrange<1, 3> into   %inc8 = add nsw i32 %j.0.0, 1 : constantrange<1, 3>

Popped off I-WL:   %inc8 = add nsw i32 %j.0.0, 1
Merged constantrange<0, 3> into   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ] : constantrange<0, 3>

Popped off I-WL:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
Merged constantrange incl. undef <0, 3> into   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0) : constantrange incl. undef <0, 3>

Popped off I-WL:   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0)
Merged constantrange<1, 4> into   %inc8 = add nsw i32 %j.0.0, 1 : constantrange<1, 4>

Popped off I-WL:   %inc8 = add nsw i32 %j.0.0, 1
Merged constantrange<0, 4> into   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ] : overdefined

Popped off I-WL:   %inc8 = add nsw i32 %j.0.0, 1

Popped off I-WL:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]

Popped off I-WL:   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0)

Popped off I-WL:   %cmp = icmp slt i32 %j.0, 10000000

Popped off I-WL:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]

Popped off I-WL:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]

Popped off I-WL: ; Function Attrs: norecurse uwtable mustprogress
define dso_local i32 @main() #3 {
entry:
  %call = call double @_Z5solvev()
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
  ret i32 0
}


Popped off OI-WL:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
Merged constantrange incl. undef <-2147483648, 10000000> into   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0) : constantrange incl. undef <-2147483648, 10000000>
markOverdefined:   %cmp = icmp slt i32 %j.0, 10000000

Popped off OI-WL:   %cmp = icmp slt i32 %j.0, 10000000
Marking Block Executable: for.end

Popped off OI-WL:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]

Popped off OI-WL:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
markOverdefined:   %conv9 = sitofp i32 %Ni.0 to double
Merged overdefined into   %inc = add nsw i32 %Ni.0, 1 : overdefined

Popped off OI-WL:   %inc = add nsw i32 %Ni.0, 1

Popped off OI-WL:   %conv9 = sitofp i32 %Ni.0 to double
markOverdefined:   %div11 = fdiv double %conv9, 1.000000e+07

Popped off OI-WL:   %div11 = fdiv double %conv9, 1.000000e+07
markOverdefined:   %mul12 = fmul double %div11, 4.000000e+00

Popped off OI-WL:   %mul12 = fmul double %div11, 4.000000e+00
Merged overdefined into ; Function Attrs: nounwind uwtable mustprogress
define dso_local double @_Z5solvev() #0 {
entry:
  %call = call i64 @time(i64* null) #6
  %conv = trunc i64 %call to i32
  call void @srand(i32 %conv) #6
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
  %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %cmp = icmp slt i32 %j.0, 10000000
  %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call1 = call i32 @rand() #6
  %conv2 = sitofp i32 %call1 to double
  %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  %call3 = call i32 @rand() #6
  %conv4 = sitofp i32 %call3 to double
  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
  %mul = fmul double %div, %div
  %mul6 = fmul double %div5, %div5
  %add = fadd double %mul, %mul6
  %cmp7 = fcmp ole double %add, 1.000000e+00
  br i1 %cmp7, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %Ni.0, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
  %inc8 = add nsw i32 %j.0.0, 1
  br label %for.cond, !llvm.loop !2

for.end:                                          ; preds = %for.cond
  %conv9 = sitofp i32 %Ni.0 to double
  %div11 = fdiv double %conv9, 1.000000e+07
  %mul12 = fmul double %div11, 4.000000e+00
  ret double %mul12
}
 : overdefined

Popped off OI-WL: ; Function Attrs: nounwind uwtable mustprogress
define dso_local double @_Z5solvev() #0 {
entry:
  %call = call i64 @time(i64* null) #6
  %conv = trunc i64 %call to i32
  call void @srand(i32 %conv) #6
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
  %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %cmp = icmp slt i32 %j.0, 10000000
  %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call1 = call i32 @rand() #6
  %conv2 = sitofp i32 %call1 to double
  %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  %call3 = call i32 @rand() #6
  %conv4 = sitofp i32 %call3 to double
  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
  %mul = fmul double %div, %div
  %mul6 = fmul double %div5, %div5
  %add = fadd double %mul, %mul6
  %cmp7 = fcmp ole double %add, 1.000000e+00
  br i1 %cmp7, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %Ni.0, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
  %inc8 = add nsw i32 %j.0.0, 1
  br label %for.cond, !llvm.loop !2

for.end:                                          ; preds = %for.cond
  %conv9 = sitofp i32 %Ni.0 to double
  %div11 = fdiv double %conv9, 1.000000e+07
  %mul12 = fmul double %div11, 4.000000e+00
  ret double %mul12
}

Merged overdefined into   %call = call double @_Z5solvev() : overdefined

Popped off OI-WL:   %call = call double @_Z5solvev()

Popped off I-WL:   %j.0.0 = call i32 @llvm.ssa.copy.262894936(i32 %j.0)
Merged constantrange<-2147483647, 10000001> into   %inc8 = add nsw i32 %j.0.0, 1 : constantrange<-2147483647, 10000001>

Popped off I-WL:   %inc8 = add nsw i32 %j.0.0, 1

Popped off BBWL: 
for.end:                                          ; preds = %for.cond
  %conv9 = sitofp i32 %Ni.0 to double
  %div11 = fdiv double %conv9, 1.000000e+07
  %mul12 = fmul double %div11, 4.000000e+00
  ret double %mul12

RESOLVING UNDEFS
Marking Block Executable: entry
Marking Block Executable: entry

Popped off BBWL: 
entry:
  %call = call double @_Z5solvev()
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
  ret i32 0

Popped off BBWL: 
entry:
  %call = call i64 @time(i64* null) #5
  %conv = trunc i64 %call to i32
  call void @srand(i32 %conv) #5
  br label %for.cond
Marking Edge Executable: entry -> for.cond
Marking Block Executable: for.cond

Popped off BBWL: 
for.cond:                                         ; preds = %for.inc, %entry
  %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
  %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %cmp = icmp slt i32 %j.0, 10000000
  br i1 %cmp, label %for.body, label %for.end
Marking Edge Executable: for.cond -> for.body
Marking Block Executable: for.body
Marking Edge Executable: for.cond -> for.end
Marking Block Executable: for.end

Popped off BBWL: 
for.end:                                          ; preds = %for.cond
  %conv9 = sitofp i32 %Ni.0 to double
  %div11 = fdiv double %conv9, 1.000000e+07
  %mul12 = fmul double %div11, 4.000000e+00
  ret double %mul12

Popped off BBWL: 
for.body:                                         ; preds = %for.cond
  %call1 = call i32 @rand() #5
  %conv2 = sitofp i32 %call1 to double
  %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  %call3 = call i32 @rand() #5
  %conv4 = sitofp i32 %call3 to double
  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
  %mul = fmul double %div, %div
  %mul6 = fmul double %div5, %div5
  %add = fadd double %mul, %mul6
  %cmp7 = fcmp ole double %add, 1.000000e+00
  br i1 %cmp7, label %if.then, label %for.inc
Marking Edge Executable: for.body -> if.then
Marking Block Executable: if.then
Marking Edge Executable: for.body -> for.inc
Marking Block Executable: for.inc

Popped off BBWL: 
for.inc:                                          ; preds = %for.body, %if.then
  %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
  %inc8 = add nsw i32 %j.0, 1
  br label %for.cond, !llvm.loop !2
Marking Edge Executable: for.inc -> for.cond

Popped off BBWL: 
if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %Ni.0, 1
  br label %for.inc
Marking Edge Executable: if.then -> for.inc

Popped off V-WL:   %inc = add nsw i32 %Ni.0, 1

Popped off V-WL:   %inc8 = add nsw i32 %j.0, 1

Popped off V-WL:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]

Popped off V-WL:   %cmp7 = fcmp ole double %add, 1.000000e+00

Popped off V-WL:   %add = fadd double %mul, %mul6

Popped off V-WL:   %mul6 = fmul double %div5, %div5

Popped off V-WL:   %mul = fmul double %div, %div

Popped off V-WL:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000

Popped off V-WL:   %conv4 = sitofp i32 %call3 to double

Popped off V-WL:   %call3 = call i32 @rand() #5

Popped off V-WL:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000

Popped off V-WL:   %conv2 = sitofp i32 %call1 to double

Popped off V-WL:   %call1 = call i32 @rand() #5

Popped off V-WL: ; Function Attrs: nounwind uwtable mustprogress
define dso_local double @_Z5solvev() #0 {
entry:
  %call = call i64 @time(i64* null) #5
  %conv = trunc i64 %call to i32
  call void @srand(i32 %conv) #5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
  %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %cmp = icmp slt i32 %j.0, 10000000
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call1 = call i32 @rand() #5
  %conv2 = sitofp i32 %call1 to double
  %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  %call3 = call i32 @rand() #5
  %conv4 = sitofp i32 %call3 to double
  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
  %mul = fmul double %div, %div
  %mul6 = fmul double %div5, %div5
  %add = fadd double %mul, %mul6
  %cmp7 = fcmp ole double %add, 1.000000e+00
  br i1 %cmp7, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %Ni.0, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
  %inc8 = add nsw i32 %j.0, 1
  br label %for.cond, !llvm.loop !2

for.end:                                          ; preds = %for.cond
  %conv9 = sitofp i32 %Ni.0 to double
  %div11 = fdiv double %conv9, 1.000000e+07
  %mul12 = fmul double %div11, 4.000000e+00
  ret double %mul12
}


Popped off V-WL:   %call = call double @_Z5solvev()

Popped off V-WL:   %mul12 = fmul double %div11, 4.000000e+00

Popped off V-WL:   %div11 = fdiv double %conv9, 1.000000e+07

Popped off V-WL:   %conv9 = sitofp i32 %Ni.0 to double

Popped off V-WL:   %cmp = icmp slt i32 %j.0, 10000000

Popped off V-WL:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]

Popped off V-WL:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]

Popped off V-WL:   %conv = trunc i64 %call to i32

Popped off V-WL:   %call = call i64 @time(i64* null) #5

Popped off V-WL: ; Function Attrs: norecurse uwtable mustprogress
define dso_local i32 @main() #3 {
entry:
  %call = call double @_Z5solvev()
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
  ret i32 0
}


Popped off V-WL:   %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
GLOBAL DEAD: ; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

GLOBAL DEAD: ; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #2

DeadArgumentEliminationPass - Deleting dead varargs
DeadArgumentEliminationPass - Determining liveness
DeadArgumentEliminationPass - Intrinsically live fn: _Z5solvev
DeadArgumentEliminationPass - Intrinsically live fn: srand
DeadArgumentEliminationPass - Intrinsically live fn: time
DeadArgumentEliminationPass - Intrinsically live fn: rand
DeadArgumentEliminationPass - Intrinsically live fn: main
DeadArgumentEliminationPass - Intrinsically live fn: printf


INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   br label %for.inc
IC: ADD:   %inc = add nsw i32 %Ni.0, 1
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %inc8 = add nsw i32 %j.0, 1
IC: ADD:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
IC: ADD:   br i1 %cmp7, label %if.then, label %for.inc
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = call i32 @rand() #4
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.0 to double
IC: ADD:   br i1 %cmp, label %for.body, label %for.end
IC: ADD:   %cmp = icmp slt i32 %j.0, 10000000
IC: ADD:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: ADD:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
IC: ADD:   br label %for.cond
IC: ADD:   call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.cond
IC: Visiting:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
IC: Visiting:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: Visiting:   %cmp = icmp slt i32 %j.0, 10000000
IC: Old =   %cmp = icmp slt i32 %j.0, 10000000
    New =   <badref> = icmp ult i32 %j.0, 10000000
IC: ADD:   %cmp = icmp ult i32 %j.0, 10000000
IC: ERASE   %0 = icmp slt i32 %j.0, 10000000
IC: ADD DEFERRED:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: ADD:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: Visiting:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: Visiting:   %cmp = icmp ult i32 %j.0, 10000000
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end
IC: Visiting:   %conv9 = sitofp i32 %Ni.0 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
IC: Visiting:   %call1 = call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   br i1 %cmp7, label %if.then, label %for.inc
IC: ADD:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: Mod =   br i1 %cmp7, label %if.then, label %for.inc
    New =   br i1 %cmp7, label %for.inc, label %if.then
IC: ADD:   br i1 %cmp7, label %for.inc, label %if.then
IC: Visiting:   br i1 %cmp7, label %for.inc, label %if.then
IC: Visiting:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: Visiting:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
IC: Visiting:   %inc8 = add nsw i32 %j.0, 1
IC: Mod =   %inc8 = add nsw i32 %j.0, 1
    New =   %inc8 = add nuw nsw i32 %j.0, 1
IC: ADD:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: ADD:   %inc8 = add nuw nsw i32 %j.0, 1
IC: Visiting:   %inc8 = add nuw nsw i32 %j.0, 1
IC: Visiting:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: Visiting:   br label %for.cond, !llvm.loop !2
IC: Visiting:   %inc = add nsw i32 %Ni.0, 1
IC: Visiting:   br label %for.inc


INSTCOMBINE ITERATION #2 on _Z5solvev
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %inc8 = add nuw nsw i32 %j.0, 1
IC: ADD:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
IC: ADD:   br label %for.inc
IC: ADD:   %inc = add nsw i32 %Ni.0, 1
IC: ADD:   br i1 %cmp7, label %for.inc, label %if.then
IC: ADD:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = call i32 @rand() #4
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.0 to double
IC: ADD:   br i1 %cmp, label %for.body, label %for.end
IC: ADD:   %cmp = icmp ult i32 %j.0, 10000000
IC: ADD:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: ADD:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
IC: ADD:   br label %for.cond
IC: ADD:   call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.cond
IC: Visiting:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.inc ]
IC: Visiting:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
IC: Visiting:   %cmp = icmp ult i32 %j.0, 10000000
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end
IC: Visiting:   %conv9 = sitofp i32 %Ni.0 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
IC: Visiting:   %call1 = call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: Visiting:   br i1 %cmp7, label %for.inc, label %if.then
IC: Visiting:   %inc = add nsw i32 %Ni.0, 1
IC: Visiting:   br label %for.inc
IC: Visiting:   %Ni.1 = phi i32 [ %inc, %if.then ], [ %Ni.0, %for.body ]
IC: Visiting:   %inc8 = add nuw nsw i32 %j.0, 1
IC: Visiting:   br label %for.cond, !llvm.loop !2
FOUND IF CONDITION!    %cmp7 = fcmp ugt double %add, 1.000000e+00  T: for.body  F: if.then
Removing BB: 

if.then:                                          ; No predecessors!
  br label %for.inc
Merging: for.inc into for.body


INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
IC: ADD:   %call = call double @_Z5solvev()
IC: Visiting:   %call = call double @_Z5solvev()
IC: Visiting:   %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %call)
IC: Visiting:   ret i32 0
Inliner visiting SCC: INDIRECTNODE: 0 call sites.
Inliner visiting SCC: time: 0 call sites.
Inliner visiting SCC: srand: 0 call sites.
Inliner visiting SCC: rand: 0 call sites.
Inliner visiting SCC: _Z5solvev: 0 call sites.
SROA function: _Z5solvev
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in for.body
EarlyCSE CVP: Add conditional value for 'cmp' as i1 false in for.end
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_Z5solvev'
LVI Getting value   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] at ''
  Result = overdefined
LVI Getting edge value i32 0 from 'entry' to 'for.cond'
  Result = constantrange<0, 1>
LVI Getting edge value   %inc8 = add nuw nsw i32 %j.0, 1 from 'for.body' to 'for.cond'
PUSH:   %inc8 = add nuw nsw i32 %j.0, 1 in for.body
PUSH:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] in for.body
PUSH:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] in for.cond
 compute BB 'for.cond' - overdefined because of pred (local).
POP   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] in for.cond = overdefined
POP   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] in for.body = constantrange<0, 10000000>
POP   %inc8 = add nuw nsw i32 %j.0, 1 in for.body = constantrange<1, 10000001>
  Result = constantrange<1, 10000001>
LVI Getting edge value   %Ni.1 = select i1 %cmp7, i32 %Ni.0, i32 %inc from 'for.body' to 'for.cond'
PUSH:   %Ni.1 = select i1 %cmp7, i32 %Ni.0, i32 %inc in for.body
PUSH:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] in for.body
PUSH:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] in for.cond
 compute BB 'for.cond' - overdefined because of pred (local).
POP   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] in for.cond = overdefined
 compute BB 'for.body' - overdefined because of pred (non local).
POP   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] in for.body = overdefined
POP   %Ni.1 = select i1 %cmp7, i32 %Ni.0, i32 %inc in for.body = overdefined
  Result = overdefined
LVI Getting edge value   %cmp7 = fcmp ugt double %add, 1.000000e+00 from 'for.body' to 'for.cond'
PUSH:   %cmp7 = fcmp ugt double %add, 1.000000e+00 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %cmp7 = fcmp ugt double %add, 1.000000e+00 in for.body = overdefined
  Result = overdefined
LVI Getting edge value   %inc8 = add nuw nsw i32 %j.0, 1 from 'for.body' to 'for.cond'
  Result = constantrange<1, 10000001>
LVI Getting block end value   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] at 'for.cond'
  Result = overdefined
LVI Getting edge value i32 0 from 'entry' to 'for.cond'
  Result = constantrange<0, 1>
LVI Getting edge value   %inc8 = add nuw nsw i32 %j.0, 1 from 'for.body' to 'for.cond'
  Result = constantrange<1, 10000001>
LVI Getting block end value   %add = fadd double %mul, %mul6 at 'for.body'
PUSH:   %add = fadd double %mul, %mul6 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %add = fadd double %mul, %mul6 in for.body = overdefined
  Result = overdefined
LVI Getting block end value   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] at 'for.body'
  Result = overdefined
LVI Getting block end value i32 1 at 'for.body'
  Result = constantrange<1, 2>
LVI Getting block end value   %cmp7 = fcmp ugt double %add, 1.000000e+00 at 'for.body'
  Result = overdefined
LVI Getting block end value   %mul12 = fmul double %div11, 4.000000e+00 at 'for.end'
PUSH:   %mul12 = fmul double %div11, 4.000000e+00 in for.end
 compute BB 'for.end' - unknown inst def found.
POP   %mul12 = fmul double %div11, 4.000000e+00 in for.end = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %inc8 = add nuw nsw i32 %j.0, 1
IC: ADD:   %Ni.1 = select i1 %cmp7, i32 %Ni.0, i32 %inc
IC: ADD:   %inc = add nsw i32 %Ni.0, 1
IC: ADD:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = call i32 @rand() #4
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.0 to double
IC: ADD:   br i1 %cmp, label %for.body, label %for.end
IC: ADD:   %cmp = icmp ult i32 %j.0, 10000000
IC: ADD:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   br label %for.cond
IC: ADD:   call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.cond
IC: Visiting:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %cmp = icmp ult i32 %j.0, 10000000
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end
IC: Visiting:   %conv9 = sitofp i32 %Ni.0 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
IC: Visiting:   %call1 = call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: Visiting:   %inc = add nsw i32 %Ni.0, 1
IC: Visiting:   %Ni.1 = select i1 %cmp7, i32 %Ni.0, i32 %inc
IC: ADD DEFERRED:   %0 = select i1 %cmp7, i32 0, i32 1
IC: Old =   %Ni.1 = select i1 %cmp7, i32 %Ni.0, i32 %0
    New =   <badref> = add nsw i32 %Ni.0, %inc
IC: ADD:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %Ni.1 = add nsw i32 %Ni.0, %inc
IC: ERASE   %1 = select i1 %cmp7, i32 %Ni.0, i32 %0
IC: ADD DEFERRED:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: ADD DEFERRED:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD DEFERRED:   %0 = add nsw i32 %Ni.0, 1
IC: ERASE   %0 = add nsw i32 %Ni.0, 1
IC: ADD:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: ADD:   %inc = select i1 %cmp7, i32 0, i32 1
IC: Visiting:   %inc = select i1 %cmp7, i32 0, i32 1
IC: ADD DEFERRED:   %not.cmp7 = xor i1 %cmp7, true
IC: Old =   %inc = select i1 %cmp7, i32 0, i32 1
    New =   <badref> = zext i1 %not.cmp7 to i32
IC: ADD:   %inc = zext i1 %not.cmp7 to i32
IC: ERASE   %0 = select i1 %cmp7, i32 0, i32 1
IC: ADD DEFERRED:   %cmp7 = fcmp ugt double %add, 1.000000e+00
IC: ADD:   %not.cmp7 = xor i1 %cmp7, true
IC: Visiting:   %not.cmp7 = xor i1 %cmp7, true
IC: Replacing   %not.cmp7 = xor i1 %cmp7, true
    with   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Mod =   %not.cmp7 = xor i1 %cmp7, true
    New =   %not.cmp7 = xor i1 %cmp7, true
IC: ERASE   %not.cmp7 = xor i1 %cmp7, true
IC: ADD DEFERRED:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %Ni.1 = add nsw i32 %Ni.0, %inc
IC: Mod =   %Ni.1 = add nsw i32 %Ni.0, %inc
    New =   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
IC: Visiting:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %inc8 = add nuw nsw i32 %j.0, 1
IC: Visiting:   br label %for.cond, !llvm.loop !2


INSTCOMBINE ITERATION #2 on _Z5solvev
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %inc8 = add nuw nsw i32 %j.0, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = call i32 @rand() #4
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.0 to double
IC: ADD:   br i1 %cmp, label %for.body, label %for.end
IC: ADD:   %cmp = icmp ult i32 %j.0, 10000000
IC: ADD:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   br label %for.cond
IC: ADD:   call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %call = call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.cond
IC: Visiting:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %cmp = icmp ult i32 %j.0, 10000000
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end
IC: Visiting:   %conv9 = sitofp i32 %Ni.0 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
IC: Visiting:   %call1 = call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.0, 1
IC: Visiting:   br label %for.cond, !llvm.loop !2
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.cond
4: %entry
5: %for.body
Found roots: %for.end 
---- Branch Probability Info : _Z5solvev ----

BPI: SCC 1: for.body for.cond
Computing probabilities for for.body
Computing probabilities for for.end
Computing probabilities for for.cond
eraseBlock for.cond
set edge for.cond -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.cond -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for entry

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.cond
 - 2: for.end
 - 3: for.body
loop-detection
 - loop = for.cond
 - loop = for.cond: member = for.body
compute-mass-in-loop: for.cond*
 - node: for.cond
  => [ local  ] weight = 2080374784, succ = for.body
  => [  exit  ] weight = 67108864, succ = for.end
  => mass:  ffffffffffffffff
  => assign 07ffffffffffffff (f800000000000000) [exit] to for.end
  => assign f800000000000000 (0000000000000000) to for.body
 - node: for.body
  => [backedge] weight = 2147483648
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) [back] to for.cond
compute-loop-scale: for.cond*
 - exit-mass = 07ffffffffffffff (ffffffffffffffff - f800000000000000)
 - scale = 32.0
packaging-loop: for.cond*
 - node: for.cond
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.cond
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.cond
 - node: for.cond
  => [ local  ] weight = 576460752303423487, succ = for.end
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.cond*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.cond: 1.0 => 32.0
 - for.body: 0.96875 => 31.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.cond: float = 32.0, scaled = 256.0, int = 256
 - for.end: float = 1.0, scaled = 8.0, int = 8
 - for.body: float = 31.0, scaled = 248.0, int = 248
block-frequency-info: _Z5solvev
 - entry: float = 1.0, int = 8
 - for.cond: float = 32.0, int = 256
 - for.body: float = 31.0, int = 248
 - for.end: float = 1.0, int = 8

Marked as tail call candidate:   %call = call i64 @time(i64* null) #4
Marked as tail call candidate:   call void @srand(i32 %conv) #4
Marked as tail call candidate:   %call1 = call i32 @rand() #4
Marked as tail call candidate:   %call3 = call i32 @rand() #4
Combine negations for:   %div11 = fdiv double %conv9, 1.000000e+07
Combine negations for:   %mul12 = fmul double %div11, 4.000000e+00
Combine negations for:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
Combine negations for:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Combine negations for:   %mul = fmul double %div, %div
Combine negations for:   %mul6 = fmul double %div5, %div5
Calculated Rank[conv4] = 393219
Calculated Rank[div5] = 393220
Calculated Rank[mul6] = 393221
Calculated Rank[conv2] = 393218
Calculated Rank[div] = 393219
Calculated Rank[mul] = 393220
Combine negations for:   %add = fadd double %mul, %mul6
Calculated Rank[add] = 393222
Calculated Rank[cmp7] = 393223
Calculated Rank[inc] = 393224
Combine negations for:   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
LINEARIZE:   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
OPERAND:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] (1)
ADD USES LEAF:   %Ni.0 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] (1)
OPERAND:   %inc = zext i1 %cmp7 to i32 (1)
ADD LEAF:   %inc = zext i1 %cmp7 to i32 (1)
RAIn:	add i32	[ %Ni.0, #262145] [ %inc, #393224] 
RAOut:	add i32	[ %inc, #393224] [ %Ni.0, #262145] 
RA:   %Ni.1 = add nuw nsw i32 %Ni.0, %inc
TO:   %Ni.1 = add nuw nsw i32 %inc, %Ni.0
Combine negations for:   %inc8 = add nuw nsw i32 %j.0, 1
LINEARIZE:   %inc8 = add nuw nsw i32 %j.0, 1
OPERAND:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] (1)
ADD USES LEAF:   %j.0 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] (1)
OPERAND: i32 1 (1)
ADD LEAF: i32 1 (1)
RAIn:	add i32	[ %j.0, #262146] [ 1, #0] 
RAOut:	add i32	[ %j.0, #262146] [ 1, #0] 
LoopRotation: rotating Loop at depth 1 containing: %for.cond<header><exiting>,%for.body<latch>
  Inserted PHI:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.0, %for.cond ]
  Inserted PHI:   %j.027 = phi i32 [ 0, %entry ], [ %j.0, %for.cond ]
Inserting edge %entry -> %for.end
	Reachable %entry -> %for.end
		NCA == %entry
Mark %for.endas affected, CurrentLevel 2
Updating NCD = %entry
	IDom(%for.end) = %entry
Inserting edge %entry -> %for.body
	Reachable %entry -> %for.body
		NCA == %entry
Mark %for.bodyas affected, CurrentLevel 2
	Successor %for.cond, level = 1
Updating NCD = %entry
	IDom(%for.body) = %entry
Deleting edge %entry -> %for.cond
	NCD %entry, ToIDom %entry
IsReachableFromIDom %for.cond
	Pred %for.body
	Support %entry
	%for.cond is reachable from support %entry
Deleting reachable %entry -> %for.cond
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Deleting edge %entry -> %for.end
	NCD %entry, ToIDom %entry
IsReachableFromIDom %for.end
	Pred %for.cond
	Support %entry
	%for.end is reachable from support %entry
Deleting reachable %entry -> %for.end
	Rebuilding subtree
The entire tree needs to be rebuilt
Merging: for.cond into for.body
DomTree recalculated, skipping future batch updates
LoopRotation: into Loop at depth 1 containing: %for.body<header><latch><exiting>
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.


INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.0.lcssa to double
IC: ADD:   %Ni.0.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2
IC: ADD:   %cmp = icmp ult i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %inc, %Ni.026
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %inc, %Ni.026
IC: Mod =   %Ni.1 = add nuw nsw i32 %inc, %Ni.026
    New =   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %cmp = icmp ult i32 %inc8, 10000000
IC: Old =   %cmp = icmp ult i32 %inc8, 10000000
    New =   <badref> = icmp ult i32 %j.027, 9999999
IC: ADD:   %cmp = icmp ult i32 %j.027, 9999999
IC: ERASE   %0 = icmp ult i32 %inc8, 10000000
IC: ADD DEFERRED:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %cmp = icmp ult i32 %j.027, 9999999
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2
IC: Visiting:   %Ni.0.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: Replacing   %Ni.0.lcssa = phi i32 [ %Ni.1, %for.body ]
    with   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Mod =   %Ni.0.lcssa = phi i32 [ %Ni.1, %for.body ]
    New =   %Ni.0.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ERASE   %Ni.0.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD DEFERRED:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12


INSTCOMBINE ITERATION #2 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1 to double
IC: ADD:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2
IC: ADD:   %cmp = icmp ult i32 %j.027, 9999999
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %cmp = icmp ult i32 %j.027, 9999999
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
loop-idiom Scanning: F[_Z5solvev] Countable Loop %for.body
INDVARS: Rewriting loop exit condition to:
      LHS:  %inc8 = add nuw nsw i32 %j.027, 1
       op:	!=
      RHS:	i32 10000000
ExitCount:	9999999
  was:   %cmp = icmp ult i32 %j.027, 9999999
Analyzing Loop for deletion: Loop at depth 1 containing: %for.body<header><latch><exiting>
Loop is not invariant, cannot delete.
Loop Unroll: F[_Z5solvev] Loop %for.body
  Loop Size = 21
  will not try to unroll partially because -unroll-allow-partial not given
SROA function: _Z5solvev
Instruction Merger
GVN iteration: 0
GVN removed:   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
GVN iteration: 1
SCCP on function '_Z5solvev'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  %call = tail call i64 @time(i64* null) #4
  %conv = trunc i64 %call to i32
  tail call void @srand(i32 %conv) #4
  br label %for.body

Merged overdefined into   %call = tail call i64 @time(i64* null) #4 : overdefined
markOverdefined:   %conv = trunc i64 %call to i32
Marking Block Executable: for.body

Popped off BBWL: 
for.body:                                         ; preds = %entry, %for.body
  %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
  %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
  %call1 = tail call i32 @rand() #4
  %conv2 = sitofp i32 %call1 to double
  %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  %call3 = tail call i32 @rand() #4
  %conv4 = sitofp i32 %call3 to double
  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
  %mul = fmul double %div, %div
  %mul6 = fmul double %div5, %div5
  %add = fadd double %mul, %mul6
  %cmp7 = fcmp ole double %add, 1.000000e+00
  %inc = zext i1 %cmp7 to i32
  %Ni.1 = add nuw nsw i32 %Ni.026, %inc
  %inc8 = add nuw nsw i32 %j.027, 1
  %exitcond = icmp ne i32 %inc8, 10000000
  br i1 %exitcond, label %for.body, label %for.end, !llvm.loop !2

Merged constantrange<0, 1> into   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] : constantrange<0, 1>
Merged constantrange<0, 1> into   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] : constantrange<0, 1>
Merged overdefined into   %call1 = tail call i32 @rand() #4 : overdefined
markOverdefined:   %conv2 = sitofp i32 %call1 to double
markOverdefined:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
Merged overdefined into   %call3 = tail call i32 @rand() #4 : overdefined
markOverdefined:   %conv4 = sitofp i32 %call3 to double
markOverdefined:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
markOverdefined:   %mul = fmul double %div, %div
markOverdefined:   %mul6 = fmul double %div5, %div5
markOverdefined:   %add = fadd double %mul, %mul6
markOverdefined:   %cmp7 = fcmp ole double %add, 1.000000e+00
markOverdefined:   %inc = zext i1 %cmp7 to i32
Merged overdefined into   %Ni.1 = add nuw nsw i32 %Ni.026, %inc : overdefined
Merged constantrange<1, 2> into   %inc8 = add nuw nsw i32 %j.027, 1 : constantrange<1, 2>
Merged constantrange<-1, 0> into   %exitcond = icmp ne i32 %inc8, 10000000 : constantrange<-1, 0>
Marking Edge Executable: for.body -> for.body
Merged constantrange<0, 2> into   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] : constantrange<0, 2>
Merged overdefined into   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] : overdefined

Popped off OI-WL:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]

Popped off OI-WL:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc

Popped off OI-WL:   %inc = zext i1 %cmp7 to i32

Popped off OI-WL:   %cmp7 = fcmp ole double %add, 1.000000e+00

Popped off OI-WL:   %add = fadd double %mul, %mul6

Popped off OI-WL:   %mul6 = fmul double %div5, %div5

Popped off OI-WL:   %mul = fmul double %div, %div

Popped off OI-WL:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000

Popped off OI-WL:   %conv4 = sitofp i32 %call3 to double

Popped off OI-WL:   %call3 = tail call i32 @rand() #4

Popped off OI-WL:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000

Popped off OI-WL:   %conv2 = sitofp i32 %call1 to double

Popped off OI-WL:   %call1 = tail call i32 @rand() #4

Popped off OI-WL:   %conv = trunc i64 %call to i32

Popped off OI-WL:   %call = tail call i64 @time(i64* null) #4

Popped off I-WL:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
Merged constantrange<1, 3> into   %inc8 = add nuw nsw i32 %j.027, 1 : constantrange<1, 3>

Popped off I-WL:   %inc8 = add nuw nsw i32 %j.027, 1
Merged constantrange<0, 3> into   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] : constantrange<0, 3>

Popped off I-WL:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
Merged constantrange<1, 4> into   %inc8 = add nuw nsw i32 %j.027, 1 : constantrange<1, 4>

Popped off I-WL:   %inc8 = add nuw nsw i32 %j.027, 1
Merged constantrange<0, 4> into   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] : overdefined

Popped off I-WL:   %exitcond = icmp ne i32 %inc8, 10000000

Popped off I-WL:   %inc8 = add nuw nsw i32 %j.027, 1

Popped off I-WL:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]

Popped off I-WL:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]

Popped off OI-WL:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
Merged overdefined into   %inc8 = add nuw nsw i32 %j.027, 1 : overdefined

Popped off OI-WL:   %inc8 = add nuw nsw i32 %j.027, 1
markOverdefined:   %exitcond = icmp ne i32 %inc8, 10000000

Popped off OI-WL:   %exitcond = icmp ne i32 %inc8, 10000000
Marking Block Executable: for.end

Popped off BBWL: 
for.end:                                          ; preds = %for.body
  %conv9 = sitofp i32 %Ni.1 to double
  %div11 = fdiv double %conv9, 1.000000e+07
  %mul12 = fmul double %div11, 4.000000e+00
  ret double %mul12

markOverdefined:   %conv9 = sitofp i32 %Ni.1 to double
markOverdefined:   %div11 = fdiv double %conv9, 1.000000e+07
markOverdefined:   %mul12 = fmul double %div11, 4.000000e+00

Popped off OI-WL:   %mul12 = fmul double %div11, 4.000000e+00

Popped off OI-WL:   %div11 = fdiv double %conv9, 1.000000e+07

Popped off OI-WL:   %conv9 = sitofp i32 %Ni.1 to double
RESOLVING UNDEFs
DemandedBits: Root:   %call = tail call i64 @time(i64* null) #4
DemandedBits: Root:   tail call void @srand(i32 %conv) #4
DemandedBits: Root:   br label %for.body
DemandedBits: Root:   %call1 = tail call i32 @rand() #4
DemandedBits: Root:   %call3 = tail call i32 @rand() #4
DemandedBits: Root:   br i1 %exitcond, label %for.body, label %for.end, !llvm.loop !2
DemandedBits: Root:   ret double %mul12
DemandedBits: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
DemandedBits: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
DemandedBits: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
DemandedBits: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc Alive Out: 0xffffffff
DemandedBits: Visiting:   %inc = zext i1 %cmp7 to i32 Alive Out: 0xffffffff
DemandedBits: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00 Alive Out: 0x1
DemandedBits: Visiting:   %add = fadd double %mul, %mul6
DemandedBits: Visiting:   %mul6 = fmul double %div5, %div5
DemandedBits: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
DemandedBits: Visiting:   %conv4 = sitofp i32 %call3 to double
DemandedBits: Visiting:   %mul = fmul double %div, %div
DemandedBits: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
DemandedBits: Visiting:   %conv2 = sitofp i32 %call1 to double
DemandedBits: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %exitcond = icmp ne i32 %inc8, 10000000 Alive Out: 0x1
DemandedBits: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %call3 = tail call i32 @rand() #4 Alive Out: 0xffffffff
DemandedBits: Visiting:   %call1 = tail call i32 @rand() #4 Alive Out: 0xffffffff
DemandedBits: Visiting:   %conv = trunc i64 %call to i32 Alive Out: 0xffffffff
DemandedBits: Visiting:   %call = tail call i64 @time(i64* null) #4 Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1 to double
IC: ADD:   br i1 %exitcond, label %for.body, label %for.end, !llvm.loop !2
IC: ADD:   %exitcond = icmp ne i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond = icmp ne i32 %inc8, 10000000
IC: Mod =   %exitcond = icmp ne i32 %inc8, 10000000
    New =   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12


INSTCOMBINE ITERATION #2 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1 to double
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
Jump threading on function '_Z5solvev'
LVI Getting value   %inc8 = add nuw nsw i32 %j.027, 1 at ''
  Result = overdefined
LVI Getting edge value   %inc8 = add nuw nsw i32 %j.027, 1 from 'for.body' to 'for.body'
PUSH:   %inc8 = add nuw nsw i32 %j.027, 1 in for.body
PUSH:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] in for.body
POP   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ] in for.body = constantrange<10000001, 10000000>
POP   %inc8 = add nuw nsw i32 %j.027, 1 in for.body = constantrange<1, 0>
  Result = constantrange<1, 0>
LVI Getting edge value   %Ni.1 = add nuw nsw i32 %Ni.026, %inc from 'for.body' to 'for.body'
PUSH:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc in for.body
PUSH:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] in for.body
PUSH:   %inc = zext i1 %cmp7 to i32 in for.body
PUSH:   %cmp7 = fcmp ole double %add, 1.000000e+00 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %cmp7 = fcmp ole double %add, 1.000000e+00 in for.body = overdefined
POP   %inc = zext i1 %cmp7 to i32 in for.body = constantrange<0, 2>
 compute BB 'for.body' - overdefined because of pred (local).
POP   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ] in for.body = overdefined
POP   %Ni.1 = add nuw nsw i32 %Ni.026, %inc in for.body = overdefined
  Result = overdefined
LVI Getting block end value   %add = fadd double %mul, %mul6 at 'for.body'
PUSH:   %add = fadd double %mul, %mul6 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %add = fadd double %mul, %mul6 in for.body = overdefined
  Result = overdefined
LVI Getting block end value   %inc8 = add nuw nsw i32 %j.027, 1 at 'for.body'
  Result = constantrange<1, 0>
LVI Getting block end value   %mul12 = fmul double %div11, 4.000000e+00 at 'for.end'
PUSH:   %mul12 = fmul double %div11, 4.000000e+00 in for.end
 compute BB 'for.end' - unknown inst def found.
POP   %mul12 = fmul double %div11, 4.000000e+00 in for.end = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.body
4: %entry
Found roots: %for.end 
mark live:   %call = tail call i64 @time(i64* null) #4
mark block live: entry
mark live:   br label %for.body
mark live:   tail call void @srand(i32 %conv) #4
mark live:   %call1 = tail call i32 @rand() #4
mark block live: for.body
mark live:   %call3 = tail call i32 @rand() #4
mark live:   ret double %mul12
mark block live: for.end
mark live:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
post-dom root child is a return: for.end
work live:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
mark live:   %exitcond.not = icmp eq i32 %inc8, 10000000
work live:   %exitcond.not = icmp eq i32 %inc8, 10000000
mark live:   %inc8 = add nuw nsw i32 %j.027, 1
work live:   %inc8 = add nuw nsw i32 %j.027, 1
mark live:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
work live:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
work live:   ret double %mul12
mark live:   %mul12 = fmul double %div11, 4.000000e+00
work live:   %mul12 = fmul double %div11, 4.000000e+00
mark live:   %div11 = fdiv double %conv9, 1.000000e+07
work live:   %div11 = fdiv double %conv9, 1.000000e+07
mark live:   %conv9 = sitofp i32 %Ni.1 to double
work live:   %conv9 = sitofp i32 %Ni.1 to double
mark live:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
work live:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
mark live:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
mark live:   %inc = zext i1 %cmp7 to i32
work live:   %inc = zext i1 %cmp7 to i32
mark live:   %cmp7 = fcmp ole double %add, 1.000000e+00
work live:   %cmp7 = fcmp ole double %add, 1.000000e+00
mark live:   %add = fadd double %mul, %mul6
work live:   %add = fadd double %mul, %mul6
mark live:   %mul = fmul double %div, %div
mark live:   %mul6 = fmul double %div5, %div5
work live:   %mul6 = fmul double %div5, %div5
mark live:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
work live:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
mark live:   %conv4 = sitofp i32 %call3 to double
work live:   %conv4 = sitofp i32 %call3 to double
work live:   %mul = fmul double %div, %div
mark live:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
work live:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
mark live:   %conv2 = sitofp i32 %call1 to double
work live:   %conv2 = sitofp i32 %call1 to double
work live:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
work live:   %call3 = tail call i32 @rand() #4
work live:   %call1 = tail call i32 @rand() #4
work live:   tail call void @srand(i32 %conv) #4
mark live:   %conv = trunc i64 %call to i32
work live:   %conv = trunc i64 %call to i32
work live:   br label %for.body
work live:   %call = tail call i64 @time(i64* null) #4
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.


INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1.lcssa to double
IC: ADD:   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: Replacing   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
    with   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Mod =   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
    New =   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ERASE   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD DEFERRED:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12


INSTCOMBINE ITERATION #2 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1 to double
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_Z5solvev'<<0xfce6120>>  #uses=2
  CS<0xfc6fcf0> calls function 'time'
  CS<0xfc6fd90> calls function 'srand'
  CS<0xfc70850> calls function 'rand'
  CS<0xfc70960> calls function 'rand'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: printf: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: 'main'<<0xfc673c0>>  #uses=1
  CS<0xfab0810> calls function '_Z5solvev'
  CS<0xfab0980> calls function 'printf'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: main: 1 call sites.
      Analyzing call of _Z5solvev... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 5
      NumInstructions: 25
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 180
      Threshold: 225
    Inlining (cost=180, threshold=225), Call:   %call = call double @_Z5solvev()
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: 'main'<<0xfc673c0>>  #uses=1
  CS<0xfd4f250> calls function 'rand'
  CS<0xfab0980> calls function 'printf'
  CS<0xfd53830> calls function 'time'
  CS<0xfd47ed0> calls function 'srand'
  CS<0xfceae10> calls function 'rand'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: main
EarlyCSE CVP: Add conditional value for 'exitcond.not.i' as i1 true in _Z5solvev.exit
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function 'main'
LVI Getting value   %inc8.i = add nuw nsw i32 %j.027.i, 1 at ''
  Result = overdefined
LVI Getting edge value   %inc8.i = add nuw nsw i32 %j.027.i, 1 from 'for.body.i' to 'for.body.i'
PUSH:   %inc8.i = add nuw nsw i32 %j.027.i, 1 in for.body.i
PUSH:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] in for.body.i
POP   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] in for.body.i = constantrange<10000001, 10000000>
POP   %inc8.i = add nuw nsw i32 %j.027.i, 1 in for.body.i = constantrange<1, 0>
  Result = constantrange<1, 0>
LVI Getting edge value   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i from 'for.body.i' to 'for.body.i'
PUSH:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i in for.body.i
PUSH:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] in for.body.i
PUSH:   %inc.i = zext i1 %cmp7.i to i32 in for.body.i
PUSH:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00 in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %cmp7.i = fcmp ole double %add.i, 1.000000e+00 in for.body.i = overdefined
POP   %inc.i = zext i1 %cmp7.i to i32 in for.body.i = constantrange<0, 2>
 compute BB 'for.body.i' - overdefined because of pred (local).
POP   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] in for.body.i = overdefined
POP   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i in for.body.i = overdefined
  Result = overdefined
LVI Getting block end value   %add.i = fadd double %mul.i, %mul6.i at 'for.body.i'
PUSH:   %add.i = fadd double %mul.i, %mul6.i in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %add.i = fadd double %mul.i, %mul6.i in for.body.i = overdefined
  Result = overdefined
LVI Getting block end value   %inc8.i = add nuw nsw i32 %j.027.i, 1 at 'for.body.i'
  Result = constantrange<1, 0>


INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = call i64 @time(i64* null) #4
IC: Visiting:   %call.i = call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0
		Looking for trivial roots
Found a new trivial root: %_Z5solvev.exit
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %_Z5solvev.exit
3: %for.body.i
4: %entry
Found roots: %_Z5solvev.exit 
---- Branch Probability Info : main ----

Computing probabilities for _Z5solvev.exit
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body.i -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.i
 - 2: _Z5solvev.exit
loop-detection
 - loop = for.body.i
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [  exit  ] weight = 67108864, succ = _Z5solvev.exit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to _Z5solvev.exit
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = _Z5solvev.exit
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to _Z5solvev.exit
 - node: _Z5solvev.exit
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body.i*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body.i: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body.i: float = 32.0, scaled = 256.0, int = 255
 - _Z5solvev.exit: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8
 - for.body.i: float = 32.0, int = 255
 - _Z5solvev.exit: float = 1.0, int = 8

Marked as tail call candidate:   %call.i = call i64 @time(i64* null) #4
Marked as tail call candidate:   call void @srand(i32 %conv.i) #4
Marked as tail call candidate:   %call1.i = call i32 @rand() #4
Marked as tail call candidate:   %call3.i = call i32 @rand() #4
Marked as tail call candidate:   %call1 = call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
Combine negations for:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
Combine negations for:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Combine negations for:   %mul.i = fmul double %div.i, %div.i
Combine negations for:   %mul6.i = fmul double %div5.i, %div5.i
Calculated Rank[conv4.i] = 262149
Calculated Rank[div5.i] = 262150
Calculated Rank[mul6.i] = 262151
Calculated Rank[conv2.i] = 262148
Calculated Rank[div.i] = 262149
Calculated Rank[mul.i] = 262150
Combine negations for:   %add.i = fadd double %mul.i, %mul6.i
Calculated Rank[add.i] = 262152
Calculated Rank[cmp7.i] = 262153
Calculated Rank[inc.i] = 262154
Combine negations for:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
LINEARIZE:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
OPERAND:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] (1)
ADD LEAF:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] (1)
OPERAND:   %inc.i = zext i1 %cmp7.i to i32 (1)
ADD LEAF:   %inc.i = zext i1 %cmp7.i to i32 (1)
RAIn:	add i32	[ %Ni.026.i, #262146] [ %inc.i, #262154] 
RAOut:	add i32	[ %inc.i, #262154] [ %Ni.026.i, #262146] 
RA:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
TO:   %Ni.1.i = add nuw nsw i32 %inc.i, %Ni.026.i
Combine negations for:   %inc8.i = add nuw nsw i32 %j.027.i, 1
LINEARIZE:   %inc8.i = add nuw nsw i32 %j.027.i, 1
OPERAND:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] (1)
ADD LEAF:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] (1)
OPERAND: i32 1 (1)
ADD USES LEAF: i32 1 (1)
RAIn:	add i32	[ %j.027.i, #262145] [ 1, #0] 
RAOut:	add i32	[ %j.027.i, #262145] [ 1, #0] 
Combine negations for:   %div11.i = fdiv double %conv9.i, 1.000000e+07
Combine negations for:   %mul12.i = fmul double %div11.i, 4.000000e+00
Perform LICM on Loop with header at block for.body.i
LICM: Using MemorySSA.


INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i.lcssa to double
IC: ADD:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %inc.i, %Ni.026.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %inc.i, %Ni.026.i
IC: Mod =   %Ni.1.i = add nuw nsw i32 %inc.i, %Ni.026.i
    New =   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: Replacing   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    with   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Mod =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    New =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ERASE   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD DEFERRED:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0


INSTCOMBINE ITERATION #2 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0
loop-idiom Scanning: F[main] Countable Loop %for.body.i
Analyzing Loop for deletion: Loop at depth 1 containing: %for.body.i<header><latch><exiting>
Loop is not invariant, cannot delete.
Loop Unroll: F[main] Loop %for.body.i
  Loop Size = 21
  will not try to unroll partially because -unroll-allow-partial not given
SROA function: main
Instruction Merger
GVN iteration: 0
GVN removed:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
GVN iteration: 1
SCCP on function 'main'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  %call.i = tail call i64 @time(i64* null) #4
  %conv.i = trunc i64 %call.i to i32
  tail call void @srand(i32 %conv.i) #4
  br label %for.body.i

Merged overdefined into   %call.i = tail call i64 @time(i64* null) #4 : overdefined
markOverdefined:   %conv.i = trunc i64 %call.i to i32
Marking Block Executable: for.body.i

Popped off BBWL: 
for.body.i:                                       ; preds = %for.body.i, %entry
  %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
  %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
  %call1.i = tail call i32 @rand() #4
  %conv2.i = sitofp i32 %call1.i to double
  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
  %call3.i = tail call i32 @rand() #4
  %conv4.i = sitofp i32 %call3.i to double
  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
  %mul.i = fmul double %div.i, %div.i
  %mul6.i = fmul double %div5.i, %div5.i
  %add.i = fadd double %mul.i, %mul6.i
  %cmp7.i = fcmp ole double %add.i, 1.000000e+00
  %inc.i = zext i1 %cmp7.i to i32
  %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
  %inc8.i = add nuw nsw i32 %j.027.i, 1
  %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
  br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2

Merged constantrange<0, 1> into   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] : constantrange<0, 1>
Merged constantrange<0, 1> into   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] : constantrange<0, 1>
Merged overdefined into   %call1.i = tail call i32 @rand() #4 : overdefined
markOverdefined:   %conv2.i = sitofp i32 %call1.i to double
markOverdefined:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
Merged overdefined into   %call3.i = tail call i32 @rand() #4 : overdefined
markOverdefined:   %conv4.i = sitofp i32 %call3.i to double
markOverdefined:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
markOverdefined:   %mul.i = fmul double %div.i, %div.i
markOverdefined:   %mul6.i = fmul double %div5.i, %div5.i
markOverdefined:   %add.i = fadd double %mul.i, %mul6.i
markOverdefined:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
markOverdefined:   %inc.i = zext i1 %cmp7.i to i32
Merged overdefined into   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i : overdefined
Merged constantrange<1, 2> into   %inc8.i = add nuw nsw i32 %j.027.i, 1 : constantrange<1, 2>
Merged constantrange<0, -1> into   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000 : constantrange<0, -1>
Marking Edge Executable: for.body.i -> for.body.i
Merged constantrange<0, 2> into   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] : constantrange<0, 2>
Merged overdefined into   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] : overdefined

Popped off OI-WL:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]

Popped off OI-WL:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i

Popped off OI-WL:   %inc.i = zext i1 %cmp7.i to i32

Popped off OI-WL:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00

Popped off OI-WL:   %add.i = fadd double %mul.i, %mul6.i

Popped off OI-WL:   %mul6.i = fmul double %div5.i, %div5.i

Popped off OI-WL:   %mul.i = fmul double %div.i, %div.i

Popped off OI-WL:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000

Popped off OI-WL:   %conv4.i = sitofp i32 %call3.i to double

Popped off OI-WL:   %call3.i = tail call i32 @rand() #4

Popped off OI-WL:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000

Popped off OI-WL:   %conv2.i = sitofp i32 %call1.i to double

Popped off OI-WL:   %call1.i = tail call i32 @rand() #4

Popped off OI-WL:   %conv.i = trunc i64 %call.i to i32

Popped off OI-WL:   %call.i = tail call i64 @time(i64* null) #4

Popped off I-WL:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
Merged constantrange<1, 3> into   %inc8.i = add nuw nsw i32 %j.027.i, 1 : constantrange<1, 3>

Popped off I-WL:   %inc8.i = add nuw nsw i32 %j.027.i, 1
Merged constantrange<0, 3> into   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] : constantrange<0, 3>

Popped off I-WL:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
Merged constantrange<1, 4> into   %inc8.i = add nuw nsw i32 %j.027.i, 1 : constantrange<1, 4>

Popped off I-WL:   %inc8.i = add nuw nsw i32 %j.027.i, 1
Merged constantrange<0, 4> into   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] : overdefined

Popped off I-WL:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000

Popped off I-WL:   %inc8.i = add nuw nsw i32 %j.027.i, 1

Popped off I-WL:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]

Popped off I-WL:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]

Popped off OI-WL:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
Merged overdefined into   %inc8.i = add nuw nsw i32 %j.027.i, 1 : overdefined

Popped off OI-WL:   %inc8.i = add nuw nsw i32 %j.027.i, 1
markOverdefined:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000

Popped off OI-WL:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
Marking Block Executable: _Z5solvev.exit

Popped off BBWL: 
_Z5solvev.exit:                                   ; preds = %for.body.i
  %conv9.i = sitofp i32 %Ni.1.i to double
  %div11.i = fdiv double %conv9.i, 1.000000e+07
  %mul12.i = fmul double %div11.i, 4.000000e+00
  %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
  ret i32 0

markOverdefined:   %conv9.i = sitofp i32 %Ni.1.i to double
markOverdefined:   %div11.i = fdiv double %conv9.i, 1.000000e+07
markOverdefined:   %mul12.i = fmul double %div11.i, 4.000000e+00
Merged overdefined into   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i) : overdefined

Popped off OI-WL:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)

Popped off OI-WL:   %mul12.i = fmul double %div11.i, 4.000000e+00

Popped off OI-WL:   %div11.i = fdiv double %conv9.i, 1.000000e+07

Popped off OI-WL:   %conv9.i = sitofp i32 %Ni.1.i to double
RESOLVING UNDEFs
DemandedBits: Root:   %call.i = tail call i64 @time(i64* null) #4
DemandedBits: Root:   tail call void @srand(i32 %conv.i) #4
DemandedBits: Root:   br label %for.body.i
DemandedBits: Root:   %call1.i = tail call i32 @rand() #4
DemandedBits: Root:   %call3.i = tail call i32 @rand() #4
DemandedBits: Root:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
DemandedBits: Root:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
DemandedBits: Root:   ret i32 0
DemandedBits: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i) Alive Out: 0x0
DemandedBits: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
DemandedBits: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
DemandedBits: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
DemandedBits: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i Alive Out: 0xffffffff
DemandedBits: Visiting:   %inc.i = zext i1 %cmp7.i to i32 Alive Out: 0xffffffff
DemandedBits: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00 Alive Out: 0x1
DemandedBits: Visiting:   %add.i = fadd double %mul.i, %mul6.i
DemandedBits: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
DemandedBits: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
DemandedBits: Visiting:   %conv4.i = sitofp i32 %call3.i to double
DemandedBits: Visiting:   %mul.i = fmul double %div.i, %div.i
DemandedBits: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
DemandedBits: Visiting:   %conv2.i = sitofp i32 %call1.i to double
DemandedBits: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000 Alive Out: 0x1
DemandedBits: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %call3.i = tail call i32 @rand() #4 Alive Out: 0xffffffff
DemandedBits: Visiting:   %call1.i = tail call i32 @rand() #4 Alive Out: 0xffffffff
DemandedBits: Visiting:   %conv.i = trunc i64 %call.i to i32 Alive Out: 0xffffffff
DemandedBits: Visiting:   %call.i = tail call i64 @time(i64* null) #4 Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0
Jump threading on function 'main'
LVI Getting value   %inc8.i = add nuw nsw i32 %j.027.i, 1 at ''
  Result = overdefined
LVI Getting edge value   %inc8.i = add nuw nsw i32 %j.027.i, 1 from 'for.body.i' to 'for.body.i'
PUSH:   %inc8.i = add nuw nsw i32 %j.027.i, 1 in for.body.i
PUSH:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] in for.body.i
POP   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ] in for.body.i = constantrange<10000001, 10000000>
POP   %inc8.i = add nuw nsw i32 %j.027.i, 1 in for.body.i = constantrange<1, 0>
  Result = constantrange<1, 0>
LVI Getting edge value   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i from 'for.body.i' to 'for.body.i'
PUSH:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i in for.body.i
PUSH:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] in for.body.i
PUSH:   %inc.i = zext i1 %cmp7.i to i32 in for.body.i
PUSH:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00 in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %cmp7.i = fcmp ole double %add.i, 1.000000e+00 in for.body.i = overdefined
POP   %inc.i = zext i1 %cmp7.i to i32 in for.body.i = constantrange<0, 2>
 compute BB 'for.body.i' - overdefined because of pred (local).
POP   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ] in for.body.i = overdefined
POP   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i in for.body.i = overdefined
  Result = overdefined
LVI Getting block end value   %add.i = fadd double %mul.i, %mul6.i at 'for.body.i'
PUSH:   %add.i = fadd double %mul.i, %mul6.i in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %add.i = fadd double %mul.i, %mul6.i in for.body.i = overdefined
  Result = overdefined
LVI Getting block end value   %inc8.i = add nuw nsw i32 %j.027.i, 1 at 'for.body.i'
  Result = constantrange<1, 0>
		Looking for trivial roots
Found a new trivial root: %_Z5solvev.exit
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %_Z5solvev.exit
3: %for.body.i
4: %entry
Found roots: %_Z5solvev.exit 
mark live:   %call.i = tail call i64 @time(i64* null) #4
mark block live: entry
mark live:   br label %for.body.i
mark live:   tail call void @srand(i32 %conv.i) #4
mark live:   %call1.i = tail call i32 @rand() #4
mark block live: for.body.i
mark live:   %call3.i = tail call i32 @rand() #4
mark live:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
mark block live: _Z5solvev.exit
mark live:   ret i32 0
mark live:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
post-dom root child is a return: _Z5solvev.exit
work live:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
mark live:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
work live:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
mark live:   %inc8.i = add nuw nsw i32 %j.027.i, 1
work live:   %inc8.i = add nuw nsw i32 %j.027.i, 1
mark live:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
work live:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
work live:   ret i32 0
work live:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
mark live:   %mul12.i = fmul double %div11.i, 4.000000e+00
work live:   %mul12.i = fmul double %div11.i, 4.000000e+00
mark live:   %div11.i = fdiv double %conv9.i, 1.000000e+07
work live:   %div11.i = fdiv double %conv9.i, 1.000000e+07
mark live:   %conv9.i = sitofp i32 %Ni.1.i to double
work live:   %conv9.i = sitofp i32 %Ni.1.i to double
mark live:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
work live:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
mark live:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
mark live:   %inc.i = zext i1 %cmp7.i to i32
work live:   %inc.i = zext i1 %cmp7.i to i32
mark live:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
work live:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
mark live:   %add.i = fadd double %mul.i, %mul6.i
work live:   %add.i = fadd double %mul.i, %mul6.i
mark live:   %mul.i = fmul double %div.i, %div.i
mark live:   %mul6.i = fmul double %div5.i, %div5.i
work live:   %mul6.i = fmul double %div5.i, %div5.i
mark live:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
work live:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
mark live:   %conv4.i = sitofp i32 %call3.i to double
work live:   %conv4.i = sitofp i32 %call3.i to double
work live:   %mul.i = fmul double %div.i, %div.i
mark live:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
work live:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
mark live:   %conv2.i = sitofp i32 %call1.i to double
work live:   %conv2.i = sitofp i32 %call1.i to double
work live:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
work live:   %call3.i = tail call i32 @rand() #4
work live:   %call1.i = tail call i32 @rand() #4
work live:   tail call void @srand(i32 %conv.i) #4
mark live:   %conv.i = trunc i64 %call.i to i32
work live:   %conv.i = trunc i64 %call.i to i32
work live:   br label %for.body.i
work live:   %call.i = tail call i64 @time(i64* null) #4
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function
Perform LICM on Loop with header at block for.body.i
LICM: Using MemorySSA.


INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i.lcssa to double
IC: ADD:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: Replacing   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    with   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Mod =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    New =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ERASE   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD DEFERRED:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0


INSTCOMBINE ITERATION #2 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: 'main'<<0xfc673c0>>  #uses=1
  CS<0xfd4f250> calls function 'rand'
  CS<0xfab0980> calls function 'printf'
  CS<0xfd53830> calls function 'time'
  CS<0xfd47ed0> calls function 'srand'
  CS<0xfceae10> calls function 'rand'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: INDIRECTNODE: 0 call sites.
F2I: Looking at function _Z5solvev
F2I:   %cmp7 = fcmp ole double %add, 1.000000e+00:empty-set
F2I:   %add = fadd double %mul, %mul6:empty-set
F2I:   %mul6 = fmul double %div5, %div5:empty-set
F2I:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000:full-set
F2I:   %mul = fmul double %div, %div:empty-set
F2I:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000:full-set
F2I:   %mul = fmul double %div, %div:full-set
F2I:   %mul6 = fmul double %div5, %div5:full-set
F2I:   %add = fadd double %mul, %mul6:full-set
F2I:   %cmp7 = fcmp ole double %add, 1.000000e+00:full-set
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.body
4: %entry
Found roots: %for.end 
---- Branch Probability Info : _Z5solvev ----

Computing probabilities for for.end
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.end
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body: float = 32.0, scaled = 256.0, int = 255
 - for.end: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - entry: float = 1.0, int = 8
 - for.body: float = 32.0, int = 255
 - for.end: float = 1.0, int = 8


LV: Checking a loop in "_Z5solvev" from montec.cpp
LV: Loop hints: force=? width=0 unroll=0
LV: Found a loop: for.body
LV: Found an induction variable.
Found an ADD reduction PHI.  %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
LV: Not vectorizing: Found a non-intrinsic callsite   %call1 = tail call i32 @rand() #4
LV: Interleaving disabled by the pass manager
LV: Can't vectorize the instructions or CFG
LV: Not vectorizing: Cannot prove legality.
LAA: Found a loop in _Z5solvev: for.body

In "_Z5solvev" checking Loop at depth 1 containing: %for.body<header><latch><exiting>



INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1.lcssa to double
IC: ADD:   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: Replacing   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
    with   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Mod =   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
    New =   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ERASE   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD DEFERRED:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12


INSTCOMBINE ITERATION #2 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1 to double
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
SLP: Analyzing blocks in _Z5solvev.
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP: Gathering due to C,S,B,O. 
SLP:  bundle:   %inc8 = add nuw nsw i32 %j.027, 1
SLP:  initialize schedule region to   %inc8 = add nuw nsw i32 %j.027, 1
SLP:  extend schedule region start to   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
SLP: try schedule bundle [  %inc8 = add nuw nsw i32 %j.027, 1;  %Ni.1 = add nuw nsw i32 %Ni.026, %inc] in block for.body
SLP:       update deps of [  %inc8 = add nuw nsw i32 %j.027, 1;  %Ni.1 = add nuw nsw i32 %Ni.026, %inc]
SLP:       update deps of /   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
SLP:     gets ready on update:   %inc8 = add nuw nsw i32 %j.027, 1
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP: 	Checking bundle:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ].
SLP: Perfect diamond merge at   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ].
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %inc8 = add nuw nsw i32 %j.027, 1.
SLP: 	Internal user will be removed:  %inc8 = add nuw nsw i32 %j.027, 1.
SLP: Checking user:  %Ni.1 = add nuw nsw i32 %Ni.026, %inc.
SLP: 	Internal user will be removed:  %Ni.1 = add nuw nsw i32 %Ni.026, %inc.
SLP: Checking user:  %exitcond.not = icmp eq i32 %inc8, 10000000.
SLP: Need to extract:  %exitcond.not = icmp eq i32 %inc8, 10000000 from lane 0 from   %inc8 = add nuw nsw i32 %j.027, 1.
SLP: Checking user:  %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ].
SLP: 	Internal user will be removed:  %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ].
SLP: Checking user:  %conv9 = sitofp i32 %Ni.1 to double.
SLP: Need to extract:  %conv9 = sitofp i32 %Ni.1 to double from lane 1 from   %Ni.1 = add nuw nsw i32 %Ni.026, %inc.
SLP: Checking user:  %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ].
SLP: 	Internal user will be removed:  %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ].
SLP: Calculating cost for tree of size 4.
SLP: Adding cost 0 for bundle that starts with   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ].
SLP: Current total cost = 0
SLP: Adding cost 0 for bundle that starts with i32 0.
SLP: Current total cost = 0
SLP: Calculated costs for Tree:
2.
Operand 0:
    %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
    %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
Operand 1:
  i32 1
    %inc = zext i1 %cmp7 to i32
Scalars: 
    %inc8 = add nuw nsw i32 %j.027, 1
    %Ni.1 = add nuw nsw i32 %Ni.026, %inc
State: Vectorize
MainOp:   %inc8 = add nuw nsw i32 %j.027, 1
AltOp:   %inc8 = add nuw nsw i32 %j.027, 1
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:1}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Adding cost -1 for bundle that starts with   %inc8 = add nuw nsw i32 %j.027, 1.
SLP: Current total cost = -1
SLP: Adding cost 3 for bundle that starts with i32 1.
SLP: Current total cost = 2
SLP: #LV: 1 j.027, Looking at   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
SLP: Spill Cost = 0.
SLP: Extract Cost = 3.
SLP: Total Cost = 5.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul = fmul double %div, %div
SLP:  initialize schedule region to   %mul = fmul double %div, %div
SLP:  extend schedule region end to   %mul6 = fmul double %div5, %div5
SLP: try schedule bundle [  %mul = fmul double %div, %div;  %mul6 = fmul double %div5, %div5] in block for.body
SLP:       update deps of [  %mul = fmul double %div, %div;  %mul6 = fmul double %div5, %div5]
SLP:       update deps of /   %mul6 = fmul double %div5, %div5
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  extend schedule region start to   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000] in block for.body
SLP:       update deps of [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP:   schedule [  %mul = fmul double %div, %div;  %mul6 = fmul double %div5, %div5]
SLP:    gets ready (def): [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %conv2 = sitofp i32 %call1 to double
SLP:  extend schedule region start to   %conv2 = sitofp i32 %call1 to double
SLP: try schedule bundle [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double] in block for.body
SLP:       update deps of [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double]
SLP:       update deps of /   %conv4 = sitofp i32 %call3 to double
SLP:   schedule [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:    gets ready (def): [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double]
SLP: We are able to schedule this bundle.
SLP: added a vector of casts.
SLP:  bundle:   %call1 = tail call i32 @rand() #4
SLP:  extend schedule region start to   %call1 = tail call i32 @rand() #4
SLP: try schedule bundle [  %call1 = tail call i32 @rand() #4;  %call3 = tail call i32 @rand() #4] in block for.body
SLP:       update deps of [  %call1 = tail call i32 @rand() #4;  %call3 = tail call i32 @rand() #4]
SLP:       update deps of /   %call3 = tail call i32 @rand() #4
SLP:   schedule [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double]
SLP:  cancel scheduling of [  %call1 = tail call i32 @rand() #4;  %call3 = tail call i32 @rand() #4]
SLP: We are not able to schedule this bundle!
SLP: Gathering due to C,S,B,O. 
SLP: 	Checking bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Perfect diamond merge at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 0 from   %mul = fmul double %div, %div.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 1 from   %mul6 = fmul double %div5, %div5.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: 	Internal user will be removed:  %mul = fmul double %div, %div.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: 	Internal user will be removed:  %mul = fmul double %div, %div.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: 	Internal user will be removed:  %mul6 = fmul double %div5, %div5.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: 	Internal user will be removed:  %mul6 = fmul double %div5, %div5.
SLP: Checking user:  %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 5.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Operand 1:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Scalars: 
    %mul = fmul double %div, %div
    %mul6 = fmul double %div5, %div5
State: Vectorize
MainOp:   %mul = fmul double %div, %div
AltOp:   %mul = fmul double %div, %div
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -2
SLP: Adding cost -2 for bundle that starts with   %mul = fmul double %div, %div.
SLP: Current total cost = -2
SLP: Calculated costs for Tree:
1.
Operand 0:
    %conv2 = sitofp i32 %call1 to double
    %conv4 = sitofp i32 %call3 to double
Operand 1:
  double 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
AltOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, {User:0 EdgeIdx:1}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 69
SLP:     ScalarCost = 76
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -7
SLP: Adding cost -7 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = -9
SLP: Calculated costs for Tree:
2.
Operand 0:
    %call1 = tail call i32 @rand() #4
    %call3 = tail call i32 @rand() #4
Scalars: 
    %conv2 = sitofp i32 %call1 to double
    %conv4 = sitofp i32 %call3 to double
State: Vectorize
MainOp:   %conv2 = sitofp i32 %call1 to double
AltOp:   %conv2 = sitofp i32 %call1 to double
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:1 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 20
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 18
SLP: Adding cost 18 for bundle that starts with   %conv2 = sitofp i32 %call1 to double.
SLP: Current total cost = 9
SLP: Adding cost 3 for bundle that starts with   %call1 = tail call i32 @rand() #4.
SLP: Current total cost = 12
SLP: Adding cost 0 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 12
SLP: #LV: 1 div, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: #LV: 1 conv2, Looking at   %conv2 = sitofp i32 %call1 to double
SLP: #LV: 0, Looking at   %call1 = tail call i32 @rand() #4
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 13.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul = fmul double %div, %div
SLP:  initialize schedule region to   %mul = fmul double %div, %div
SLP:  extend schedule region start to   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000] in block for.body
SLP:       update deps of [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 0 from   %mul = fmul double %div, %div.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %conv4 = sitofp i32 %call3 to double
Operand 1:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul = fmul double %div, %div
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul = fmul double %div, %div
AltOp:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul = fmul double %div, %div.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul = fmul double %div, %div
SLP:  initialize schedule region to   %mul = fmul double %div, %div
SLP:  extend schedule region start to   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000] in block for.body
SLP:       update deps of [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 0 from   %mul = fmul double %div, %div.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %conv4 = sitofp i32 %call3 to double
Operand 1:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul = fmul double %div, %div
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul = fmul double %div, %div
AltOp:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul = fmul double %div, %div.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6 = fmul double %div5, %div5
SLP: try schedule bundle [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5] in block for.body
SLP:       update deps of [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP:       update deps of /   %mul6 = fmul double %div5, %div5
SLP:       update deps of   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:   schedule   %mul = fmul double %div, %div
SLP:    gets ready (def): [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 1 from   %mul6 = fmul double %div5, %div5.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2 = sitofp i32 %call1 to double
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Scalars: 
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %mul6 = fmul double %div5, %div5
State: Vectorize
MainOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
AltOp:   %mul6 = fmul double %div5, %div5
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2 = sitofp i32 %call1 to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2 = sitofp i32 %call1 to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6 = fmul double %div5, %div5
SLP: try schedule bundle [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5] in block for.body
SLP:       update deps of [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP:       update deps of /   %mul6 = fmul double %div5, %div5
SLP:       update deps of   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:   schedule   %mul = fmul double %div, %div
SLP:    gets ready (def): [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 1 from   %mul6 = fmul double %div5, %div5.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2 = sitofp i32 %call1 to double
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Scalars: 
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %mul6 = fmul double %div5, %div5
State: Vectorize
MainOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
AltOp:   %mul6 = fmul double %div5, %div5
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2 = sitofp i32 %call1 to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2 = sitofp i32 %call1 to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul = fmul double %div, %div
SLP:  initialize schedule region to   %mul = fmul double %div, %div
SLP:  extend schedule region end to   %mul6 = fmul double %div5, %div5
SLP: try schedule bundle [  %mul = fmul double %div, %div;  %mul6 = fmul double %div5, %div5] in block for.body
SLP:       update deps of [  %mul = fmul double %div, %div;  %mul6 = fmul double %div5, %div5]
SLP:       update deps of /   %mul6 = fmul double %div5, %div5
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  extend schedule region start to   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000] in block for.body
SLP:       update deps of [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP:   schedule [  %mul = fmul double %div, %div;  %mul6 = fmul double %div5, %div5]
SLP:    gets ready (def): [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %conv2 = sitofp i32 %call1 to double
SLP:  extend schedule region start to   %conv2 = sitofp i32 %call1 to double
SLP: try schedule bundle [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double] in block for.body
SLP:       update deps of [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double]
SLP:       update deps of /   %conv4 = sitofp i32 %call3 to double
SLP:   schedule [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:    gets ready (def): [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double]
SLP: We are able to schedule this bundle.
SLP: added a vector of casts.
SLP:  bundle:   %call1 = tail call i32 @rand() #4
SLP:  extend schedule region start to   %call1 = tail call i32 @rand() #4
SLP: try schedule bundle [  %call1 = tail call i32 @rand() #4;  %call3 = tail call i32 @rand() #4] in block for.body
SLP:       update deps of [  %call1 = tail call i32 @rand() #4;  %call3 = tail call i32 @rand() #4]
SLP:       update deps of /   %call3 = tail call i32 @rand() #4
SLP:   schedule [  %conv2 = sitofp i32 %call1 to double;  %conv4 = sitofp i32 %call3 to double]
SLP:  cancel scheduling of [  %call1 = tail call i32 @rand() #4;  %call3 = tail call i32 @rand() #4]
SLP: We are not able to schedule this bundle!
SLP: Gathering due to C,S,B,O. 
SLP: 	Checking bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Perfect diamond merge at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 0 from   %mul = fmul double %div, %div.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 1 from   %mul6 = fmul double %div5, %div5.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: 	Internal user will be removed:  %mul = fmul double %div, %div.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: 	Internal user will be removed:  %mul = fmul double %div, %div.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: 	Internal user will be removed:  %mul6 = fmul double %div5, %div5.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: 	Internal user will be removed:  %mul6 = fmul double %div5, %div5.
SLP: Checking user:  %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 5.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Operand 1:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Scalars: 
    %mul = fmul double %div, %div
    %mul6 = fmul double %div5, %div5
State: Vectorize
MainOp:   %mul = fmul double %div, %div
AltOp:   %mul = fmul double %div, %div
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -2
SLP: Adding cost -2 for bundle that starts with   %mul = fmul double %div, %div.
SLP: Current total cost = -2
SLP: Calculated costs for Tree:
1.
Operand 0:
    %conv2 = sitofp i32 %call1 to double
    %conv4 = sitofp i32 %call3 to double
Operand 1:
  double 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
AltOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, {User:0 EdgeIdx:1}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 69
SLP:     ScalarCost = 76
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -7
SLP: Adding cost -7 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = -9
SLP: Calculated costs for Tree:
2.
Operand 0:
    %call1 = tail call i32 @rand() #4
    %call3 = tail call i32 @rand() #4
Scalars: 
    %conv2 = sitofp i32 %call1 to double
    %conv4 = sitofp i32 %call3 to double
State: Vectorize
MainOp:   %conv2 = sitofp i32 %call1 to double
AltOp:   %conv2 = sitofp i32 %call1 to double
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:1 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 20
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 18
SLP: Adding cost 18 for bundle that starts with   %conv2 = sitofp i32 %call1 to double.
SLP: Current total cost = 9
SLP: Adding cost 3 for bundle that starts with   %call1 = tail call i32 @rand() #4.
SLP: Current total cost = 12
SLP: Adding cost 0 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 12
SLP: #LV: 1 div, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: #LV: 1 conv2, Looking at   %conv2 = sitofp i32 %call1 to double
SLP: #LV: 0, Looking at   %call1 = tail call i32 @rand() #4
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 13.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul = fmul double %div, %div
SLP:  initialize schedule region to   %mul = fmul double %div, %div
SLP:  extend schedule region start to   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000] in block for.body
SLP:       update deps of [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 0 from   %mul = fmul double %div, %div.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %conv4 = sitofp i32 %call3 to double
Operand 1:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul = fmul double %div, %div
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul = fmul double %div, %div
AltOp:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul = fmul double %div, %div.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul = fmul double %div, %div
SLP:  initialize schedule region to   %mul = fmul double %div, %div
SLP:  extend schedule region start to   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000] in block for.body
SLP:       update deps of [  %mul = fmul double %div, %div;  %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 0 from   %mul = fmul double %div, %div.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6 = fmul double %div5, %div5.
SLP: Need to extract:  %mul6 = fmul double %div5, %div5 from lane 1 from   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %conv4 = sitofp i32 %call3 to double
Operand 1:
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul = fmul double %div, %div
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul = fmul double %div, %div
AltOp:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul = fmul double %div, %div.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6 = fmul double %div5, %div5
SLP: try schedule bundle [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5] in block for.body
SLP:       update deps of [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP:       update deps of /   %mul6 = fmul double %div5, %div5
SLP:       update deps of   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:   schedule   %mul = fmul double %div, %div
SLP:    gets ready (def): [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 1 from   %mul6 = fmul double %div5, %div5.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2 = sitofp i32 %call1 to double
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Scalars: 
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %mul6 = fmul double %div5, %div5
State: Vectorize
MainOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
AltOp:   %mul6 = fmul double %div5, %div5
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2 = sitofp i32 %call1 to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2 = sitofp i32 %call1 to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6 = fmul double %div5, %div5
SLP: try schedule bundle [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5] in block for.body
SLP:       update deps of [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP:       update deps of /   %mul6 = fmul double %div5, %div5
SLP:       update deps of   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:     gets ready on update:   %mul = fmul double %div, %div
SLP:   schedule   %mul = fmul double %div, %div
SLP:    gets ready (def): [  %div = fdiv double %conv2, 0x41DFFFFFFFC00000;  %mul6 = fmul double %div5, %div5]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul = fmul double %div, %div.
SLP: Need to extract:  %mul = fmul double %div, %div from lane 0 from   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add = fadd double %mul, %mul6.
SLP: Need to extract:  %add = fadd double %mul, %mul6 from lane 1 from   %mul6 = fmul double %div5, %div5.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2 = sitofp i32 %call1 to double
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
Scalars: 
    %div = fdiv double %conv2, 0x41DFFFFFFFC00000
    %mul6 = fmul double %div5, %div5
State: Vectorize
MainOp:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
AltOp:   %mul6 = fmul double %div5, %div5
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div = fdiv double %conv2, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2 = sitofp i32 %call1 to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2 = sitofp i32 %call1 to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .


INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1 to double
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
Loop Unroll: F[_Z5solvev] Loop %for.body
  Loop Size = 21
  will not try to unroll partially because -unroll-allow-partial not given


INSTCOMBINE ITERATION #1 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1.lcssa to double
IC: ADD:   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: Replacing   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
    with   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Mod =   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
    New =   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ERASE   %Ni.1.lcssa = phi i32 [ %Ni.1, %for.body ]
IC: ADD DEFERRED:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12


INSTCOMBINE ITERATION #2 on _Z5solvev
IC: ADD:   ret double %mul12
IC: ADD:   %mul12 = fmul double %div11, 4.000000e+00
IC: ADD:   %div11 = fdiv double %conv9, 1.000000e+07
IC: ADD:   %conv9 = sitofp i32 %Ni.1 to double
IC: ADD:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: ADD:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: ADD:   %inc8 = add nuw nsw i32 %j.027, 1
IC: ADD:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: ADD:   %inc = zext i1 %cmp7 to i32
IC: ADD:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: ADD:   %add = fadd double %mul, %mul6
IC: ADD:   %mul6 = fmul double %div5, %div5
IC: ADD:   %mul = fmul double %div, %div
IC: ADD:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: ADD:   %conv4 = sitofp i32 %call3 to double
IC: ADD:   %call3 = tail call i32 @rand() #4
IC: ADD:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: ADD:   %conv2 = sitofp i32 %call1 to double
IC: ADD:   %call1 = tail call i32 @rand() #4
IC: ADD:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: ADD:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: ADD:   br label %for.body
IC: ADD:   tail call void @srand(i32 %conv) #4
IC: ADD:   %conv = trunc i64 %call to i32
IC: ADD:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %call = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv = trunc i64 %call to i32
IC: Visiting:   tail call void @srand(i32 %conv) #4
IC: Visiting:   br label %for.body
IC: Visiting:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
IC: Visiting:   %Ni.026 = phi i32 [ 0, %entry ], [ %Ni.1, %for.body ]
IC: Visiting:   %call1 = tail call i32 @rand() #4
IC: Visiting:   %conv2 = sitofp i32 %call1 to double
IC: Visiting:   %div = fdiv double %conv2, 0x41DFFFFFFFC00000
IC: Visiting:   %call3 = tail call i32 @rand() #4
IC: Visiting:   %conv4 = sitofp i32 %call3 to double
IC: Visiting:   %div5 = fdiv double %conv4, 0x41DFFFFFFFC00000
IC: Visiting:   %mul = fmul double %div, %div
IC: Visiting:   %mul6 = fmul double %div5, %div5
IC: Visiting:   %add = fadd double %mul, %mul6
IC: Visiting:   %cmp7 = fcmp ole double %add, 1.000000e+00
IC: Visiting:   %inc = zext i1 %cmp7 to i32
IC: Visiting:   %Ni.1 = add nuw nsw i32 %Ni.026, %inc
IC: Visiting:   %inc8 = add nuw nsw i32 %j.027, 1
IC: Visiting:   %exitcond.not = icmp eq i32 %inc8, 10000000
IC: Visiting:   br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !2
IC: Visiting:   %conv9 = sitofp i32 %Ni.1 to double
IC: Visiting:   %div11 = fdiv double %conv9, 1.000000e+07
IC: Visiting:   %mul12 = fmul double %div11, 4.000000e+00
IC: Visiting:   ret double %mul12
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.
F2I: Looking at function main
F2I:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00:empty-set
F2I:   %add.i = fadd double %mul.i, %mul6.i:empty-set
F2I:   %mul6.i = fmul double %div5.i, %div5.i:empty-set
F2I:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000:full-set
F2I:   %mul.i = fmul double %div.i, %div.i:empty-set
F2I:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000:full-set
F2I:   %mul.i = fmul double %div.i, %div.i:full-set
F2I:   %mul6.i = fmul double %div5.i, %div5.i:full-set
F2I:   %add.i = fadd double %mul.i, %mul6.i:full-set
F2I:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00:full-set
		Looking for trivial roots
Found a new trivial root: %_Z5solvev.exit
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %_Z5solvev.exit
3: %for.body.i
4: %entry
Found roots: %_Z5solvev.exit 
---- Branch Probability Info : main ----

Computing probabilities for _Z5solvev.exit
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body.i -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.i
 - 2: _Z5solvev.exit
loop-detection
 - loop = for.body.i
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [  exit  ] weight = 67108864, succ = _Z5solvev.exit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to _Z5solvev.exit
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = _Z5solvev.exit
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to _Z5solvev.exit
 - node: _Z5solvev.exit
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body.i*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body.i: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body.i: float = 32.0, scaled = 256.0, int = 255
 - _Z5solvev.exit: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8
 - for.body.i: float = 32.0, int = 255
 - _Z5solvev.exit: float = 1.0, int = 8


LV: Checking a loop in "main" from montec.cpp
LV: Loop hints: force=? width=0 unroll=0
LV: Found a loop: for.body.i
LV: Found an induction variable.
Found an ADD reduction PHI.  %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
LV: Not vectorizing: Found a non-intrinsic callsite   %call1.i = tail call i32 @rand() #4
LV: Interleaving disabled by the pass manager
LV: Can't vectorize the instructions or CFG
LV: Not vectorizing: Cannot prove legality.
LAA: Found a loop in main: for.body.i

In "main" checking Loop at depth 1 containing: %for.body.i<header><latch><exiting>



INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i.lcssa to double
IC: ADD:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: Replacing   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    with   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Mod =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    New =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ERASE   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD DEFERRED:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0


INSTCOMBINE ITERATION #2 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0
SLP: Analyzing blocks in main.
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP: Gathering due to C,S,B,O. 
SLP:  bundle:   %inc8.i = add nuw nsw i32 %j.027.i, 1
SLP:  initialize schedule region to   %inc8.i = add nuw nsw i32 %j.027.i, 1
SLP:  extend schedule region start to   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
SLP: try schedule bundle [  %inc8.i = add nuw nsw i32 %j.027.i, 1;  %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i] in block for.body.i
SLP:       update deps of [  %inc8.i = add nuw nsw i32 %j.027.i, 1;  %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i]
SLP:       update deps of /   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
SLP:     gets ready on update:   %inc8.i = add nuw nsw i32 %j.027.i, 1
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP: 	Checking bundle:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ].
SLP: Perfect diamond merge at   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ].
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %inc8.i = add nuw nsw i32 %j.027.i, 1.
SLP: 	Internal user will be removed:  %inc8.i = add nuw nsw i32 %j.027.i, 1.
SLP: Checking user:  %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i.
SLP: 	Internal user will be removed:  %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i.
SLP: Checking user:  %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ].
SLP: 	Internal user will be removed:  %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ].
SLP: Checking user:  %exitcond.not.i = icmp eq i32 %inc8.i, 10000000.
SLP: Need to extract:  %exitcond.not.i = icmp eq i32 %inc8.i, 10000000 from lane 0 from   %inc8.i = add nuw nsw i32 %j.027.i, 1.
SLP: Checking user:  %conv9.i = sitofp i32 %Ni.1.i to double.
SLP: Need to extract:  %conv9.i = sitofp i32 %Ni.1.i to double from lane 1 from   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i.
SLP: Checking user:  %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ].
SLP: 	Internal user will be removed:  %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ].
SLP: Calculating cost for tree of size 4.
SLP: Adding cost 0 for bundle that starts with   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ].
SLP: Current total cost = 0
SLP: Adding cost 0 for bundle that starts with i32 0.
SLP: Current total cost = 0
SLP: Calculated costs for Tree:
2.
Operand 0:
    %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
    %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
Operand 1:
  i32 1
    %inc.i = zext i1 %cmp7.i to i32
Scalars: 
    %inc8.i = add nuw nsw i32 %j.027.i, 1
    %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
State: Vectorize
MainOp:   %inc8.i = add nuw nsw i32 %j.027.i, 1
AltOp:   %inc8.i = add nuw nsw i32 %j.027.i, 1
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:1}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Adding cost -1 for bundle that starts with   %inc8.i = add nuw nsw i32 %j.027.i, 1.
SLP: Current total cost = -1
SLP: Adding cost 3 for bundle that starts with i32 1.
SLP: Current total cost = 2
SLP: #LV: 1 j.027.i, Looking at   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
SLP: Spill Cost = 0.
SLP: Extract Cost = 3.
SLP: Total Cost = 5.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul.i = fmul double %div.i, %div.i
SLP:  initialize schedule region to   %mul.i = fmul double %div.i, %div.i
SLP:  extend schedule region end to   %mul6.i = fmul double %div5.i, %div5.i
SLP: try schedule bundle [  %mul.i = fmul double %div.i, %div.i;  %mul6.i = fmul double %div5.i, %div5.i] in block for.body.i
SLP:       update deps of [  %mul.i = fmul double %div.i, %div.i;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:       update deps of /   %mul6.i = fmul double %div5.i, %div5.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  extend schedule region start to   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000] in block for.body.i
SLP:       update deps of [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP:   schedule [  %mul.i = fmul double %div.i, %div.i;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:    gets ready (def): [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %conv2.i = sitofp i32 %call1.i to double
SLP:  extend schedule region start to   %conv2.i = sitofp i32 %call1.i to double
SLP: try schedule bundle [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double] in block for.body.i
SLP:       update deps of [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double]
SLP:       update deps of /   %conv4.i = sitofp i32 %call3.i to double
SLP:   schedule [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:    gets ready (def): [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double]
SLP: We are able to schedule this bundle.
SLP: added a vector of casts.
SLP:  bundle:   %call1.i = tail call i32 @rand() #4
SLP:  extend schedule region start to   %call1.i = tail call i32 @rand() #4
SLP: try schedule bundle [  %call1.i = tail call i32 @rand() #4;  %call3.i = tail call i32 @rand() #4] in block for.body.i
SLP:       update deps of [  %call1.i = tail call i32 @rand() #4;  %call3.i = tail call i32 @rand() #4]
SLP:       update deps of /   %call3.i = tail call i32 @rand() #4
SLP:   schedule [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double]
SLP:  cancel scheduling of [  %call1.i = tail call i32 @rand() #4;  %call3.i = tail call i32 @rand() #4]
SLP: We are not able to schedule this bundle!
SLP: Gathering due to C,S,B,O. 
SLP: 	Checking bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Perfect diamond merge at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 0 from   %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 1 from   %mul6.i = fmul double %div5.i, %div5.i.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: 	Internal user will be removed:  %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: 	Internal user will be removed:  %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: 	Internal user will be removed:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: 	Internal user will be removed:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Checking user:  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 5.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Operand 1:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Scalars: 
    %mul.i = fmul double %div.i, %div.i
    %mul6.i = fmul double %div5.i, %div5.i
State: Vectorize
MainOp:   %mul.i = fmul double %div.i, %div.i
AltOp:   %mul.i = fmul double %div.i, %div.i
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -2
SLP: Adding cost -2 for bundle that starts with   %mul.i = fmul double %div.i, %div.i.
SLP: Current total cost = -2
SLP: Calculated costs for Tree:
1.
Operand 0:
    %conv2.i = sitofp i32 %call1.i to double
    %conv4.i = sitofp i32 %call3.i to double
Operand 1:
  double 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
AltOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, {User:0 EdgeIdx:1}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 69
SLP:     ScalarCost = 76
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -7
SLP: Adding cost -7 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = -9
SLP: Calculated costs for Tree:
2.
Operand 0:
    %call1.i = tail call i32 @rand() #4
    %call3.i = tail call i32 @rand() #4
Scalars: 
    %conv2.i = sitofp i32 %call1.i to double
    %conv4.i = sitofp i32 %call3.i to double
State: Vectorize
MainOp:   %conv2.i = sitofp i32 %call1.i to double
AltOp:   %conv2.i = sitofp i32 %call1.i to double
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:1 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 20
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 18
SLP: Adding cost 18 for bundle that starts with   %conv2.i = sitofp i32 %call1.i to double.
SLP: Current total cost = 9
SLP: Adding cost 3 for bundle that starts with   %call1.i = tail call i32 @rand() #4.
SLP: Current total cost = 12
SLP: Adding cost 0 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 12
SLP: #LV: 1 div.i, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: #LV: 1 conv2.i, Looking at   %conv2.i = sitofp i32 %call1.i to double
SLP: #LV: 0, Looking at   %call1.i = tail call i32 @rand() #4
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 13.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul.i = fmul double %div.i, %div.i
SLP:  initialize schedule region to   %mul.i = fmul double %div.i, %div.i
SLP:  extend schedule region start to   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000] in block for.body.i
SLP:       update deps of [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 0 from   %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %conv4.i = sitofp i32 %call3.i to double
Operand 1:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul.i = fmul double %div.i, %div.i
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul.i = fmul double %div.i, %div.i
AltOp:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul.i = fmul double %div.i, %div.i.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul.i = fmul double %div.i, %div.i
SLP:  initialize schedule region to   %mul.i = fmul double %div.i, %div.i
SLP:  extend schedule region start to   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000] in block for.body.i
SLP:       update deps of [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 0 from   %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %conv4.i = sitofp i32 %call3.i to double
Operand 1:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul.i = fmul double %div.i, %div.i
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul.i = fmul double %div.i, %div.i
AltOp:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul.i = fmul double %div.i, %div.i.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6.i = fmul double %div5.i, %div5.i
SLP: try schedule bundle [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i] in block for.body.i
SLP:       update deps of [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:       update deps of /   %mul6.i = fmul double %div5.i, %div5.i
SLP:       update deps of   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:   schedule   %mul.i = fmul double %div.i, %div.i
SLP:    gets ready (def): [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 1 from   %mul6.i = fmul double %div5.i, %div5.i.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2.i = sitofp i32 %call1.i to double
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Scalars: 
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %mul6.i = fmul double %div5.i, %div5.i
State: Vectorize
MainOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
AltOp:   %mul6.i = fmul double %div5.i, %div5.i
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2.i = sitofp i32 %call1.i to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2.i = sitofp i32 %call1.i to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6.i = fmul double %div5.i, %div5.i
SLP: try schedule bundle [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i] in block for.body.i
SLP:       update deps of [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:       update deps of /   %mul6.i = fmul double %div5.i, %div5.i
SLP:       update deps of   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:   schedule   %mul.i = fmul double %div.i, %div.i
SLP:    gets ready (def): [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 1 from   %mul6.i = fmul double %div5.i, %div5.i.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2.i = sitofp i32 %call1.i to double
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Scalars: 
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %mul6.i = fmul double %div5.i, %div5.i
State: Vectorize
MainOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
AltOp:   %mul6.i = fmul double %div5.i, %div5.i
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2.i = sitofp i32 %call1.i to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2.i = sitofp i32 %call1.i to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul.i = fmul double %div.i, %div.i
SLP:  initialize schedule region to   %mul.i = fmul double %div.i, %div.i
SLP:  extend schedule region end to   %mul6.i = fmul double %div5.i, %div5.i
SLP: try schedule bundle [  %mul.i = fmul double %div.i, %div.i;  %mul6.i = fmul double %div5.i, %div5.i] in block for.body.i
SLP:       update deps of [  %mul.i = fmul double %div.i, %div.i;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:       update deps of /   %mul6.i = fmul double %div5.i, %div5.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  extend schedule region start to   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000] in block for.body.i
SLP:       update deps of [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP:   schedule [  %mul.i = fmul double %div.i, %div.i;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:    gets ready (def): [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP:  bundle:   %conv2.i = sitofp i32 %call1.i to double
SLP:  extend schedule region start to   %conv2.i = sitofp i32 %call1.i to double
SLP: try schedule bundle [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double] in block for.body.i
SLP:       update deps of [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double]
SLP:       update deps of /   %conv4.i = sitofp i32 %call3.i to double
SLP:   schedule [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:    gets ready (def): [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double]
SLP: We are able to schedule this bundle.
SLP: added a vector of casts.
SLP:  bundle:   %call1.i = tail call i32 @rand() #4
SLP:  extend schedule region start to   %call1.i = tail call i32 @rand() #4
SLP: try schedule bundle [  %call1.i = tail call i32 @rand() #4;  %call3.i = tail call i32 @rand() #4] in block for.body.i
SLP:       update deps of [  %call1.i = tail call i32 @rand() #4;  %call3.i = tail call i32 @rand() #4]
SLP:       update deps of /   %call3.i = tail call i32 @rand() #4
SLP:   schedule [  %conv2.i = sitofp i32 %call1.i to double;  %conv4.i = sitofp i32 %call3.i to double]
SLP:  cancel scheduling of [  %call1.i = tail call i32 @rand() #4;  %call3.i = tail call i32 @rand() #4]
SLP: We are not able to schedule this bundle!
SLP: Gathering due to C,S,B,O. 
SLP: 	Checking bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Perfect diamond merge at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 0 from   %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 1 from   %mul6.i = fmul double %div5.i, %div5.i.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: 	Internal user will be removed:  %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: 	Internal user will be removed:  %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: 	Internal user will be removed:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: 	Internal user will be removed:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Checking user:  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: 	Internal user will be removed:  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 5.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Operand 1:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Scalars: 
    %mul.i = fmul double %div.i, %div.i
    %mul6.i = fmul double %div5.i, %div5.i
State: Vectorize
MainOp:   %mul.i = fmul double %div.i, %div.i
AltOp:   %mul.i = fmul double %div.i, %div.i
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -2
SLP: Adding cost -2 for bundle that starts with   %mul.i = fmul double %div.i, %div.i.
SLP: Current total cost = -2
SLP: Calculated costs for Tree:
1.
Operand 0:
    %conv2.i = sitofp i32 %call1.i to double
    %conv4.i = sitofp i32 %call3.i to double
Operand 1:
  double 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
AltOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, {User:0 EdgeIdx:1}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 69
SLP:     ScalarCost = 76
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -7
SLP: Adding cost -7 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = -9
SLP: Calculated costs for Tree:
2.
Operand 0:
    %call1.i = tail call i32 @rand() #4
    %call3.i = tail call i32 @rand() #4
Scalars: 
    %conv2.i = sitofp i32 %call1.i to double
    %conv4.i = sitofp i32 %call3.i to double
State: Vectorize
MainOp:   %conv2.i = sitofp i32 %call1.i to double
AltOp:   %conv2.i = sitofp i32 %call1.i to double
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:1 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 20
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 18
SLP: Adding cost 18 for bundle that starts with   %conv2.i = sitofp i32 %call1.i to double.
SLP: Current total cost = 9
SLP: Adding cost 3 for bundle that starts with   %call1.i = tail call i32 @rand() #4.
SLP: Current total cost = 12
SLP: Adding cost 0 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 12
SLP: #LV: 1 div.i, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: #LV: 1 conv2.i, Looking at   %conv2.i = sitofp i32 %call1.i to double
SLP: #LV: 0, Looking at   %call1.i = tail call i32 @rand() #4
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 13.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul.i = fmul double %div.i, %div.i
SLP:  initialize schedule region to   %mul.i = fmul double %div.i, %div.i
SLP:  extend schedule region start to   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000] in block for.body.i
SLP:       update deps of [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 0 from   %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %conv4.i = sitofp i32 %call3.i to double
Operand 1:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul.i = fmul double %div.i, %div.i
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul.i = fmul double %div.i, %div.i
AltOp:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul.i = fmul double %div.i, %div.i.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul.i = fmul double %div.i, %div.i
SLP:  initialize schedule region to   %mul.i = fmul double %div.i, %div.i
SLP:  extend schedule region start to   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP: try schedule bundle [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000] in block for.body.i
SLP:       update deps of [  %mul.i = fmul double %div.i, %div.i;  %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000]
SLP:       update deps of /   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 0 from   %mul.i = fmul double %div.i, %div.i.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul6.i = fmul double %div5.i, %div5.i.
SLP: Need to extract:  %mul6.i = fmul double %div5.i, %div5.i from lane 1 from   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %conv4.i = sitofp i32 %call3.i to double
Operand 1:
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
  double 0x41DFFFFFFFC00000
Scalars: 
    %mul.i = fmul double %div.i, %div.i
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
State: Vectorize
MainOp:   %mul.i = fmul double %div.i, %div.i
AltOp:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %mul.i = fmul double %div.i, %div.i.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: #LV: 0, Looking at   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6.i = fmul double %div5.i, %div5.i
SLP: try schedule bundle [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i] in block for.body.i
SLP:       update deps of [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:       update deps of /   %mul6.i = fmul double %div5.i, %div5.i
SLP:       update deps of   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:   schedule   %mul.i = fmul double %div.i, %div.i
SLP:    gets ready (def): [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 1 from   %mul6.i = fmul double %div5.i, %div5.i.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2.i = sitofp i32 %call1.i to double
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Scalars: 
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %mul6.i = fmul double %div5.i, %div5.i
State: Vectorize
MainOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
AltOp:   %mul6.i = fmul double %div5.i, %div5.i
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2.i = sitofp i32 %call1.i to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2.i = sitofp i32 %call1.i to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  initialize schedule region to   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
SLP:  extend schedule region end to   %mul6.i = fmul double %div5.i, %div5.i
SLP: try schedule bundle [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i] in block for.body.i
SLP:       update deps of [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP:       update deps of /   %mul6.i = fmul double %div5.i, %div5.i
SLP:       update deps of   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:     gets ready on update:   %mul.i = fmul double %div.i, %div.i
SLP:   schedule   %mul.i = fmul double %div.i, %div.i
SLP:    gets ready (def): [  %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000;  %mul6.i = fmul double %div5.i, %div5.i]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %mul.i = fmul double %div.i, %div.i.
SLP: Need to extract:  %mul.i = fmul double %div.i, %div.i from lane 0 from   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Checking user:  %add.i = fadd double %mul.i, %mul6.i.
SLP: Need to extract:  %add.i = fadd double %mul.i, %mul6.i from lane 1 from   %mul6.i = fmul double %div5.i, %div5.i.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %conv2.i = sitofp i32 %call1.i to double
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Operand 1:
  double 0x41DFFFFFFFC00000
    %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
Scalars: 
    %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
    %mul6.i = fmul double %div5.i, %div5.i
State: Vectorize
MainOp:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
AltOp:   %mul6.i = fmul double %div5.i, %div5.i
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 72
SLP:     ScalarCost = 40
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 32
SLP: Adding cost 32 for bundle that starts with   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000.
SLP: Current total cost = 32
SLP: Adding cost 1 for bundle that starts with   %conv2.i = sitofp i32 %call1.i to double.
SLP: Current total cost = 33
SLP: Adding cost 1 for bundle that starts with double 0x41DFFFFFFFC00000.
SLP: Current total cost = 34
SLP: #LV: 0, Looking at   %conv2.i = sitofp i32 %call1.i to double
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 35.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .


INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0
Loop Unroll: F[main] Loop %for.body.i
  Loop Size = 21
  will not try to unroll partially because -unroll-allow-partial not given


INSTCOMBINE ITERATION #1 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i.lcssa to double
IC: ADD:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: Replacing   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    with   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Mod =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
    New =   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ERASE   %Ni.1.i.lcssa = phi i32 [ %Ni.1.i, %for.body.i ]
IC: ADD DEFERRED:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0


INSTCOMBINE ITERATION #2 on main
IC: ADD:   ret i32 0
IC: ADD:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: ADD:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: ADD:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: ADD:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: ADD:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: ADD:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: ADD:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: ADD:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: ADD:   %inc.i = zext i1 %cmp7.i to i32
IC: ADD:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: ADD:   %add.i = fadd double %mul.i, %mul6.i
IC: ADD:   %mul6.i = fmul double %div5.i, %div5.i
IC: ADD:   %mul.i = fmul double %div.i, %div.i
IC: ADD:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv4.i = sitofp i32 %call3.i to double
IC: ADD:   %call3.i = tail call i32 @rand() #4
IC: ADD:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: ADD:   %conv2.i = sitofp i32 %call1.i to double
IC: ADD:   %call1.i = tail call i32 @rand() #4
IC: ADD:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: ADD:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: ADD:   br label %for.body.i
IC: ADD:   tail call void @srand(i32 %conv.i) #4
IC: ADD:   %conv.i = trunc i64 %call.i to i32
IC: ADD:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %call.i = tail call i64 @time(i64* null) #4
IC: Visiting:   %conv.i = trunc i64 %call.i to i32
IC: Visiting:   tail call void @srand(i32 %conv.i) #4
IC: Visiting:   br label %for.body.i
IC: Visiting:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
IC: Visiting:   %Ni.026.i = phi i32 [ 0, %entry ], [ %Ni.1.i, %for.body.i ]
IC: Visiting:   %call1.i = tail call i32 @rand() #4
IC: Visiting:   %conv2.i = sitofp i32 %call1.i to double
IC: Visiting:   %div.i = fdiv double %conv2.i, 0x41DFFFFFFFC00000
IC: Visiting:   %call3.i = tail call i32 @rand() #4
IC: Visiting:   %conv4.i = sitofp i32 %call3.i to double
IC: Visiting:   %div5.i = fdiv double %conv4.i, 0x41DFFFFFFFC00000
IC: Visiting:   %mul.i = fmul double %div.i, %div.i
IC: Visiting:   %mul6.i = fmul double %div5.i, %div5.i
IC: Visiting:   %add.i = fadd double %mul.i, %mul6.i
IC: Visiting:   %cmp7.i = fcmp ole double %add.i, 1.000000e+00
IC: Visiting:   %inc.i = zext i1 %cmp7.i to i32
IC: Visiting:   %Ni.1.i = add nuw nsw i32 %Ni.026.i, %inc.i
IC: Visiting:   %inc8.i = add nuw nsw i32 %j.027.i, 1
IC: Visiting:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
IC: Visiting:   br i1 %exitcond.not.i, label %_Z5solvev.exit, label %for.body.i, !llvm.loop !2
IC: Visiting:   %conv9.i = sitofp i32 %Ni.1.i to double
IC: Visiting:   %div11.i = fdiv double %conv9.i, 1.000000e+07
IC: Visiting:   %mul12.i = fmul double %div11.i, 4.000000e+00
IC: Visiting:   %call1 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0), double %mul12.i)
IC: Visiting:   ret i32 0
Perform LICM on Loop with header at block for.body.i
LICM: Using MemorySSA.
Cmap[[11 x i8] c"\0A\CF\80\E2\89\92%lf\0A\00"] = .str
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.body
4: %entry
Found roots: %for.end 
---- Branch Probability Info : _Z5solvev ----

Computing probabilities for for.end
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.end
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body: float = 32.0, scaled = 256.0, int = 255
 - for.end: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - entry: float = 1.0, int = 8
 - for.body: float = 32.0, int = 255
 - for.end: float = 1.0, int = 8


block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.end
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body: float = 32.0, scaled = 256.0, int = 255
 - for.end: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - entry: float = 1.0, int = 8
 - for.body: float = 32.0, int = 255
 - for.end: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %_Z5solvev.exit
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %_Z5solvev.exit
3: %for.body.i
4: %entry
Found roots: %_Z5solvev.exit 
---- Branch Probability Info : main ----

Computing probabilities for _Z5solvev.exit
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body.i -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.i
 - 2: _Z5solvev.exit
loop-detection
 - loop = for.body.i
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [  exit  ] weight = 67108864, succ = _Z5solvev.exit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to _Z5solvev.exit
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = _Z5solvev.exit
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to _Z5solvev.exit
 - node: _Z5solvev.exit
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body.i*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body.i: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body.i: float = 32.0, scaled = 256.0, int = 255
 - _Z5solvev.exit: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8
 - for.body.i: float = 32.0, int = 255
 - _Z5solvev.exit: float = 1.0, int = 8


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.i
 - 2: _Z5solvev.exit
loop-detection
 - loop = for.body.i
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [  exit  ] weight = 67108864, succ = _Z5solvev.exit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to _Z5solvev.exit
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = _Z5solvev.exit
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to _Z5solvev.exit
 - node: _Z5solvev.exit
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body.i*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body.i: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body.i: float = 32.0, scaled = 256.0, int = 255
 - _Z5solvev.exit: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8
 - for.body.i: float = 32.0, int = 255
 - _Z5solvev.exit: float = 1.0, int = 8

canonfr: PHI:   %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]
LV: PHI is not a poly recurrence.
FOUND USER:   %exitcond.not = icmp eq i32 %inc8, 10000000
   OF SCEV: {1,+,1}<nuw><nsw><%for.body>

LSR on loop %for.body:
  Change loop exiting icmp to use postinc iv:   %exitcond.not = icmp eq i32 %inc8, 10000000
Collecting IV Chains.
IV Chain#0 Head: (  %exitcond.not = icmp eq i32 %inc8, 10000000) IV={1,+,1}<nuw><nsw><%for.body>
IV Chain#0  Inc: (  %j.027 = phi i32 [ 0, %entry ], [ %inc8, %for.body ]) IV+0
Chain:   %exitcond.not = icmp eq i32 %inc8, 10000000 Cost: 1
LSR is examining the following fixup sites:
  UserInst=%exitcond.not, OperandValToReplace=%inc8, PostIncLoop=%for.body
LSR found 1 uses:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body>)
Generating cross-use offsets for {0,+,-1}<nw><%for.body>: 0 10000000
Skipping cross-use reuse for {0,+,-1}<nw><%for.body>
Skipping cross-use reuse for {10000000,+,-1}<nw><%for.body>
Generating cross-use offsets for {0,+,1}<nuw><nsw><%for.body>: -10000000 0
Skipping cross-use reuse for {-10000000,+,1}<nw><%for.body>
Skipping cross-use reuse for {0,+,1}<nuw><nsw><%for.body>

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body>)
    10000000 + reg({0,+,-1}<nw><%for.body>)
    reg({-10000000,+,1}<nw><%for.body>)
    -10000000 + reg({0,+,1}<nuw><nsw><%for.body>)
Filtering for use LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
  Filtering out formula 10000000 + reg({0,+,-1}<nw><%for.body>)
    in favor of formula reg({10000000,+,-1}<nw><%for.body>)
  Filtering out formula -10000000 + reg({0,+,1}<nuw><nsw><%for.body>)
    in favor of formula reg({10000000,+,-1}<nw><%for.body>)
  Filtering out formula reg({-10000000,+,1}<nw><%for.body>)
    in favor of formula reg({10000000,+,-1}<nw><%for.body>)

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body>)
New best at 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost.
Regs:
- {10000000,+,-1}<nw><%for.body>


The chosen solution requires 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body>)
MergeICmpsLegacyPass: _Z5solvev
processPhi()
skip: non-constant value not from cmp or not from last block.
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.body
4: %entry
Found roots: %for.end 
---- Branch Probability Info : _Z5solvev ----

Computing probabilities for for.end
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.end
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body: float = 32.0, scaled = 256.0, int = 255
 - for.end: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - entry: float = 1.0, int = 8
 - for.body: float = 32.0, int = 255
 - for.end: float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: _Z5solvev
********** End Constant Hoisting **********
*** Interleaved Access Pass: _Z5solvev
---- Branch Probability Info : _Z5solvev ----

		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.body
4: %entry
Found roots: %for.end 
Computing probabilities for for.end
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.end
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body: float = 32.0, scaled = 256.0, int = 255
 - for.end: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - entry: float = 1.0, int = 8
 - for.body: float = 32.0, int = 255
 - for.end: float = 1.0, int = 8

canonfr: PHI:   %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]
LV: PHI is not a poly recurrence.
FOUND USER:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
   OF SCEV: {1,+,1}<nuw><nsw><%for.body.i>

LSR on loop %for.body.i:
  Change loop exiting icmp to use postinc iv:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000
Collecting IV Chains.
IV Chain#0 Head: (  %exitcond.not.i = icmp eq i32 %inc8.i, 10000000) IV={1,+,1}<nuw><nsw><%for.body.i>
IV Chain#0  Inc: (  %j.027.i = phi i32 [ 0, %entry ], [ %inc8.i, %for.body.i ]) IV+0
Chain:   %exitcond.not.i = icmp eq i32 %inc8.i, 10000000 Cost: 1
LSR is examining the following fixup sites:
  UserInst=%exitcond.not.i, OperandValToReplace=%inc8.i, PostIncLoop=%for.body.i
LSR found 1 uses:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body.i>)
Generating cross-use offsets for {0,+,-1}<nw><%for.body.i>: 0 10000000
Skipping cross-use reuse for {0,+,-1}<nw><%for.body.i>
Skipping cross-use reuse for {10000000,+,-1}<nw><%for.body.i>
Generating cross-use offsets for {0,+,1}<nuw><nsw><%for.body.i>: -10000000 0
Skipping cross-use reuse for {-10000000,+,1}<nw><%for.body.i>
Skipping cross-use reuse for {0,+,1}<nuw><nsw><%for.body.i>

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body.i>)
    10000000 + reg({0,+,-1}<nw><%for.body.i>)
    reg({-10000000,+,1}<nw><%for.body.i>)
    -10000000 + reg({0,+,1}<nuw><nsw><%for.body.i>)
Filtering for use LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
  Filtering out formula 10000000 + reg({0,+,-1}<nw><%for.body.i>)
    in favor of formula reg({10000000,+,-1}<nw><%for.body.i>)
  Filtering out formula -10000000 + reg({0,+,1}<nuw><nsw><%for.body.i>)
    in favor of formula reg({10000000,+,-1}<nw><%for.body.i>)
  Filtering out formula reg({-10000000,+,1}<nw><%for.body.i>)
    in favor of formula reg({10000000,+,-1}<nw><%for.body.i>)

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body.i>)
New best at 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost.
Regs:
- {10000000,+,-1}<nw><%for.body.i>


The chosen solution requires 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({10000000,+,-1}<nw><%for.body.i>)
MergeICmpsLegacyPass: main
processPhi()
skip: non-constant value not from cmp or not from last block.
		Looking for trivial roots
Found a new trivial root: %_Z5solvev.exit
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %_Z5solvev.exit
3: %for.body.i
4: %entry
Found roots: %_Z5solvev.exit 
---- Branch Probability Info : main ----

Computing probabilities for _Z5solvev.exit
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body.i -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.i
 - 2: _Z5solvev.exit
loop-detection
 - loop = for.body.i
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [  exit  ] weight = 67108864, succ = _Z5solvev.exit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to _Z5solvev.exit
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = _Z5solvev.exit
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to _Z5solvev.exit
 - node: _Z5solvev.exit
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body.i*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body.i: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body.i: float = 32.0, scaled = 256.0, int = 255
 - _Z5solvev.exit: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8
 - for.body.i: float = 32.0, int = 255
 - _Z5solvev.exit: float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: main
********** End Constant Hoisting **********
*** Interleaved Access Pass: main
---- Branch Probability Info : main ----

		Looking for trivial roots
Found a new trivial root: %_Z5solvev.exit
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %_Z5solvev.exit
3: %for.body.i
4: %entry
Found roots: %_Z5solvev.exit 
Computing probabilities for _Z5solvev.exit
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body.i -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.i
 - 2: _Z5solvev.exit
loop-detection
 - loop = for.body.i
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [  exit  ] weight = 67108864, succ = _Z5solvev.exit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to _Z5solvev.exit
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = _Z5solvev.exit
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to _Z5solvev.exit
 - node: _Z5solvev.exit
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body.i*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.body.i: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.body.i: float = 32.0, scaled = 256.0, int = 255
 - _Z5solvev.exit: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8
 - for.body.i: float = 32.0, int = 255
 - _Z5solvev.exit: float = 1.0, int = 8

[SafeStack] Function: _Z5solvev
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.body
4: %entry
Found roots: %for.end 
---- Branch Probability Info : _Z5solvev ----

Computing probabilities for for.end
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry



=== _Z5solvev
Creating constant: t2: i64 = Constant<0>
Creating constant: t3: i64 = TargetConstant<0>
Creating new node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Creating new node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Creating new node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Creating new node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Creating new node: t13: i32 = truncate t12
Creating new node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Creating new node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Creating new node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Creating constant: t21: i32 = Constant<10000000>
Creating new node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Creating constant: t24: i32 = Constant<0>
Creating new node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Creating new node: t27: ch = TokenFactor t23, t26, t20
Initial selection DAG: %bb.0 '_Z5solvev:entry'
SelectionDAG has 28 nodes:
  t0: ch = EntryToken
  t1: i64 = GlobalAddress<i64 (i64*)* @time> 0
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
  t14: i64 = GlobalAddress<void (i32)* @srand> 0
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20



Combining: t27: ch = TokenFactor t23, t26, t20

Combining: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

Combining: t25: i32 = Register %5

Combining: t24: i32 = Constant<0>

Combining: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

Combining: t22: i32 = Register %4

Combining: t21: i32 = Constant<10000000>

Combining: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Combining: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1

Combining: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

Combining: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

Combining: t16: i32 = Register $edi

Combining: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t13: i32 = truncate t12

Combining: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

Combining: t11: i64 = Register $rax

Combining: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Combining: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Combining: t8: Untyped = RegisterMask

Combining: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

Combining: t5: i64 = Register $rdi

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: i64 = TargetConstant<0>

Combining: t2: i64 = Constant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 '_Z5solvev:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20


Legalizing node: t25: i32 = Register %5
Ignoring node results
Legally typed node: t25: i32 = Register %5

Legalizing node: t24: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t24: i32 = Constant<0>

Legalizing node: t22: i32 = Register %4
Ignoring node results
Legally typed node: t22: i32 = Register %4

Legalizing node: t21: i32 = Constant<10000000>
Analyzing result type: i32
Legal result type
Legally typed node: t21: i32 = Constant<10000000>

Legalizing node: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Analyzing result type: i64
Legal result type
Legally typed node: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

Legalizing node: t16: i32 = Register $edi
Ignoring node results
Legally typed node: t16: i32 = Register $edi

Legalizing node: t11: i64 = Register $rax
Ignoring node results
Legally typed node: t11: i64 = Register $rax

Legalizing node: t8: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t8: Untyped = RegisterMask

Legalizing node: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

Legalizing node: t5: i64 = Register $rdi
Ignoring node results
Legally typed node: t5: i64 = Register $rdi

Legalizing node: t3: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t3: i64 = TargetConstant<0>

Legalizing node: t2: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<0>
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

Legalizing node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal operand
Analyzing operand: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal operand
Legally typed node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Analyzing operand: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Legally typed node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Legal operand
Analyzing operand: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Legal operand
Legally typed node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

Legalizing node: t13: i32 = truncate t12
Analyzing result type: i32
Legal result type
Analyzing operand: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal operand
Legally typed node: t13: i32 = truncate t12

Legalizing node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal operand
Legally typed node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t13: i32 = truncate t12
Legal operand
Legally typed node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

Legalizing node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal operand
Analyzing operand: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Analyzing operand: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal operand
Legally typed node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1

Legalizing node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal operand
Analyzing operand: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal operand
Legally typed node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i32 = Constant<10000000>
Legal operand
Legally typed node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

Legalizing node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: i32 = Constant<0>
Legal operand
Legally typed node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

Legalizing node: t27: ch = TokenFactor t23, t26, t20
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Legal operand
Analyzing operand: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Legal operand
Analyzing operand: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Legal operand
Legally typed node: t27: ch = TokenFactor t23, t26, t20

Legalizing node: t65535: ch = handlenode t27
Analyzing result type: ch
Legal result type
Analyzing operand: t27: ch = TokenFactor t23, t26, t20
Legal operand
Legally typed node: t65535: ch = handlenode t27

Type-legalized selection DAG: %bb.0 '_Z5solvev:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20



Legalizing: t27: ch = TokenFactor t23, t26, t20
Legal node: nothing to do

Legalizing: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal node: nothing to do

Legalizing: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal node: nothing to do

Legalizing: t13: i32 = truncate t12
Legal node: nothing to do

Legalizing: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal node: nothing to do

Legalizing: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Legal node: nothing to do

Legalizing: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Legal node: nothing to do

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t25: i32 = Register %5

Legalizing: t24: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t22: i32 = Register %4

Legalizing: t21: i32 = Constant<10000000>
Legal node: nothing to do

Legalizing: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Legal node: nothing to do

Legalizing: t16: i32 = Register $edi

Legalizing: t11: i64 = Register $rax

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Legal node: nothing to do

Legalizing: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Legalizing: t2: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 '_Z5solvev:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20



Legalizing: t27: ch = TokenFactor t23, t26, t20
Legal node: nothing to do

Combining: t27: ch = TokenFactor t23, t26, t20

Legalizing: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Combining: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal node: nothing to do

Combining: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1

Legalizing: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal node: nothing to do

Combining: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

Legalizing: t13: i32 = truncate t12
Legal node: nothing to do

Combining: t13: i32 = truncate t12

Legalizing: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal node: nothing to do

Combining: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

Legalizing: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Combining: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Combining: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

Legalizing: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Legal node: nothing to do

Combining: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

Legalizing: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Legal node: nothing to do

Combining: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t25: i32 = Register %5

Combining: t25: i32 = Register %5

Legalizing: t24: i32 = Constant<0>
Legal node: nothing to do

Combining: t24: i32 = Constant<0>

Legalizing: t22: i32 = Register %4

Combining: t22: i32 = Register %4

Legalizing: t21: i32 = Constant<10000000>
Legal node: nothing to do

Combining: t21: i32 = Constant<10000000>

Legalizing: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Legal node: nothing to do

Combining: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

Legalizing: t16: i32 = Register $edi

Combining: t16: i32 = Register $edi

Legalizing: t11: i64 = Register $rax

Combining: t11: i64 = Register $rax

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Combining: t8: Untyped = RegisterMask

Legalizing: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Legal node: nothing to do

Combining: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

Legalizing: t5: i64 = Register $rdi

Combining: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Combining: t3: i64 = TargetConstant<0>

Legalizing: t2: i64 = Constant<0>
Legal node: nothing to do

Combining: t2: i64 = Constant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 '_Z5solvev:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t27: ch = TokenFactor t23, t26, t20

ISEL: Starting selection on root node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
ISEL: Starting pattern match
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

ISEL: Starting selection on root node: t13: i32 = truncate t12
ISEL: Starting pattern match
  Initial Opcode index to 123421
  Match failed at index 123424
  Continuing at 123543
  TypeSwitch[i32] from 123546 to 123581
Creating constant: t28: i32 = TargetConstant<6>
  Morphed node: t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t29: i32 = TargetConstant<0>
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

ISEL: Starting selection on root node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

ISEL: Starting selection on root node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

ISEL: Starting selection on root node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

ISEL: Starting selection on root node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i32 = Register %5

ISEL: Starting selection on root node: t24: i32 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  TypeSwitch[i32] from 123997 to 124000
  Morphed node: t24: i32,i32 = MOV32r0
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i32 = Register %4

ISEL: Starting selection on root node: t21: i32 = Constant<10000000>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i32] from 124159 to 124162
  Skipped scope entry (due to false predicate) at index 124164, continuing at 124177
Creating constant: t30: i32 = TargetConstant<10000000>
  Morphed node: t21: i32 = MOV32ri TargetConstant:i32<10000000>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

ISEL: Starting selection on root node: t16: i32 = Register $edi

ISEL: Starting selection on root node: t11: i64 = Register $rax

ISEL: Starting selection on root node: t8: Untyped = RegisterMask

ISEL: Starting selection on root node: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

ISEL: Starting selection on root node: t5: i64 = Register $rdi

ISEL: Starting selection on root node: t3: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t2: i64 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  TypeSwitch[i64] from 123997 to 124049
  Created node: t24: i32,i32 = MOV32r0
  Morphed node: t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 '_Z5solvev:entry'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
  t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2
  t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
  t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1
  t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2
    t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1
    t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>
  t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13
  t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1
      t21: i32 = MOV32ri TargetConstant:i32<10000000>
    t23: ch = CopyToReg t0, Register:i32 %4, t21
    t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32
    t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1
  t27: ch = TokenFactor t23, t26, t20:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t27: ch = TokenFactor t23, t26, t20:1

  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(9): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(5): t24: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(4): Data Latency=1
    SU(8): Data Latency=1
SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(9): Data Latency=1

Examining Available:
Height 0: SU(0): t27: ch = TokenFactor t23, t26, t20:1


*** Scheduling [0]: SU(0): t27: ch = TokenFactor t23, t26, t20:1


Examining Available:
Height 1: SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21

Height 1: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [1]: SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21


Examining Available:
Height 2: SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>

Height 1: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [2]: SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>


Examining Available:
Height 1: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [3]: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32


Examining Available:
Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [4]: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


Examining Available:
Height 5: SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

Height 5: SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>


*** Scheduling [5]: SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1


Examining Available:
Height 5: SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>


*** Scheduling [6]: SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>


Examining Available:
Height 7: SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1


*** Scheduling [7]: SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1


Examining Available:
Height 8: SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 8: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [8]: SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>


Examining Available:
Height 9: SU(5): t24: i32,i32 = MOV32r0

Height 8: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [9]: SU(5): t24: i32,i32 = MOV32r0


Examining Available:
Height 8: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [10]: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(5): t24: i32,i32 = MOV32r0

SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>

SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1

SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>

SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21

SU(0): t27: ch = TokenFactor t23, t26, t20:1


Total amount of phi nodes to update: 2
Node 0 : (0xfd7a7d8, 2147483652)
Node 1 : (0xfd7a840, 2147483653)
Creating constant: t2: i64 = TargetConstant<0>
Creating new node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Creating new node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Creating new node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Creating new node: t10: f64 = sint_to_fp t9
Creating fp constant: t11: f64 = ConstantFP<2.147484e+09>
Creating new node: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Creating new node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Creating new node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Creating new node: t17: f64 = sint_to_fp t16
Creating new node: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Creating new node: t19: f64 = fmul t12, t12
Creating new node: t20: f64 = fmul t18, t18
Creating new node: t21: f64 = fadd t19, t20
Creating fp constant: t22: f64 = ConstantFP<1.000000e+00>
Creating new node: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Creating new node: t25: i32 = zero_extend t24
Creating new node: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Creating new node: t28: i32 = add nuw nsw t27, t25
Creating new node: t30: ch = CopyToReg t0, Register:i32 %2, t28
Creating new node: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Creating constant: t33: i32 = Constant<-1>
Creating new node: t34: i32 = add nsw t32, Constant:i32<-1>
Creating new node: t36: ch = CopyToReg t0, Register:i32 %3, t34
Creating constant: t37: i32 = Constant<0>
Creating new node: t39: i1 = setcc t34, Constant:i32<0>, seteq:ch
Creating constant: t40: i1 = Constant<-1>
Creating new node: t41: i1 = xor t39, Constant:i1<-1>
Creating new node: t42: ch = TokenFactor t30, t36, t16:1
Creating new node: t44: ch = brcond t42, t41, BasicBlock:ch<for.body 0xfd7a700>
Creating new node: t46: ch = br t44, BasicBlock:ch<for.end 0xfd7a8a8>
Initial selection DAG: %bb.1 '_Z5solvev:for.body'
SelectionDAG has 47 nodes:
  t0: ch = EntryToken
  t1: i64 = GlobalAddress<i32 ()* @rand> 0
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                  t19: f64 = fmul t12, t12
                  t20: f64 = fmul t18, t18
                t21: f64 = fadd t19, t20
              t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
            t25: i32 = zero_extend t24
          t28: i32 = add nuw nsw t27, t25
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
        t39: i1 = setcc t34, Constant:i32<0>, seteq:ch
      t41: i1 = xor t39, Constant:i1<-1>
    t44: ch = brcond t42, t41, BasicBlock:ch<for.body 0xfd7a700>
  t46: ch = br t44, BasicBlock:ch<for.end 0xfd7a8a8>



Combining: t46: ch = br t44, BasicBlock:ch<for.end 0xfd7a8a8>

Combining: t45: ch = BasicBlock<for.end 0xfd7a8a8>

Combining: t44: ch = brcond t42, t41, BasicBlock:ch<for.body 0xfd7a700>
Creating new node: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Creating new node: t49: ch = brcond t42, t48, BasicBlock:ch<for.body 0xfd7a700>
 ... into: t49: ch = brcond t42, t48, BasicBlock:ch<for.body 0xfd7a700>

Combining: t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>

Combining: t49: ch = brcond t42, t48, BasicBlock:ch<for.body 0xfd7a700>

Combining: t48: i1 = setcc t34, Constant:i32<0>, setne:ch

Combining: t47: ch = setne

Combining: t43: ch = BasicBlock<for.body 0xfd7a700>

Combining: t42: ch = TokenFactor t30, t36, t16:1

Combining: t37: i32 = Constant<0>

Combining: t36: ch = CopyToReg t0, Register:i32 %3, t34

Combining: t35: i32 = Register %3

Combining: t34: i32 = add nsw t32, Constant:i32<-1>

Combining: t33: i32 = Constant<-1>

Combining: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t31: i32 = Register %0

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t28

Combining: t29: i32 = Register %2

Combining: t28: i32 = add nuw nsw t27, t25

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t26: i32 = Register %1

Combining: t25: i32 = zero_extend t24
Creating constant: t50: i1 = Constant<-1>
Creating constant: t51: i1 = Constant<0>

Combining: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Combining: t23: ch = setole

Combining: t22: f64 = ConstantFP<1.000000e+00>

Combining: t21: f64 = fadd t19, t20

Combining: t20: f64 = fmul t18, t18

Combining: t19: f64 = fmul t12, t12

Combining: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Creating fp constant: t52: f64 = ConstantFP<-2.147484e+09>

Combining: t17: f64 = sint_to_fp t16

Combining: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Creating fp constant: t53: f64 = ConstantFP<-2.147484e+09>

Combining: t11: f64 = ConstantFP<2.147484e+09>

Combining: t10: f64 = sint_to_fp t9

Combining: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Combining: t8: i32 = Register $eax

Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t5: Untyped = RegisterMask

Combining: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t2: i64 = TargetConstant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 '_Z5solvev:for.body'
SelectionDAG has 44 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                  t19: f64 = fmul t12, t12
                  t20: f64 = fmul t18, t18
                t21: f64 = fadd t19, t20
              t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
            t25: i32 = zero_extend t24
          t28: i32 = add nuw nsw t27, t25
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
      t48: i1 = setcc t34, Constant:i32<0>, setne:ch
    t49: ch = brcond t42, t48, BasicBlock:ch<for.body 0xfd7a700>
  t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>


Legalizing node: t47: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t47: ch = setne

Legalizing node: t45: ch = BasicBlock<for.end 0xfd7a8a8>
Analyzing result type: ch
Legal result type
Legally typed node: t45: ch = BasicBlock<for.end 0xfd7a8a8>

Legalizing node: t43: ch = BasicBlock<for.body 0xfd7a700>
Analyzing result type: ch
Legal result type
Legally typed node: t43: ch = BasicBlock<for.body 0xfd7a700>

Legalizing node: t37: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t37: i32 = Constant<0>

Legalizing node: t35: i32 = Register %3
Ignoring node results
Legally typed node: t35: i32 = Register %3

Legalizing node: t33: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t33: i32 = Constant<-1>

Legalizing node: t31: i32 = Register %0
Ignoring node results
Legally typed node: t31: i32 = Register %0

Legalizing node: t29: i32 = Register %2
Ignoring node results
Legally typed node: t29: i32 = Register %2

Legalizing node: t26: i32 = Register %1
Ignoring node results
Legally typed node: t26: i32 = Register %1

Legalizing node: t23: ch = setole
Analyzing result type: ch
Legal result type
Legally typed node: t23: ch = setole

Legalizing node: t22: f64 = ConstantFP<1.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t22: f64 = ConstantFP<1.000000e+00>

Legalizing node: t11: f64 = ConstantFP<2.147484e+09>
Analyzing result type: f64
Legal result type
Legally typed node: t11: f64 = ConstantFP<2.147484e+09>

Legalizing node: t8: i32 = Register $eax
Ignoring node results
Legally typed node: t8: i32 = Register $eax

Legalizing node: t5: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t5: Untyped = RegisterMask

Legalizing node: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Analyzing result type: i64
Legal result type
Legally typed node: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Legalizing node: t2: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t2: i64 = TargetConstant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal operand
Analyzing operand: t5: Untyped = RegisterMask
Legal operand
Legally typed node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Legal operand
Analyzing operand: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Legal operand
Legally typed node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Legalizing node: t10: f64 = sint_to_fp t9
Analyzing result type: f64
Legal result type
Analyzing operand: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal operand
Legally typed node: t10: f64 = sint_to_fp t9

Legalizing node: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Analyzing result type: f64
Legal result type
Analyzing operand: t10: f64 = sint_to_fp t9
Legal operand
Analyzing operand: t11: f64 = ConstantFP<2.147484e+09>
Legal operand
Legally typed node: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>

Legalizing node: t19: f64 = fmul t12, t12
Analyzing result type: f64
Legal result type
Analyzing operand: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Legal operand
Analyzing operand: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Legal operand
Legally typed node: t19: f64 = fmul t12, t12

Legalizing node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal operand
Legally typed node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal operand
Analyzing operand: t5: Untyped = RegisterMask
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Legalizing node: t17: f64 = sint_to_fp t16
Analyzing result type: f64
Legal result type
Analyzing operand: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal operand
Legally typed node: t17: f64 = sint_to_fp t16

Legalizing node: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Analyzing result type: f64
Legal result type
Analyzing operand: t17: f64 = sint_to_fp t16
Legal operand
Analyzing operand: t11: f64 = ConstantFP<2.147484e+09>
Legal operand
Legally typed node: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>

Legalizing node: t20: f64 = fmul t18, t18
Analyzing result type: f64
Legal result type
Analyzing operand: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Legal operand
Analyzing operand: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Legal operand
Legally typed node: t20: f64 = fmul t18, t18

Legalizing node: t21: f64 = fadd t19, t20
Analyzing result type: f64
Legal result type
Analyzing operand: t19: f64 = fmul t12, t12
Legal operand
Analyzing operand: t20: f64 = fmul t18, t18
Legal operand
Legally typed node: t21: f64 = fadd t19, t20

Legalizing node: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Analyzing result type: i1
Promote integer result: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Creating new node: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Legalizing node: t25: i32 = zero_extend t24
Analyzing result type: i32
Legal result type
Analyzing operand: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Promote integer operand: t25: i32 = zero_extend t24

Creating new node: t55: i32 = any_extend t54
Creating constant: t56: i32 = Constant<1>
Creating new node: t57: i32 = and t55, Constant:i32<1>
Replacing: t25: i32 = zero_extend t24
     with: t57: i32 = and t55, Constant:i32<1>
Legalizing node: t56: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t56: i32 = Constant<1>

Legalizing node: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t21: f64 = fadd t19, t20
Legal operand
Analyzing operand: t22: f64 = ConstantFP<1.000000e+00>
Legal operand
Analyzing operand: t23: ch = setole
Legal operand
Legally typed node: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Legalizing node: t55: i32 = any_extend t54
Analyzing result type: i32
Legal result type
Analyzing operand: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Legal operand
Legally typed node: t55: i32 = any_extend t54

Legalizing node: t57: i32 = and t55, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t55: i32 = any_extend t54
Legal operand
Analyzing operand: t56: i32 = Constant<1>
Legal operand
Legally typed node: t57: i32 = and t55, Constant:i32<1>

Legalizing node: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing node: t28: i32 = add nuw nsw t27, t57
Analyzing result type: i32
Legal result type
Analyzing operand: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Legal operand
Analyzing operand: t57: i32 = and t55, Constant:i32<1>
Legal operand
Legally typed node: t28: i32 = add nuw nsw t27, t57

Legalizing node: t30: ch = CopyToReg t0, Register:i32 %2, t28
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t28: i32 = add nuw nsw t27, t57
Legal operand
Legally typed node: t30: ch = CopyToReg t0, Register:i32 %2, t28

Legalizing node: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t34: i32 = add nsw t32, Constant:i32<-1>
Analyzing result type: i32
Legal result type
Analyzing operand: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t33: i32 = Constant<-1>
Legal operand
Legally typed node: t34: i32 = add nsw t32, Constant:i32<-1>

Legalizing node: t36: ch = CopyToReg t0, Register:i32 %3, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t34: i32 = add nsw t32, Constant:i32<-1>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i32 %3, t34

Legalizing node: t42: ch = TokenFactor t30, t36, t16:1
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = CopyToReg t0, Register:i32 %2, t28
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i32 %3, t34
Legal operand
Analyzing operand: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal operand
Legally typed node: t42: ch = TokenFactor t30, t36, t16:1

Legalizing node: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Analyzing result type: i1
Promote integer result: t48: i1 = setcc t34, Constant:i32<0>, setne:ch

Creating new node: t58: i8 = setcc t34, Constant:i32<0>, setne:ch
Legalizing node: t49: ch = brcond t42, t48, BasicBlock:ch<for.body 0xfd7a700>
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = TokenFactor t30, t36, t16:1
Legal operand
Analyzing operand: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Promote integer operand: t49: ch = brcond t42, t48, BasicBlock:ch<for.body 0xfd7a700>

Creating new node: t59: i8 = zero_extend t48
Legalizing node: t59: i8 = zero_extend t48
Analyzing result type: i8
Legal result type
Analyzing operand: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Promote integer operand: t59: i8 = zero_extend t48

Creating constant: t60: i8 = Constant<1>
Creating new node: t61: i8 = and t58, Constant:i8<1>
Replacing: t59: i8 = zero_extend t48
     with: t61: i8 = and t58, Constant:i8<1>
Legalizing node: t60: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t60: i8 = Constant<1>

Legalizing node: t58: i8 = setcc t34, Constant:i32<0>, setne:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t34: i32 = add nsw t32, Constant:i32<-1>
Legal operand
Analyzing operand: t37: i32 = Constant<0>
Legal operand
Analyzing operand: t47: ch = setne
Legal operand
Legally typed node: t58: i8 = setcc t34, Constant:i32<0>, setne:ch

Legalizing node: t61: i8 = and t58, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t58: i8 = setcc t34, Constant:i32<0>, setne:ch
Legal operand
Analyzing operand: t60: i8 = Constant<1>
Legal operand
Legally typed node: t61: i8 = and t58, Constant:i8<1>

Legalizing node: t49: ch = brcond t42, t61, BasicBlock:ch<for.body 0xfd7a700>
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = TokenFactor t30, t36, t16:1
Legal operand
Analyzing operand: t61: i8 = and t58, Constant:i8<1>
Legal operand
Analyzing operand: t43: ch = BasicBlock<for.body 0xfd7a700>
Legal operand
Legally typed node: t49: ch = brcond t42, t61, BasicBlock:ch<for.body 0xfd7a700>

Legalizing node: t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch = brcond t42, t61, BasicBlock:ch<for.body 0xfd7a700>
Legal operand
Analyzing operand: t45: ch = BasicBlock<for.end 0xfd7a8a8>
Legal operand
Legally typed node: t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>

Legalizing node: t65535: ch = handlenode t46
Analyzing result type: ch
Legal result type
Analyzing operand: t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>
Legal operand
Legally typed node: t65535: ch = handlenode t46

Type-legalized selection DAG: %bb.1 '_Z5solvev:for.body'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                    t19: f64 = fmul t12, t12
                    t20: f64 = fmul t18, t18
                  t21: f64 = fadd t19, t20
                t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
              t55: i32 = any_extend t54
            t57: i32 = and t55, Constant:i32<1>
          t28: i32 = add nuw nsw t27, t57
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
        t58: i8 = setcc t34, Constant:i32<0>, setne:ch
      t61: i8 = and t58, Constant:i8<1>
    t49: ch = brcond t42, t61, BasicBlock:ch<for.body 0xfd7a700>
  t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>



Combining: t61: i8 = and t58, Constant:i8<1>

Replacing.2 t61: i8 = and t58, Constant:i8<1>

With: t58: i8 = setcc t34, Constant:i32<0>, setne:ch


Combining: t58: i8 = setcc t34, Constant:i32<0>, setne:ch

Combining: t57: i32 = and t55, Constant:i32<1>
Creating new node: t62: i32 = zero_extend t54

Replacing.1 t57: i32 = and t55, Constant:i32<1>

With: t62: i32 = zero_extend t54
 and 0 other values

Replacing.1 t55: i32 = any_extend t54

With: t62: i32 = zero_extend t54
 and 0 other values

Combining: t62: i32 = zero_extend t54
Creating constant: t63: i8 = Constant<1>
Creating constant: t64: i8 = Constant<0>

Combining: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Combining: t49: ch = brcond t42, t58, BasicBlock:ch<for.body 0xfd7a700>

Combining: t47: ch = setne

Combining: t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>

Combining: t45: ch = BasicBlock<for.end 0xfd7a8a8>

Combining: t43: ch = BasicBlock<for.body 0xfd7a700>

Combining: t42: ch = TokenFactor t30, t36, t16:1

Combining: t37: i32 = Constant<0>

Combining: t36: ch = CopyToReg t0, Register:i32 %3, t34

Combining: t35: i32 = Register %3

Combining: t34: i32 = add nsw t32, Constant:i32<-1>

Combining: t33: i32 = Constant<-1>

Combining: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t31: i32 = Register %0

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t28

Combining: t29: i32 = Register %2

Combining: t28: i32 = add nuw nsw t27, t62

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t26: i32 = Register %1

Combining: t23: ch = setole

Combining: t22: f64 = ConstantFP<1.000000e+00>

Combining: t21: f64 = fadd t19, t20

Combining: t20: f64 = fmul t18, t18

Combining: t19: f64 = fmul t12, t12

Combining: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Creating fp constant: t65: f64 = ConstantFP<-2.147484e+09>

Combining: t17: f64 = sint_to_fp t16

Combining: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Creating fp constant: t66: f64 = ConstantFP<-2.147484e+09>

Combining: t11: f64 = ConstantFP<2.147484e+09>

Combining: t10: f64 = sint_to_fp t9

Combining: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Combining: t8: i32 = Register $eax

Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t5: Untyped = RegisterMask

Combining: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t2: i64 = TargetConstant<0>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.1 '_Z5solvev:for.body'
SelectionDAG has 44 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                  t19: f64 = fmul t12, t12
                  t20: f64 = fmul t18, t18
                t21: f64 = fadd t19, t20
              t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
            t62: i32 = zero_extend t54
          t28: i32 = add nuw nsw t27, t62
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
      t58: i8 = setcc t34, Constant:i32<0>, setne:ch
    t49: ch = brcond t42, t58, BasicBlock:ch<for.body 0xfd7a700>
  t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>



Legalizing: t46: ch = br t49, BasicBlock:ch<for.end 0xfd7a8a8>
Legal node: nothing to do

Legalizing: t49: ch = brcond t42, t58, BasicBlock:ch<for.body 0xfd7a700>
Trying custom legalization
Creating new node: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
Creating constant: t68: i8 = TargetConstant<5>
Creating new node: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1
Successfully custom legalized node
 ... replacing: t49: ch = brcond t42, t58, BasicBlock:ch<for.body 0xfd7a700>
     with:      t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1

Legalizing: t42: ch = TokenFactor t30, t36, t16:1
Legal node: nothing to do

Legalizing: t30: ch = CopyToReg t0, Register:i32 %2, t28
Legal node: nothing to do

Legalizing: t28: i32 = add nuw nsw t27, t62
Legal node: nothing to do

Legalizing: t62: i32 = zero_extend t54
Legal node: nothing to do

Legalizing: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Trying custom legalization
Creating new node: t70: i32 = X86ISD::FCMP ConstantFP:f64<1.000000e+00>, t21
Creating constant: t71: i8 = TargetConstant<3>
Creating new node: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
Successfully custom legalized node
 ... replacing: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
     with:      t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70

Legalizing: t21: f64 = fadd t19, t20
Trying custom legalization

Legalizing: t20: f64 = fmul t18, t18
Legal node: nothing to do

Legalizing: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Legal node: nothing to do

Legalizing: t17: f64 = sint_to_fp t16
Trying custom legalization

Legalizing: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal node: nothing to do

Legalizing: t19: f64 = fmul t12, t12
Legal node: nothing to do

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Legal node: nothing to do

Legalizing: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t10: f64 = sint_to_fp t9
Trying custom legalization

Legalizing: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i32 %3, t67
Legal node: nothing to do

Legalizing: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Legalizing: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t45: ch = BasicBlock<for.end 0xfd7a8a8>
Legal node: nothing to do

Legalizing: t43: ch = BasicBlock<for.body 0xfd7a700>
Legal node: nothing to do

Legalizing: t35: i32 = Register %3

Legalizing: t33: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t31: i32 = Register %0

Legalizing: t29: i32 = Register %2

Legalizing: t26: i32 = Register %1

Legalizing: t22: f64 = ConstantFP<1.000000e+00>
Trying to expand node
Creating new constant pool: t73: i64 = ConstantPool<double 1.000000e+00> 0
Creating new node: t74: i64 = undef
Creating new node: t75: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t22: f64 = ConstantFP<1.000000e+00>
     with:      t75: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64

Legalizing: t11: f64 = ConstantFP<2.147484e+09>
Trying to expand node
Creating new constant pool: t76: i64 = ConstantPool<double 0x41DFFFFFFFC00000> 0
Creating new node: t77: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 0x41DFFFFFFFC00000> 0, undef:i64
Successfully expanded node
 ... replacing: t11: f64 = ConstantFP<2.147484e+09>
     with:      t77: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 0x41DFFFFFFFC00000> 0, undef:i64

Legalizing: t8: i32 = Register $eax

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal node: nothing to do

Legalizing: t2: i64 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t77: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 0x41DFFFFFFFC00000> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t76: i64 = ConstantPool<double 0x41DFFFFFFFC00000> 0
Trying custom legalization
Creating new constant pool: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
Creating new node: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
Successfully custom legalized node
 ... replacing: t76: i64 = ConstantPool<double 0x41DFFFFFFFC00000> 0
     with:      t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0

Legalizing: t75: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t74: i64 = undef
Legal node: nothing to do

Legalizing: t73: i64 = ConstantPool<double 1.000000e+00> 0
Trying custom legalization
Creating new constant pool: t80: i64 = TargetConstantPool<double 1.000000e+00> 0
Creating new node: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Successfully custom legalized node
 ... replacing: t73: i64 = ConstantPool<double 1.000000e+00> 0
     with:      t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
Legal node: nothing to do

Legalizing: t71: i8 = TargetConstant<3>

Legalizing: t70: i32 = X86ISD::FCMP t75, t21
Legal node: nothing to do

Legalizing: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1
Legal node: nothing to do

Legalizing: t68: i8 = TargetConstant<5>

Legalizing: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
Legal node: nothing to do

Legalizing: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Legalizing: t80: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do

Legalizing: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do

Legalizing: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do
Legalized selection DAG: %bb.1 '_Z5solvev:for.body'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, t77
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, t77
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
    t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
  t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                    t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
                  t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
                    t19: f64 = fmul t12, t12
                    t20: f64 = fmul t18, t18
                  t21: f64 = fadd t19, t20
                t70: i32 = X86ISD::FCMP t75, t21
              t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
            t62: i32 = zero_extend t72
          t28: i32 = add nuw nsw t27, t62
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t67
      t42: ch = TokenFactor t30, t36, t16:1
    t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1
  t46: ch = br t69, BasicBlock:ch<for.end 0xfd7a8a8>



Legalizing: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t80: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t80: i64 = TargetConstantPool<double 1.000000e+00> 0

Legalizing: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do

Combining: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0

Legalizing: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do

Combining: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0

Legalizing: t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
Legalizing non-extending load operation

Combining: t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64

Legalizing: t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
Legalizing non-extending load operation

Combining: t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64

Legalizing: t74: i64 = undef
Legal node: nothing to do

Combining: t74: i64 = undef

Legalizing: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
Legal node: nothing to do

Combining: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70

Legalizing: t71: i8 = TargetConstant<3>

Combining: t71: i8 = TargetConstant<3>

Legalizing: t70: i32 = X86ISD::FCMP t75, t21
Legal node: nothing to do

Combining: t70: i32 = X86ISD::FCMP t75, t21

Legalizing: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1
Legal node: nothing to do

Combining: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1

Legalizing: t68: i8 = TargetConstant<5>

Combining: t68: i8 = TargetConstant<5>

Legalizing: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
Legal node: nothing to do

Combining: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>

Legalizing: t46: ch = br t69, BasicBlock:ch<for.end 0xfd7a8a8>
Legal node: nothing to do

Combining: t46: ch = br t69, BasicBlock:ch<for.end 0xfd7a8a8>

Legalizing: t42: ch = TokenFactor t30, t36, t16:1
Legal node: nothing to do

Combining: t42: ch = TokenFactor t30, t36, t16:1

Legalizing: t30: ch = CopyToReg t0, Register:i32 %2, t28
Legal node: nothing to do

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t28

Legalizing: t28: i32 = add nuw nsw t27, t62
Legal node: nothing to do

Combining: t28: i32 = add nuw nsw t27, t62
Creating new node: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
 ... into: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70

Legalizing: t70: i32 = X86ISD::FCMP t75, t21
Legal node: nothing to do

Combining: t70: i32 = X86ISD::FCMP t75, t21

Legalizing: t30: ch = CopyToReg t0, Register:i32 %2, t82
Legal node: nothing to do

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t82

Legalizing: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
Legal node: nothing to do

Combining: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70

Legalizing: t21: f64 = fadd t19, t20
Trying custom legalization

Combining: t21: f64 = fadd t19, t20

Legalizing: t20: f64 = fmul t18, t18
Legal node: nothing to do

Combining: t20: f64 = fmul t18, t18

Legalizing: t18: f64 = fdiv t17, t77
Legal node: nothing to do

Combining: t18: f64 = fdiv t17, t77

Legalizing: t17: f64 = sint_to_fp t16
Trying custom legalization

Combining: t17: f64 = sint_to_fp t16

Legalizing: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal node: nothing to do

Combining: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Legalizing: t19: f64 = fmul t12, t12
Legal node: nothing to do

Combining: t19: f64 = fmul t12, t12

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t12: f64 = fdiv t10, t77
Legal node: nothing to do

Combining: t12: f64 = fdiv t10, t77

Legalizing: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing: t10: f64 = sint_to_fp t9
Trying custom legalization

Combining: t10: f64 = sint_to_fp t9

Legalizing: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal node: nothing to do

Combining: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Legalizing: t36: ch = CopyToReg t0, Register:i32 %3, t67
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i32 %3, t67

Legalizing: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t45: ch = BasicBlock<for.end 0xfd7a8a8>
Legal node: nothing to do

Combining: t45: ch = BasicBlock<for.end 0xfd7a8a8>

Legalizing: t43: ch = BasicBlock<for.body 0xfd7a700>
Legal node: nothing to do

Combining: t43: ch = BasicBlock<for.body 0xfd7a700>

Legalizing: t35: i32 = Register %3

Combining: t35: i32 = Register %3

Legalizing: t33: i32 = Constant<-1>
Legal node: nothing to do

Combining: t33: i32 = Constant<-1>

Legalizing: t31: i32 = Register %0

Combining: t31: i32 = Register %0

Legalizing: t29: i32 = Register %2

Combining: t29: i32 = Register %2

Legalizing: t26: i32 = Register %1

Combining: t26: i32 = Register %1

Legalizing: t8: i32 = Register $eax

Combining: t8: i32 = Register $eax

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Combining: t5: Untyped = RegisterMask

Legalizing: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal node: nothing to do

Combining: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Legalizing: t2: i64 = TargetConstant<0>

Combining: t2: i64 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 '_Z5solvev:for.body'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, t77
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, t77
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
    t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
  t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
              t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
                t19: f64 = fmul t12, t12
                t20: f64 = fmul t18, t18
              t21: f64 = fadd t19, t20
            t70: i32 = X86ISD::FCMP t75, t21
          t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
        t30: ch = CopyToReg t0, Register:i32 %2, t82
        t36: ch = CopyToReg t0, Register:i32 %3, t67
      t42: ch = TokenFactor t30, t36, t16:1
    t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1
  t46: ch = br t69, BasicBlock:ch<for.end 0xfd7a8a8>


===== Instruction selection begins: %bb.1 'for.body'

ISEL: Starting selection on root node: t46: ch = br t69, BasicBlock:ch<for.end 0xfd7a8a8>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t46: ch = JMP_1 BasicBlock:ch<for.end 0xfd7a8a8>, t69
ISEL: Match complete!

ISEL: Starting selection on root node: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t67:1
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1
  Morphed node: t69: ch = JCC_1 BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t84, t84:1
ISEL: Match complete!

ISEL: Starting selection on root node: t42: ch = TokenFactor t30, t36, t16:1

ISEL: Starting selection on root node: t30: ch = CopyToReg t0, Register:i32 %2, t82

ISEL: Starting selection on root node: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
ISEL: Starting pattern match
  Initial Opcode index to 90509
  Match failed at index 90513
  Continuing at 90632
  Match failed at index 90651
  Continuing at 90667
  Match failed at index 90674
  Continuing at 90690
Creating constant: t85: i32 = TargetConstant<-1>
Creating new node: t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70
  Morphed node: t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1
ISEL: Match complete!

ISEL: Starting selection on root node: t70: i32 = X86ISD::FCMP t75, t21
ISEL: Starting pattern match
  Initial Opcode index to 93700
  Skipped scope entry (due to false predicate) at index 93703, continuing at 93828
  Match failed at index 93834
  Continuing at 93905
  Skipped scope entry (due to false predicate) at index 93909, continuing at 93919
  Skipped scope entry (due to false predicate) at index 93920, continuing at 93930
  Morphed node: t70: i32 = UCOMISDrr nofpexcept t75, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: f64 = fadd t19, t20
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t21: f64 = ADDSDrr nofpexcept t19, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: f64 = fmul t18, t18
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t20: f64 = MULSDrr nofpexcept t18, t18
ISEL: Match complete!

ISEL: Starting selection on root node: t18: f64 = fdiv t17, t77
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  Match failed at index 157821
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  Match failed at index 158422
  Continuing at 158553
  TypeSwitch[f64] from 158555 to 158607
  Skipped scope entry (due to false predicate) at index 158609, continuing at 158620
  Skipped scope entry (due to false predicate) at index 158621, continuing at 158631
  Morphed node: t18: f64 = DIVSDrr nofpexcept t17, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t17: f64 = sint_to_fp t16
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t17: f64 = CVTSI2SDrr t16
ISEL: Match complete!

ISEL: Starting selection on root node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

ISEL: Starting selection on root node: t19: f64 = fmul t12, t12
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t19: f64 = MULSDrr nofpexcept t12, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: f64 = fdiv t10, t77
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  Match failed at index 157821
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  Match failed at index 158422
  Continuing at 158553
  TypeSwitch[f64] from 158555 to 158607
  Skipped scope entry (due to false predicate) at index 158609, continuing at 158620
  Skipped scope entry (due to false predicate) at index 158621, continuing at 158631
  Morphed node: t12: f64 = DIVSDrr nofpexcept t10, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t10: f64 = sint_to_fp t9
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t10: f64 = CVTSI2SDrr t9
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t87: i32 = TargetConstant<0>
  Morphed node: t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i32 %3, t67

ISEL: Starting selection on root node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t89: i8 = TargetConstant<1>
Creating new constant pool: t91: i32 = TargetConstantPool<double 1.000000e+00> 0
  Morphed node: t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t93: i32 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
  Morphed node: t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
ISEL: Starting pattern match
  Initial Opcode index to 88180
  Match failed at index 88184
  Continuing at 88287
  Match failed at index 88289
  Continuing at 88396
  Skipped scope entry (due to false predicate) at index 88401, continuing at 88447
  TypeSwitch[i32] from 88461 to 88488
  Match failed at index 88488
  Continuing at 88511
  Match failed at index 88512
  Continuing at 88588
  Match failed at index 88589
  Continuing at 88620
  Match failed at index 88635
  Continuing at 88648
  Match failed at index 88654
  Continuing at 88667
  Morphed node: t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t27: i32,ch = CopyFromReg t0, Register:i32 %1

ISEL: Starting selection on root node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t68: i8 = TargetConstant<5>

ISEL: Starting selection on root node: t45: ch = BasicBlock<for.end 0xfd7a8a8>

ISEL: Starting selection on root node: t43: ch = BasicBlock<for.body 0xfd7a700>

ISEL: Starting selection on root node: t35: i32 = Register %3

ISEL: Starting selection on root node: t31: i32 = Register %0

ISEL: Starting selection on root node: t29: i32 = Register %2

ISEL: Starting selection on root node: t26: i32 = Register %1

ISEL: Starting selection on root node: t8: i32 = Register $eax

ISEL: Starting selection on root node: t5: Untyped = RegisterMask

ISEL: Starting selection on root node: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

ISEL: Starting selection on root node: t2: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 '_Z5solvev:for.body'
SelectionDAG has 50 nodes:
  t0: ch = EntryToken
    t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>
  t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0
  t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1
  t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2
    t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1
  t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1
    t10: f64 = CVTSI2SDrr t9
  t12: f64 = DIVSDrr nofpexcept t10, t77
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
  t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2
    t17: f64 = CVTSI2SDrr t16
  t18: f64 = DIVSDrr nofpexcept t17, t77
          t27: i32,ch = CopyFromReg t0, Register:i32 %1
              t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
                t19: f64 = MULSDrr nofpexcept t12, t12
                t20: f64 = MULSDrr nofpexcept t18, t18
              t21: f64 = ADDSDrr nofpexcept t19, t20
            t70: i32 = UCOMISDrr nofpexcept t75, t21
          t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70
        t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1
      t30: ch = CopyToReg t0, Register:i32 %2, t82
      t36: ch = CopyToReg t0, Register:i32 %3, t67
    t42: ch = TokenFactor t30, t36, t16:1
  t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1
    t69: ch = JCC_1 BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t84, t84:1
  t46: ch = JMP_1 BasicBlock:ch<for.end 0xfd7a8a8>, t69


********** List Scheduling %bb.1 'for.body' **********
SU(0): t46: ch = JMP_1 BasicBlock:ch<for.end 0xfd7a8a8>, t69

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
    SU(9): Data Latency=1
SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=1
SU(4): t42: ch = TokenFactor t30, t36, t16:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(10): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 9
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(17): Data Latency=1
SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 11
  Predecessors:
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(20): Data Latency=1
SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 2
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(22): Data Latency=1
    SU(12): Data Latency=1 Reg=$eflags
  Successors:
    SU(10): Data Latency=1
SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(21): Data Latency=1
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1 Reg=$eflags
SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(18): Data Latency=1
    SU(14): Data Latency=1
  Successors:
    SU(12): Data Latency=1
SU(14): t20: f64 = MULSDrr nofpexcept t18, t18

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 6
  Predecessors:
    SU(15): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 7
  Predecessors:
    SU(17): Data Latency=1
    SU(16): Data Latency=1
  Successors:
    SU(14): Data Latency=1
SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(15): Data Latency=1
    SU(19): Data Latency=1
SU(17): t17: f64 = CVTSI2SDrr t16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(15): Data Latency=1
SU(18): t19: f64 = MULSDrr nofpexcept t12, t12

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(19): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(20): Data Latency=1
    SU(16): Data Latency=1
  Successors:
    SU(18): Data Latency=1
SU(20): t10: f64 = CVTSI2SDrr t9

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(19): Data Latency=1
SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(12): Data Latency=1
SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(11): Data Latency=1

Examining Available:
Height 0: SU(0): t46: ch = JMP_1 BasicBlock:ch<for.end 0xfd7a8a8>, t69


*** Scheduling [0]: SU(0): t46: ch = JMP_1 BasicBlock:ch<for.end 0xfd7a8a8>, t69


Examining Available:
Height 1: SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1


*** Scheduling [1]: SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1


Examining Available:
Height 1: SU(4): t42: ch = TokenFactor t30, t36, t16:1


*** Scheduling [2]: SU(4): t42: ch = TokenFactor t30, t36, t16:1


Examining Available:
Height 3: SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67

Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [3]: SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67


Examining Available:
Height 4: SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>

Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [4]: SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>


Examining Available:
Height 5: SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0

Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [5]: SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [6]: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


Examining Available:
Height 7: SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70


*** Scheduling [7]: SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70


Examining Available:
Height 8: SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1

Height 8: SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21


*** Scheduling [8]: SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1


Examining Available:
Height 8: SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21


*** Scheduling [9]: SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21


Examining Available:
Height 10: SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

Height 10: SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20


*** Scheduling [10]: SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 10: SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20


*** Scheduling [11]: SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20


Examining Available:
Height 12: SU(14): t20: f64 = MULSDrr nofpexcept t18, t18

Height 12: SU(18): t19: f64 = MULSDrr nofpexcept t12, t12


*** Scheduling [12]: SU(14): t20: f64 = MULSDrr nofpexcept t18, t18


Examining Available:
Height 12: SU(18): t19: f64 = MULSDrr nofpexcept t12, t12

Height 13: SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77


*** Scheduling [13]: SU(18): t19: f64 = MULSDrr nofpexcept t12, t12


Examining Available:
Height 13: SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [14]: SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77


Examining Available:
Height 15: SU(17): t17: f64 = CVTSI2SDrr t16

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [15]: SU(17): t17: f64 = CVTSI2SDrr t16


Examining Available:
Height 16: SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [16]: SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


Examining Available:
Height 17: SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [17]: SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1


Examining Available:
Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [18]: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


Examining Available:
Height 19: SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0

Height 19: SU(20): t10: f64 = CVTSI2SDrr t9


*** Scheduling [19]: SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0


Examining Available:
Height 19: SU(20): t10: f64 = CVTSI2SDrr t9


*** Scheduling [20]: SU(20): t10: f64 = CVTSI2SDrr t9


Examining Available:
Height 21: SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1


*** Scheduling [21]: SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1


Examining Available:
Height 22: SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [22]: SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

SU(20): t10: f64 = CVTSI2SDrr t9

SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0

SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77

SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1

SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

SU(17): t17: f64 = CVTSI2SDrr t16

SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77

SU(18): t19: f64 = MULSDrr nofpexcept t12, t12

SU(14): t20: f64 = MULSDrr nofpexcept t18, t18

SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20

SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21

SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1

SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70

SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82

SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0

SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>

SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67

SU(4): t42: ch = TokenFactor t30, t36, t16:1

SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body 0xfd7a700>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1

SU(0): t46: ch = JMP_1 BasicBlock:ch<for.end 0xfd7a8a8>, t69


Total amount of phi nodes to update: 2
Node 0 : (0xfd7a7d8, 2147483651)
Node 1 : (0xfd7a840, 2147483650)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Creating new node: t3: f64 = sint_to_fp t2
Creating fp constant: t4: f64 = ConstantFP<1.000000e+07>
Creating new node: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Creating fp constant: t6: f64 = ConstantFP<4.000000e+00>
Creating new node: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Creating constant: t8: i32 = TargetConstant<0>
Creating new node: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
Creating new node: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1
Initial selection DAG: %bb.2 '_Z5solvev:for.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
      t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
    t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
  t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
  t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1



Combining: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1

Combining: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7

Combining: t9: f64 = Register $xmm0

Combining: t8: i32 = TargetConstant<0>

Combining: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Creating fp constant: t12: f64 = ConstantFP<-1.000000e+07>
Creating new node: t13: f64 = fdiv t3, ConstantFP:f64<-1.000000e+07>
Creating fp constant: t14: f64 = ConstantFP<-4.000000e+00>

Combining: t6: f64 = ConstantFP<4.000000e+00>

Combining: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Creating fp constant: t15: f64 = ConstantFP<-1.000000e+07>

Combining: t4: f64 = ConstantFP<1.000000e+07>

Combining: t3: f64 = sint_to_fp t2

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Combining: t1: i32 = Register %2

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.2 '_Z5solvev:for.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
      t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
    t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
  t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
  t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1


Legalizing node: t9: f64 = Register $xmm0
Ignoring node results
Legally typed node: t9: f64 = Register $xmm0

Legalizing node: t8: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t8: i32 = TargetConstant<0>

Legalizing node: t6: f64 = ConstantFP<4.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t6: f64 = ConstantFP<4.000000e+00>

Legalizing node: t4: f64 = ConstantFP<1.000000e+07>
Analyzing result type: f64
Legal result type
Legally typed node: t4: f64 = ConstantFP<1.000000e+07>

Legalizing node: t1: i32 = Register %2
Ignoring node results
Legally typed node: t1: i32 = Register %2

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing node: t3: f64 = sint_to_fp t2
Analyzing result type: f64
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal operand
Legally typed node: t3: f64 = sint_to_fp t2

Legalizing node: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Analyzing result type: f64
Legal result type
Analyzing operand: t3: f64 = sint_to_fp t2
Legal operand
Analyzing operand: t4: f64 = ConstantFP<1.000000e+07>
Legal operand
Legally typed node: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>

Legalizing node: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Legal operand
Analyzing operand: t6: f64 = ConstantFP<4.000000e+00>
Legal operand
Legally typed node: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>

Legalizing node: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7

Legalizing node: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
Legal operand
Legally typed node: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1

Legalizing node: t65535: ch = handlenode t11
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1
Legal operand
Legally typed node: t65535: ch = handlenode t11

Type-legalized selection DAG: %bb.2 '_Z5solvev:for.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
      t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
    t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
  t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
  t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1



Legalizing: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
Legal node: nothing to do

Legalizing: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Legal node: nothing to do

Legalizing: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Legal node: nothing to do

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Legalizing: t9: f64 = Register $xmm0

Legalizing: t8: i32 = TargetConstant<0>

Legalizing: t6: f64 = ConstantFP<4.000000e+00>
Trying to expand node
Creating new constant pool: t16: i64 = ConstantPool<double 4.000000e+00> 0
Creating new node: t17: i64 = undef
Creating new node: t18: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t6: f64 = ConstantFP<4.000000e+00>
     with:      t18: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64

Legalizing: t4: f64 = ConstantFP<1.000000e+07>
Trying to expand node
Creating new constant pool: t19: i64 = ConstantPool<double 1.000000e+07> 0
Creating new node: t20: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+07> 0, undef:i64
Successfully expanded node
 ... replacing: t4: f64 = ConstantFP<1.000000e+07>
     with:      t20: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+07> 0, undef:i64

Legalizing: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t20: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+07> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t19: i64 = ConstantPool<double 1.000000e+07> 0
Trying custom legalization
Creating new constant pool: t21: i64 = TargetConstantPool<double 1.000000e+07> 0
Creating new node: t22: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
Successfully custom legalized node
 ... replacing: t19: i64 = ConstantPool<double 1.000000e+07> 0
     with:      t22: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0

Legalizing: t18: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t17: i64 = undef
Legal node: nothing to do

Legalizing: t16: i64 = ConstantPool<double 4.000000e+00> 0
Trying custom legalization
Creating new constant pool: t23: i64 = TargetConstantPool<double 4.000000e+00> 0
Creating new node: t24: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Successfully custom legalized node
 ... replacing: t16: i64 = ConstantPool<double 4.000000e+00> 0
     with:      t24: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t24: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t23: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t22: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
Legal node: nothing to do

Legalizing: t21: i64 = TargetConstantPool<double 1.000000e+07> 0
Legal node: nothing to do
Legalized selection DAG: %bb.2 '_Z5solvev:for.end'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
          t22: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
        t20: f64,ch = load<(load 8 from constant-pool)> t0, t22, undef:i64
      t5: f64 = fdiv t3, t20
        t24: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
      t18: f64,ch = load<(load 8 from constant-pool)> t0, t24, undef:i64
    t7: f64 = fmul t5, t18
  t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
  t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1



Legalizing: t24: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t24: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t23: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t23: i64 = TargetConstantPool<double 4.000000e+00> 0

Legalizing: t22: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
Legal node: nothing to do

Combining: t22: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0

Legalizing: t21: i64 = TargetConstantPool<double 1.000000e+07> 0
Legal node: nothing to do

Combining: t21: i64 = TargetConstantPool<double 1.000000e+07> 0

Legalizing: t20: f64,ch = load<(load 8 from constant-pool)> t0, t22, undef:i64
Legalizing non-extending load operation

Combining: t20: f64,ch = load<(load 8 from constant-pool)> t0, t22, undef:i64

Legalizing: t18: f64,ch = load<(load 8 from constant-pool)> t0, t24, undef:i64
Legalizing non-extending load operation

Combining: t18: f64,ch = load<(load 8 from constant-pool)> t0, t24, undef:i64

Legalizing: t17: i64 = undef
Legal node: nothing to do

Combining: t17: i64 = undef

Legalizing: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1
Legal node: nothing to do

Combining: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1

Legalizing: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7

Legalizing: t7: f64 = fmul t5, t18
Legal node: nothing to do

Combining: t7: f64 = fmul t5, t18

Legalizing: t5: f64 = fdiv t3, t20
Legal node: nothing to do

Combining: t5: f64 = fdiv t3, t20

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Combining: t3: f64 = sint_to_fp t2

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing: t9: f64 = Register $xmm0

Combining: t9: f64 = Register $xmm0

Legalizing: t8: i32 = TargetConstant<0>

Combining: t8: i32 = TargetConstant<0>

Legalizing: t1: i32 = Register %2

Combining: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.2 '_Z5solvev:for.end'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
          t22: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
        t20: f64,ch = load<(load 8 from constant-pool)> t0, t22, undef:i64
      t5: f64 = fdiv t3, t20
        t24: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
      t18: f64,ch = load<(load 8 from constant-pool)> t0, t24, undef:i64
    t7: f64 = fmul t5, t18
  t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
  t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1


===== Instruction selection begins: %bb.2 'for.end'

ISEL: Starting selection on root node: t11: ch = X86ISD::RET_FLAG t10, TargetConstant:i32<0>, Register:f64 $xmm0, t10:1
ISEL: Starting pattern match
  Initial Opcode index to 127064
  Morphed node: t11: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t10, t10:1
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7

ISEL: Starting selection on root node: t7: f64 = fmul t5, t18
ISEL: Starting pattern match
  Initial Opcode index to 154194
  OpcodeSwitch from 154199 to 154204
  TypeSwitch[f64] from 154215 to 154239
  Match failed at index 154239
  Continuing at 154259
  Match failed at index 154260
  Continuing at 154333
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  TypeSwitch[f64] from 154811 to 154875
  Skipped scope entry (due to false predicate) at index 154877, continuing at 154895
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t26: i8 = TargetConstant<1>
Creating new constant pool: t28: i32 = TargetConstantPool<double 4.000000e+00> 0
  Morphed node: t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: f64 = fdiv t3, t20
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  TypeSwitch[f64] from 157830 to 157854
  Match failed at index 157854
  Continuing at 157874
  Match failed at index 157875
  Continuing at 157948
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  TypeSwitch[f64] from 158429 to 158493
  Skipped scope entry (due to false predicate) at index 158495, continuing at 158513
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t30: i32 = TargetConstantPool<double 1.000000e+07> 0
  Morphed node: t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t3: f64 = sint_to_fp t2
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t3: f64 = CVTSI2SDrr t2
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %2

ISEL: Starting selection on root node: t9: f64 = Register $xmm0

ISEL: Starting selection on root node: t8: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t1: i32 = Register %2

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 '_Z5solvev:for.end'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = CVTSI2SDrr t2
      t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0
    t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
  t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7
  t11: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t10, t10:1


********** List Scheduling %bb.2 'for.end' **********
SU(0): t11: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t10, t10:1

    t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t3: f64 = CVTSI2SDrr t2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1

Examining Available:
Height 0: SU(0): t11: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t10, t10:1

    t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7


*** Scheduling [0]: SU(0): t11: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t10, t10:1

    t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7


Examining Available:
Height 1: SU(1): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [1]: SU(1): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 2: SU(2): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0


*** Scheduling [2]: SU(2): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0


Examining Available:
Height 3: SU(3): t3: f64 = CVTSI2SDrr t2


*** Scheduling [3]: SU(3): t3: f64 = CVTSI2SDrr t2


Examining Available:
Height 4: SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %2


*** Scheduling [4]: SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %2

*** Final schedule ***
SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %2

SU(3): t3: f64 = CVTSI2SDrr t2

SU(2): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0

SU(1): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

SU(0): t11: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t10, t10:1

    t10: ch,glue = CopyToReg t0, Register:f64 $xmm0, t7


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z5solvev: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %5:gr32 = MOV32r0 implicit-def dead $eflags
  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
  $rdi = COPY %6:gr64
  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %7:gr64 = COPY $rax
  %8:gr32 = COPY %7.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %8:gr32
  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %4:gr32 = MOV32ri 10000000

bb.1.for.body:
; predecessors: %bb.0, %bb.1
  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

  %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
  %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  %10:fr64 = CVTSI2SDrr %9:gr32
  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %12:fr64 = nofpexcept DIVSDrr %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr32 = COPY $eax
  %14:fr64 = CVTSI2SDrr %13:gr32
  %15:fr64 = nofpexcept DIVSDrr %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  %16:fr64 = nofpexcept MULSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept MULSDrr %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  %18:fr64 = nofpexcept ADDSDrr %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
  %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
  %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.1, 5, implicit $eflags
  JMP_1 %bb.2

bb.2.for.end:
; predecessors: %bb.1

  %20:fr64 = CVTSI2SDrr %2:gr32
  %21:fr64 = nofpexcept DIVSDrm %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %22:fr64 = nofpexcept MULSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  $xmm0 = COPY %22:fr64
  RET 0, $xmm0

# End machine code for function _Z5solvev.

***** Machine Function before Domain Reassignment *****
# Machine code for function _Z5solvev: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %5:gr32 = MOV32r0 implicit-def dead $eflags
  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
  $rdi = COPY %6:gr64
  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %7:gr64 = COPY $rax
  %8:gr32 = COPY %7.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %8:gr32
  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %4:gr32 = MOV32ri 10000000

bb.1.for.body:
; predecessors: %bb.0, %bb.1
  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

  %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
  %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  %10:fr64 = CVTSI2SDrr %9:gr32
  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %12:fr64 = nofpexcept DIVSDrr %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr32 = COPY $eax
  %14:fr64 = CVTSI2SDrr %13:gr32
  %15:fr64 = nofpexcept DIVSDrr %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  %16:fr64 = nofpexcept MULSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept MULSDrr %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  %18:fr64 = nofpexcept ADDSDrr %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
  %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
  %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.1, 5, implicit $eflags
  JMP_1 %bb.2

bb.2.for.end:
; predecessors: %bb.1

  %20:fr64 = CVTSI2SDrr %2:gr32
  %21:fr64 = nofpexcept DIVSDrm %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %22:fr64 = nofpexcept MULSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  $xmm0 = COPY %22:fr64
  RET 0, $xmm0

# End machine code for function _Z5solvev.

# Machine code for function _Z5solvev: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %5:gr32 = MOV32r0 implicit-def dead $eflags
48B	  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
64B	  $rdi = COPY %6:gr64
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64 = COPY $rax
128B	  %8:gr32 = COPY %7.sub_32bit:gr64
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %8:gr32
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr32 = MOV32ri 10000000

224B	bb.1.for.body:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

240B	  %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
256B	  %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
272B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
288B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
320B	  %9:gr32 = COPY $eax
336B	  %10:fr64 = CVTSI2SDrr %9:gr32
352B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
368B	  %12:fr64 = nofpexcept DIVSDrr %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
384B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
432B	  %13:gr32 = COPY $eax
448B	  %14:fr64 = CVTSI2SDrr %13:gr32
464B	  %15:fr64 = nofpexcept DIVSDrr %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
480B	  %16:fr64 = nofpexcept MULSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
496B	  %17:fr64 = nofpexcept MULSDrr %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
512B	  %18:fr64 = nofpexcept ADDSDrr %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
528B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
544B	  nofpexcept UCOMISDrr killed %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
560B	  %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
576B	  %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
592B	  JCC_1 %bb.1, 5, implicit $eflags
608B	  JMP_1 %bb.2

624B	bb.2.for.end:
	; predecessors: %bb.1

640B	  %20:fr64 = CVTSI2SDrr %2:gr32
656B	  %21:fr64 = nofpexcept DIVSDrm %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
672B	  %22:fr64 = nofpexcept MULSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
688B	  $xmm0 = COPY %22:fr64
704B	  RET 0, $xmm0

# End machine code for function _Z5solvev.

********** Stack Coloring **********
********** Function: _Z5solvev
********** EARLY IF-CONVERSION **********
********** Function: _Z5solvev
Machine InstCombiner: _Z5solvev
Combining MBB entry
Combining MBB for.body
Combining MBB for.end
********** X86 cmov Conversion : _Z5solvev**********

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body]
 - 2: BB2[for.end]
loop-detection
 - loop = BB1[for.body]
compute-mass-in-loop: BB1[for.body]*
 - node: BB1[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.end]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.end]
compute-loop-scale: BB1[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body]*
 - node: BB1[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body]
 - node: BB1[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.end]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.end]
 - node: BB2[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body]: float = 32.0, scaled = 256.0, int = 255
 - BB2[for.end]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body]: float = 32.0, int = 255
 - BB2[for.end]: float = 1.0, int = 8

******** Pre-regalloc Machine LICM: _Z5solvev ********
Entering %bb.1
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
 from %bb.1 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 from %bb.1 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body]
 - 2: BB2[for.end]
loop-detection
 - loop = BB1[for.body]
compute-mass-in-loop: BB1[for.body]*
 - node: BB1[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.end]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.end]
compute-loop-scale: BB1[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body]*
 - node: BB1[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body]
 - node: BB1[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.end]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.end]
 - node: BB2[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body]: float = 32.0, scaled = 256.0, int = 255
 - BB2[for.end]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body]: float = 32.0, int = 255
 - BB2[for.end]: float = 1.0, int = 8

Entering: entry
Entering: for.body
Entering: for.end
Exiting: for.end
Exiting: for.body
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.1
4: %bb.0
Found roots: %bb.2 
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: _Z5solvev
Encountered load fold barrier on CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Encountered load fold barrier on CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
Optimize recurrence chain from %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
	Inst: %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
Optimize recurrence chain from %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
	Inst: %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
Encountered load fold barrier on CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
Encountered load fold barrier on CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
**** Analysing _Z5solvev
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : _Z5solvev **********
********** X86 EFLAGS copy lowering : _Z5solvev **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: _Z5solvev
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z5solvev
	%12:fr64 = nofpexcept DIVSDrr killed %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
		prepend:	%12:fr64 = COPY %10:fr64
		rewrite to:	%12:fr64 = nofpexcept DIVSDrr %12:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	%15:fr64 = nofpexcept DIVSDrr killed %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
		prepend:	%15:fr64 = COPY %14:fr64
		rewrite to:	%15:fr64 = nofpexcept DIVSDrr %15:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	%16:fr64 = nofpexcept MULSDrr killed %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
		prepend:	%16:fr64 = COPY %12:fr64
		rewrite to:	%16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
	%17:fr64 = nofpexcept MULSDrr killed %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
		prepend:	%17:fr64 = COPY %15:fr64
		rewrite to:	%17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
	%18:fr64 = nofpexcept ADDSDrr killed %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
2addr: COMMUTING  : %18:fr64 = nofpexcept ADDSDrr killed %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
2addr: COMMUTED TO: %18:fr64 = nofpexcept ADDSDrr killed %17:fr64(tied-def 0), killed %16:fr64, implicit $mxcsr
		prepend:	%18:fr64 = COPY %17:fr64
		rewrite to:	%18:fr64 = nofpexcept ADDSDrr %18:fr64(tied-def 0), killed %16:fr64, implicit $mxcsr
	%2:gr32 = SBB32ri8 killed %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
		prepend:	%2:gr32 = COPY %1:gr32
		rewrite to:	%2:gr32 = SBB32ri8 %2:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
	%3:gr32 = ADD32ri8 killed %0:gr32(tied-def 0), -1, implicit-def $eflags
		prepend:	%3:gr32 = COPY %0:gr32
		rewrite to:	%3:gr32 = ADD32ri8 %3:gr32(tied-def 0), -1, implicit-def $eflags
	%21:fr64 = nofpexcept DIVSDrm killed %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		prepend:	%21:fr64 = COPY %20:fr64
		rewrite to:	%21:fr64 = nofpexcept DIVSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	%22:fr64 = nofpexcept MULSDrm killed %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		prepend:	%22:fr64 = COPY %21:fr64
		rewrite to:	%22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
# Machine code for function _Z5solvev: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %5:gr32 = MOV32r0 implicit-def dead $eflags
48B	  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
64B	  $rdi = COPY killed %6:gr64
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64 = COPY killed $rax
128B	  %8:gr32 = COPY killed %7.sub_32bit:gr64
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY killed %8:gr32
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
256B	  %23:gr32 = COPY killed %4:gr32
272B	  %24:gr32 = COPY killed %5:gr32

288B	bb.1.for.body:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

304B	  %1:gr32 = COPY killed %24:gr32
320B	  %0:gr32 = COPY killed %23:gr32
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %10:fr64 = CVTSI2SDrr killed %9:gr32
416B	  %12:fr64 = COPY killed %10:fr64
432B	  %12:fr64 = nofpexcept DIVSDrr %12:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %14:fr64 = CVTSI2SDrr killed %13:gr32
528B	  %15:fr64 = COPY killed %14:fr64
544B	  %15:fr64 = nofpexcept DIVSDrr %15:fr64(tied-def 0), %11:fr64, implicit $mxcsr
560B	  %16:fr64 = COPY killed %12:fr64
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
592B	  %17:fr64 = COPY killed %15:fr64
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
624B	  %18:fr64 = COPY killed %17:fr64
640B	  %18:fr64 = nofpexcept ADDSDrr %18:fr64(tied-def 0), killed %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
672B	  %2:gr32 = COPY killed %1:gr32
688B	  %2:gr32 = SBB32ri8 %2:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
704B	  %3:gr32 = COPY killed %0:gr32
720B	  %3:gr32 = ADD32ri8 %3:gr32(tied-def 0), -1, implicit-def $eflags
736B	  %23:gr32 = COPY killed %3:gr32
752B	  %24:gr32 = COPY %2:gr32
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2.for.end:
	; predecessors: %bb.1

816B	  %20:fr64 = CVTSI2SDrr killed %2:gr32
832B	  %21:fr64 = COPY killed %20:fr64
848B	  %21:fr64 = nofpexcept DIVSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
864B	  %22:fr64 = COPY killed %21:fr64
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  $xmm0 = COPY killed %22:fr64
912B	  RET 0, killed $xmm0

# End machine code for function _Z5solvev.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%0 [320r,704r:0)  0@320r weight:0.000000e+00
%1 [304r,672r:0)  0@304r weight:0.000000e+00
%2 [672r,688r:0)[688r,816r:1)  0@672r 1@688r weight:0.000000e+00
%3 [704r,720r:0)[720r,736r:1)  0@704r 1@720r weight:0.000000e+00
%4 [208r,256r:0)  0@208r weight:0.000000e+00
%5 [32r,272r:0)  0@32r weight:0.000000e+00
%6 [48r,64r:0)  0@48r weight:0.000000e+00
%7 [112r,128r:0)  0@112r weight:0.000000e+00
%8 [128r,160r:0)  0@128r weight:0.000000e+00
%9 [384r,400r:0)  0@384r weight:0.000000e+00
%10 [400r,416r:0)  0@400r weight:0.000000e+00
%11 [224r,800B:0)  0@224r weight:0.000000e+00
%12 [416r,432r:0)[432r,560r:1)  0@416r 1@432r weight:0.000000e+00
%13 [496r,512r:0)  0@496r weight:0.000000e+00
%14 [512r,528r:0)  0@512r weight:0.000000e+00
%15 [528r,544r:0)[544r,592r:1)  0@528r 1@544r weight:0.000000e+00
%16 [560r,576r:0)[576r,640r:1)  0@560r 1@576r weight:0.000000e+00
%17 [592r,608r:0)[608r,624r:1)  0@592r 1@608r weight:0.000000e+00
%18 [624r,640r:0)[640r,656r:1)  0@624r 1@640r weight:0.000000e+00
%19 [240r,800B:0)  0@240r weight:0.000000e+00
%20 [816r,832r:0)  0@816r weight:0.000000e+00
%21 [832r,848r:0)[848r,864r:1)  0@832r 1@848r weight:0.000000e+00
%22 [864r,880r:0)[880r,896r:1)  0@864r 1@880r weight:0.000000e+00
%23 [256r,288B:0)[288B,320r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
%24 [272r,288B:0)[288B,304r:2)[752r,800B:1)  0@272r 1@752r 2@288B-phi weight:0.000000e+00
RegMasks: 80r 176r 352r 464r
********** MACHINEINSTRS **********
# Machine code for function _Z5solvev: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %5:gr32 = MOV32r0 implicit-def dead $eflags
48B	  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
64B	  $rdi = COPY %6:gr64
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64 = COPY killed $rax
128B	  %8:gr32 = COPY %7.sub_32bit:gr64
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %8:gr32
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
256B	  %23:gr32 = COPY %4:gr32
272B	  %24:gr32 = COPY %5:gr32

288B	bb.1.for.body:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

304B	  %1:gr32 = COPY %24:gr32
320B	  %0:gr32 = COPY %23:gr32
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %10:fr64 = CVTSI2SDrr %9:gr32
416B	  %12:fr64 = COPY %10:fr64
432B	  %12:fr64 = nofpexcept DIVSDrr %12:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %14:fr64 = CVTSI2SDrr %13:gr32
528B	  %15:fr64 = COPY %14:fr64
544B	  %15:fr64 = nofpexcept DIVSDrr %15:fr64(tied-def 0), %11:fr64, implicit $mxcsr
560B	  %16:fr64 = COPY %12:fr64
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
592B	  %17:fr64 = COPY %15:fr64
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
624B	  %18:fr64 = COPY %17:fr64
640B	  %18:fr64 = nofpexcept ADDSDrr %18:fr64(tied-def 0), %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, %18:fr64, implicit-def $eflags, implicit $mxcsr
672B	  %2:gr32 = COPY %1:gr32
688B	  %2:gr32 = SBB32ri8 %2:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
704B	  %3:gr32 = COPY %0:gr32
720B	  %3:gr32 = ADD32ri8 %3:gr32(tied-def 0), -1, implicit-def $eflags
736B	  %23:gr32 = COPY %3:gr32
752B	  %24:gr32 = COPY %2:gr32
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2.for.end:
	; predecessors: %bb.1

816B	  %20:fr64 = CVTSI2SDrr %2:gr32
832B	  %21:fr64 = COPY %20:fr64
848B	  %21:fr64 = nofpexcept DIVSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
864B	  %22:fr64 = COPY %21:fr64
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  $xmm0 = COPY %22:fr64
912B	  RET 0, killed $xmm0

# End machine code for function _Z5solvev.

********** SIMPLE REGISTER COALESCING **********
********** Function: _Z5solvev
********** JOINING INTERVALS ***********
for.body:
384B	%9:gr32 = COPY killed $eax
	Considering merging %9 with $eax
	Can only merge into reserved registers.
496B	%13:gr32 = COPY killed $eax
	Considering merging %13 with $eax
	Can only merge into reserved registers.
752B	%24:gr32 = COPY %2:gr32
	Considering merging to GR32 with %2 in %24
		RHS = %2 [672r,688r:0)[688r,816r:1)  0@672r 1@688r weight:0.000000e+00
		LHS = %24 [272r,288B:0)[288B,304r:2)[752r,800B:1)  0@272r 1@752r 2@288B-phi weight:0.000000e+00
		merge %24:1@752r into %2:1@688r --> @688r
		erased:	752r	%24:gr32 = COPY %2:gr32
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
		updated: 672B	%24:gr32 = COPY %1:gr32
		updated: 688B	%24:gr32 = SBB32ri8 %24:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
		updated: 816B	%20:fr64 = CVTSI2SDrr %24:gr32
	Success: %2 -> %24
	Result = %24 [272r,288B:0)[288B,304r:2)[672r,688r:3)[688r,816r:1)  0@272r 1@688r 2@288B-phi 3@672r weight:0.000000e+00
304B	%1:gr32 = COPY %24:gr32
	Considering merging to GR32 with %1 in %24
		RHS = %1 [304r,672r:0)  0@304r weight:0.000000e+00
		LHS = %24 [272r,288B:0)[288B,304r:2)[672r,688r:3)[688r,816r:1)  0@272r 1@688r 2@288B-phi 3@672r weight:0.000000e+00
		merge %1:0@304r into %24:2@288B --> @288B
		merge %24:3@672r into %1:0@304r --> @288B
		erased:	672r	%24:gr32 = COPY %1:gr32
		erased:	304r	%1:gr32 = COPY %24:gr32
	Success: %1 -> %24
	Result = %24 [272r,288B:0)[288B,688r:2)[688r,816r:1)  0@272r 1@688r 2@288B-phi weight:0.000000e+00
320B	%0:gr32 = COPY %23:gr32
	Considering merging to GR32 with %0 in %23
		RHS = %0 [320r,704r:0)  0@320r weight:0.000000e+00
		LHS = %23 [256r,288B:0)[288B,320r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
		merge %0:0@320r into %23:2@288B --> @288B
		erased:	320r	%0:gr32 = COPY %23:gr32
		updated: 704B	%3:gr32 = COPY %23:gr32
	Success: %0 -> %23
	Result = %23 [256r,288B:0)[288B,704r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
416B	%12:fr64 = COPY %10:fr64
	Considering merging to FR64 with %10 in %12
		RHS = %10 [400r,416r:0)  0@400r weight:0.000000e+00
		LHS = %12 [416r,432r:0)[432r,560r:1)  0@416r 1@432r weight:0.000000e+00
		merge %12:0@416r into %10:0@400r --> @400r
		erased:	416r	%12:fr64 = COPY %10:fr64
AllocationOrder(FR64) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
		updated: 400B	%12:fr64 = CVTSI2SDrr %9:gr32
	Success: %10 -> %12
	Result = %12 [400r,432r:0)[432r,560r:1)  0@400r 1@432r weight:0.000000e+00
528B	%15:fr64 = COPY %14:fr64
	Considering merging to FR64 with %14 in %15
		RHS = %14 [512r,528r:0)  0@512r weight:0.000000e+00
		LHS = %15 [528r,544r:0)[544r,592r:1)  0@528r 1@544r weight:0.000000e+00
		merge %15:0@528r into %14:0@512r --> @512r
		erased:	528r	%15:fr64 = COPY %14:fr64
		updated: 512B	%15:fr64 = CVTSI2SDrr %13:gr32
	Success: %14 -> %15
	Result = %15 [512r,544r:0)[544r,592r:1)  0@512r 1@544r weight:0.000000e+00
560B	%16:fr64 = COPY %12:fr64
	Considering merging to FR64 with %12 in %16
		RHS = %12 [400r,432r:0)[432r,560r:1)  0@400r 1@432r weight:0.000000e+00
		LHS = %16 [560r,576r:0)[576r,640r:1)  0@560r 1@576r weight:0.000000e+00
		merge %16:0@560r into %12:1@432r --> @432r
		erased:	560r	%16:fr64 = COPY %12:fr64
		updated: 400B	%16:fr64 = CVTSI2SDrr %9:gr32
		updated: 432B	%16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	Success: %12 -> %16
	Result = %16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:0.000000e+00
592B	%17:fr64 = COPY %15:fr64
	Considering merging to FR64 with %15 in %17
		RHS = %15 [512r,544r:0)[544r,592r:1)  0@512r 1@544r weight:0.000000e+00
		LHS = %17 [592r,608r:0)[608r,624r:1)  0@592r 1@608r weight:0.000000e+00
		merge %17:0@592r into %15:1@544r --> @544r
		erased:	592r	%17:fr64 = COPY %15:fr64
		updated: 512B	%17:fr64 = CVTSI2SDrr %13:gr32
		updated: 544B	%17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	Success: %15 -> %17
	Result = %17 [512r,544r:2)[544r,608r:0)[608r,624r:1)  0@544r 1@608r 2@512r weight:0.000000e+00
624B	%18:fr64 = COPY %17:fr64
	Considering merging to FR64 with %18 in %17
		RHS = %18 [624r,640r:0)[640r,656r:1)  0@624r 1@640r weight:0.000000e+00
		LHS = %17 [512r,544r:2)[544r,608r:0)[608r,624r:1)  0@544r 1@608r 2@512r weight:0.000000e+00
		merge %18:0@624r into %17:1@608r --> @608r
		erased:	624r	%18:fr64 = COPY %17:fr64
		updated: 640B	%17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
		updated: 656B	nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
	Success: %18 -> %17
	Result = %17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:0.000000e+00
704B	%3:gr32 = COPY %23:gr32
	Considering merging to GR32 with %3 in %23
		RHS = %3 [704r,720r:0)[720r,736r:1)  0@704r 1@720r weight:0.000000e+00
		LHS = %23 [256r,288B:0)[288B,704r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
		merge %23:1@736r into %3:1@720r --> @720r
		merge %3:0@704r into %23:2@288B --> @288B
		erased:	736r	%23:gr32 = COPY %3:gr32
		erased:	704r	%3:gr32 = COPY %23:gr32
		updated: 720B	%23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
	Success: %3 -> %23
	Result = %23 [256r,288B:0)[288B,720r:2)[720r,800B:1)  0@256r 1@720r 2@288B-phi weight:0.000000e+00
entry:
48B	%6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
	Considering merging to GR64_with_sub_8bit with %5 in %6:sub_32bit
		RHS = %5 [32r,272r:0)  0@32r weight:0.000000e+00
		LHS = %6 [48r,64r:0)  0@48r weight:0.000000e+00
		merge %6:0@48r into %5:0@32r --> @32r
		erased:	48r	%6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
AllocationOrder(GR64_with_sub_8bit) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
		updated: 32B	undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
		updated: 272B	%24:gr32 = COPY %6.sub_32bit:gr64_with_sub_8bit
	Success: %5:sub_32bit -> %6
	Result = %6 [32r,272r:0)  0@32r weight:0.000000e+00
64B	$rdi = COPY %6:gr64_with_sub_8bit
	Considering merging %6 with $rdi
	Can only merge into reserved registers.
Remat: dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
Shrink: %6 [32r,272r:0)  0@32r weight:0.000000e+00
Shrunk: %6 [32r,272r:0)  0@32r weight:0.000000e+00
112B	%7:gr64 = COPY killed $rax
	Considering merging %7 with $rax
	Can only merge into reserved registers.
160B	$edi = COPY %8:gr32
	Considering merging %8 with $edi
	Can only merge into reserved registers.
for.end:
896B	$xmm0 = COPY %22:fr64
	Considering merging %22 with $xmm0
	Can only merge into reserved registers.
128B	%8:gr32 = COPY %7.sub_32bit:gr64
	Considering merging to GR64_with_sub_8bit with %8 in %7:sub_32bit
		RHS = %8 [128r,160r:0)  0@128r weight:0.000000e+00
		LHS = %7 [112r,128r:0)  0@112r weight:0.000000e+00
		merge %8:0@128r into %7:0@112r --> @112r
		erased:	128r	%8:gr32 = COPY %7.sub_32bit:gr64
		updated: 160B	$edi = COPY %7.sub_32bit:gr64_with_sub_8bit
	Success: %8:sub_32bit -> %7
	Result = %7 [112r,160r:0)  0@112r weight:0.000000e+00
256B	%23:gr32 = COPY %4:gr32
	Considering merging to GR32 with %4 in %23
		RHS = %4 [208r,256r:0)  0@208r weight:0.000000e+00
		LHS = %23 [256r,288B:0)[288B,720r:2)[720r,800B:1)  0@256r 1@720r 2@288B-phi weight:0.000000e+00
		merge %23:0@256r into %4:0@208r --> @208r
		erased:	256r	%23:gr32 = COPY %4:gr32
		updated: 208B	%23:gr32 = MOV32ri 10000000
	Success: %4 -> %23
	Result = %23 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:0.000000e+00
272B	%24:gr32 = COPY %6.sub_32bit:gr64_with_sub_8bit
	Considering merging to GR64_with_sub_8bit with %24 in %6:sub_32bit
		RHS = %24 [272r,288B:0)[288B,688r:2)[688r,816r:1)  0@272r 1@688r 2@288B-phi weight:0.000000e+00
		LHS = %6 [32r,272r:0)  0@32r weight:0.000000e+00
		merge %24:0@272r into %6:0@32r --> @32r
		erased:	272r	%24:gr32 = COPY %6.sub_32bit:gr64_with_sub_8bit
		updated: 688B	%6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
		updated: 816B	%20:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
	Success: %24:sub_32bit -> %6
	Result = %6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:0.000000e+00
832B	%21:fr64 = COPY %20:fr64
	Considering merging to FR64 with %20 in %21
		RHS = %20 [816r,832r:0)  0@816r weight:0.000000e+00
		LHS = %21 [832r,848r:0)[848r,864r:1)  0@832r 1@848r weight:0.000000e+00
		merge %21:0@832r into %20:0@816r --> @816r
		erased:	832r	%21:fr64 = COPY %20:fr64
		updated: 816B	%21:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
	Success: %20 -> %21
	Result = %21 [816r,848r:0)[848r,864r:1)  0@816r 1@848r weight:0.000000e+00
864B	%22:fr64 = COPY %21:fr64
	Considering merging to FR64 with %21 in %22
		RHS = %21 [816r,848r:0)[848r,864r:1)  0@816r 1@848r weight:0.000000e+00
		LHS = %22 [864r,880r:0)[880r,896r:1)  0@864r 1@880r weight:0.000000e+00
		merge %22:0@864r into %21:1@848r --> @848r
		erased:	864r	%22:fr64 = COPY %21:fr64
		updated: 816B	%22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
		updated: 848B	%22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	Success: %21 -> %22
	Result = %22 [816r,848r:2)[848r,880r:0)[880r,896r:1)  0@848r 1@880r 2@816r weight:0.000000e+00
160B	$edi = COPY %7.sub_32bit:gr64_with_sub_8bit
	Considering merging %7 with $rdi
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
%6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:0.000000e+00
%7 [112r,160r:0)  0@112r weight:0.000000e+00
%9 [384r,400r:0)  0@384r weight:0.000000e+00
%11 [224r,800B:0)  0@224r weight:0.000000e+00
%13 [496r,512r:0)  0@496r weight:0.000000e+00
%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:0.000000e+00
%17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:0.000000e+00
%19 [240r,800B:0)  0@240r weight:0.000000e+00
%22 [816r,848r:2)[848r,880r:0)[880r,896r:1)  0@848r 1@880r 2@816r weight:0.000000e+00
%23 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:0.000000e+00
RegMasks: 80r 176r 352r 464r
********** MACHINEINSTRS **********
# Machine code for function _Z5solvev: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
64B	  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64_with_sub_8bit = COPY killed $rax
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %7.sub_32bit:gr64_with_sub_8bit
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %23:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

288B	bb.1.for.body:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %16:fr64 = CVTSI2SDrr %9:gr32
432B	  %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %17:fr64 = CVTSI2SDrr %13:gr32
544B	  %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
640B	  %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
688B	  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
720B	  %23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2.for.end:
	; predecessors: %bb.1

816B	  %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
848B	  %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  $xmm0 = COPY %22:fr64
912B	  RET 0, killed $xmm0

# End machine code for function _Z5solvev.

Before MISched:
# Machine code for function _Z5solvev: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %7:gr64_with_sub_8bit = COPY killed $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %7.sub_32bit:gr64_with_sub_8bit
  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %23:gr32 = MOV32ri 10000000
  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

bb.1.for.body:
; predecessors: %bb.0, %bb.1
  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY killed $eax
  %16:fr64 = CVTSI2SDrr %9:gr32
  %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr32 = COPY killed $eax
  %17:fr64 = CVTSI2SDrr %13:gr32
  %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
  %23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.1, 5, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.end:
; predecessors: %bb.1

  %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
  %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  $xmm0 = COPY %22:fr64
  RET 0, killed $xmm0

# End machine code for function _Z5solvev.

AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
AllocationOrder(GR16) = [ $ax $cx $dx $si $di $r8w $r9w $r10w $r11w $bx $bp $r14w $r15w $r12w $r13w ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
********** MI Scheduling **********
_Z5solvev:%bb.0 entry
  From: %23:gr32 = MOV32ri 10000000
    To: End RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %23:gr32 = MOV32ri 10000000
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
SU(2):   %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 5c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %23:gr32 = MOV32ri 10000000
  Ready @0c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %23:gr32 = MOV32ri 10000000
SU(1):   %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(2):   %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

********** MI Scheduling **********
_Z5solvev:%bb.0 entry
  From: undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
    To: CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
SU(1):   dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi

********** MI Scheduling **********
_Z5solvev:%bb.1 for.body
  From: %13:gr32 = COPY killed $eax
    To: JCC_1 %bb.1, 5, implicit killed $eflags
 RegionInstrs: 9
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
FR32=4
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP_with_GR64_TCW64=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=4
GR16=6
Live In: %23 %6 %19 %16 %11 AH AL HAX 
Live Out: %23 %6 %19 %11 
Live Thru: FR32=2
FR32X=2
GR16=4
  LiveReg: %23
  LiveReg: %6
  LiveReg: %19
  UpdateRegP: SU(6) nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
              to FR32 1    FR32X 1
  LiveReg: %11
  UpdateRegP: SU(2) %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
              to 
Top Pressure:
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
FR32=3
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP_with_GR64_TCW64=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=3
GR16=6
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
AllocationOrder(TILECFG) = [ $tmmcfg ]
AllocationOrder(BNDR) = [ $bnd0 $bnd1 $bnd2 $bnd3 ]
AllocationOrder(SEGMENT_REG) = [ ]
AllocationOrder(GR32_BPSP) = [ $ebp ] (sub-class)
AllocationOrder(GR32_BPSP) = [ $ebp ] (sub-class)
AllocationOrder(GR32_BSI) = [ $esi $ebx ] (sub-class)
AllocationOrder(GR32_BSI) = [ $esi $ebx ] (sub-class)
AllocationOrder(GR32_DIBP) = [ $edi $ebp ] (sub-class)
AllocationOrder(GR32_DIBP) = [ $edi $ebp ] (sub-class)
AllocationOrder(RFP32) = [ $fp0 $fp1 $fp2 $fp3 $fp4 $fp5 $fp6 ]
AllocationOrder(GR8_ABCD_H) = [ $ah $ch $dh $bh ] (sub-class)
AllocationOrder(GR8_ABCD_L) = [ $al $cl $dl $bl ] (sub-class)
AllocationOrder(VK1) = [ $k0 $k1 $k2 $k3 $k4 $k5 $k6 $k7 ]
AllocationOrder(VR64) = [ $mm0 $mm1 $mm2 $mm3 $mm4 $mm5 $mm6 $mm7 ]
AllocationOrder(TILE) = [ $tmm0 $tmm1 $tmm2 $tmm3 $tmm4 $tmm5 $tmm6 $tmm7 ]
AllocationOrder(GR8_NOREX) = [ $al $cl $dl $bl ]
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
AllocationOrder(GR64_NOREX_and_GR64_TCW64) = [ $rax $rcx $rdx ] (sub-class)
AllocationOrder(GR64_NOREX_and_GR64_TCW64) = [ $rax $rcx $rdx ] (sub-class)
AllocationOrder(DEBUG_REG) = [ $dr0 $dr1 $dr2 $dr3 $dr4 $dr5 $dr6 $dr7 $dr8 $dr9 $dr10 $dr11 $dr12 $dr13 $dr14 $dr15 ]
AllocationOrder(FR32) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
AllocationOrder(CONTROL_REG) = [ $cr0 $cr1 $cr2 $cr3 $cr4 $cr5 $cr6 $cr7 $cr8 $cr9 $cr10 $cr11 $cr12 $cr13 $cr14 $cr15 ]
AllocationOrder(GR64_NOREX) = [ $rax $rcx $rdx $rsi $rdi $rbx $rbp ] (sub-class)
AllocationOrder(GR64_TCW64) = [ $rax $rcx $rdx $r8 $r9 $r10 $r11 ] (sub-class)
AllocationOrder(GR64_TCW64) = [ $rax $rcx $rdx $r8 $r9 $r10 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR64_TC) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR64_TC) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(FR32X) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
AllocationOrder(LOW32_ADDR_ACCESS_RBP) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d $rbp ]
Excess PSets: 
Macro fuse: SU(8) - ExitSU /  ADD32ri8 - JCC_1
  Bind SU(7) - SU(8)
SU(0):   %13:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 37
  Successors:
    SU(1): Data Latency=0 Reg=%13
  Pressure Diff      : GR8_ABCD_H_with_GR32_BSI 1    GR8_ABCD_L_with_GR32_BSI 1    GR8_NOREX 2    GR32_TC 2    GR32_BPSP_with_GR32_TC 2    GR64_NOREX 2    GR64_TCW64 2    GR32_BPSP_with_GR64_TCW64 2    GR8 2    GR8_with_GR32_DIBP 2    GR8_with_GR32_BSI 2    GR64_TC_with_GR64_TCW64 2    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit 2    GR8_with_GR64_NOREX 2    GR64_TC 2    GR8_with_GR64_TCW64 2
  Single Issue       : false;
SU(1):   %17:fr64 = CVTSI2SDrr %13:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 37
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Successors:
    SU(2): Data Latency=4 Reg=%17
    SU(2): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(2):   %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 22
  Depth              : 4
  Height             : 33
  Predecessors:
    SU(1): Data Latency=4 Reg=%17
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=22 Reg=%17
    SU(4): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 11
  Successors:
    SU(5): Data Latency=5 Reg=%16
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 26
  Height             : 11
  Predecessors:
    SU(2): Data Latency=22 Reg=%17
    SU(2): Out  Latency=0
  Successors:
    SU(5): Data Latency=5 Reg=%17
    SU(5): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 31
  Height             : 6
  Predecessors:
    SU(4): Data Latency=5 Reg=%17
    SU(4): Out  Latency=0
    SU(3): Data Latency=5 Reg=%16
  Successors:
    SU(6): Data Latency=3 Reg=%17
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(6):   nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 2
  Depth              : 34
  Height             : 3
  Predecessors:
    SU(5): Data Latency=3 Reg=%17
  Successors:
    SU(8): Out  Latency=0
    SU(7): Out  Latency=0
    SU(7): Data Latency=2 Reg=$eflags
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(7):   %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 2
  Depth              : 36
  Height             : 1
  Predecessors:
    SU(6): Out  Latency=0
    SU(6): Data Latency=2 Reg=$eflags
  Successors:
    SU(8): Out  Latency=0
    SU(8): Anti Latency=0
    ExitSU: Ord  Latency=1 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  # preds left       : 3
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 36
  Height             : 0
  Predecessors:
    SU(7): Out  Latency=0
    SU(7): Anti Latency=0
    SU(6): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   JCC_1 %bb.1, 5, implicit killed $eflags
  # preds left       : 2
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 37
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=0 Artificial
    SU(7): Ord  Latency=1 Artificial
    SU(8): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 37
Cyclic Path: SU(8) -> SU(8) = 1c
Cyclic Path: SU(7) -> SU(7) = 2c
Cyclic Critical Path: 2c
IssueCycles=2c IterCycles=2c NumIters=14 InFlight=148m BufferLim=168m
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) %23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  LiveReg: %23
  UpdateRegP: SU(8) %23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
              to GR16 -2
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A TopLatency SU(8) 36c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  LiveReg: %6
  UpdateRegP: SU(7) %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
              to GR16 -2
  Ready @1c
  SBPort05 +1x6u
  *** Critical resource SBPort05: 0c
  SBPort015 +2x4u
  *** Critical resource SBPort015: 1c
  SBPortAny +2x2u
  BotQ.A BotLatency SU(7) 1c
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
  SU(6) uops=2
** ScheduleDAGMILive::schedule picking next node
Cycle: 1 BotQ.A
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
Bottom Pressure:
FR32=3
FR32X=3
GR16=4
  LiveReg: %17
  UpdateRegP: SU(6) nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
              to 
  Ready @3c
  SBPort0 +1x12u
  SBPort1 +1x12u
  SBPort01 +2x6u
  SBPort05 +1x6u
  SBPort15 +1x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(6) 3c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 SBPort015
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %17
  UpdateRegP: SU(5) %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
              to 
  LiveReg: %16
  UpdateRegP: SU(5) %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @6c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 2c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(5) 6c
BotQ.A @1c
  Retired: 6
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %17
  UpdateRegP: SU(4) %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @11c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  *** Critical resource SBPort015: 2c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(4) 11c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 7
  Executed: 2c
  Critical: 2c, 7 SBPort015
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %16
  UpdateRegP: SU(3) %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @11c
  SBPort0 +1x12u
  *** Critical resource SBPort0: 3c
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @2c
  Retired: 8
  Executed: 3c
  Critical: 3c, 3 SBPort0
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %17
  UpdateRegP: SU(2) %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @33c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 33c
BotQ.A @2c
  Retired: 9
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 33c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %17:fr64 = CVTSI2SDrr %13:gr32
Bottom Pressure:
FR32=3
FR32X=3
GR16=6
  LiveReg: %13
  UpdateRegP: SU(1) %17:fr64 = CVTSI2SDrr %13:gr32
              to FR32 -1    FR32X -1
  Ready @37c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(1) 37c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 11
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 37c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %13:gr32 = COPY killed $eax
Bottom Pressure:
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
FR32=3
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP_with_GR64_TCW64=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=3
GR16=6
  Ready @37c
BotQ.A @3c
  Retired: 11
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 37c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   %13:gr32 = COPY killed $eax
SU(1):   %17:fr64 = CVTSI2SDrr %13:gr32
SU(2):   %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
SU(3):   %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
SU(4):   %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
SU(5):   %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
SU(6):   nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
SU(7):   %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
SU(8):   %23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags

********** MI Scheduling **********
_Z5solvev:%bb.1 for.body
  From: %9:gr32 = COPY killed $eax
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %9:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 25
  Successors:
    SU(1): Data Latency=0 Reg=%9
  Single Issue       : false;
SU(1):   %16:fr64 = CVTSI2SDrr %9:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 25
  Predecessors:
    SU(0): Data Latency=0 Reg=%9
  Successors:
    SU(2): Data Latency=4 Reg=%16
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 22
  Depth              : 4
  Height             : 21
  Predecessors:
    SU(1): Data Latency=4 Reg=%16
    SU(1): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=21 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 25
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=21 Artificial
Critical Path(GS-RR ): 25
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  Ready @21c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(2) 4c
  BotQ.A BotLatency SU(2) 21c
BotQ.A @0c
  Retired: 1
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 21c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %16:fr64 = CVTSI2SDrr %9:gr32
  Ready @25c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(1) 25c
BotQ.A @0c
  Retired: 3
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 25c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %9:gr32 = COPY killed $eax
  Ready @25c
BotQ.A @0c
  Retired: 3
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 25c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   %9:gr32 = COPY killed $eax
SU(1):   %16:fr64 = CVTSI2SDrr %9:gr32
SU(2):   %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr

********** MI Scheduling **********
_Z5solvev:%bb.2 for.end
  From: %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
    To: RET 0, killed $xmm0
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 34
  Successors:
    SU(1): Data Latency=0 Reg=%22
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 28
  Depth              : 0
  Height             : 34
  Predecessors:
    SU(0): Data Latency=0 Reg=%22
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=23 Reg=%22
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 11
  Depth              : 23
  Height             : 11
  Predecessors:
    SU(1): Data Latency=23 Reg=%22
    SU(1): Out  Latency=0
  Successors:
    SU(3): Data Latency=11 Reg=%22
  Single Issue       : false;
SU(3):   $xmm0 = COPY %22:fr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 34
  Height             : 0
  Predecessors:
    SU(2): Data Latency=11 Reg=%22
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   RET 0, killed $xmm0
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 34
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 34
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) $xmm0 = COPY %22:fr64
  Ready @0c
  BotQ.A TopLatency SU(3) 34c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  Ready @11c
  SBPort0 +1x12u
  *** Critical resource SBPort0: 1c
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort23 +1x6u
  SBPort015 +1x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(2) 11c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort0
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  Ready @34c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort23 +1x6u
  SBPort015 +1x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(1) 34c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 34c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
  Ready @34c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
BotQ.A @1c
  Retired: 6
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 34c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
SU(1):   %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
SU(2):   %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
SU(3):   $xmm0 = COPY %22:fr64

********** INTERVALS **********
%6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:0.000000e+00
%7 [112r,160r:0)  0@112r weight:0.000000e+00
%9 [384r,400r:0)  0@384r weight:0.000000e+00
%11 [224r,800B:0)  0@224r weight:0.000000e+00
%13 [496r,512r:0)  0@496r weight:0.000000e+00
%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:0.000000e+00
%17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:0.000000e+00
%19 [240r,800B:0)  0@240r weight:0.000000e+00
%22 [816r,848r:2)[848r,880r:0)[880r,896r:1)  0@848r 1@880r 2@816r weight:0.000000e+00
%23 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:0.000000e+00
RegMasks: 80r 176r 352r 464r
********** MACHINEINSTRS **********
# Machine code for function _Z5solvev: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
64B	  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64_with_sub_8bit = COPY killed $rax
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %7.sub_32bit:gr64_with_sub_8bit
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %23:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

288B	bb.1.for.body:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %16:fr64 = CVTSI2SDrr %9:gr32
432B	  %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %17:fr64 = CVTSI2SDrr %13:gr32
544B	  %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
640B	  %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
688B	  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
720B	  %23:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2.for.end:
	; predecessors: %bb.1

816B	  %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
848B	  %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  $xmm0 = COPY %22:fr64
912B	  RET 0, killed $xmm0

# End machine code for function _Z5solvev.


block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body]
 - 2: BB2[for.end]
loop-detection
 - loop = BB1[for.body]
compute-mass-in-loop: BB1[for.body]*
 - node: BB1[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.end]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.end]
compute-loop-scale: BB1[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body]*
 - node: BB1[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body]
 - node: BB1[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.end]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.end]
 - node: BB2[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body]: float = 32.0, scaled = 256.0, int = 255
 - BB2[for.end]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body]: float = 32.0, int = 255
 - BB2[for.end]: float = 1.0, int = 8

********** BASIC REGISTER ALLOCATION **********
********** Function: _Z5solvev
********** Compute Spill Weights **********
********** Function: _Z5solvev
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
VirtReg:9-> 0(group: GR32(0) size:15)
VirtReg:13-> 1(group: GR32(0) size:15)
AllocationOrder(FR64) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
VirtReg:22-> 2(group: FR64(1) size:16)
VirtReg:17-> 3(group: FR64(1) size:16)
VirtReg:16-> 4(group: FR64(1) size:16)
VirtReg:23-> 5(group: GR32(0) size:15)
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
AllocationOrder(GR64_with_sub_8bit) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
VirtReg:6-> 6(group: GR64_with_sub_8bit(2) size:15)
VirtReg:11-> 7(group: FR64(1) size:16)
VirtReg:19-> 8(group: FR64(1) size:16)
VirtReg:7-> 9(group: GR64_with_sub_8bit(2) size:15)
test!!! regcount = 10

selectOrSplit GR32:%9 [384r,400r:0)  0@384r weight:INF w=INF
hints: $eax
assigning %9 to $eax: AH [384r,400r:0)  0@384r AL [384r,400r:0)  0@384r HAX [384r,400r:0)  0@384r

selectOrSplit GR32:%13 [496r,512r:0)  0@496r weight:INF w=INF
hints: $eax
assigning %13 to $eax: AH [496r,512r:0)  0@496r AL [496r,512r:0)  0@496r HAX [496r,512r:0)  0@496r

selectOrSplit FR64:%22 [816r,848r:2)[848r,880r:0)[880r,896r:1)  0@848r 1@880r 2@816r weight:INF w=INF
hints: $xmm0
assigning %22 to $xmm0: XMM0 [816r,848r:2)[848r,880r:0)[880r,896r:1)  0@848r 1@880r 2@816r

selectOrSplit FR64:%17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:4.687500e-01 w=4.687500e-01
assigning %17 to $xmm0: XMM0 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r

selectOrSplit FR64:%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:2.988281e-01 w=2.988281e-01
16-> 17, 
spilling: %16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:2.988281e-01
Inline spilling FR64:%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:2.988281e-01
From original %16
Merged spilled regs: SS#0 [400r,640r:0)  0@x weight:0.000000e+00
spillAroundUses %16
	reload:   408r	%25:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
	rewrite: 432r	%25:fr64 = nofpexcept DIVSDrr %25:fr64(tied-def 0), %11:fr64, implicit $mxcsr

	spill:   440r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %25:fr64 :: (store 8 into %stack.0)
	rewrite: 400r	%26:fr64 = CVTSI2SDrr %9:gr32

	spill:   404r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %26:fr64 :: (store 8 into %stack.0)
	reload:   552r	%27:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
	rewrite: 576r	%27:fr64 = nofpexcept MULSDrr %27:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr

	spill:   584r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %27:fr64 :: (store 8 into %stack.0)
	folded:   640r	%17:fr64 = nofpexcept ADDSDrm %17:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
queuing new interval: %25 [408r,432r:1)[432r,440r:0)  0@432r 1@408r weight:INF
queuing new interval: %26 [400r,404r:0)  0@400r weight:INF
queuing new interval: %27 [552r,576r:1)[576r,584r:0)  0@576r 1@552r weight:INF

selectOrSplit FR64:%25 [408r,432r:1)[432r,440r:0)  0@432r 1@408r weight:INF w=INF
assigning %25 to $xmm0: XMM0 [408r,432r:1)[432r,440r:0)  0@432r 1@408r

selectOrSplit FR64:%26 [400r,404r:0)  0@400r weight:INF w=INF
assigning %26 to $xmm0: XMM0 [400r,404r:0)  0@400r

selectOrSplit FR64:%27 [552r,576r:1)[576r,584r:0)  0@576r 1@552r weight:INF w=INF
27-> 17, 
assigning %27 to $xmm1: XMM1 [552r,576r:1)[576r,584r:0)  0@576r 1@552r

selectOrSplit GR32:%23 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:1.941919e-01 w=1.941919e-01
23-> 9, 13, 
23-> 9, 13, 
23-> 9, 13, 
assigning %23 to $ebx: BH [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi BL [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi HBX [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi

selectOrSplit GR64_with_sub_8bit:%6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:1.632179e-01 w=1.632179e-01
6-> 9, 13, 
6-> 9, 13, 
6-> 9, 13, 
6-> 23, 
6-> 23, 
6-> 23, 
assigning %6 to $r14: R14B [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi R14BH [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi R14WH [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi

selectOrSplit FR64:%11 [224r,800B:0)  0@224r weight:3.323922e-02 w=3.323922e-02
11-> 26, 25, 17, 
11-> 27, 
spilling: %11 [224r,800B:0)  0@224r weight:3.323922e-02
Inline spilling FR64:%11 [224r,800B:0)  0@224r weight:3.323922e-02
From original %11
	folded:   432r	%25:fr64 = nofpexcept DIVSDrm %25:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	folded:   544r	%17:fr64 = nofpexcept DIVSDrm %17:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
All defs dead: dead %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 224r	dead %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.

selectOrSplit FR64:%19 [240r,800B:0)  0@240r weight:1.715814e-02 w=1.715814e-02
19-> 26, 25, 17, 
19-> 27, 
spilling: %19 [240r,800B:0)  0@240r weight:1.715814e-02
Inline spilling FR64:%19 [240r,800B:0)  0@240r weight:1.715814e-02
From original %19
	remat:  648r	%29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
	        656e	nofpexcept UCOMISDrr killed %29:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr

All defs dead: dead %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 240r	dead %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.
queuing new interval: %29 [648r,656r:0)  0@648r weight:INF

selectOrSplit FR64:%29 [648r,656r:0)  0@648r weight:INF w=INF
29-> 17, 
assigning %29 to $xmm1: XMM1 [648r,656r:0)  0@648r

selectOrSplit GR64_with_sub_8bit:%7 [112r,160r:0)  0@112r weight:4.508928e-03 w=4.508928e-03
hints: $rax $rdi
assigning %7 to $rax: AH [112r,160r:0)  0@112r AL [112r,160r:0)  0@112r HAX [112r,160r:0)  0@112r

For Slot0 and VN0:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot0 and VN2:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot0 and VN1:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 
Post alloc VirtRegMap:
********** REGISTER MAP **********
[%6 -> $r14] GR64_with_sub_8bit
[%7 -> $rax] GR64_with_sub_8bit
[%9 -> $eax] GR32
[%13 -> $eax] GR32
[%17 -> $xmm0] FR64
[%22 -> $xmm0] FR64
[%23 -> $ebx] GR32
[%25 -> $xmm0] FR64
[%26 -> $xmm0] FR64
[%27 -> $xmm1] FR64
[%29 -> $xmm1] FR64
[%16 -> fi#0] FR64


********** REWRITE VIRTUAL REGISTERS **********
********** Function: _Z5solvev
********** REGISTER MAP **********
[%6 -> $r14] GR64_with_sub_8bit
[%7 -> $rax] GR64_with_sub_8bit
[%9 -> $eax] GR32
[%13 -> $eax] GR32
[%17 -> $xmm0] FR64
[%22 -> $xmm0] FR64
[%23 -> $ebx] GR32
[%25 -> $xmm0] FR64
[%26 -> $xmm0] FR64
[%27 -> $xmm1] FR64
[%29 -> $xmm1] FR64
[%16 -> fi#0] FR64

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
64B	  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64_with_sub_8bit = COPY $rax
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY killed %7.sub_32bit:gr64_with_sub_8bit
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %23:gr32 = MOV32ri 10000000
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r14d = MOV32r0 implicit-def dead $eflags, implicit-def $r14
> dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
> CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rax
Identity copy: renamable $rax = COPY $rax
  deleted.
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $edi = COPY renamable $eax, implicit killed $rax
> CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $ebx = MOV32ri 10000000
288B	bb.1.for.body:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)
	  liveins: $ebx, $r14
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY $eax
400B	  %26:fr64 = CVTSI2SDrr killed %9:gr32
404B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %26:fr64 :: (store 8 into %stack.0)
408B	  %25:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
432B	  %25:fr64 = nofpexcept DIVSDrm killed %25:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
440B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %25:fr64 :: (store 8 into %stack.0)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY $eax
512B	  %17:fr64 = CVTSI2SDrr killed %13:gr32
544B	  %17:fr64 = nofpexcept DIVSDrm killed %17:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
552B	  %27:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
576B	  %27:fr64 = nofpexcept MULSDrr killed %27:fr64(tied-def 0), %27:fr64, implicit $mxcsr
584B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %27:fr64 :: (store 8 into %stack.0)
608B	  %17:fr64 = nofpexcept MULSDrr killed %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
640B	  %17:fr64 = nofpexcept ADDSDrm killed %17:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
648B	  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
656B	  nofpexcept UCOMISDrr killed %29:fr64, killed %17:fr64, implicit-def $eflags, implicit $mxcsr
688B	  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 killed %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
720B	  %23:gr32 = ADD32ri8 killed %23:gr32(tied-def 0), -1, implicit-def $eflags
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $eax = COPY $eax
Identity copy: renamable $eax = COPY $eax
  deleted.
> renamable $xmm0 = CVTSI2SDrr killed renamable $eax
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
> renamable $xmm0 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
> renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $eax = COPY $eax
Identity copy: renamable $eax = COPY $eax
  deleted.
> renamable $xmm0 = CVTSI2SDrr killed renamable $eax
> renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> renamable $xmm1 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
> renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm1 :: (store 8 into %stack.0)
> renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
> renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
> nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
> renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
> renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
> JCC_1 %bb.1, 5, implicit killed $eflags
> JMP_1 %bb.2
800B	bb.2.for.end:
	; predecessors: %bb.1
	  liveins: $r14
816B	  %22:fr64 = CVTSI2SDrr killed %6.sub_32bit:gr64_with_sub_8bit
848B	  %22:fr64 = nofpexcept DIVSDrm killed %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
880B	  %22:fr64 = nofpexcept MULSDrm killed %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  $xmm0 = COPY killed %22:fr64
912B	  RET 0, $xmm0
> renamable $xmm0 = CVTSI2SDrr renamable $r14d, implicit killed $r14
> renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> RET 0, $xmm0
********** Stack Slot Coloring **********
********** Function: _Z5solvev
Spill slot intervals:
SS#0 [400r,640r:0)  0@x weight:1.912500e+02

Color spill slot intervals:
Assigning fi#0 to fi#0

Spill slots after coloring:
SS#0 [400r,640r:0)  0@x weight:1.912500e+02

MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: BackwardCopyPropagateBlock for.end
MCP: ForwardCopyPropagateBlock for.end
******** Post-regalloc Machine LICM: _Z5solvev ********
***** X86 Load Value Injection (LVI) Load Hardening : _Z5solvev *****

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body]
 - 2: BB2[for.end]
loop-detection
 - loop = BB1[for.body]
compute-mass-in-loop: BB1[for.body]*
 - node: BB1[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.end]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.end]
compute-loop-scale: BB1[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body]*
 - node: BB1[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body]
 - node: BB1[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.end]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.end]
 - node: BB2[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body]: float = 32.0, scaled = 256.0, int = 255
 - BB2[for.end]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body]: float = 32.0, int = 255
 - BB2[for.end]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.1
4: %bb.0
Found roots: %bb.2 
**** Analysing _Z5solvev
Look into: 0 entry
Frame instruction: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

No Shrink wrap candidate found
alloc FI(0) at SP[-32]
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: BackwardCopyPropagateBlock for.end
MCP: ForwardCopyPropagateBlock for.end
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z5solvev
real copy:   $edi = COPY renamable $eax, implicit killed $rax
replaced by: $edi = MOV32rr $eax, implicit killed $rax

block-frequency: _Z5solvev
==========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body]
 - 2: BB2[for.end]
loop-detection
 - loop = BB1[for.body]
compute-mass-in-loop: BB1[for.body]*
 - node: BB1[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.end]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.end]
compute-loop-scale: BB1[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body]*
 - node: BB1[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body]
 - node: BB1[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.end]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.end]
 - node: BB2[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body]: float = 32.0, scaled = 256.0, int = 255
 - BB2[for.end]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z5solvev
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body]: float = 32.0, int = 255
 - BB2[for.end]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.1
4: %bb.0
Found roots: %bb.2 
Pre-computing triangle chains.
Finding best loop top for: %bb.1 ('for.body')
    final top unchanged
Finding best loop exit for: %bb.1 ('for.body')
    exiting: %bb.1 ('for.body') -> %bb.2 ('for.end') [L:0] (0.875)
    No other candidate exit blocks, using loop header
Selecting best successor for: %bb.1 ('for.body')
Finished forming chain for header block %bb.1 ('for.body')
          ... %bb.1 ('for.body')
Selecting best successor for: %bb.0 ('entry')
    Candidate: %bb.1 ('for.body'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.1 ('for.body')
Merging from %bb.0 ('entry') to %bb.1 ('for.body')
Selecting best successor for: %bb.1 ('for.body')
    Candidate: %bb.2 ('for.end'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.2 ('for.end')
Merging from %bb.1 ('for.body') to %bb.2 ('for.end')
Selecting best successor for: %bb.2 ('for.end')
Finished forming chain for header block %bb.0 ('entry')
[MBP] Function: _Z5solvev
Placing chain %bb.0 ('entry')
          ... %bb.1 ('for.body')
Updating terminators on %bb.0
          ... %bb.2 ('for.end')
Updating terminators on %bb.1
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
$eip:	0	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eiz:	0	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$es:	0	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eip:	2	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eiz:	2	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$es:	2	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eip:	4	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$eiz:	4	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$es:	4	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$k7:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm0:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm1:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$dx:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$k7:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm0:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm1:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$cl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$cs:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$dl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$dx:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$cl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$cs:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$dl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$eip:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$eiz:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$es:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$hbp:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$noreg:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$ah:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$dh:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$cl:	11	$edi = MOV32rr $eax, implicit killed $rax
$cs:	11	$edi = MOV32rr $eax, implicit killed $rax
$dl:	11	$edi = MOV32rr $eax, implicit killed $rax
$eip:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$eiz:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$es:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$hbp:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$al:	13	renamable $ebx = MOV32ri 10000000
$ax:	13	renamable $ebx = MOV32ri 10000000
$dih:	13	renamable $ebx = MOV32ri 10000000
%bb.1: incomplete
$eip:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$eiz:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$es:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$hbp:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$noreg:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$ah:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$dh:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$st5:	1	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$st5:	3	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$st5:	4	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$eip:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$eiz:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$es:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$hbp:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$noreg:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$ah:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$dh:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$st5:	7	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$st5:	8	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st6:	9	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$st6:	10	renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
$st5:	12	renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
$st5:	13	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$st6:	14	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$dx:	15	nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
$k7:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm0:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm1:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$dx:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$k7:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm0:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm1:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$al:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
$ax:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
$dih:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
$dx:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
%bb.1: all preds known
%bb.2: all preds known
$st5:	0	renamable $xmm0 = CVTSI2SDrr renamable $r14d, implicit killed $r14
$st5:	1	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st5:	2	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$eip:	3	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$eiz:	3	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$es:	3	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$dx:	3	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$al:	5	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$ax:	5	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$dih:	5	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	5	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	5	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	5	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$k7:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm0:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm1:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
%bb.1: incomplete
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
%bb.1: all preds known
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
%bb.2: all preds known
$xmm0:	renamable $xmm0 = CVTSI2SDrr renamable $r14d, implicit killed $r14
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
********** BREAK FALSE DEPENDENCIES **********
Clearance: 7, want 64: Break dependency.
Clearance: 3, want 64: Break dependency.
Clearance: 6, want 64: Break dependency.
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: _Z5solvev **********

Debug Range Extension
X86 Indirect Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : _Z5solvev *****
[SafeStack] Function: main
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %_Z5solvev.exit
Last visited node: %entry
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %_Z5solvev.exit
3: %for.body.i
4: %entry
Found roots: %_Z5solvev.exit 
---- Branch Probability Info : main ----

Computing probabilities for _Z5solvev.exit
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body.i -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for entry



=== main
Creating constant: t2: i64 = Constant<0>
Creating constant: t3: i64 = TargetConstant<0>
Creating new node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Creating new node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Creating new node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Creating new node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Creating new node: t13: i32 = truncate t12
Creating new node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Creating new node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Creating new node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Creating constant: t21: i32 = Constant<10000000>
Creating new node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Creating constant: t24: i32 = Constant<0>
Creating new node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Creating new node: t27: ch = TokenFactor t23, t26, t20
Initial selection DAG: %bb.0 'main:entry'
SelectionDAG has 28 nodes:
  t0: ch = EntryToken
  t1: i64 = GlobalAddress<i64 (i64*)* @time> 0
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
  t14: i64 = GlobalAddress<void (i32)* @srand> 0
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20



Combining: t27: ch = TokenFactor t23, t26, t20

Combining: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

Combining: t25: i32 = Register %5

Combining: t24: i32 = Constant<0>

Combining: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

Combining: t22: i32 = Register %4

Combining: t21: i32 = Constant<10000000>

Combining: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Combining: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1

Combining: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

Combining: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

Combining: t16: i32 = Register $edi

Combining: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t13: i32 = truncate t12

Combining: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

Combining: t11: i64 = Register $rax

Combining: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Combining: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Combining: t8: Untyped = RegisterMask

Combining: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

Combining: t5: i64 = Register $rdi

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: i64 = TargetConstant<0>

Combining: t2: i64 = Constant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'main:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20


Legalizing node: t25: i32 = Register %5
Ignoring node results
Legally typed node: t25: i32 = Register %5

Legalizing node: t24: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t24: i32 = Constant<0>

Legalizing node: t22: i32 = Register %4
Ignoring node results
Legally typed node: t22: i32 = Register %4

Legalizing node: t21: i32 = Constant<10000000>
Analyzing result type: i32
Legal result type
Legally typed node: t21: i32 = Constant<10000000>

Legalizing node: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Analyzing result type: i64
Legal result type
Legally typed node: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

Legalizing node: t16: i32 = Register $edi
Ignoring node results
Legally typed node: t16: i32 = Register $edi

Legalizing node: t11: i64 = Register $rax
Ignoring node results
Legally typed node: t11: i64 = Register $rax

Legalizing node: t8: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t8: Untyped = RegisterMask

Legalizing node: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

Legalizing node: t5: i64 = Register $rdi
Ignoring node results
Legally typed node: t5: i64 = Register $rdi

Legalizing node: t3: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t3: i64 = TargetConstant<0>

Legalizing node: t2: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = Constant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = Constant<0>
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

Legalizing node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal operand
Analyzing operand: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal operand
Legally typed node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Analyzing operand: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Legally typed node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Legal operand
Analyzing operand: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Legal operand
Legally typed node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

Legalizing node: t13: i32 = truncate t12
Analyzing result type: i32
Legal result type
Analyzing operand: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal operand
Legally typed node: t13: i32 = truncate t12

Legalizing node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal operand
Legally typed node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t13: i32 = truncate t12
Legal operand
Legally typed node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

Legalizing node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal operand
Analyzing operand: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Analyzing operand: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal operand
Legally typed node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1

Legalizing node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal operand
Analyzing operand: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal operand
Legally typed node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i32 = Constant<10000000>
Legal operand
Legally typed node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

Legalizing node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: i32 = Constant<0>
Legal operand
Legally typed node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

Legalizing node: t27: ch = TokenFactor t23, t26, t20
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Legal operand
Analyzing operand: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Legal operand
Analyzing operand: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Legal operand
Legally typed node: t27: ch = TokenFactor t23, t26, t20

Legalizing node: t65535: ch = handlenode t27
Analyzing result type: ch
Legal result type
Analyzing operand: t27: ch = TokenFactor t23, t26, t20
Legal operand
Legally typed node: t65535: ch = handlenode t27

Type-legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20



Legalizing: t27: ch = TokenFactor t23, t26, t20
Legal node: nothing to do

Legalizing: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal node: nothing to do

Legalizing: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal node: nothing to do

Legalizing: t13: i32 = truncate t12
Legal node: nothing to do

Legalizing: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal node: nothing to do

Legalizing: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal node: nothing to do

Legalizing: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Legal node: nothing to do

Legalizing: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Legal node: nothing to do

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t25: i32 = Register %5

Legalizing: t24: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t22: i32 = Register %4

Legalizing: t21: i32 = Constant<10000000>
Legal node: nothing to do

Legalizing: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Legal node: nothing to do

Legalizing: t16: i32 = Register $edi

Legalizing: t11: i64 = Register $rax

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Legal node: nothing to do

Legalizing: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Legalizing: t2: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20



Legalizing: t27: ch = TokenFactor t23, t26, t20
Legal node: nothing to do

Combining: t27: ch = TokenFactor t23, t26, t20

Legalizing: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Combining: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
Legal node: nothing to do

Combining: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1

Legalizing: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
Legal node: nothing to do

Combining: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

Legalizing: t13: i32 = truncate t12
Legal node: nothing to do

Combining: t13: i32 = truncate t12

Legalizing: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
Legal node: nothing to do

Combining: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

Legalizing: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Combining: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Combining: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

Legalizing: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
Legal node: nothing to do

Combining: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

Legalizing: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
Legal node: nothing to do

Combining: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t25: i32 = Register %5

Combining: t25: i32 = Register %5

Legalizing: t24: i32 = Constant<0>
Legal node: nothing to do

Combining: t24: i32 = Constant<0>

Legalizing: t22: i32 = Register %4

Combining: t22: i32 = Register %4

Legalizing: t21: i32 = Constant<10000000>
Legal node: nothing to do

Combining: t21: i32 = Constant<10000000>

Legalizing: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0
Legal node: nothing to do

Combining: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

Legalizing: t16: i32 = Register $edi

Combining: t16: i32 = Register $edi

Legalizing: t11: i64 = Register $rax

Combining: t11: i64 = Register $rax

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Combining: t8: Untyped = RegisterMask

Legalizing: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0
Legal node: nothing to do

Combining: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

Legalizing: t5: i64 = Register $rdi

Combining: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Combining: t3: i64 = TargetConstant<0>

Legalizing: t2: i64 = Constant<0>
Legal node: nothing to do

Combining: t2: i64 = Constant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 26 nodes:
  t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t13: i32 = truncate t12
  t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13
  t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
    t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>
    t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>
    t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t27: ch = TokenFactor t23, t26, t20


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t27: ch = TokenFactor t23, t26, t20

ISEL: Starting selection on root node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch,glue = X86ISD::CALL t17, TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch,glue = CopyToReg t15, Register:i32 $edi, t13

ISEL: Starting selection on root node: t13: i32 = truncate t12
ISEL: Starting pattern match
  Initial Opcode index to 123421
  Match failed at index 123424
  Continuing at 123543
  TypeSwitch[i32] from 123546 to 123581
Creating constant: t28: i32 = TargetConstant<6>
  Morphed node: t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t29: i32 = TargetConstant<0>
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i64,ch,glue = CopyFromReg t10, Register:i64 $rax, t10:1

ISEL: Starting selection on root node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, Constant:i64<0>

ISEL: Starting selection on root node: t26: ch = CopyToReg t0, Register:i32 %5, Constant:i32<0>

ISEL: Starting selection on root node: t23: ch = CopyToReg t0, Register:i32 %4, Constant:i32<10000000>

ISEL: Starting selection on root node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i32 = Register %5

ISEL: Starting selection on root node: t24: i32 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  TypeSwitch[i32] from 123997 to 124000
  Morphed node: t24: i32,i32 = MOV32r0
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i32 = Register %4

ISEL: Starting selection on root node: t21: i32 = Constant<10000000>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i32] from 124159 to 124162
  Skipped scope entry (due to false predicate) at index 124164, continuing at 124177
Creating constant: t30: i32 = TargetConstant<10000000>
  Morphed node: t21: i32 = MOV32ri TargetConstant:i32<10000000>
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i64 = TargetGlobalAddress<void (i32)* @srand> 0

ISEL: Starting selection on root node: t16: i32 = Register $edi

ISEL: Starting selection on root node: t11: i64 = Register $rax

ISEL: Starting selection on root node: t8: Untyped = RegisterMask

ISEL: Starting selection on root node: t7: i64 = TargetGlobalAddress<i64 (i64*)* @time> 0

ISEL: Starting selection on root node: t5: i64 = Register $rdi

ISEL: Starting selection on root node: t3: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t2: i64 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  TypeSwitch[i64] from 123997 to 124049
  Created node: t24: i32,i32 = MOV32r0
  Morphed node: t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'main:entry'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>
  t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2
  t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
  t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1
  t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2
    t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1
    t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>
  t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13
  t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1
      t21: i32 = MOV32ri TargetConstant:i32<10000000>
    t23: ch = CopyToReg t0, Register:i32 %4, t21
    t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32
    t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1
  t27: ch = TokenFactor t23, t26, t20:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t27: ch = TokenFactor t23, t26, t20:1

  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(9): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(5): t24: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(4): Data Latency=1
    SU(8): Data Latency=1
SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(9): Data Latency=1

Examining Available:
Height 0: SU(0): t27: ch = TokenFactor t23, t26, t20:1


*** Scheduling [0]: SU(0): t27: ch = TokenFactor t23, t26, t20:1


Examining Available:
Height 1: SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21

Height 1: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [1]: SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21


Examining Available:
Height 2: SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>

Height 1: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [2]: SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>


Examining Available:
Height 1: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [3]: SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32


Examining Available:
Height 1: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


*** Scheduling [4]: SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1


Examining Available:
Height 5: SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

Height 5: SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>


*** Scheduling [5]: SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1


Examining Available:
Height 5: SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>


*** Scheduling [6]: SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>


Examining Available:
Height 7: SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1


*** Scheduling [7]: SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1


Examining Available:
Height 8: SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

Height 8: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [8]: SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>


Examining Available:
Height 9: SU(5): t24: i32,i32 = MOV32r0

Height 8: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [9]: SU(5): t24: i32,i32 = MOV32r0


Examining Available:
Height 8: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [10]: SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(6): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(5): t24: i32,i32 = MOV32r0

SU(4): t2: i64 = SUBREG_TO_REG TargetConstant:i64<0>, MOV32r0:i32,i32, TargetConstant:i32<6>

SU(3): t12: i64,ch,glue = CopyFromReg t10:1, Register:i64 $rax, t10:2

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t2

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i64 (i64*)* @time> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

SU(2): t13: i32 = EXTRACT_SUBREG t12, TargetConstant:i32<6>

SU(7): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

SU(1): t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

    t17: ch,glue = CopyToReg t15:1, Register:i32 $edi, t13

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32)* @srand> 0, Register:i32 $edi, RegisterMask:Untyped, t17, t17:1

SU(8): t26: ch = CopyToReg t0, Register:i32 %5, MOV32r0:i32,i32

SU(10): t21: i32 = MOV32ri TargetConstant:i32<10000000>

SU(9): t23: ch = CopyToReg t0, Register:i32 %4, t21

SU(0): t27: ch = TokenFactor t23, t26, t20:1


Total amount of phi nodes to update: 2
Node 0 : (0xfdbfdf8, 2147483652)
Node 1 : (0xfdbfe60, 2147483653)
Creating constant: t2: i64 = TargetConstant<0>
Creating new node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Creating new node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Creating new node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Creating new node: t10: f64 = sint_to_fp t9
Creating fp constant: t11: f64 = ConstantFP<2.147484e+09>
Creating new node: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Creating new node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Creating new node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Creating new node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Creating new node: t17: f64 = sint_to_fp t16
Creating new node: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Creating new node: t19: f64 = fmul t12, t12
Creating new node: t20: f64 = fmul t18, t18
Creating new node: t21: f64 = fadd t19, t20
Creating fp constant: t22: f64 = ConstantFP<1.000000e+00>
Creating new node: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Creating new node: t25: i32 = zero_extend t24
Creating new node: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Creating new node: t28: i32 = add nuw nsw t27, t25
Creating new node: t30: ch = CopyToReg t0, Register:i32 %2, t28
Creating new node: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Creating constant: t33: i32 = Constant<-1>
Creating new node: t34: i32 = add nsw t32, Constant:i32<-1>
Creating new node: t36: ch = CopyToReg t0, Register:i32 %3, t34
Creating constant: t37: i32 = Constant<0>
Creating new node: t39: i1 = setcc t34, Constant:i32<0>, seteq:ch
Creating constant: t40: i1 = Constant<-1>
Creating new node: t41: i1 = xor t39, Constant:i1<-1>
Creating new node: t42: ch = TokenFactor t30, t36, t16:1
Creating new node: t44: ch = brcond t42, t41, BasicBlock:ch<for.body.i 0xfdbfd20>
Creating new node: t46: ch = br t44, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>
Initial selection DAG: %bb.1 'main:for.body.i'
SelectionDAG has 47 nodes:
  t0: ch = EntryToken
  t1: i64 = GlobalAddress<i32 ()* @rand> 0
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                  t19: f64 = fmul t12, t12
                  t20: f64 = fmul t18, t18
                t21: f64 = fadd t19, t20
              t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
            t25: i32 = zero_extend t24
          t28: i32 = add nuw nsw t27, t25
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
        t39: i1 = setcc t34, Constant:i32<0>, seteq:ch
      t41: i1 = xor t39, Constant:i1<-1>
    t44: ch = brcond t42, t41, BasicBlock:ch<for.body.i 0xfdbfd20>
  t46: ch = br t44, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>



Combining: t46: ch = br t44, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>

Combining: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>

Combining: t44: ch = brcond t42, t41, BasicBlock:ch<for.body.i 0xfdbfd20>
Creating new node: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Creating new node: t49: ch = brcond t42, t48, BasicBlock:ch<for.body.i 0xfdbfd20>
 ... into: t49: ch = brcond t42, t48, BasicBlock:ch<for.body.i 0xfdbfd20>

Combining: t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>

Combining: t49: ch = brcond t42, t48, BasicBlock:ch<for.body.i 0xfdbfd20>

Combining: t48: i1 = setcc t34, Constant:i32<0>, setne:ch

Combining: t47: ch = setne

Combining: t43: ch = BasicBlock<for.body.i 0xfdbfd20>

Combining: t42: ch = TokenFactor t30, t36, t16:1

Combining: t37: i32 = Constant<0>

Combining: t36: ch = CopyToReg t0, Register:i32 %3, t34

Combining: t35: i32 = Register %3

Combining: t34: i32 = add nsw t32, Constant:i32<-1>

Combining: t33: i32 = Constant<-1>

Combining: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t31: i32 = Register %0

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t28

Combining: t29: i32 = Register %2

Combining: t28: i32 = add nuw nsw t27, t25

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t26: i32 = Register %1

Combining: t25: i32 = zero_extend t24
Creating constant: t50: i1 = Constant<-1>
Creating constant: t51: i1 = Constant<0>

Combining: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Combining: t23: ch = setole

Combining: t22: f64 = ConstantFP<1.000000e+00>

Combining: t21: f64 = fadd t19, t20

Combining: t20: f64 = fmul t18, t18

Combining: t19: f64 = fmul t12, t12

Combining: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Creating fp constant: t52: f64 = ConstantFP<-2.147484e+09>

Combining: t17: f64 = sint_to_fp t16

Combining: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Creating fp constant: t53: f64 = ConstantFP<-2.147484e+09>

Combining: t11: f64 = ConstantFP<2.147484e+09>

Combining: t10: f64 = sint_to_fp t9

Combining: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Combining: t8: i32 = Register $eax

Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t5: Untyped = RegisterMask

Combining: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t2: i64 = TargetConstant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 'main:for.body.i'
SelectionDAG has 44 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                  t19: f64 = fmul t12, t12
                  t20: f64 = fmul t18, t18
                t21: f64 = fadd t19, t20
              t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
            t25: i32 = zero_extend t24
          t28: i32 = add nuw nsw t27, t25
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
      t48: i1 = setcc t34, Constant:i32<0>, setne:ch
    t49: ch = brcond t42, t48, BasicBlock:ch<for.body.i 0xfdbfd20>
  t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>


Legalizing node: t47: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t47: ch = setne

Legalizing node: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>
Analyzing result type: ch
Legal result type
Legally typed node: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>

Legalizing node: t43: ch = BasicBlock<for.body.i 0xfdbfd20>
Analyzing result type: ch
Legal result type
Legally typed node: t43: ch = BasicBlock<for.body.i 0xfdbfd20>

Legalizing node: t37: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t37: i32 = Constant<0>

Legalizing node: t35: i32 = Register %3
Ignoring node results
Legally typed node: t35: i32 = Register %3

Legalizing node: t33: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t33: i32 = Constant<-1>

Legalizing node: t31: i32 = Register %0
Ignoring node results
Legally typed node: t31: i32 = Register %0

Legalizing node: t29: i32 = Register %2
Ignoring node results
Legally typed node: t29: i32 = Register %2

Legalizing node: t26: i32 = Register %1
Ignoring node results
Legally typed node: t26: i32 = Register %1

Legalizing node: t23: ch = setole
Analyzing result type: ch
Legal result type
Legally typed node: t23: ch = setole

Legalizing node: t22: f64 = ConstantFP<1.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t22: f64 = ConstantFP<1.000000e+00>

Legalizing node: t11: f64 = ConstantFP<2.147484e+09>
Analyzing result type: f64
Legal result type
Legally typed node: t11: f64 = ConstantFP<2.147484e+09>

Legalizing node: t8: i32 = Register $eax
Ignoring node results
Legally typed node: t8: i32 = Register $eax

Legalizing node: t5: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t5: Untyped = RegisterMask

Legalizing node: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Analyzing result type: i64
Legal result type
Legally typed node: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Legalizing node: t2: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t2: i64 = TargetConstant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal operand
Analyzing operand: t5: Untyped = RegisterMask
Legal operand
Legally typed node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Legal operand
Analyzing operand: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Legal operand
Legally typed node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Legalizing node: t10: f64 = sint_to_fp t9
Analyzing result type: f64
Legal result type
Analyzing operand: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal operand
Legally typed node: t10: f64 = sint_to_fp t9

Legalizing node: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Analyzing result type: f64
Legal result type
Analyzing operand: t10: f64 = sint_to_fp t9
Legal operand
Analyzing operand: t11: f64 = ConstantFP<2.147484e+09>
Legal operand
Legally typed node: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>

Legalizing node: t19: f64 = fmul t12, t12
Analyzing result type: f64
Legal result type
Analyzing operand: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Legal operand
Analyzing operand: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Legal operand
Legally typed node: t19: f64 = fmul t12, t12

Legalizing node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal operand
Legally typed node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal operand
Analyzing operand: t5: Untyped = RegisterMask
Legal operand
Legally typed node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Analyzing operand: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
Legal operand
Legally typed node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Legalizing node: t17: f64 = sint_to_fp t16
Analyzing result type: f64
Legal result type
Analyzing operand: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal operand
Legally typed node: t17: f64 = sint_to_fp t16

Legalizing node: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Analyzing result type: f64
Legal result type
Analyzing operand: t17: f64 = sint_to_fp t16
Legal operand
Analyzing operand: t11: f64 = ConstantFP<2.147484e+09>
Legal operand
Legally typed node: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>

Legalizing node: t20: f64 = fmul t18, t18
Analyzing result type: f64
Legal result type
Analyzing operand: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Legal operand
Analyzing operand: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Legal operand
Legally typed node: t20: f64 = fmul t18, t18

Legalizing node: t21: f64 = fadd t19, t20
Analyzing result type: f64
Legal result type
Analyzing operand: t19: f64 = fmul t12, t12
Legal operand
Analyzing operand: t20: f64 = fmul t18, t18
Legal operand
Legally typed node: t21: f64 = fadd t19, t20

Legalizing node: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Analyzing result type: i1
Promote integer result: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Creating new node: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Legalizing node: t25: i32 = zero_extend t24
Analyzing result type: i32
Legal result type
Analyzing operand: t24: i1 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Promote integer operand: t25: i32 = zero_extend t24

Creating new node: t55: i32 = any_extend t54
Creating constant: t56: i32 = Constant<1>
Creating new node: t57: i32 = and t55, Constant:i32<1>
Replacing: t25: i32 = zero_extend t24
     with: t57: i32 = and t55, Constant:i32<1>
Legalizing node: t56: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t56: i32 = Constant<1>

Legalizing node: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t21: f64 = fadd t19, t20
Legal operand
Analyzing operand: t22: f64 = ConstantFP<1.000000e+00>
Legal operand
Analyzing operand: t23: ch = setole
Legal operand
Legally typed node: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Legalizing node: t55: i32 = any_extend t54
Analyzing result type: i32
Legal result type
Analyzing operand: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Legal operand
Legally typed node: t55: i32 = any_extend t54

Legalizing node: t57: i32 = and t55, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t55: i32 = any_extend t54
Legal operand
Analyzing operand: t56: i32 = Constant<1>
Legal operand
Legally typed node: t57: i32 = and t55, Constant:i32<1>

Legalizing node: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing node: t28: i32 = add nuw nsw t27, t57
Analyzing result type: i32
Legal result type
Analyzing operand: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Legal operand
Analyzing operand: t57: i32 = and t55, Constant:i32<1>
Legal operand
Legally typed node: t28: i32 = add nuw nsw t27, t57

Legalizing node: t30: ch = CopyToReg t0, Register:i32 %2, t28
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t28: i32 = add nuw nsw t27, t57
Legal operand
Legally typed node: t30: ch = CopyToReg t0, Register:i32 %2, t28

Legalizing node: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t34: i32 = add nsw t32, Constant:i32<-1>
Analyzing result type: i32
Legal result type
Analyzing operand: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t33: i32 = Constant<-1>
Legal operand
Legally typed node: t34: i32 = add nsw t32, Constant:i32<-1>

Legalizing node: t36: ch = CopyToReg t0, Register:i32 %3, t34
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t34: i32 = add nsw t32, Constant:i32<-1>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:i32 %3, t34

Legalizing node: t42: ch = TokenFactor t30, t36, t16:1
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = CopyToReg t0, Register:i32 %2, t28
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:i32 %3, t34
Legal operand
Analyzing operand: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal operand
Legally typed node: t42: ch = TokenFactor t30, t36, t16:1

Legalizing node: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Analyzing result type: i1
Promote integer result: t48: i1 = setcc t34, Constant:i32<0>, setne:ch

Creating new node: t58: i8 = setcc t34, Constant:i32<0>, setne:ch
Legalizing node: t49: ch = brcond t42, t48, BasicBlock:ch<for.body.i 0xfdbfd20>
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = TokenFactor t30, t36, t16:1
Legal operand
Analyzing operand: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Promote integer operand: t49: ch = brcond t42, t48, BasicBlock:ch<for.body.i 0xfdbfd20>

Creating new node: t59: i8 = zero_extend t48
Legalizing node: t59: i8 = zero_extend t48
Analyzing result type: i8
Legal result type
Analyzing operand: t48: i1 = setcc t34, Constant:i32<0>, setne:ch
Promote integer operand: t59: i8 = zero_extend t48

Creating constant: t60: i8 = Constant<1>
Creating new node: t61: i8 = and t58, Constant:i8<1>
Replacing: t59: i8 = zero_extend t48
     with: t61: i8 = and t58, Constant:i8<1>
Legalizing node: t60: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t60: i8 = Constant<1>

Legalizing node: t58: i8 = setcc t34, Constant:i32<0>, setne:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t34: i32 = add nsw t32, Constant:i32<-1>
Legal operand
Analyzing operand: t37: i32 = Constant<0>
Legal operand
Analyzing operand: t47: ch = setne
Legal operand
Legally typed node: t58: i8 = setcc t34, Constant:i32<0>, setne:ch

Legalizing node: t61: i8 = and t58, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t58: i8 = setcc t34, Constant:i32<0>, setne:ch
Legal operand
Analyzing operand: t60: i8 = Constant<1>
Legal operand
Legally typed node: t61: i8 = and t58, Constant:i8<1>

Legalizing node: t49: ch = brcond t42, t61, BasicBlock:ch<for.body.i 0xfdbfd20>
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = TokenFactor t30, t36, t16:1
Legal operand
Analyzing operand: t61: i8 = and t58, Constant:i8<1>
Legal operand
Analyzing operand: t43: ch = BasicBlock<for.body.i 0xfdbfd20>
Legal operand
Legally typed node: t49: ch = brcond t42, t61, BasicBlock:ch<for.body.i 0xfdbfd20>

Legalizing node: t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>
Analyzing result type: ch
Legal result type
Analyzing operand: t49: ch = brcond t42, t61, BasicBlock:ch<for.body.i 0xfdbfd20>
Legal operand
Analyzing operand: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>
Legal operand
Legally typed node: t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>

Legalizing node: t65535: ch = handlenode t46
Analyzing result type: ch
Legal result type
Analyzing operand: t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>
Legal operand
Legally typed node: t65535: ch = handlenode t46

Type-legalized selection DAG: %bb.1 'main:for.body.i'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                    t19: f64 = fmul t12, t12
                    t20: f64 = fmul t18, t18
                  t21: f64 = fadd t19, t20
                t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
              t55: i32 = any_extend t54
            t57: i32 = and t55, Constant:i32<1>
          t28: i32 = add nuw nsw t27, t57
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
        t58: i8 = setcc t34, Constant:i32<0>, setne:ch
      t61: i8 = and t58, Constant:i8<1>
    t49: ch = brcond t42, t61, BasicBlock:ch<for.body.i 0xfdbfd20>
  t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>



Combining: t61: i8 = and t58, Constant:i8<1>

Replacing.2 t61: i8 = and t58, Constant:i8<1>

With: t58: i8 = setcc t34, Constant:i32<0>, setne:ch


Combining: t58: i8 = setcc t34, Constant:i32<0>, setne:ch

Combining: t57: i32 = and t55, Constant:i32<1>
Creating new node: t62: i32 = zero_extend t54

Replacing.1 t57: i32 = and t55, Constant:i32<1>

With: t62: i32 = zero_extend t54
 and 0 other values

Replacing.1 t55: i32 = any_extend t54

With: t62: i32 = zero_extend t54
 and 0 other values

Combining: t62: i32 = zero_extend t54
Creating constant: t63: i8 = Constant<1>
Creating constant: t64: i8 = Constant<0>

Combining: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch

Combining: t49: ch = brcond t42, t58, BasicBlock:ch<for.body.i 0xfdbfd20>

Combining: t47: ch = setne

Combining: t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>

Combining: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>

Combining: t43: ch = BasicBlock<for.body.i 0xfdbfd20>

Combining: t42: ch = TokenFactor t30, t36, t16:1

Combining: t37: i32 = Constant<0>

Combining: t36: ch = CopyToReg t0, Register:i32 %3, t34

Combining: t35: i32 = Register %3

Combining: t34: i32 = add nsw t32, Constant:i32<-1>

Combining: t33: i32 = Constant<-1>

Combining: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t31: i32 = Register %0

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t28

Combining: t29: i32 = Register %2

Combining: t28: i32 = add nuw nsw t27, t62

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t26: i32 = Register %1

Combining: t23: ch = setole

Combining: t22: f64 = ConstantFP<1.000000e+00>

Combining: t21: f64 = fadd t19, t20

Combining: t20: f64 = fmul t18, t18

Combining: t19: f64 = fmul t12, t12

Combining: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Creating fp constant: t65: f64 = ConstantFP<-2.147484e+09>

Combining: t17: f64 = sint_to_fp t16

Combining: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Creating fp constant: t66: f64 = ConstantFP<-2.147484e+09>

Combining: t11: f64 = ConstantFP<2.147484e+09>

Combining: t10: f64 = sint_to_fp t9

Combining: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Combining: t8: i32 = Register $eax

Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Combining: t5: Untyped = RegisterMask

Combining: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t2: i64 = TargetConstant<0>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.1 'main:for.body.i'
SelectionDAG has 44 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t34: i32 = add nsw t32, Constant:i32<-1>
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                  t19: f64 = fmul t12, t12
                  t20: f64 = fmul t18, t18
                t21: f64 = fadd t19, t20
              t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
            t62: i32 = zero_extend t54
          t28: i32 = add nuw nsw t27, t62
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t34
      t42: ch = TokenFactor t30, t36, t16:1
      t58: i8 = setcc t34, Constant:i32<0>, setne:ch
    t49: ch = brcond t42, t58, BasicBlock:ch<for.body.i 0xfdbfd20>
  t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>



Legalizing: t46: ch = br t49, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>
Legal node: nothing to do

Legalizing: t49: ch = brcond t42, t58, BasicBlock:ch<for.body.i 0xfdbfd20>
Trying custom legalization
Creating new node: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
Creating constant: t68: i8 = TargetConstant<5>
Creating new node: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1
Successfully custom legalized node
 ... replacing: t49: ch = brcond t42, t58, BasicBlock:ch<for.body.i 0xfdbfd20>
     with:      t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1

Legalizing: t42: ch = TokenFactor t30, t36, t16:1
Legal node: nothing to do

Legalizing: t30: ch = CopyToReg t0, Register:i32 %2, t28
Legal node: nothing to do

Legalizing: t28: i32 = add nuw nsw t27, t62
Legal node: nothing to do

Legalizing: t62: i32 = zero_extend t54
Legal node: nothing to do

Legalizing: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
Trying custom legalization
Creating new node: t70: i32 = X86ISD::FCMP ConstantFP:f64<1.000000e+00>, t21
Creating constant: t71: i8 = TargetConstant<3>
Creating new node: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
Successfully custom legalized node
 ... replacing: t54: i8 = setcc t21, ConstantFP:f64<1.000000e+00>, setole:ch
     with:      t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70

Legalizing: t21: f64 = fadd t19, t20
Trying custom legalization

Legalizing: t20: f64 = fmul t18, t18
Legal node: nothing to do

Legalizing: t18: f64 = fdiv t17, ConstantFP:f64<2.147484e+09>
Legal node: nothing to do

Legalizing: t17: f64 = sint_to_fp t16
Trying custom legalization

Legalizing: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal node: nothing to do

Legalizing: t19: f64 = fmul t12, t12
Legal node: nothing to do

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t12: f64 = fdiv t10, ConstantFP:f64<2.147484e+09>
Legal node: nothing to do

Legalizing: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t10: f64 = sint_to_fp t9
Trying custom legalization

Legalizing: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:i32 %3, t67
Legal node: nothing to do

Legalizing: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Legalizing: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>
Legal node: nothing to do

Legalizing: t43: ch = BasicBlock<for.body.i 0xfdbfd20>
Legal node: nothing to do

Legalizing: t35: i32 = Register %3

Legalizing: t33: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t31: i32 = Register %0

Legalizing: t29: i32 = Register %2

Legalizing: t26: i32 = Register %1

Legalizing: t22: f64 = ConstantFP<1.000000e+00>
Trying to expand node
Creating new constant pool: t73: i64 = ConstantPool<double 1.000000e+00> 0
Creating new node: t74: i64 = undef
Creating new node: t75: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t22: f64 = ConstantFP<1.000000e+00>
     with:      t75: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64

Legalizing: t11: f64 = ConstantFP<2.147484e+09>
Trying to expand node
Creating new constant pool: t76: i64 = ConstantPool<double 0x41DFFFFFFFC00000> 0
Creating new node: t77: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 0x41DFFFFFFFC00000> 0, undef:i64
Successfully expanded node
 ... replacing: t11: f64 = ConstantFP<2.147484e+09>
     with:      t77: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 0x41DFFFFFFFC00000> 0, undef:i64

Legalizing: t8: i32 = Register $eax

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal node: nothing to do

Legalizing: t2: i64 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t77: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 0x41DFFFFFFFC00000> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t76: i64 = ConstantPool<double 0x41DFFFFFFFC00000> 0
Trying custom legalization
Creating new constant pool: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
Creating new node: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
Successfully custom legalized node
 ... replacing: t76: i64 = ConstantPool<double 0x41DFFFFFFFC00000> 0
     with:      t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0

Legalizing: t75: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t74: i64 = undef
Legal node: nothing to do

Legalizing: t73: i64 = ConstantPool<double 1.000000e+00> 0
Trying custom legalization
Creating new constant pool: t80: i64 = TargetConstantPool<double 1.000000e+00> 0
Creating new node: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Successfully custom legalized node
 ... replacing: t73: i64 = ConstantPool<double 1.000000e+00> 0
     with:      t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
Legal node: nothing to do

Legalizing: t71: i8 = TargetConstant<3>

Legalizing: t70: i32 = X86ISD::FCMP t75, t21
Legal node: nothing to do

Legalizing: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1
Legal node: nothing to do

Legalizing: t68: i8 = TargetConstant<5>

Legalizing: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
Legal node: nothing to do

Legalizing: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Legalizing: t80: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do

Legalizing: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do

Legalizing: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do
Legalized selection DAG: %bb.1 'main:for.body.i'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, t77
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, t77
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
    t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
  t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                    t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
                  t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
                    t19: f64 = fmul t12, t12
                    t20: f64 = fmul t18, t18
                  t21: f64 = fadd t19, t20
                t70: i32 = X86ISD::FCMP t75, t21
              t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
            t62: i32 = zero_extend t72
          t28: i32 = add nuw nsw t27, t62
        t30: ch = CopyToReg t0, Register:i32 %2, t28
        t36: ch = CopyToReg t0, Register:i32 %3, t67
      t42: ch = TokenFactor t30, t36, t16:1
    t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1
  t46: ch = br t69, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>



Legalizing: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t80: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t80: i64 = TargetConstantPool<double 1.000000e+00> 0

Legalizing: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do

Combining: t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0

Legalizing: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
Legal node: nothing to do

Combining: t78: i64 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0

Legalizing: t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
Legalizing non-extending load operation

Combining: t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64

Legalizing: t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
Legalizing non-extending load operation

Combining: t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64

Legalizing: t74: i64 = undef
Legal node: nothing to do

Combining: t74: i64 = undef

Legalizing: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70
Legal node: nothing to do

Combining: t72: i8 = X86ISD::SETCC TargetConstant:i8<3>, t70

Legalizing: t71: i8 = TargetConstant<3>

Combining: t71: i8 = TargetConstant<3>

Legalizing: t70: i32 = X86ISD::FCMP t75, t21
Legal node: nothing to do

Combining: t70: i32 = X86ISD::FCMP t75, t21

Legalizing: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1
Legal node: nothing to do

Combining: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1

Legalizing: t68: i8 = TargetConstant<5>

Combining: t68: i8 = TargetConstant<5>

Legalizing: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
Legal node: nothing to do

Combining: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>

Legalizing: t46: ch = br t69, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>
Legal node: nothing to do

Combining: t46: ch = br t69, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>

Legalizing: t42: ch = TokenFactor t30, t36, t16:1
Legal node: nothing to do

Combining: t42: ch = TokenFactor t30, t36, t16:1

Legalizing: t30: ch = CopyToReg t0, Register:i32 %2, t28
Legal node: nothing to do

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t28

Legalizing: t28: i32 = add nuw nsw t27, t62
Legal node: nothing to do

Combining: t28: i32 = add nuw nsw t27, t62
Creating new node: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
 ... into: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70

Legalizing: t70: i32 = X86ISD::FCMP t75, t21
Legal node: nothing to do

Combining: t70: i32 = X86ISD::FCMP t75, t21

Legalizing: t30: ch = CopyToReg t0, Register:i32 %2, t82
Legal node: nothing to do

Combining: t30: ch = CopyToReg t0, Register:i32 %2, t82

Legalizing: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
Legal node: nothing to do

Combining: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70

Legalizing: t21: f64 = fadd t19, t20
Trying custom legalization

Combining: t21: f64 = fadd t19, t20

Legalizing: t20: f64 = fmul t18, t18
Legal node: nothing to do

Combining: t20: f64 = fmul t18, t18

Legalizing: t18: f64 = fdiv t17, t77
Legal node: nothing to do

Combining: t18: f64 = fdiv t17, t77

Legalizing: t17: f64 = sint_to_fp t16
Trying custom legalization

Combining: t17: f64 = sint_to_fp t16

Legalizing: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
Legal node: nothing to do

Combining: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

Legalizing: t19: f64 = fmul t12, t12
Legal node: nothing to do

Combining: t19: f64 = fmul t12, t12

Legalizing: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Combining: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1

Legalizing: t12: f64 = fdiv t10, t77
Legal node: nothing to do

Combining: t12: f64 = fdiv t10, t77

Legalizing: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing: t10: f64 = sint_to_fp t9
Trying custom legalization

Combining: t10: f64 = sint_to_fp t9

Legalizing: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
Legal node: nothing to do

Combining: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

Legalizing: t36: ch = CopyToReg t0, Register:i32 %3, t67
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:i32 %3, t67

Legalizing: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped

Legalizing: t32: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t32: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t27: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>
Legal node: nothing to do

Combining: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>

Legalizing: t43: ch = BasicBlock<for.body.i 0xfdbfd20>
Legal node: nothing to do

Combining: t43: ch = BasicBlock<for.body.i 0xfdbfd20>

Legalizing: t35: i32 = Register %3

Combining: t35: i32 = Register %3

Legalizing: t33: i32 = Constant<-1>
Legal node: nothing to do

Combining: t33: i32 = Constant<-1>

Legalizing: t31: i32 = Register %0

Combining: t31: i32 = Register %0

Legalizing: t29: i32 = Register %2

Combining: t29: i32 = Register %2

Legalizing: t26: i32 = Register %1

Combining: t26: i32 = Register %1

Legalizing: t8: i32 = Register $eax

Combining: t8: i32 = Register $eax

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Combining: t5: Untyped = RegisterMask

Legalizing: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0
Legal node: nothing to do

Combining: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

Legalizing: t2: i64 = TargetConstant<0>

Combining: t2: i64 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 'main:for.body.i'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
  t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1
    t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
    t10: f64 = sint_to_fp t9
  t12: f64 = fdiv t10, t77
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
  t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1
    t17: f64 = sint_to_fp t16
  t18: f64 = fdiv t17, t77
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
    t79: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 0x41DFFFFFFFC00000> 0
  t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
            t27: i32,ch = CopyFromReg t0, Register:i32 %1
                t81: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
              t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
                t19: f64 = fmul t12, t12
                t20: f64 = fmul t18, t18
              t21: f64 = fadd t19, t20
            t70: i32 = X86ISD::FCMP t75, t21
          t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
        t30: ch = CopyToReg t0, Register:i32 %2, t82
        t36: ch = CopyToReg t0, Register:i32 %3, t67
      t42: ch = TokenFactor t30, t36, t16:1
    t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1
  t46: ch = br t69, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>


===== Instruction selection begins: %bb.1 'for.body.i'

ISEL: Starting selection on root node: t46: ch = br t69, BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t46: ch = JMP_1 BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>, t69
ISEL: Match complete!

ISEL: Starting selection on root node: t69: ch = X86ISD::BRCOND t42, BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t67:1
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1
  Morphed node: t69: ch = JCC_1 BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t84, t84:1
ISEL: Match complete!

ISEL: Starting selection on root node: t42: ch = TokenFactor t30, t36, t16:1

ISEL: Starting selection on root node: t30: ch = CopyToReg t0, Register:i32 %2, t82

ISEL: Starting selection on root node: t82: i32,i32 = X86ISD::SBB t27, Constant:i32<-1>, t70
ISEL: Starting pattern match
  Initial Opcode index to 90509
  Match failed at index 90513
  Continuing at 90632
  Match failed at index 90651
  Continuing at 90667
  Match failed at index 90674
  Continuing at 90690
Creating constant: t85: i32 = TargetConstant<-1>
Creating new node: t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70
  Morphed node: t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1
ISEL: Match complete!

ISEL: Starting selection on root node: t70: i32 = X86ISD::FCMP t75, t21
ISEL: Starting pattern match
  Initial Opcode index to 93700
  Skipped scope entry (due to false predicate) at index 93703, continuing at 93828
  Match failed at index 93834
  Continuing at 93905
  Skipped scope entry (due to false predicate) at index 93909, continuing at 93919
  Skipped scope entry (due to false predicate) at index 93920, continuing at 93930
  Morphed node: t70: i32 = UCOMISDrr nofpexcept t75, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: f64 = fadd t19, t20
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t21: f64 = ADDSDrr nofpexcept t19, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: f64 = fmul t18, t18
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t20: f64 = MULSDrr nofpexcept t18, t18
ISEL: Match complete!

ISEL: Starting selection on root node: t18: f64 = fdiv t17, t77
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  Match failed at index 157821
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  Match failed at index 158422
  Continuing at 158553
  TypeSwitch[f64] from 158555 to 158607
  Skipped scope entry (due to false predicate) at index 158609, continuing at 158620
  Skipped scope entry (due to false predicate) at index 158621, continuing at 158631
  Morphed node: t18: f64 = DIVSDrr nofpexcept t17, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t17: f64 = sint_to_fp t16
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t17: f64 = CVTSI2SDrr t16
ISEL: Match complete!

ISEL: Starting selection on root node: t16: i32,ch,glue = CopyFromReg t15, Register:i32 $eax, t15:1

ISEL: Starting selection on root node: t19: f64 = fmul t12, t12
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t19: f64 = MULSDrr nofpexcept t12, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: f64 = fdiv t10, t77
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  Match failed at index 157821
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  Match failed at index 158422
  Continuing at 158553
  TypeSwitch[f64] from 158555 to 158607
  Skipped scope entry (due to false predicate) at index 158609, continuing at 158620
  Skipped scope entry (due to false predicate) at index 158621, continuing at 158631
  Morphed node: t12: f64 = DIVSDrr nofpexcept t10, t77
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = X86ISD::CALL t13, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t10: f64 = sint_to_fp t9
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t10: f64 = CVTSI2SDrr t9
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch,glue = callseq_start t9:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t87: i32 = TargetConstant<0>
  Morphed node: t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i32,ch,glue = CopyFromReg t7, Register:i32 $eax, t7:1

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:i32 %3, t67

ISEL: Starting selection on root node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t75: f64,ch = load<(load 8 from constant-pool)> t0, t81, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t89: i8 = TargetConstant<1>
Creating new constant pool: t91: i32 = TargetConstantPool<double 1.000000e+00> 0
  Morphed node: t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t77: f64,ch = load<(load 8 from constant-pool)> t0, t79, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t93: i32 = TargetConstantPool<double 0x41DFFFFFFFC00000> 0
  Morphed node: t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t67: i32,i32 = X86ISD::ADD t32, Constant:i32<-1>
ISEL: Starting pattern match
  Initial Opcode index to 88180
  Match failed at index 88184
  Continuing at 88287
  Match failed at index 88289
  Continuing at 88396
  Skipped scope entry (due to false predicate) at index 88401, continuing at 88447
  TypeSwitch[i32] from 88461 to 88488
  Match failed at index 88488
  Continuing at 88511
  Match failed at index 88512
  Continuing at 88588
  Match failed at index 88589
  Continuing at 88620
  Match failed at index 88635
  Continuing at 88648
  Match failed at index 88654
  Continuing at 88667
  Morphed node: t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t27: i32,ch = CopyFromReg t0, Register:i32 %1

ISEL: Starting selection on root node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t68: i8 = TargetConstant<5>

ISEL: Starting selection on root node: t45: ch = BasicBlock<_Z5solvev.exit 0xfdbfec8>

ISEL: Starting selection on root node: t43: ch = BasicBlock<for.body.i 0xfdbfd20>

ISEL: Starting selection on root node: t35: i32 = Register %3

ISEL: Starting selection on root node: t31: i32 = Register %0

ISEL: Starting selection on root node: t29: i32 = Register %2

ISEL: Starting selection on root node: t26: i32 = Register %1

ISEL: Starting selection on root node: t8: i32 = Register $eax

ISEL: Starting selection on root node: t5: Untyped = RegisterMask

ISEL: Starting selection on root node: t4: i64 = TargetGlobalAddress<i32 ()* @rand> 0

ISEL: Starting selection on root node: t2: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 'main:for.body.i'
SelectionDAG has 50 nodes:
  t0: ch = EntryToken
    t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1
    t32: i32,ch = CopyFromReg t0, Register:i32 %0
  t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>
  t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0
  t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1
  t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2
    t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1
  t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1
    t10: f64 = CVTSI2SDrr t9
  t12: f64 = DIVSDrr nofpexcept t10, t77
  t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1
  t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2
    t17: f64 = CVTSI2SDrr t16
  t18: f64 = DIVSDrr nofpexcept t17, t77
          t27: i32,ch = CopyFromReg t0, Register:i32 %1
              t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
                t19: f64 = MULSDrr nofpexcept t12, t12
                t20: f64 = MULSDrr nofpexcept t18, t18
              t21: f64 = ADDSDrr nofpexcept t19, t20
            t70: i32 = UCOMISDrr nofpexcept t75, t21
          t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70
        t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1
      t30: ch = CopyToReg t0, Register:i32 %2, t82
      t36: ch = CopyToReg t0, Register:i32 %3, t67
    t42: ch = TokenFactor t30, t36, t16:1
  t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1
    t69: ch = JCC_1 BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t84, t84:1
  t46: ch = JMP_1 BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>, t69


********** List Scheduling %bb.1 'for.body.i' **********
SU(0): t46: ch = JMP_1 BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>, t69

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
    SU(9): Data Latency=1
SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=1
SU(4): t42: ch = TokenFactor t30, t36, t16:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(10): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 9
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(17): Data Latency=1
SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 11
  Predecessors:
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(20): Data Latency=1
SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 2
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(22): Data Latency=1
    SU(12): Data Latency=1 Reg=$eflags
  Successors:
    SU(10): Data Latency=1
SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(21): Data Latency=1
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1 Reg=$eflags
SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(18): Data Latency=1
    SU(14): Data Latency=1
  Successors:
    SU(12): Data Latency=1
SU(14): t20: f64 = MULSDrr nofpexcept t18, t18

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 6
  Predecessors:
    SU(15): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 7
  Predecessors:
    SU(17): Data Latency=1
    SU(16): Data Latency=1
  Successors:
    SU(14): Data Latency=1
SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(15): Data Latency=1
    SU(19): Data Latency=1
SU(17): t17: f64 = CVTSI2SDrr t16

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(15): Data Latency=1
SU(18): t19: f64 = MULSDrr nofpexcept t12, t12

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(19): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(20): Data Latency=1
    SU(16): Data Latency=1
  Successors:
    SU(18): Data Latency=1
SU(20): t10: f64 = CVTSI2SDrr t9

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(19): Data Latency=1
SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(12): Data Latency=1
SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(11): Data Latency=1

Examining Available:
Height 0: SU(0): t46: ch = JMP_1 BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>, t69


*** Scheduling [0]: SU(0): t46: ch = JMP_1 BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>, t69


Examining Available:
Height 1: SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1


*** Scheduling [1]: SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1


Examining Available:
Height 1: SU(4): t42: ch = TokenFactor t30, t36, t16:1


*** Scheduling [2]: SU(4): t42: ch = TokenFactor t30, t36, t16:1


Examining Available:
Height 3: SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67

Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [3]: SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67


Examining Available:
Height 4: SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>

Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [4]: SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>


Examining Available:
Height 5: SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0

Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [5]: SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 3: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


*** Scheduling [6]: SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82


Examining Available:
Height 7: SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70


*** Scheduling [7]: SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70


Examining Available:
Height 8: SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1

Height 8: SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21


*** Scheduling [8]: SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1


Examining Available:
Height 8: SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21


*** Scheduling [9]: SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21


Examining Available:
Height 10: SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

Height 10: SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20


*** Scheduling [10]: SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 10: SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20


*** Scheduling [11]: SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20


Examining Available:
Height 12: SU(14): t20: f64 = MULSDrr nofpexcept t18, t18

Height 12: SU(18): t19: f64 = MULSDrr nofpexcept t12, t12


*** Scheduling [12]: SU(14): t20: f64 = MULSDrr nofpexcept t18, t18


Examining Available:
Height 12: SU(18): t19: f64 = MULSDrr nofpexcept t12, t12

Height 13: SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77


*** Scheduling [13]: SU(18): t19: f64 = MULSDrr nofpexcept t12, t12


Examining Available:
Height 13: SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [14]: SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77


Examining Available:
Height 15: SU(17): t17: f64 = CVTSI2SDrr t16

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [15]: SU(17): t17: f64 = CVTSI2SDrr t16


Examining Available:
Height 16: SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [16]: SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1


Examining Available:
Height 17: SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1

Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [17]: SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1


Examining Available:
Height 14: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


*** Scheduling [18]: SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77


Examining Available:
Height 19: SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0

Height 19: SU(20): t10: f64 = CVTSI2SDrr t9


*** Scheduling [19]: SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0


Examining Available:
Height 19: SU(20): t10: f64 = CVTSI2SDrr t9


*** Scheduling [20]: SU(20): t10: f64 = CVTSI2SDrr t9


Examining Available:
Height 21: SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1


*** Scheduling [21]: SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1


Examining Available:
Height 22: SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [22]: SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(8): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(7): t9: i32,ch,glue = CopyFromReg t7:1, Register:i32 $eax, t7:2

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t3:1

    t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

SU(20): t10: f64 = CVTSI2SDrr t9

SU(16): t77: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 0x41DFFFFFFFC00000> 0, Register:i16 $noreg, t0

SU(19): t12: f64 = DIVSDrr nofpexcept t10, t77

SU(6): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t9:1

SU(5): t16: i32,ch,glue = CopyFromReg t15:1, Register:i32 $eax, t15:2

    t14: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 ()* @rand> 0, RegisterMask:Untyped, t13:1

    t15: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t14, t14:1

SU(17): t17: f64 = CVTSI2SDrr t16

SU(15): t18: f64 = DIVSDrr nofpexcept t17, t77

SU(18): t19: f64 = MULSDrr nofpexcept t12, t12

SU(14): t20: f64 = MULSDrr nofpexcept t18, t18

SU(13): t21: f64 = ADDSDrr nofpexcept t19, t20

SU(21): t75: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

SU(12): t70: i32 = UCOMISDrr nofpexcept t75, t21

SU(22): t27: i32,ch = CopyFromReg t0, Register:i32 %1

SU(11): t82: i32,i32 = SBB32ri8 t27, TargetConstant:i32<-1>, t86:1

    t86: ch,glue = CopyToReg t0, Register:i32 $eflags, t70

SU(10): t30: ch = CopyToReg t0, Register:i32 %2, t82

SU(3): t32: i32,ch = CopyFromReg t0, Register:i32 %0

SU(2): t67: i32,i32 = ADD32ri8 t32, TargetConstant:i32<-1>

SU(9): t36: ch = CopyToReg t0, Register:i32 %3, t67

SU(4): t42: ch = TokenFactor t30, t36, t16:1

SU(1): t69: ch = JCC_1 BasicBlock:ch<for.body.i 0xfdbfd20>, TargetConstant:i8<5>, t84, t84:1

    t84: ch,glue = CopyToReg t42, Register:i32 $eflags, t67:1

SU(0): t46: ch = JMP_1 BasicBlock:ch<_Z5solvev.exit 0xfdbfec8>, t69


Total amount of phi nodes to update: 2
Node 0 : (0xfdbfdf8, 2147483651)
Node 1 : (0xfdbfe60, 2147483650)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Creating new node: t3: f64 = sint_to_fp t2
Creating fp constant: t4: f64 = ConstantFP<1.000000e+07>
Creating new node: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Creating fp constant: t6: f64 = ConstantFP<4.000000e+00>
Creating new node: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Creating constant: t10: i64 = TargetConstant<0>
Creating new node: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating constant: t12: i8 = Constant<1>
Creating new node: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
Creating new node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
Creating new node: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
Creating new node: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
Creating new node: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
Creating new node: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
Creating constant: t25: i32 = Constant<0>
Creating constant: t26: i32 = TargetConstant<0>
Creating new node: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
Creating new node: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1
Initial selection DAG: %bb.2 'main:_Z5solvev.exit'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
  t8: i64 = GlobalAddress<i32 (i8*, ...)* @printf> 0
    t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
      t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
    t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
  t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
  t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
  t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
    t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
  t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
  t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1



Combining: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1

Combining: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>

Combining: t26: i32 = TargetConstant<0>

Combining: t25: i32 = Constant<0>

Combining: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1

Combining: t23: i32 = Register $eax

Combining: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1

Combining: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1

Combining: t20: Untyped = RegisterMask

Combining: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0

Combining: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1

Combining: t17: i8 = Register $al

Combining: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

Combining: t15: f64 = Register $xmm0

Combining: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0

Combining: t13: i64 = Register $rdi

Combining: t12: i8 = Constant<1>

Combining: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t10: i64 = TargetConstant<0>

Combining: t9: i64 = GlobalAddress<[11 x i8]* @.str> 0

Combining: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Creating fp constant: t29: f64 = ConstantFP<-1.000000e+07>
Creating new node: t30: f64 = fdiv t3, ConstantFP:f64<-1.000000e+07>
Creating fp constant: t31: f64 = ConstantFP<-4.000000e+00>

Combining: t6: f64 = ConstantFP<4.000000e+00>

Combining: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Creating fp constant: t32: f64 = ConstantFP<-1.000000e+07>

Combining: t4: f64 = ConstantFP<1.000000e+07>

Combining: t3: f64 = sint_to_fp t2

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Combining: t1: i32 = Register %2

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.2 'main:_Z5solvev.exit'
SelectionDAG has 28 nodes:
  t0: ch = EntryToken
    t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
      t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
    t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
  t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
  t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
  t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
    t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
  t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
  t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1


Legalizing node: t26: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t26: i32 = TargetConstant<0>

Legalizing node: t25: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t25: i32 = Constant<0>

Legalizing node: t23: i32 = Register $eax
Ignoring node results
Legally typed node: t23: i32 = Register $eax

Legalizing node: t20: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t20: Untyped = RegisterMask

Legalizing node: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0

Legalizing node: t17: i8 = Register $al
Ignoring node results
Legally typed node: t17: i8 = Register $al

Legalizing node: t15: f64 = Register $xmm0
Ignoring node results
Legally typed node: t15: f64 = Register $xmm0

Legalizing node: t13: i64 = Register $rdi
Ignoring node results
Legally typed node: t13: i64 = Register $rdi

Legalizing node: t12: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t12: i8 = Constant<1>

Legalizing node: t10: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t10: i64 = TargetConstant<0>

Legalizing node: t9: i64 = GlobalAddress<[11 x i8]* @.str> 0
Analyzing result type: i64
Legal result type
Legally typed node: t9: i64 = GlobalAddress<[11 x i8]* @.str> 0

Legalizing node: t6: f64 = ConstantFP<4.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t6: f64 = ConstantFP<4.000000e+00>

Legalizing node: t4: f64 = ConstantFP<1.000000e+07>
Analyzing result type: f64
Legal result type
Legally typed node: t4: f64 = ConstantFP<1.000000e+07>

Legalizing node: t1: i32 = Register %2
Ignoring node results
Legally typed node: t1: i32 = Register %2

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing node: t3: f64 = sint_to_fp t2
Analyzing result type: f64
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal operand
Legally typed node: t3: f64 = sint_to_fp t2

Legalizing node: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Analyzing result type: f64
Legal result type
Analyzing operand: t3: f64 = sint_to_fp t2
Legal operand
Analyzing operand: t4: f64 = ConstantFP<1.000000e+07>
Legal operand
Legally typed node: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>

Legalizing node: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Legal operand
Analyzing operand: t6: f64 = ConstantFP<4.000000e+00>
Legal operand
Legally typed node: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>

Legalizing node: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t9: i64 = GlobalAddress<[11 x i8]* @.str> 0
Legal operand
Legally typed node: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0

Legalizing node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
Legal operand
Analyzing operand: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Legal operand
Analyzing operand: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
Legal operand
Legally typed node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

Legalizing node: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
Legal operand
Analyzing operand: t12: i8 = Constant<1>
Legal operand
Analyzing operand: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
Legal operand
Legally typed node: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1

Legalizing node: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
Legal operand
Analyzing operand: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0
Legal operand
Analyzing operand: t20: Untyped = RegisterMask
Legal operand
Analyzing operand: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
Legal operand
Legally typed node: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1

Legalizing node: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
Legal operand
Analyzing operand: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
Legal operand
Legally typed node: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1

Legalizing node: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
Legal operand
Analyzing operand: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
Legal operand
Legally typed node: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1

Legalizing node: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
Legal operand
Analyzing operand: t25: i32 = Constant<0>
Legal operand
Legally typed node: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>

Legalizing node: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1
Analyzing result type: ch
Legal result type
Analyzing operand: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
Legal operand
Analyzing operand: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
Legal operand
Legally typed node: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1

Legalizing node: t65535: ch = handlenode t28
Analyzing result type: ch
Legal result type
Analyzing operand: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1
Legal operand
Legally typed node: t65535: ch = handlenode t28

Type-legalized selection DAG: %bb.2 'main:_Z5solvev.exit'
SelectionDAG has 28 nodes:
  t0: ch = EntryToken
    t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
      t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
    t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
  t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
  t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
  t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
    t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
  t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
  t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1



Legalizing: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1
Legal node: nothing to do

Legalizing: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
Legal node: nothing to do

Legalizing: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
Legal node: nothing to do

Legalizing: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1

Legalizing: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
Legal node: nothing to do

Legalizing: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
Legal node: nothing to do

Legalizing: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
Legal node: nothing to do

Legalizing: t7: f64 = fmul t5, ConstantFP:f64<4.000000e+00>
Legal node: nothing to do

Legalizing: t5: f64 = fdiv t3, ConstantFP:f64<1.000000e+07>
Legal node: nothing to do

Legalizing: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, GlobalAddress:i64<[11 x i8]* @.str> 0
Legal node: nothing to do

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Legalizing: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Legalizing: t26: i32 = TargetConstant<0>

Legalizing: t25: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t23: i32 = Register $eax

Legalizing: t20: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0
Legal node: nothing to do

Legalizing: t17: i8 = Register $al

Legalizing: t15: f64 = Register $xmm0

Legalizing: t13: i64 = Register $rdi

Legalizing: t12: i8 = Constant<1>
Legal node: nothing to do

Legalizing: t10: i64 = TargetConstant<0>

Legalizing: t9: i64 = GlobalAddress<[11 x i8]* @.str> 0
Trying custom legalization
Creating new node: t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0
Successfully custom legalized node
 ... replacing: t9: i64 = GlobalAddress<[11 x i8]* @.str> 0
     with:      t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0

Legalizing: t6: f64 = ConstantFP<4.000000e+00>
Trying to expand node
Creating new constant pool: t35: i64 = ConstantPool<double 4.000000e+00> 0
Creating new node: t36: i64 = undef
Creating new node: t37: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t6: f64 = ConstantFP<4.000000e+00>
     with:      t37: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64

Legalizing: t4: f64 = ConstantFP<1.000000e+07>
Trying to expand node
Creating new constant pool: t38: i64 = ConstantPool<double 1.000000e+07> 0
Creating new node: t39: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+07> 0, undef:i64
Successfully expanded node
 ... replacing: t4: f64 = ConstantFP<1.000000e+07>
     with:      t39: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+07> 0, undef:i64

Legalizing: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t39: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+07> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t38: i64 = ConstantPool<double 1.000000e+07> 0
Trying custom legalization
Creating new constant pool: t40: i64 = TargetConstantPool<double 1.000000e+07> 0
Creating new node: t41: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
Successfully custom legalized node
 ... replacing: t38: i64 = ConstantPool<double 1.000000e+07> 0
     with:      t41: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0

Legalizing: t37: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t36: i64 = undef
Legal node: nothing to do

Legalizing: t35: i64 = ConstantPool<double 4.000000e+00> 0
Trying custom legalization
Creating new constant pool: t42: i64 = TargetConstantPool<double 4.000000e+00> 0
Creating new node: t43: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Successfully custom legalized node
 ... replacing: t35: i64 = ConstantPool<double 4.000000e+00> 0
     with:      t43: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0
Legal node: nothing to do

Legalizing: t33: i64 = TargetGlobalAddress<[11 x i8]* @.str> 0
Legal node: nothing to do

Legalizing: t43: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t42: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t41: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
Legal node: nothing to do

Legalizing: t40: i64 = TargetConstantPool<double 1.000000e+07> 0
Legal node: nothing to do
Legalized selection DAG: %bb.2 'main:_Z5solvev.exit'
SelectionDAG has 34 nodes:
  t0: ch = EntryToken
    t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0
  t14: ch,glue = CopyToReg t11, Register:i64 $rdi, t34
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
          t41: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
        t39: f64,ch = load<(load 8 from constant-pool)> t0, t41, undef:i64
      t5: f64 = fdiv t3, t39
        t43: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
      t37: f64,ch = load<(load 8 from constant-pool)> t0, t43, undef:i64
    t7: f64 = fmul t5, t37
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
  t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
  t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
  t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
    t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
  t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
  t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1



Legalizing: t43: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t43: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t42: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t42: i64 = TargetConstantPool<double 4.000000e+00> 0

Legalizing: t41: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
Legal node: nothing to do

Combining: t41: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0

Legalizing: t40: i64 = TargetConstantPool<double 1.000000e+07> 0
Legal node: nothing to do

Combining: t40: i64 = TargetConstantPool<double 1.000000e+07> 0

Legalizing: t39: f64,ch = load<(load 8 from constant-pool)> t0, t41, undef:i64
Legalizing non-extending load operation

Combining: t39: f64,ch = load<(load 8 from constant-pool)> t0, t41, undef:i64

Legalizing: t37: f64,ch = load<(load 8 from constant-pool)> t0, t43, undef:i64
Legalizing non-extending load operation

Combining: t37: f64,ch = load<(load 8 from constant-pool)> t0, t43, undef:i64

Legalizing: t36: i64 = undef
Legal node: nothing to do

Combining: t36: i64 = undef

Legalizing: t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0
Legal node: nothing to do

Combining: t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0

Legalizing: t33: i64 = TargetGlobalAddress<[11 x i8]* @.str> 0
Legal node: nothing to do

Combining: t33: i64 = TargetGlobalAddress<[11 x i8]* @.str> 0

Legalizing: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1
Legal node: nothing to do

Combining: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1

Legalizing: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
Legal node: nothing to do

Combining: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>

Legalizing: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
Legal node: nothing to do

Combining: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1

Legalizing: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1

Combining: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1

Legalizing: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
Legal node: nothing to do

Combining: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1

Legalizing: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
Legal node: nothing to do

Combining: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1

Legalizing: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
Legal node: nothing to do

Combining: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

Legalizing: t7: f64 = fmul t5, t37
Legal node: nothing to do

Combining: t7: f64 = fmul t5, t37

Legalizing: t5: f64 = fdiv t3, t39
Legal node: nothing to do

Combining: t5: f64 = fdiv t3, t39

Legalizing: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, t34
Legal node: nothing to do

Combining: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, t34

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Combining: t3: f64 = sint_to_fp t2

Legalizing: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing: t26: i32 = TargetConstant<0>

Combining: t26: i32 = TargetConstant<0>

Legalizing: t25: i32 = Constant<0>
Legal node: nothing to do

Combining: t25: i32 = Constant<0>

Legalizing: t23: i32 = Register $eax

Combining: t23: i32 = Register $eax

Legalizing: t20: Untyped = RegisterMask
Legal node: nothing to do

Combining: t20: Untyped = RegisterMask

Legalizing: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0
Legal node: nothing to do

Combining: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0

Legalizing: t17: i8 = Register $al

Combining: t17: i8 = Register $al

Legalizing: t15: f64 = Register $xmm0

Combining: t15: f64 = Register $xmm0

Legalizing: t13: i64 = Register $rdi

Combining: t13: i64 = Register $rdi

Legalizing: t12: i8 = Constant<1>
Legal node: nothing to do

Combining: t12: i8 = Constant<1>

Legalizing: t10: i64 = TargetConstant<0>

Combining: t10: i64 = TargetConstant<0>

Legalizing: t1: i32 = Register %2

Combining: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.2 'main:_Z5solvev.exit'
SelectionDAG has 34 nodes:
  t0: ch = EntryToken
    t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0
  t14: ch,glue = CopyToReg t11, Register:i64 $rdi, t34
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = sint_to_fp t2
          t41: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+07> 0
        t39: f64,ch = load<(load 8 from constant-pool)> t0, t41, undef:i64
      t5: f64 = fdiv t3, t39
        t43: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
      t37: f64,ch = load<(load 8 from constant-pool)> t0, t43, undef:i64
    t7: f64 = fmul t5, t37
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
  t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1
  t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
  t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
    t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1
  t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>
  t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1


===== Instruction selection begins: %bb.2 '_Z5solvev.exit'

ISEL: Starting selection on root node: t28: ch = X86ISD::RET_FLAG t27, TargetConstant:i32<0>, Register:i32 $eax, t27:1
ISEL: Starting pattern match
  Initial Opcode index to 127064
  Morphed node: t28: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t27, t27:1
ISEL: Match complete!

ISEL: Starting selection on root node: t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, Constant:i32<0>

ISEL: Starting selection on root node: t24: i32,ch,glue = CopyFromReg t22, Register:i32 $eax, t22:1

ISEL: Starting selection on root node: t22: ch,glue = callseq_end t21, TargetConstant:i64<0>, TargetConstant:i64<0>, t21:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t22: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t21, t21:1
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch,glue = X86ISD::CALL t18, TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t21: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18, t18:1
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch,glue = CopyToReg t16, Register:i8 $al, Constant:i8<1>, t16:1

ISEL: Starting selection on root node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

ISEL: Starting selection on root node: t7: f64 = fmul t5, t37
ISEL: Starting pattern match
  Initial Opcode index to 154194
  OpcodeSwitch from 154199 to 154204
  TypeSwitch[f64] from 154215 to 154239
  Match failed at index 154239
  Continuing at 154259
  Match failed at index 154260
  Continuing at 154333
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  TypeSwitch[f64] from 154811 to 154875
  Skipped scope entry (due to false predicate) at index 154877, continuing at 154895
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t45: i8 = TargetConstant<1>
Creating new constant pool: t47: i32 = TargetConstantPool<double 4.000000e+00> 0
  Morphed node: t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: f64 = fdiv t3, t39
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  TypeSwitch[f64] from 157830 to 157854
  Match failed at index 157854
  Continuing at 157874
  Match failed at index 157875
  Continuing at 157948
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  TypeSwitch[f64] from 158429 to 158493
  Skipped scope entry (due to false predicate) at index 158495, continuing at 158513
MatchAddress: X86ISelAddressMode 0x7fffc1558960
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t49: i32 = TargetConstantPool<double 1.000000e+07> 0
  Morphed node: t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: ch,glue = CopyToReg t11, Register:i64 $rdi, t34

ISEL: Starting selection on root node: t3: f64 = sint_to_fp t2
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t3: f64 = CVTSI2SDrr t2
ISEL: Match complete!

ISEL: Starting selection on root node: t34: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[11 x i8]* @.str> 0
ISEL: Starting pattern match
  Initial Opcode index to 127392
  Morphed node: t34: i64 = MOV32ri64 TargetGlobalAddress:i64<[11 x i8]* @.str> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %2

ISEL: Starting selection on root node: t33: i64 = TargetGlobalAddress<[11 x i8]* @.str> 0

ISEL: Starting selection on root node: t26: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t25: i32 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  TypeSwitch[i32] from 123997 to 124000
  Morphed node: t25: i32,i32 = MOV32r0
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i32 = Register $eax

ISEL: Starting selection on root node: t20: Untyped = RegisterMask

ISEL: Starting selection on root node: t19: i64 = TargetGlobalAddress<i32 (i8*, ...)* @printf> 0

ISEL: Starting selection on root node: t17: i8 = Register $al

ISEL: Starting selection on root node: t15: f64 = Register $xmm0

ISEL: Starting selection on root node: t13: i64 = Register $rdi

ISEL: Starting selection on root node: t12: i8 = Constant<1>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Match failed at index 124075
  Continuing at 124110
  Match failed at index 124111
  Continuing at 124157
  TypeSwitch[i8] from 124159 to 124242
  Morphed node: t12: i8 = MOV8ri TargetConstant:i8<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t1: i32 = Register %2

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 'main:_Z5solvev.exit'
SelectionDAG has 33 nodes:
  t0: ch = EntryToken
    t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t34: i64 = MOV32ri64 TargetGlobalAddress:i64<[11 x i8]* @.str> 0
  t14: ch,glue = CopyToReg t11:1, Register:i64 $rdi, t34
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t3: f64 = CVTSI2SDrr t2
      t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0
    t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1
    t12: i8 = MOV8ri TargetConstant:i8<1>
  t18: ch,glue = CopyToReg t16, Register:i8 $al, t12, t16:1
  t21: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18, t18:1
  t22: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t21, t21:1
    t24: i32,ch,glue = CopyFromReg t22:1, Register:i32 $eax, t22:2
  t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, MOV32r0:i32,i32
  t28: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t27, t27:1


********** List Scheduling %bb.2 '_Z5solvev.exit' **********
SU(0): t28: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t27, t27:1

    t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, MOV32r0:i32,i32

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Barrier
    SU(1): Data Latency=1
SU(1): t25: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t24: i32,ch,glue = CopyFromReg t22:1, Register:i32 $eax, t22:2

    t14: ch,glue = CopyToReg t11:1, Register:i64 $rdi, t34

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

    t18: ch,glue = CopyToReg t16, Register:i8 $al, t12, t16:1

    t21: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18, t18:1

    t22: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t21, t21:1

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(4): Data Latency=1
    SU(9): Ord  Latency=1 Barrier
    SU(8): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(3): t12: i8 = MOV8ri TargetConstant:i8<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
SU(4): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(5): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t3: f64 = CVTSI2SDrr t2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(6): Data Latency=1
SU(8): t34: i64 = MOV32ri64 TargetGlobalAddress:i64<[11 x i8]* @.str> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
SU(9): t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t28: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t27, t27:1

    t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, MOV32r0:i32,i32


*** Scheduling [0]: SU(0): t28: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t27, t27:1

    t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, MOV32r0:i32,i32


Examining Available:
Height 1: SU(1): t25: i32,i32 = MOV32r0

Height 1: SU(2): t24: i32,ch,glue = CopyFromReg t22:1, Register:i32 $eax, t22:2

    t14: ch,glue = CopyToReg t11:1, Register:i64 $rdi, t34

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

    t18: ch,glue = CopyToReg t16, Register:i8 $al, t12, t16:1

    t21: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18, t18:1

    t22: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t21, t21:1


*** Scheduling [1]: SU(1): t25: i32,i32 = MOV32r0


Examining Available:
Height 1: SU(2): t24: i32,ch,glue = CopyFromReg t22:1, Register:i32 $eax, t22:2

    t14: ch,glue = CopyToReg t11:1, Register:i64 $rdi, t34

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

    t18: ch,glue = CopyToReg t16, Register:i8 $al, t12, t16:1

    t21: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18, t18:1

    t22: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t21, t21:1


*** Scheduling [2]: SU(2): t24: i32,ch,glue = CopyFromReg t22:1, Register:i32 $eax, t22:2

    t14: ch,glue = CopyToReg t11:1, Register:i64 $rdi, t34

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

    t18: ch,glue = CopyToReg t16, Register:i8 $al, t12, t16:1

    t21: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18, t18:1

    t22: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t21, t21:1


Examining Available:
Height 3: SU(3): t12: i8 = MOV8ri TargetConstant:i8<1>

Height 3: SU(8): t34: i64 = MOV32ri64 TargetGlobalAddress:i64<[11 x i8]* @.str> 0

Height 3: SU(9): t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 3: SU(4): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [3]: SU(3): t12: i8 = MOV8ri TargetConstant:i8<1>


Examining Available:
Height 3: SU(8): t34: i64 = MOV32ri64 TargetGlobalAddress:i64<[11 x i8]* @.str> 0

Height 3: SU(9): t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 3: SU(4): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [4]: SU(8): t34: i64 = MOV32ri64 TargetGlobalAddress:i64<[11 x i8]* @.str> 0


Examining Available:
Height 3: SU(9): t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 3: SU(4): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [5]: SU(9): t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


Examining Available:
Height 3: SU(4): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [6]: SU(4): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 7: SU(5): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0


*** Scheduling [7]: SU(5): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0


Examining Available:
Height 8: SU(6): t3: f64 = CVTSI2SDrr t2


*** Scheduling [8]: SU(6): t3: f64 = CVTSI2SDrr t2


Examining Available:
Height 9: SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %2


*** Scheduling [9]: SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %2

*** Final schedule ***
SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %2

SU(6): t3: f64 = CVTSI2SDrr t2

SU(5): t5: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t3, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+07> 0, Register:i16 $noreg, t0

SU(4): t7: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t5, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

SU(9): t11: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(8): t34: i64 = MOV32ri64 TargetGlobalAddress:i64<[11 x i8]* @.str> 0

SU(3): t12: i8 = MOV8ri TargetConstant:i8<1>

SU(2): t24: i32,ch,glue = CopyFromReg t22:1, Register:i32 $eax, t22:2

    t14: ch,glue = CopyToReg t11:1, Register:i64 $rdi, t34

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm0, t7, t14:1

    t18: ch,glue = CopyToReg t16, Register:i8 $al, t12, t16:1

    t21: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<i32 (i8*, ...)* @printf> 0, Register:i64 $rdi, Register:f64 $xmm0, Register:i8 $al, RegisterMask:Untyped, t18, t18:1

    t22: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t21, t21:1

SU(1): t25: i32,i32 = MOV32r0

SU(0): t28: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t27, t27:1

    t27: ch,glue = CopyToReg t24:1, Register:i32 $eax, MOV32r0:i32,i32


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %5:gr32 = MOV32r0 implicit-def dead $eflags
  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
  $rdi = COPY %6:gr64
  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %7:gr64 = COPY $rax
  %8:gr32 = COPY %7.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %8:gr32
  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %4:gr32 = MOV32ri 10000000

bb.1.for.body.i:
; predecessors: %bb.0, %bb.1
  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

  %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
  %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  %10:fr64 = CVTSI2SDrr %9:gr32
  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %12:fr64 = nofpexcept DIVSDrr %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr32 = COPY $eax
  %14:fr64 = CVTSI2SDrr %13:gr32
  %15:fr64 = nofpexcept DIVSDrr %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  %16:fr64 = nofpexcept MULSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept MULSDrr %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  %18:fr64 = nofpexcept ADDSDrr %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
  %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
  %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.1, 5, implicit $eflags
  JMP_1 %bb.2

bb.2._Z5solvev.exit:
; predecessors: %bb.1

  %20:fr64 = CVTSI2SDrr %2:gr32
  %21:fr64 = nofpexcept DIVSDrm %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %22:fr64 = nofpexcept MULSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %23:gr64 = MOV32ri64 @.str
  %24:gr8 = MOV8ri 1
  $rdi = COPY %23:gr64
  $xmm0 = COPY %22:fr64
  $al = COPY %24:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = COPY $eax
  %26:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %26:gr32
  RET 0, $eax

# End machine code for function main.

***** Machine Function before Domain Reassignment *****
# Machine code for function main: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %5:gr32 = MOV32r0 implicit-def dead $eflags
  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
  $rdi = COPY %6:gr64
  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %7:gr64 = COPY $rax
  %8:gr32 = COPY %7.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %8:gr32
  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %4:gr32 = MOV32ri 10000000

bb.1.for.body.i:
; predecessors: %bb.0, %bb.1
  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

  %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
  %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  %10:fr64 = CVTSI2SDrr %9:gr32
  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %12:fr64 = nofpexcept DIVSDrr %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr32 = COPY $eax
  %14:fr64 = CVTSI2SDrr %13:gr32
  %15:fr64 = nofpexcept DIVSDrr %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  %16:fr64 = nofpexcept MULSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept MULSDrr %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  %18:fr64 = nofpexcept ADDSDrr %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
  %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
  %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.1, 5, implicit $eflags
  JMP_1 %bb.2

bb.2._Z5solvev.exit:
; predecessors: %bb.1

  %20:fr64 = CVTSI2SDrr %2:gr32
  %21:fr64 = nofpexcept DIVSDrm %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %22:fr64 = nofpexcept MULSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %23:gr64 = MOV32ri64 @.str
  %24:gr8 = MOV8ri 1
  $rdi = COPY %23:gr64
  $xmm0 = COPY %22:fr64
  $al = COPY %24:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:gr32 = COPY $eax
  %26:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %26:gr32
  RET 0, $eax

# End machine code for function main.

# Machine code for function main: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %5:gr32 = MOV32r0 implicit-def dead $eflags
48B	  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
64B	  $rdi = COPY %6:gr64
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64 = COPY $rax
128B	  %8:gr32 = COPY %7.sub_32bit:gr64
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %8:gr32
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr32 = MOV32ri 10000000

224B	bb.1.for.body.i:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

240B	  %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
256B	  %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
272B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
288B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
304B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
320B	  %9:gr32 = COPY $eax
336B	  %10:fr64 = CVTSI2SDrr %9:gr32
352B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
368B	  %12:fr64 = nofpexcept DIVSDrr %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
384B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
432B	  %13:gr32 = COPY $eax
448B	  %14:fr64 = CVTSI2SDrr %13:gr32
464B	  %15:fr64 = nofpexcept DIVSDrr %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
480B	  %16:fr64 = nofpexcept MULSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
496B	  %17:fr64 = nofpexcept MULSDrr %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
512B	  %18:fr64 = nofpexcept ADDSDrr %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
528B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
544B	  nofpexcept UCOMISDrr killed %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
560B	  %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
576B	  %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
592B	  JCC_1 %bb.1, 5, implicit $eflags
608B	  JMP_1 %bb.2

624B	bb.2._Z5solvev.exit:
	; predecessors: %bb.1

640B	  %20:fr64 = CVTSI2SDrr %2:gr32
656B	  %21:fr64 = nofpexcept DIVSDrm %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
672B	  %22:fr64 = nofpexcept MULSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
688B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  %23:gr64 = MOV32ri64 @.str
720B	  %24:gr8 = MOV8ri 1
736B	  $rdi = COPY %23:gr64
752B	  $xmm0 = COPY %22:fr64
768B	  $al = COPY %24:gr8
784B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
816B	  %25:gr32 = COPY $eax
832B	  %26:gr32 = MOV32r0 implicit-def dead $eflags
848B	  $eax = COPY %26:gr32
864B	  RET 0, $eax

# End machine code for function main.

********** Stack Coloring **********
********** Function: main
DeadMachineInstructionElim: DELETING: %25:gr32 = COPY $eax
********** EARLY IF-CONVERSION **********
********** Function: main
Machine InstCombiner: main
Combining MBB entry
Combining MBB for.body.i
Combining MBB _Z5solvev.exit
********** X86 cmov Conversion : main**********

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.i]
 - 2: BB2[_Z5solvev.exit]
loop-detection
 - loop = BB1[for.body.i]
compute-mass-in-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
  => [  exit  ] weight = 67108864, succ = BB2[_Z5solvev.exit]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[_Z5solvev.exit]
compute-loop-scale: BB1[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body.i]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body.i]
 - node: BB1[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[_Z5solvev.exit]
 - node: BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body.i]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body.i]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body.i]: float = 32.0, scaled = 256.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body.i]: float = 32.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, int = 8

******** Pre-regalloc Machine LICM: main ********
Entering %bb.1
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
 from %bb.1 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 from %bb.1 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.i]
 - 2: BB2[_Z5solvev.exit]
loop-detection
 - loop = BB1[for.body.i]
compute-mass-in-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
  => [  exit  ] weight = 67108864, succ = BB2[_Z5solvev.exit]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[_Z5solvev.exit]
compute-loop-scale: BB1[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body.i]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body.i]
 - node: BB1[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[_Z5solvev.exit]
 - node: BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body.i]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body.i]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body.i]: float = 32.0, scaled = 256.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body.i]: float = 32.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, int = 8

Entering: entry
Entering: for.body.i
Entering: _Z5solvev.exit
Examining: %26:gr32 = MOV32r0 implicit-def dead $eflags
*** Found a common subexpression: %5:gr32 = MOV32r0 implicit-def dead $eflags
*** Not profitable, avoid CSE!
Exiting: _Z5solvev.exit
Exiting: for.body.i
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.1
4: %bb.0
Found roots: %bb.2 
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: main
Encountered load fold barrier on CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Encountered load fold barrier on CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp
Optimize recurrence chain from %0:gr32 = PHI %4:gr32, %bb.0, %3:gr32, %bb.1
	Inst: %3:gr32 = ADD32ri8 %0:gr32(tied-def 0), -1, implicit-def $eflags
Optimize recurrence chain from %1:gr32 = PHI %5:gr32, %bb.0, %2:gr32, %bb.1
	Inst: %2:gr32 = SBB32ri8 %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit $eflags
Encountered load fold barrier on CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
Encountered load fold barrier on CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
Encountered load fold barrier on CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
**** Analysing main
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : main **********
********** X86 EFLAGS copy lowering : main **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
	%12:fr64 = nofpexcept DIVSDrr killed %10:fr64(tied-def 0), %11:fr64, implicit $mxcsr
		prepend:	%12:fr64 = COPY %10:fr64
		rewrite to:	%12:fr64 = nofpexcept DIVSDrr %12:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	%15:fr64 = nofpexcept DIVSDrr killed %14:fr64(tied-def 0), %11:fr64, implicit $mxcsr
		prepend:	%15:fr64 = COPY %14:fr64
		rewrite to:	%15:fr64 = nofpexcept DIVSDrr %15:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	%16:fr64 = nofpexcept MULSDrr killed %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
		prepend:	%16:fr64 = COPY %12:fr64
		rewrite to:	%16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
	%17:fr64 = nofpexcept MULSDrr killed %15:fr64(tied-def 0), %15:fr64, implicit $mxcsr
		prepend:	%17:fr64 = COPY %15:fr64
		rewrite to:	%17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
	%18:fr64 = nofpexcept ADDSDrr killed %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
2addr: COMMUTING  : %18:fr64 = nofpexcept ADDSDrr killed %16:fr64(tied-def 0), killed %17:fr64, implicit $mxcsr
2addr: COMMUTED TO: %18:fr64 = nofpexcept ADDSDrr killed %17:fr64(tied-def 0), killed %16:fr64, implicit $mxcsr
		prepend:	%18:fr64 = COPY %17:fr64
		rewrite to:	%18:fr64 = nofpexcept ADDSDrr %18:fr64(tied-def 0), killed %16:fr64, implicit $mxcsr
	%2:gr32 = SBB32ri8 killed %1:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
		prepend:	%2:gr32 = COPY %1:gr32
		rewrite to:	%2:gr32 = SBB32ri8 %2:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
	%3:gr32 = ADD32ri8 killed %0:gr32(tied-def 0), -1, implicit-def $eflags
		prepend:	%3:gr32 = COPY %0:gr32
		rewrite to:	%3:gr32 = ADD32ri8 %3:gr32(tied-def 0), -1, implicit-def $eflags
	%21:fr64 = nofpexcept DIVSDrm killed %20:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		prepend:	%21:fr64 = COPY %20:fr64
		rewrite to:	%21:fr64 = nofpexcept DIVSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	%22:fr64 = nofpexcept MULSDrm killed %21:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		prepend:	%22:fr64 = COPY %21:fr64
		rewrite to:	%22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %5:gr32 = MOV32r0 implicit-def dead $eflags
48B	  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
64B	  $rdi = COPY killed %6:gr64
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64 = COPY killed $rax
128B	  %8:gr32 = COPY killed %7.sub_32bit:gr64
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY killed %8:gr32
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
256B	  %27:gr32 = COPY killed %4:gr32
272B	  %28:gr32 = COPY killed %5:gr32

288B	bb.1.for.body.i:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

304B	  %1:gr32 = COPY killed %28:gr32
320B	  %0:gr32 = COPY killed %27:gr32
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %10:fr64 = CVTSI2SDrr killed %9:gr32
416B	  %12:fr64 = COPY killed %10:fr64
432B	  %12:fr64 = nofpexcept DIVSDrr %12:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %14:fr64 = CVTSI2SDrr killed %13:gr32
528B	  %15:fr64 = COPY killed %14:fr64
544B	  %15:fr64 = nofpexcept DIVSDrr %15:fr64(tied-def 0), %11:fr64, implicit $mxcsr
560B	  %16:fr64 = COPY killed %12:fr64
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
592B	  %17:fr64 = COPY killed %15:fr64
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
624B	  %18:fr64 = COPY killed %17:fr64
640B	  %18:fr64 = nofpexcept ADDSDrr %18:fr64(tied-def 0), killed %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, killed %18:fr64, implicit-def $eflags, implicit $mxcsr
672B	  %2:gr32 = COPY killed %1:gr32
688B	  %2:gr32 = SBB32ri8 %2:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
704B	  %3:gr32 = COPY killed %0:gr32
720B	  %3:gr32 = ADD32ri8 %3:gr32(tied-def 0), -1, implicit-def $eflags
736B	  %27:gr32 = COPY killed %3:gr32
752B	  %28:gr32 = COPY %2:gr32
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2._Z5solvev.exit:
	; predecessors: %bb.1

816B	  %20:fr64 = CVTSI2SDrr killed %2:gr32
832B	  %21:fr64 = COPY killed %20:fr64
848B	  %21:fr64 = nofpexcept DIVSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
864B	  %22:fr64 = COPY killed %21:fr64
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %23:gr64 = MOV32ri64 @.str
928B	  %24:gr8 = MOV8ri 1
944B	  $rdi = COPY killed %23:gr64
960B	  $xmm0 = COPY killed %22:fr64
976B	  $al = COPY killed %24:gr8
992B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  %26:gr32 = MOV32r0 implicit-def dead $eflags
1040B	  $eax = COPY killed %26:gr32
1056B	  RET 0, killed $eax

# End machine code for function main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%0 [320r,704r:0)  0@320r weight:0.000000e+00
%1 [304r,672r:0)  0@304r weight:0.000000e+00
%2 [672r,688r:0)[688r,816r:1)  0@672r 1@688r weight:0.000000e+00
%3 [704r,720r:0)[720r,736r:1)  0@704r 1@720r weight:0.000000e+00
%4 [208r,256r:0)  0@208r weight:0.000000e+00
%5 [32r,272r:0)  0@32r weight:0.000000e+00
%6 [48r,64r:0)  0@48r weight:0.000000e+00
%7 [112r,128r:0)  0@112r weight:0.000000e+00
%8 [128r,160r:0)  0@128r weight:0.000000e+00
%9 [384r,400r:0)  0@384r weight:0.000000e+00
%10 [400r,416r:0)  0@400r weight:0.000000e+00
%11 [224r,800B:0)  0@224r weight:0.000000e+00
%12 [416r,432r:0)[432r,560r:1)  0@416r 1@432r weight:0.000000e+00
%13 [496r,512r:0)  0@496r weight:0.000000e+00
%14 [512r,528r:0)  0@512r weight:0.000000e+00
%15 [528r,544r:0)[544r,592r:1)  0@528r 1@544r weight:0.000000e+00
%16 [560r,576r:0)[576r,640r:1)  0@560r 1@576r weight:0.000000e+00
%17 [592r,608r:0)[608r,624r:1)  0@592r 1@608r weight:0.000000e+00
%18 [624r,640r:0)[640r,656r:1)  0@624r 1@640r weight:0.000000e+00
%19 [240r,800B:0)  0@240r weight:0.000000e+00
%20 [816r,832r:0)  0@816r weight:0.000000e+00
%21 [832r,848r:0)[848r,864r:1)  0@832r 1@848r weight:0.000000e+00
%22 [864r,880r:0)[880r,960r:1)  0@864r 1@880r weight:0.000000e+00
%23 [912r,944r:0)  0@912r weight:0.000000e+00
%24 [928r,976r:0)  0@928r weight:0.000000e+00
%26 [1024r,1040r:0)  0@1024r weight:0.000000e+00
%27 [256r,288B:0)[288B,320r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
%28 [272r,288B:0)[288B,304r:2)[752r,800B:1)  0@272r 1@752r 2@288B-phi weight:0.000000e+00
RegMasks: 80r 176r 352r 464r 992r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %5:gr32 = MOV32r0 implicit-def dead $eflags
48B	  %6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
64B	  $rdi = COPY %6:gr64
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64 = COPY killed $rax
128B	  %8:gr32 = COPY %7.sub_32bit:gr64
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %8:gr32
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %4:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
256B	  %27:gr32 = COPY %4:gr32
272B	  %28:gr32 = COPY %5:gr32

288B	bb.1.for.body.i:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

304B	  %1:gr32 = COPY %28:gr32
320B	  %0:gr32 = COPY %27:gr32
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %10:fr64 = CVTSI2SDrr %9:gr32
416B	  %12:fr64 = COPY %10:fr64
432B	  %12:fr64 = nofpexcept DIVSDrr %12:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %14:fr64 = CVTSI2SDrr %13:gr32
528B	  %15:fr64 = COPY %14:fr64
544B	  %15:fr64 = nofpexcept DIVSDrr %15:fr64(tied-def 0), %11:fr64, implicit $mxcsr
560B	  %16:fr64 = COPY %12:fr64
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
592B	  %17:fr64 = COPY %15:fr64
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
624B	  %18:fr64 = COPY %17:fr64
640B	  %18:fr64 = nofpexcept ADDSDrr %18:fr64(tied-def 0), %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, %18:fr64, implicit-def $eflags, implicit $mxcsr
672B	  %2:gr32 = COPY %1:gr32
688B	  %2:gr32 = SBB32ri8 %2:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
704B	  %3:gr32 = COPY %0:gr32
720B	  %3:gr32 = ADD32ri8 %3:gr32(tied-def 0), -1, implicit-def $eflags
736B	  %27:gr32 = COPY %3:gr32
752B	  %28:gr32 = COPY %2:gr32
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2._Z5solvev.exit:
	; predecessors: %bb.1

816B	  %20:fr64 = CVTSI2SDrr %2:gr32
832B	  %21:fr64 = COPY %20:fr64
848B	  %21:fr64 = nofpexcept DIVSDrm %21:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
864B	  %22:fr64 = COPY %21:fr64
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %23:gr64 = MOV32ri64 @.str
928B	  %24:gr8 = MOV8ri 1
944B	  $rdi = COPY %23:gr64
960B	  $xmm0 = COPY %22:fr64
976B	  $al = COPY %24:gr8
992B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  %26:gr32 = MOV32r0 implicit-def dead $eflags
1040B	  $eax = COPY %26:gr32
1056B	  RET 0, killed $eax

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
for.body.i:
384B	%9:gr32 = COPY killed $eax
	Considering merging %9 with $eax
	Can only merge into reserved registers.
496B	%13:gr32 = COPY killed $eax
	Considering merging %13 with $eax
	Can only merge into reserved registers.
752B	%28:gr32 = COPY %2:gr32
	Considering merging to GR32 with %2 in %28
		RHS = %2 [672r,688r:0)[688r,816r:1)  0@672r 1@688r weight:0.000000e+00
		LHS = %28 [272r,288B:0)[288B,304r:2)[752r,800B:1)  0@272r 1@752r 2@288B-phi weight:0.000000e+00
		merge %28:1@752r into %2:1@688r --> @688r
		erased:	752r	%28:gr32 = COPY %2:gr32
		updated: 672B	%28:gr32 = COPY %1:gr32
		updated: 688B	%28:gr32 = SBB32ri8 %28:gr32(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
		updated: 816B	%20:fr64 = CVTSI2SDrr %28:gr32
	Success: %2 -> %28
	Result = %28 [272r,288B:0)[288B,304r:2)[672r,688r:3)[688r,816r:1)  0@272r 1@688r 2@288B-phi 3@672r weight:0.000000e+00
304B	%1:gr32 = COPY %28:gr32
	Considering merging to GR32 with %1 in %28
		RHS = %1 [304r,672r:0)  0@304r weight:0.000000e+00
		LHS = %28 [272r,288B:0)[288B,304r:2)[672r,688r:3)[688r,816r:1)  0@272r 1@688r 2@288B-phi 3@672r weight:0.000000e+00
		merge %1:0@304r into %28:2@288B --> @288B
		merge %28:3@672r into %1:0@304r --> @288B
		erased:	672r	%28:gr32 = COPY %1:gr32
		erased:	304r	%1:gr32 = COPY %28:gr32
	Success: %1 -> %28
	Result = %28 [272r,288B:0)[288B,688r:2)[688r,816r:1)  0@272r 1@688r 2@288B-phi weight:0.000000e+00
320B	%0:gr32 = COPY %27:gr32
	Considering merging to GR32 with %0 in %27
		RHS = %0 [320r,704r:0)  0@320r weight:0.000000e+00
		LHS = %27 [256r,288B:0)[288B,320r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
		merge %0:0@320r into %27:2@288B --> @288B
		erased:	320r	%0:gr32 = COPY %27:gr32
		updated: 704B	%3:gr32 = COPY %27:gr32
	Success: %0 -> %27
	Result = %27 [256r,288B:0)[288B,704r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
416B	%12:fr64 = COPY %10:fr64
	Considering merging to FR64 with %10 in %12
		RHS = %10 [400r,416r:0)  0@400r weight:0.000000e+00
		LHS = %12 [416r,432r:0)[432r,560r:1)  0@416r 1@432r weight:0.000000e+00
		merge %12:0@416r into %10:0@400r --> @400r
		erased:	416r	%12:fr64 = COPY %10:fr64
		updated: 400B	%12:fr64 = CVTSI2SDrr %9:gr32
	Success: %10 -> %12
	Result = %12 [400r,432r:0)[432r,560r:1)  0@400r 1@432r weight:0.000000e+00
528B	%15:fr64 = COPY %14:fr64
	Considering merging to FR64 with %14 in %15
		RHS = %14 [512r,528r:0)  0@512r weight:0.000000e+00
		LHS = %15 [528r,544r:0)[544r,592r:1)  0@528r 1@544r weight:0.000000e+00
		merge %15:0@528r into %14:0@512r --> @512r
		erased:	528r	%15:fr64 = COPY %14:fr64
		updated: 512B	%15:fr64 = CVTSI2SDrr %13:gr32
	Success: %14 -> %15
	Result = %15 [512r,544r:0)[544r,592r:1)  0@512r 1@544r weight:0.000000e+00
560B	%16:fr64 = COPY %12:fr64
	Considering merging to FR64 with %12 in %16
		RHS = %12 [400r,432r:0)[432r,560r:1)  0@400r 1@432r weight:0.000000e+00
		LHS = %16 [560r,576r:0)[576r,640r:1)  0@560r 1@576r weight:0.000000e+00
		merge %16:0@560r into %12:1@432r --> @432r
		erased:	560r	%16:fr64 = COPY %12:fr64
		updated: 400B	%16:fr64 = CVTSI2SDrr %9:gr32
		updated: 432B	%16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	Success: %12 -> %16
	Result = %16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:0.000000e+00
592B	%17:fr64 = COPY %15:fr64
	Considering merging to FR64 with %15 in %17
		RHS = %15 [512r,544r:0)[544r,592r:1)  0@512r 1@544r weight:0.000000e+00
		LHS = %17 [592r,608r:0)[608r,624r:1)  0@592r 1@608r weight:0.000000e+00
		merge %17:0@592r into %15:1@544r --> @544r
		erased:	592r	%17:fr64 = COPY %15:fr64
		updated: 512B	%17:fr64 = CVTSI2SDrr %13:gr32
		updated: 544B	%17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	Success: %15 -> %17
	Result = %17 [512r,544r:2)[544r,608r:0)[608r,624r:1)  0@544r 1@608r 2@512r weight:0.000000e+00
624B	%18:fr64 = COPY %17:fr64
	Considering merging to FR64 with %18 in %17
		RHS = %18 [624r,640r:0)[640r,656r:1)  0@624r 1@640r weight:0.000000e+00
		LHS = %17 [512r,544r:2)[544r,608r:0)[608r,624r:1)  0@544r 1@608r 2@512r weight:0.000000e+00
		merge %18:0@624r into %17:1@608r --> @608r
		erased:	624r	%18:fr64 = COPY %17:fr64
		updated: 640B	%17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
		updated: 656B	nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
	Success: %18 -> %17
	Result = %17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:0.000000e+00
704B	%3:gr32 = COPY %27:gr32
	Considering merging to GR32 with %3 in %27
		RHS = %3 [704r,720r:0)[720r,736r:1)  0@704r 1@720r weight:0.000000e+00
		LHS = %27 [256r,288B:0)[288B,704r:2)[736r,800B:1)  0@256r 1@736r 2@288B-phi weight:0.000000e+00
		merge %27:1@736r into %3:1@720r --> @720r
		merge %3:0@704r into %27:2@288B --> @288B
		erased:	736r	%27:gr32 = COPY %3:gr32
		erased:	704r	%3:gr32 = COPY %27:gr32
		updated: 720B	%27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags
	Success: %3 -> %27
	Result = %27 [256r,288B:0)[288B,720r:2)[720r,800B:1)  0@256r 1@720r 2@288B-phi weight:0.000000e+00
entry:
48B	%6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
	Considering merging to GR64_with_sub_8bit with %5 in %6:sub_32bit
		RHS = %5 [32r,272r:0)  0@32r weight:0.000000e+00
		LHS = %6 [48r,64r:0)  0@48r weight:0.000000e+00
		merge %6:0@48r into %5:0@32r --> @32r
		erased:	48r	%6:gr64 = SUBREG_TO_REG 0, %5:gr32, %subreg.sub_32bit
		updated: 32B	undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
		updated: 272B	%28:gr32 = COPY %6.sub_32bit:gr64_with_sub_8bit
	Success: %5:sub_32bit -> %6
	Result = %6 [32r,272r:0)  0@32r weight:0.000000e+00
64B	$rdi = COPY %6:gr64_with_sub_8bit
	Considering merging %6 with $rdi
	Can only merge into reserved registers.
Remat: dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
Shrink: %6 [32r,272r:0)  0@32r weight:0.000000e+00
Shrunk: %6 [32r,272r:0)  0@32r weight:0.000000e+00
112B	%7:gr64 = COPY killed $rax
	Considering merging %7 with $rax
	Can only merge into reserved registers.
160B	$edi = COPY %8:gr32
	Considering merging %8 with $edi
	Can only merge into reserved registers.
_Z5solvev.exit:
944B	$rdi = COPY %23:gr64
	Considering merging %23 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 @.str
Shrink: %23 [912r,944r:0)  0@912r weight:0.000000e+00
All defs dead: 912r	dead %23:gr64 = MOV32ri64 @.str
Shrunk: %23 [912r,912d:0)  0@912r weight:0.000000e+00
Deleting dead def 912r	dead %23:gr64 = MOV32ri64 @.str
960B	$xmm0 = COPY %22:fr64
	Considering merging %22 with $xmm0
	Can only merge into reserved registers.
976B	$al = COPY %24:gr8
	Considering merging %24 with $al
	Can only merge into reserved registers.
Remat: $al = MOV8ri 1
Shrink: %24 [928r,976r:0)  0@928r weight:0.000000e+00
All defs dead: 928r	dead %24:gr8 = MOV8ri 1
Shrunk: %24 [928r,928d:0)  0@928r weight:0.000000e+00
Deleting dead def 928r	dead %24:gr8 = MOV8ri 1
1040B	$eax = COPY %26:gr32
	Considering merging %26 with $eax
	Can only merge into reserved registers.
Remat: $eax = MOV32r0 implicit-def dead $eflags
Shrink: %26 [1024r,1040r:0)  0@1024r weight:0.000000e+00
All defs dead: 1024r	dead %26:gr32 = MOV32r0 implicit-def dead $eflags
Shrunk: %26 [1024r,1024d:0)  0@1024r weight:0.000000e+00
Deleting dead def 1024r	dead %26:gr32 = MOV32r0 implicit-def dead $eflags
128B	%8:gr32 = COPY %7.sub_32bit:gr64
	Considering merging to GR64_with_sub_8bit with %8 in %7:sub_32bit
		RHS = %8 [128r,160r:0)  0@128r weight:0.000000e+00
		LHS = %7 [112r,128r:0)  0@112r weight:0.000000e+00
		merge %8:0@128r into %7:0@112r --> @112r
		erased:	128r	%8:gr32 = COPY %7.sub_32bit:gr64
		updated: 160B	$edi = COPY %7.sub_32bit:gr64_with_sub_8bit
	Success: %8:sub_32bit -> %7
	Result = %7 [112r,160r:0)  0@112r weight:0.000000e+00
256B	%27:gr32 = COPY %4:gr32
	Considering merging to GR32 with %4 in %27
		RHS = %4 [208r,256r:0)  0@208r weight:0.000000e+00
		LHS = %27 [256r,288B:0)[288B,720r:2)[720r,800B:1)  0@256r 1@720r 2@288B-phi weight:0.000000e+00
		merge %27:0@256r into %4:0@208r --> @208r
		erased:	256r	%27:gr32 = COPY %4:gr32
		updated: 208B	%27:gr32 = MOV32ri 10000000
	Success: %4 -> %27
	Result = %27 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:0.000000e+00
272B	%28:gr32 = COPY %6.sub_32bit:gr64_with_sub_8bit
	Considering merging to GR64_with_sub_8bit with %28 in %6:sub_32bit
		RHS = %28 [272r,288B:0)[288B,688r:2)[688r,816r:1)  0@272r 1@688r 2@288B-phi weight:0.000000e+00
		LHS = %6 [32r,272r:0)  0@32r weight:0.000000e+00
		merge %28:0@272r into %6:0@32r --> @32r
		erased:	272r	%28:gr32 = COPY %6.sub_32bit:gr64_with_sub_8bit
		updated: 688B	%6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
		updated: 816B	%20:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
	Success: %28:sub_32bit -> %6
	Result = %6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:0.000000e+00
832B	%21:fr64 = COPY %20:fr64
	Considering merging to FR64 with %20 in %21
		RHS = %20 [816r,832r:0)  0@816r weight:0.000000e+00
		LHS = %21 [832r,848r:0)[848r,864r:1)  0@832r 1@848r weight:0.000000e+00
		merge %21:0@832r into %20:0@816r --> @816r
		erased:	832r	%21:fr64 = COPY %20:fr64
		updated: 816B	%21:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
	Success: %20 -> %21
	Result = %21 [816r,848r:0)[848r,864r:1)  0@816r 1@848r weight:0.000000e+00
864B	%22:fr64 = COPY %21:fr64
	Considering merging to FR64 with %21 in %22
		RHS = %21 [816r,848r:0)[848r,864r:1)  0@816r 1@848r weight:0.000000e+00
		LHS = %22 [864r,880r:0)[880r,960r:1)  0@864r 1@880r weight:0.000000e+00
		merge %22:0@864r into %21:1@848r --> @848r
		erased:	864r	%22:fr64 = COPY %21:fr64
		updated: 816B	%22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
		updated: 848B	%22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	Success: %21 -> %22
	Result = %22 [816r,848r:2)[848r,880r:0)[880r,960r:1)  0@848r 1@880r 2@816r weight:0.000000e+00
160B	$edi = COPY %7.sub_32bit:gr64_with_sub_8bit
	Considering merging %7 with $rdi
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
%6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:0.000000e+00
%7 [112r,160r:0)  0@112r weight:0.000000e+00
%9 [384r,400r:0)  0@384r weight:0.000000e+00
%11 [224r,800B:0)  0@224r weight:0.000000e+00
%13 [496r,512r:0)  0@496r weight:0.000000e+00
%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:0.000000e+00
%17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:0.000000e+00
%19 [240r,800B:0)  0@240r weight:0.000000e+00
%22 [816r,848r:2)[848r,880r:0)[880r,960r:1)  0@848r 1@880r 2@816r weight:0.000000e+00
%27 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:0.000000e+00
RegMasks: 80r 176r 352r 464r 992r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
64B	  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64_with_sub_8bit = COPY killed $rax
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %7.sub_32bit:gr64_with_sub_8bit
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %27:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

288B	bb.1.for.body.i:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %16:fr64 = CVTSI2SDrr %9:gr32
432B	  %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %17:fr64 = CVTSI2SDrr %13:gr32
544B	  %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
640B	  %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
688B	  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
720B	  %27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2._Z5solvev.exit:
	; predecessors: %bb.1

816B	  %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
848B	  %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
944B	  $rdi = MOV32ri64 @.str
960B	  $xmm0 = COPY %22:fr64
976B	  $al = MOV8ri 1
992B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $eax = MOV32r0 implicit-def dead $eflags
1056B	  RET 0, killed $eax

# End machine code for function main.

Before MISched:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %7:gr64_with_sub_8bit = COPY killed $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %7.sub_32bit:gr64_with_sub_8bit
  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %27:gr32 = MOV32ri 10000000
  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

bb.1.for.body.i:
; predecessors: %bb.0, %bb.1
  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY killed $eax
  %16:fr64 = CVTSI2SDrr %9:gr32
  %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %13:gr32 = COPY killed $eax
  %17:fr64 = CVTSI2SDrr %13:gr32
  %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
  %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
  %27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.1, 5, implicit killed $eflags
  JMP_1 %bb.2

bb.2._Z5solvev.exit:
; predecessors: %bb.1

  %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
  %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @.str
  $xmm0 = COPY %22:fr64
  $al = MOV8ri 1
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, killed $eax

# End machine code for function main.

********** MI Scheduling **********
main:%bb.0 entry
  From: %27:gr32 = MOV32ri 10000000
    To: End RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %27:gr32 = MOV32ri 10000000
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
SU(2):   %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 2 1 
  Cand SU(0) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 5c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %27:gr32 = MOV32ri 10000000
  Ready @0c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %27:gr32 = MOV32ri 10000000
SU(1):   %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(2):   %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

********** MI Scheduling **********
main:%bb.0 entry
  From: undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
    To: CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
  Ready @1c
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 MOps
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
SU(1):   dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi

********** MI Scheduling **********
main:%bb.1 for.body.i
  From: %13:gr32 = COPY killed $eax
    To: JCC_1 %bb.1, 5, implicit killed $eflags
 RegionInstrs: 9
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
FR32=4
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP_with_GR64_TCW64=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=4
GR16=6
Live In: %27 %6 %19 %16 %11 AH AL HAX 
Live Out: %27 %6 %19 %11 
Live Thru: FR32=2
FR32X=2
GR16=4
  LiveReg: %27
  LiveReg: %6
  LiveReg: %19
  UpdateRegP: SU(6) nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
              to FR32 1    FR32X 1
  LiveReg: %11
  UpdateRegP: SU(2) %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
              to 
Top Pressure:
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
FR32=3
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP_with_GR64_TCW64=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=3
GR16=6
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
Excess PSets: 
Macro fuse: SU(8) - ExitSU /  ADD32ri8 - JCC_1
  Bind SU(7) - SU(8)
SU(0):   %13:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 37
  Successors:
    SU(1): Data Latency=0 Reg=%13
  Pressure Diff      : GR8_ABCD_H_with_GR32_BSI 1    GR8_ABCD_L_with_GR32_BSI 1    GR8_NOREX 2    GR32_TC 2    GR32_BPSP_with_GR32_TC 2    GR64_NOREX 2    GR64_TCW64 2    GR32_BPSP_with_GR64_TCW64 2    GR8 2    GR8_with_GR32_DIBP 2    GR8_with_GR32_BSI 2    GR64_TC_with_GR64_TCW64 2    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit 2    GR8_with_GR64_NOREX 2    GR64_TC 2    GR8_with_GR64_TCW64 2
  Single Issue       : false;
SU(1):   %17:fr64 = CVTSI2SDrr %13:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 37
  Predecessors:
    SU(0): Data Latency=0 Reg=%13
  Successors:
    SU(2): Data Latency=4 Reg=%17
    SU(2): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1    GR16 2
  Single Issue       : false;
SU(2):   %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 22
  Depth              : 4
  Height             : 33
  Predecessors:
    SU(1): Data Latency=4 Reg=%17
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=22 Reg=%17
    SU(4): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 11
  Successors:
    SU(5): Data Latency=5 Reg=%16
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 26
  Height             : 11
  Predecessors:
    SU(2): Data Latency=22 Reg=%17
    SU(2): Out  Latency=0
  Successors:
    SU(5): Data Latency=5 Reg=%17
    SU(5): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 31
  Height             : 6
  Predecessors:
    SU(4): Data Latency=5 Reg=%17
    SU(4): Out  Latency=0
    SU(3): Data Latency=5 Reg=%16
  Successors:
    SU(6): Data Latency=3 Reg=%17
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(6):   nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 2
  Depth              : 34
  Height             : 3
  Predecessors:
    SU(5): Data Latency=3 Reg=%17
  Successors:
    SU(8): Out  Latency=0
    SU(7): Out  Latency=0
    SU(7): Data Latency=2 Reg=$eflags
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(7):   %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 2
  Depth              : 36
  Height             : 1
  Predecessors:
    SU(6): Out  Latency=0
    SU(6): Data Latency=2 Reg=$eflags
  Successors:
    SU(8): Out  Latency=0
    SU(8): Anti Latency=0
    ExitSU: Ord  Latency=1 Artificial
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags
  # preds left       : 3
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 36
  Height             : 0
  Predecessors:
    SU(7): Out  Latency=0
    SU(7): Anti Latency=0
    SU(6): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   JCC_1 %bb.1, 5, implicit killed $eflags
  # preds left       : 2
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 37
  Height             : 0
  Predecessors:
    SU(8): Ord  Latency=0 Artificial
    SU(7): Ord  Latency=1 Artificial
    SU(8): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 37
Cyclic Path: SU(8) -> SU(8) = 1c
Cyclic Path: SU(7) -> SU(7) = 2c
Cyclic Critical Path: 2c
IssueCycles=2c IterCycles=2c NumIters=14 InFlight=148m BufferLim=168m
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) %27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  LiveReg: %27
  UpdateRegP: SU(8) %27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags
              to GR16 -2
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A TopLatency SU(8) 36c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  LiveReg: %6
  UpdateRegP: SU(7) %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
              to GR16 -2
  Ready @1c
  SBPort05 +1x6u
  *** Critical resource SBPort05: 0c
  SBPort015 +2x4u
  *** Critical resource SBPort015: 1c
  SBPortAny +2x2u
  BotQ.A BotLatency SU(7) 1c
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
  SU(6) uops=2
** ScheduleDAGMILive::schedule picking next node
Cycle: 1 BotQ.A
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
Bottom Pressure:
FR32=3
FR32X=3
GR16=4
  LiveReg: %17
  UpdateRegP: SU(6) nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
              to 
  Ready @3c
  SBPort0 +1x12u
  SBPort1 +1x12u
  SBPort01 +2x6u
  SBPort05 +1x6u
  SBPort15 +1x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(6) 3c
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 5 SBPort015
  ExpectedLatency: 3c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %17
  UpdateRegP: SU(5) %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
              to 
  LiveReg: %16
  UpdateRegP: SU(5) %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @6c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 2c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(5) 6c
BotQ.A @1c
  Retired: 6
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 3 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %17
  UpdateRegP: SU(4) %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @11c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  *** Critical resource SBPort015: 2c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(4) 11c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 7
  Executed: 2c
  Critical: 2c, 7 SBPort015
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %16
  UpdateRegP: SU(3) %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @11c
  SBPort0 +1x12u
  *** Critical resource SBPort0: 3c
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @2c
  Retired: 8
  Executed: 3c
  Critical: 3c, 3 SBPort0
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %17
  UpdateRegP: SU(2) %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @33c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 33c
BotQ.A @2c
  Retired: 9
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 33c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %17:fr64 = CVTSI2SDrr %13:gr32
Bottom Pressure:
FR32=3
FR32X=3
GR16=6
  LiveReg: %13
  UpdateRegP: SU(1) %17:fr64 = CVTSI2SDrr %13:gr32
              to FR32 -1    FR32X -1
  Ready @37c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(1) 37c
  *** Max MOps 4 at cycle 2
Cycle: 3 BotQ.A
BotQ.A @3c
  Retired: 11
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 37c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %13:gr32 = COPY killed $eax
Bottom Pressure:
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=2
GR32_TC=2
GR32_BPSP_with_GR32_TC=2
FR32=3
GR64_NOREX=2
GR64_TCW64=2
GR32_BPSP_with_GR64_TCW64=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=3
GR16=6
  Ready @37c
BotQ.A @3c
  Retired: 11
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 37c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   %13:gr32 = COPY killed $eax
SU(1):   %17:fr64 = CVTSI2SDrr %13:gr32
SU(2):   %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
SU(3):   %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
SU(4):   %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
SU(5):   %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
SU(6):   nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
SU(7):   %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
SU(8):   %27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags

********** MI Scheduling **********
main:%bb.1 for.body.i
  From: %9:gr32 = COPY killed $eax
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %9:gr32 = COPY killed $eax
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 25
  Successors:
    SU(1): Data Latency=0 Reg=%9
  Single Issue       : false;
SU(1):   %16:fr64 = CVTSI2SDrr %9:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 25
  Predecessors:
    SU(0): Data Latency=0 Reg=%9
  Successors:
    SU(2): Data Latency=4 Reg=%16
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 22
  Depth              : 4
  Height             : 21
  Predecessors:
    SU(1): Data Latency=4 Reg=%16
    SU(1): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=21 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 25
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=21 Artificial
Critical Path(GS-RR ): 25
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
  Ready @21c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(2) 4c
  BotQ.A BotLatency SU(2) 21c
BotQ.A @0c
  Retired: 1
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 21c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %16:fr64 = CVTSI2SDrr %9:gr32
  Ready @25c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(1) 25c
BotQ.A @0c
  Retired: 3
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 25c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %9:gr32 = COPY killed $eax
  Ready @25c
BotQ.A @0c
  Retired: 3
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 25c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   %9:gr32 = COPY killed $eax
SU(1):   %16:fr64 = CVTSI2SDrr %9:gr32
SU(2):   %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr

********** MI Scheduling **********
main:%bb.2 _Z5solvev.exit
  From: $rdi = MOV32ri64 @.str
    To: CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @.str
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $xmm0 = COPY %22:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $al = MOV8ri 1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $al = MOV8ri 1
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) $xmm0 = COPY %22:fr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @.str
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   $rdi = MOV32ri64 @.str
SU(1):   $xmm0 = COPY %22:fr64
SU(2):   $al = MOV8ri 1

********** MI Scheduling **********
main:%bb.2 _Z5solvev.exit
  From: %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 33
  Successors:
    SU(1): Data Latency=0 Reg=%22
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 28
  Depth              : 0
  Height             : 33
  Predecessors:
    SU(0): Data Latency=0 Reg=%22
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=23 Reg=%22
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 11
  Depth              : 23
  Height             : 10
  Predecessors:
    SU(1): Data Latency=23 Reg=%22
    SU(1): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=10 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 33
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=10 Artificial
Critical Path(GS-RR ): 33
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  Ready @10c
  SBPort0 +1x12u
  *** Critical resource SBPort0: 1c
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort23 +1x6u
  SBPort015 +1x4u
  SBPortAny +2x2u
  BotQ.A TopLatency SU(2) 23c
  BotQ.A BotLatency SU(2) 10c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort0
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  Ready @33c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort23 +1x6u
  SBPort015 +1x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(1) 33c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 33c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
  Ready @33c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
BotQ.A @1c
  Retired: 6
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 33c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
SU(1):   %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
SU(2):   %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)

********** INTERVALS **********
%6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:0.000000e+00
%7 [112r,160r:0)  0@112r weight:0.000000e+00
%9 [384r,400r:0)  0@384r weight:0.000000e+00
%11 [224r,800B:0)  0@224r weight:0.000000e+00
%13 [496r,512r:0)  0@496r weight:0.000000e+00
%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:0.000000e+00
%17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:0.000000e+00
%19 [240r,800B:0)  0@240r weight:0.000000e+00
%22 [816r,848r:2)[848r,880r:0)[880r,960r:1)  0@848r 1@880r 2@816r weight:0.000000e+00
%27 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:0.000000e+00
RegMasks: 80r 176r 352r 464r 992r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 0x41DFFFFFFFC00000, align=8
  cp#1: 1.000000e+00, align=8
  cp#2: 1.000000e+07, align=8
  cp#3: 4.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
64B	  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64_with_sub_8bit = COPY killed $rax
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY %7.sub_32bit:gr64_with_sub_8bit
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %27:gr32 = MOV32ri 10000000
224B	  %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

288B	bb.1.for.body.i:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)

336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY killed $eax
400B	  %16:fr64 = CVTSI2SDrr %9:gr32
432B	  %16:fr64 = nofpexcept DIVSDrr %16:fr64(tied-def 0), %11:fr64, implicit $mxcsr
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY killed $eax
512B	  %17:fr64 = CVTSI2SDrr %13:gr32
544B	  %17:fr64 = nofpexcept DIVSDrr %17:fr64(tied-def 0), %11:fr64, implicit $mxcsr
576B	  %16:fr64 = nofpexcept MULSDrr %16:fr64(tied-def 0), %16:fr64, implicit $mxcsr
608B	  %17:fr64 = nofpexcept MULSDrr %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
640B	  %17:fr64 = nofpexcept ADDSDrr %17:fr64(tied-def 0), %16:fr64, implicit $mxcsr
656B	  nofpexcept UCOMISDrr %19:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
688B	  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
720B	  %27:gr32 = ADD32ri8 %27:gr32(tied-def 0), -1, implicit-def $eflags
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2

800B	bb.2._Z5solvev.exit:
	; predecessors: %bb.1

816B	  %22:fr64 = CVTSI2SDrr %6.sub_32bit:gr64_with_sub_8bit
848B	  %22:fr64 = nofpexcept DIVSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
880B	  %22:fr64 = nofpexcept MULSDrm %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
944B	  $rdi = MOV32ri64 @.str
960B	  $xmm0 = COPY %22:fr64
976B	  $al = MOV8ri 1
992B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit killed $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $eax = MOV32r0 implicit-def dead $eflags
1056B	  RET 0, killed $eax

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.i]
 - 2: BB2[_Z5solvev.exit]
loop-detection
 - loop = BB1[for.body.i]
compute-mass-in-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
  => [  exit  ] weight = 67108864, succ = BB2[_Z5solvev.exit]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[_Z5solvev.exit]
compute-loop-scale: BB1[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body.i]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body.i]
 - node: BB1[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[_Z5solvev.exit]
 - node: BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body.i]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body.i]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body.i]: float = 32.0, scaled = 256.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body.i]: float = 32.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, int = 8

********** BASIC REGISTER ALLOCATION **********
********** Function: main
********** Compute Spill Weights **********
********** Function: main
VirtReg:9-> 0(group: GR32(0) size:15)
VirtReg:13-> 1(group: GR32(0) size:15)
VirtReg:17-> 2(group: FR64(1) size:16)
VirtReg:16-> 3(group: FR64(1) size:16)
VirtReg:27-> 4(group: GR32(0) size:15)
VirtReg:6-> 5(group: GR64_with_sub_8bit(2) size:15)
VirtReg:11-> 6(group: FR64(1) size:16)
VirtReg:19-> 7(group: FR64(1) size:16)
VirtReg:22-> 8(group: FR64(1) size:16)
VirtReg:7-> 9(group: GR64_with_sub_8bit(2) size:15)
test!!! regcount = 10

selectOrSplit GR32:%9 [384r,400r:0)  0@384r weight:INF w=INF
hints: $eax
assigning %9 to $eax: AH [384r,400r:0)  0@384r AL [384r,400r:0)  0@384r HAX [384r,400r:0)  0@384r

selectOrSplit GR32:%13 [496r,512r:0)  0@496r weight:INF w=INF
hints: $eax
assigning %13 to $eax: AH [496r,512r:0)  0@496r AL [496r,512r:0)  0@496r HAX [496r,512r:0)  0@496r

selectOrSplit FR64:%17 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r weight:4.687500e-01 w=4.687500e-01
assigning %17 to $xmm0: XMM0 [512r,544r:2)[544r,608r:0)[608r,640r:1)[640r,656r:3)  0@544r 1@608r 2@512r 3@640r

selectOrSplit FR64:%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:2.988281e-01 w=2.988281e-01
16-> 17, 
spilling: %16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:2.988281e-01
Inline spilling FR64:%16 [400r,432r:2)[432r,576r:0)[576r,640r:1)  0@432r 1@576r 2@400r weight:2.988281e-01
From original %16
Merged spilled regs: SS#0 [400r,640r:0)  0@x weight:0.000000e+00
spillAroundUses %16
	reload:   408r	%29:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
	rewrite: 432r	%29:fr64 = nofpexcept DIVSDrr %29:fr64(tied-def 0), %11:fr64, implicit $mxcsr

	spill:   440r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %29:fr64 :: (store 8 into %stack.0)
	rewrite: 400r	%30:fr64 = CVTSI2SDrr %9:gr32

	spill:   404r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %30:fr64 :: (store 8 into %stack.0)
	reload:   552r	%31:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
	rewrite: 576r	%31:fr64 = nofpexcept MULSDrr %31:fr64(tied-def 0), killed %31:fr64, implicit $mxcsr

	spill:   584r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %31:fr64 :: (store 8 into %stack.0)
	folded:   640r	%17:fr64 = nofpexcept ADDSDrm %17:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
queuing new interval: %29 [408r,432r:1)[432r,440r:0)  0@432r 1@408r weight:INF
queuing new interval: %30 [400r,404r:0)  0@400r weight:INF
queuing new interval: %31 [552r,576r:1)[576r,584r:0)  0@576r 1@552r weight:INF

selectOrSplit FR64:%29 [408r,432r:1)[432r,440r:0)  0@432r 1@408r weight:INF w=INF
assigning %29 to $xmm0: XMM0 [408r,432r:1)[432r,440r:0)  0@432r 1@408r

selectOrSplit FR64:%30 [400r,404r:0)  0@400r weight:INF w=INF
assigning %30 to $xmm0: XMM0 [400r,404r:0)  0@400r

selectOrSplit FR64:%31 [552r,576r:1)[576r,584r:0)  0@576r 1@552r weight:INF w=INF
31-> 17, 
assigning %31 to $xmm1: XMM1 [552r,576r:1)[576r,584r:0)  0@576r 1@552r

selectOrSplit GR32:%27 [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi weight:1.941919e-01 w=1.941919e-01
27-> 9, 13, 
27-> 9, 13, 
27-> 9, 13, 
assigning %27 to $ebx: BH [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi BL [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi HBX [208r,288B:0)[288B,720r:2)[720r,800B:1)  0@208r 1@720r 2@288B-phi

selectOrSplit GR64_with_sub_8bit:%6 [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi weight:1.632179e-01 w=1.632179e-01
6-> 9, 13, 
6-> 9, 13, 
6-> 9, 13, 
6-> 27, 
6-> 27, 
6-> 27, 
assigning %6 to $r14: R14B [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi R14BH [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi R14WH [32r,288B:0)[288B,688r:2)[688r,816r:1)  0@32r 1@688r 2@288B-phi

selectOrSplit FR64:%11 [224r,800B:0)  0@224r weight:3.323922e-02 w=3.323922e-02
11-> 30, 29, 17, 
11-> 31, 
spilling: %11 [224r,800B:0)  0@224r weight:3.323922e-02
Inline spilling FR64:%11 [224r,800B:0)  0@224r weight:3.323922e-02
From original %11
	folded:   432r	%29:fr64 = nofpexcept DIVSDrm %29:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	folded:   544r	%17:fr64 = nofpexcept DIVSDrm %17:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
All defs dead: dead %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 224r	dead %11:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.

selectOrSplit FR64:%19 [240r,800B:0)  0@240r weight:1.715814e-02 w=1.715814e-02
19-> 30, 29, 17, 
19-> 31, 
spilling: %19 [240r,800B:0)  0@240r weight:1.715814e-02
Inline spilling FR64:%19 [240r,800B:0)  0@240r weight:1.715814e-02
From original %19
	remat:  648r	%33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
	        656e	nofpexcept UCOMISDrr killed %33:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr

All defs dead: dead %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 240r	dead %19:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.
queuing new interval: %33 [648r,656r:0)  0@648r weight:INF

selectOrSplit FR64:%33 [648r,656r:0)  0@648r weight:INF w=INF
33-> 17, 
assigning %33 to $xmm1: XMM1 [648r,656r:0)  0@648r

selectOrSplit FR64:%22 [816r,848r:2)[848r,880r:0)[880r,960r:1)  0@848r 1@880r 2@816r weight:1.113971e-02 w=1.113971e-02
hints: $xmm0
assigning %22 to $xmm0: XMM0 [816r,848r:2)[848r,880r:0)[880r,960r:1)  0@848r 1@880r 2@816r

selectOrSplit GR64_with_sub_8bit:%7 [112r,160r:0)  0@112r weight:4.508928e-03 w=4.508928e-03
hints: $rax $rdi
assigning %7 to $rax: AH [112r,160r:0)  0@112r AL [112r,160r:0)  0@112r HAX [112r,160r:0)  0@112r

For Slot0 and VN0:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot0 and VN2:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot0 and VN1:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 
Post alloc VirtRegMap:
********** REGISTER MAP **********
[%6 -> $r14] GR64_with_sub_8bit
[%7 -> $rax] GR64_with_sub_8bit
[%9 -> $eax] GR32
[%13 -> $eax] GR32
[%17 -> $xmm0] FR64
[%22 -> $xmm0] FR64
[%27 -> $ebx] GR32
[%29 -> $xmm0] FR64
[%30 -> $xmm0] FR64
[%31 -> $xmm1] FR64
[%33 -> $xmm1] FR64
[%16 -> fi#0] FR64


********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********
[%6 -> $r14] GR64_with_sub_8bit
[%7 -> $rax] GR64_with_sub_8bit
[%9 -> $eax] GR32
[%13 -> $eax] GR32
[%17 -> $xmm0] FR64
[%22 -> $xmm0] FR64
[%27 -> $ebx] GR32
[%29 -> $xmm0] FR64
[%30 -> $xmm0] FR64
[%31 -> $xmm1] FR64
[%33 -> $xmm1] FR64
[%16 -> fi#0] FR64

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  undef %6.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
64B	  dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
80B	  CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
96B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  %7:gr64_with_sub_8bit = COPY $rax
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $edi = COPY killed %7.sub_32bit:gr64_with_sub_8bit
176B	  CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %27:gr32 = MOV32ri 10000000
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r14d = MOV32r0 implicit-def dead $eflags, implicit-def $r14
> dead $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi
> CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rax
Identity copy: renamable $rax = COPY $rax
  deleted.
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $edi = COPY renamable $eax, implicit killed $rax
> CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $ebx = MOV32ri 10000000
288B	bb.1.for.body.i:
	; predecessors: %bb.0, %bb.1
	  successors: %bb.2(0x04000000), %bb.1(0x7c000000); %bb.2(3.12%), %bb.1(96.88%)
	  liveins: $ebx, $r14
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %9:gr32 = COPY $eax
400B	  %30:fr64 = CVTSI2SDrr killed %9:gr32
404B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %30:fr64 :: (store 8 into %stack.0)
408B	  %29:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
432B	  %29:fr64 = nofpexcept DIVSDrm killed %29:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
440B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %29:fr64 :: (store 8 into %stack.0)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  %13:gr32 = COPY $eax
512B	  %17:fr64 = CVTSI2SDrr killed %13:gr32
544B	  %17:fr64 = nofpexcept DIVSDrm killed %17:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
552B	  %31:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
576B	  %31:fr64 = nofpexcept MULSDrr killed %31:fr64(tied-def 0), %31:fr64, implicit $mxcsr
584B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %31:fr64 :: (store 8 into %stack.0)
608B	  %17:fr64 = nofpexcept MULSDrr killed %17:fr64(tied-def 0), %17:fr64, implicit $mxcsr
640B	  %17:fr64 = nofpexcept ADDSDrm killed %17:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
648B	  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
656B	  nofpexcept UCOMISDrr killed %33:fr64, killed %17:fr64, implicit-def $eflags, implicit $mxcsr
688B	  %6.sub_32bit:gr64_with_sub_8bit = SBB32ri8 killed %6.sub_32bit:gr64_with_sub_8bit(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags
720B	  %27:gr32 = ADD32ri8 killed %27:gr32(tied-def 0), -1, implicit-def $eflags
768B	  JCC_1 %bb.1, 5, implicit killed $eflags
784B	  JMP_1 %bb.2
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $eax = COPY $eax
Identity copy: renamable $eax = COPY $eax
  deleted.
> renamable $xmm0 = CVTSI2SDrr killed renamable $eax
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
> renamable $xmm0 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
> renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $eax = COPY $eax
Identity copy: renamable $eax = COPY $eax
  deleted.
> renamable $xmm0 = CVTSI2SDrr killed renamable $eax
> renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> renamable $xmm1 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
> renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm1 :: (store 8 into %stack.0)
> renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
> renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
> nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
> renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
> renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
> JCC_1 %bb.1, 5, implicit killed $eflags
> JMP_1 %bb.2
800B	bb.2._Z5solvev.exit:
	; predecessors: %bb.1
	  liveins: $r14
816B	  %22:fr64 = CVTSI2SDrr killed %6.sub_32bit:gr64_with_sub_8bit
848B	  %22:fr64 = nofpexcept DIVSDrm killed %22:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
880B	  %22:fr64 = nofpexcept MULSDrm killed %22:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
896B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
944B	  $rdi = MOV32ri64 @.str
960B	  $xmm0 = COPY killed %22:fr64
976B	  $al = MOV8ri 1
992B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $eax = MOV32r0 implicit-def dead $eflags
1056B	  RET 0, $eax
> renamable $xmm0 = CVTSI2SDrr renamable $r14d, implicit killed $r14
> renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 @.str
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> $al = MOV8ri 1
> CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $eax = MOV32r0 implicit-def dead $eflags
> RET 0, $eax
********** Stack Slot Coloring **********
********** Function: main
Spill slot intervals:
SS#0 [400r,640r:0)  0@x weight:1.912500e+02

Color spill slot intervals:
Assigning fi#0 to fi#0

Spill slots after coloring:
SS#0 [400r,640r:0)  0@x weight:1.912500e+02

MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: BackwardCopyPropagateBlock for.body.i
MCP: ForwardCopyPropagateBlock for.body.i
MCP: BackwardCopyPropagateBlock _Z5solvev.exit
MCP: ForwardCopyPropagateBlock _Z5solvev.exit
******** Post-regalloc Machine LICM: main ********
***** X86 Load Value Injection (LVI) Load Hardening : main *****

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.i]
 - 2: BB2[_Z5solvev.exit]
loop-detection
 - loop = BB1[for.body.i]
compute-mass-in-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
  => [  exit  ] weight = 67108864, succ = BB2[_Z5solvev.exit]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[_Z5solvev.exit]
compute-loop-scale: BB1[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body.i]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body.i]
 - node: BB1[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[_Z5solvev.exit]
 - node: BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body.i]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body.i]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body.i]: float = 32.0, scaled = 256.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body.i]: float = 32.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.1
4: %bb.0
Found roots: %bb.2 
**** Analysing main
Look into: 0 entry
Frame instruction: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

No Shrink wrap candidate found
alloc FI(0) at SP[-32]
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: Copy is used - not dead:   $edi = COPY renamable $eax, implicit killed $rax
MCP: BackwardCopyPropagateBlock for.body.i
MCP: ForwardCopyPropagateBlock for.body.i
MCP: BackwardCopyPropagateBlock _Z5solvev.exit
MCP: ForwardCopyPropagateBlock _Z5solvev.exit
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
real copy:   $edi = COPY renamable $eax, implicit killed $rax
replaced by: $edi = MOV32rr $eax, implicit killed $rax

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.i]
 - 2: BB2[_Z5solvev.exit]
loop-detection
 - loop = BB1[for.body.i]
compute-mass-in-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
  => [  exit  ] weight = 67108864, succ = BB2[_Z5solvev.exit]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[_Z5solvev.exit]
compute-loop-scale: BB1[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[for.body.i]*
 - node: BB1[for.body.i]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body.i]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body.i]
 - node: BB1[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[_Z5solvev.exit]
 - node: BB2[_Z5solvev.exit]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[for.body.i]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[for.body.i]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
 - BB1[for.body.i]: float = 32.0, scaled = 256.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body.i]: float = 32.0, int = 255
 - BB2[_Z5solvev.exit]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.1
4: %bb.0
Found roots: %bb.2 
Pre-computing triangle chains.
Finding best loop top for: %bb.1 ('for.body.i')
    final top unchanged
Finding best loop exit for: %bb.1 ('for.body.i')
    exiting: %bb.1 ('for.body.i') -> %bb.2 ('_Z5solvev.exit') [L:0] (0.875)
    No other candidate exit blocks, using loop header
Selecting best successor for: %bb.1 ('for.body.i')
Finished forming chain for header block %bb.1 ('for.body.i')
          ... %bb.1 ('for.body.i')
Selecting best successor for: %bb.0 ('entry')
    Candidate: %bb.1 ('for.body.i'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.1 ('for.body.i')
Merging from %bb.0 ('entry') to %bb.1 ('for.body.i')
Selecting best successor for: %bb.1 ('for.body.i')
    Candidate: %bb.2 ('_Z5solvev.exit'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.2 ('_Z5solvev.exit')
Merging from %bb.1 ('for.body.i') to %bb.2 ('_Z5solvev.exit')
Selecting best successor for: %bb.2 ('_Z5solvev.exit')
Finished forming chain for header block %bb.0 ('entry')
[MBP] Function: main
Placing chain %bb.0 ('entry')
          ... %bb.1 ('for.body.i')
Updating terminators on %bb.0
          ... %bb.2 ('_Z5solvev.exit')
Updating terminators on %bb.1
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
$eip:	0	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eiz:	0	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$es:	0	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eip:	2	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eiz:	2	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$es:	2	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eip:	4	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$eiz:	4	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$es:	4	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$k7:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm0:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm1:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$dx:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$k7:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm0:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$mm1:	8	renamable $r14d = XOR32rr undef $r14d(tied-def 0), undef $r14d, implicit-def dead $eflags, implicit-def $r14
$cl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$cs:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$dl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$dx:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$cl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$cs:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$dl:	9	dead $edi = XOR32rr undef $edi(tied-def 0), undef $edi, implicit-def dead $eflags, implicit-def $rdi
$eip:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$eiz:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$es:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$hbp:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$noreg:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$ah:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$dh:	10	CALL64pcrel32 @time, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$cl:	11	$edi = MOV32rr $eax, implicit killed $rax
$cs:	11	$edi = MOV32rr $eax, implicit killed $rax
$dl:	11	$edi = MOV32rr $eax, implicit killed $rax
$eip:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$eiz:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$es:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$hbp:	12	CALL64pcrel32 @srand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit-def $rsp, implicit-def $ssp
$al:	13	renamable $ebx = MOV32ri 10000000
$ax:	13	renamable $ebx = MOV32ri 10000000
$dih:	13	renamable $ebx = MOV32ri 10000000
%bb.1: incomplete
$eip:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$eiz:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$es:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$hbp:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$noreg:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$ah:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$dh:	0	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$st5:	1	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$st5:	3	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$st5:	4	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$eip:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$eiz:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$es:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$hbp:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$noreg:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$ah:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$dh:	6	CALL64pcrel32 @rand, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
$st5:	7	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$st5:	8	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st6:	9	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$st6:	10	renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
$st5:	12	renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
$st5:	13	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$st6:	14	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$dx:	15	nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
$k7:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm0:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm1:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$dx:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$k7:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm0:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$mm1:	16	renamable $r14d = SBB32ri8 renamable $r14d(tied-def 0), -1, implicit-def dead $eflags, implicit killed $eflags, implicit killed $r14, implicit-def $r14
$al:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
$ax:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
$dih:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
$dx:	17	renamable $ebx = ADD32ri8 killed renamable $ebx(tied-def 0), -1, implicit-def $eflags
%bb.1: all preds known
%bb.2: all preds known
$st5:	0	renamable $xmm0 = CVTSI2SDrr renamable $r14d, implicit killed $r14
$st5:	1	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st5:	2	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$cl:	3	$edi = MOV32ri @.str, implicit-def $rdi
$cs:	3	$edi = MOV32ri @.str, implicit-def $rdi
$dl:	3	$edi = MOV32ri @.str, implicit-def $rdi
$cl:	3	$edi = MOV32ri @.str, implicit-def $rdi
$cs:	3	$edi = MOV32ri @.str, implicit-def $rdi
$dl:	3	$edi = MOV32ri @.str, implicit-def $rdi
$ah:	4	$al = MOV8ri 1
$eip:	5	CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
$eiz:	5	CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
$es:	5	CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
$hbp:	5	CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
$noreg:	5	CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
$ah:	5	CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
$dh:	5	CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax
$noreg:	6	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$ah:	6	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$dh:	6	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$dx:	6	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$eip:	7	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$eiz:	7	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$es:	7	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$dx:	7	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 8, implicit-def dead $eflags
$al:	9	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$ax:	9	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$dih:	9	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	9	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	9	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	9	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$k7:	11	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm0:	11	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm1:	11	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	11	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	11	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	11	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
%bb.1: incomplete
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
%bb.1: all preds known
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = CVTSI2SDrr killed renamable $eax
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = nofpexcept MULSDrr killed renamable $xmm1(tied-def 0), renamable $xmm1, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
%bb.2: all preds known
$xmm0:	renamable $xmm0 = CVTSI2SDrr renamable $r14d, implicit killed $r14
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
********** BREAK FALSE DEPENDENCIES **********
Clearance: 7, want 64: Break dependency.
Clearance: 3, want 64: Break dependency.
Clearance: 6, want 64: Break dependency.
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: main **********

Debug Range Extension
X86 Indirect Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : main *****
assembler backend - pre-layout
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd5cd50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0xfce6410 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCAlignFragment<MCFragment 0xfdc29f0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdc2da0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[41,56,53,50,45,31,F6,31,FF,E8,00,00,00,00,89,C7,E8,00,00,00,00,BB,80,96,98,00] (26 bytes),
        Fixups:[<MCFixup Offset:10 Value:time-4 Kind:136>,
                <MCFixup Offset:17 Value:srand-4 Kind:136>]>,
      <MCAlignFragment<MCFragment 0xfdc2f20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdc3250 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,5E,05,00,00,00,00,F2,0F,10,0C,24,F2,0F,59,C9,F2,0F,11,0C,24,F2,0F,59,C0,F2,0F,58,04,24,F2,0F,10,0D,00,00,00,00,66,0F,2E,C8,41,83,DE,FF,83,C3,FF] (97 bytes),
        Fixups:[<MCFixup Offset:1 Value:rand-4 Kind:136>,
                <MCFixup Offset:26 Value:.LCPI0_0-4 Kind:128>,
                <MCFixup Offset:36 Value:rand-4 Kind:136>,
                <MCFixup Offset:51 Value:.LCPI0_0-4 Kind:128>,
                <MCFixup Offset:82 Value:.LCPI0_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0xfd329e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB0_1)> <MCOperand Imm:5>> (2 bytes)>,
      <MCDataFragment<MCFragment 0xfdce350 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,41,0F,2A,C6,F2,0F,5E,05,00,00,00,00,F2,0F,59,05,00,00,00,00,48,83,C4,08,5B,41,5E,C3] (32 bytes),
        Fixups:[<MCFixup Offset:12 Value:.LCPI0_2-4 Kind:128>,
                <MCFixup Offset:20 Value:.LCPI0_3-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0xfd97c60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdd0c60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[41,56,53,50,45,31,F6,31,FF,E8,00,00,00,00,89,C7,E8,00,00,00,00,BB,80,96,98,00] (26 bytes),
        Fixups:[<MCFixup Offset:10 Value:time-4 Kind:136>,
                <MCFixup Offset:17 Value:srand-4 Kind:136>]>,
      <MCAlignFragment<MCFragment 0xfdc2a50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdd0fe0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,5E,05,00,00,00,00,F2,0F,10,0C,24,F2,0F,59,C9,F2,0F,11,0C,24,F2,0F,59,C0,F2,0F,58,04,24,F2,0F,10,0D,00,00,00,00,66,0F,2E,C8,41,83,DE,FF,83,C3,FF] (97 bytes),
        Fixups:[<MCFixup Offset:1 Value:rand-4 Kind:136>,
                <MCFixup Offset:26 Value:.LCPI1_0-4 Kind:128>,
                <MCFixup Offset:36 Value:rand-4 Kind:136>,
                <MCFixup Offset:51 Value:.LCPI1_0-4 Kind:128>,
                <MCFixup Offset:82 Value:.LCPI1_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0xfc72e50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB1_1)> <MCOperand Imm:5>> (2 bytes)>,
      <MCDataFragment<MCFragment 0xfdd1160 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,41,0F,2A,C6,F2,0F,5E,05,00,00,00,00,F2,0F,59,05,00,00,00,00,BF,00,00,00,00,B0,01,E8,00,00,00,00,31,C0,48,83,C4,08,5B,41,5E,C3] (46 bytes),
        Fixups:[<MCFixup Offset:12 Value:.LCPI1_2-4 Kind:128>,
                <MCFixup Offset:20 Value:.LCPI1_3-4 Kind:128>,
                <MCFixup Offset:25 Value:.L.str Kind:3>,
                <MCFixup Offset:32 Value:printf-4 Kind:136>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd62fa0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0xfd797e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdbf330 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd79720 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf420 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,C0,FF,FF,FF,DF,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd79780 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf510 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd9e250 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf600 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd9e1f0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2570 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd796c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2660 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,D0,12,63,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd82480 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2750 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfdc2840 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc28a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfdc2990 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0xfd880e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdc5c80 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd9fc90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfd96480 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,C0,FF,FF,FF,DF,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfdc5bc0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfd9f650 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd97d30 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2b20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd88200 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2db0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd881a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2ea0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,D0,12,63,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd869a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2f90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd87ee0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd3080 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd88140 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd82710 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0A,CF,80,E2,89,92,25,6C,66,0A,00] (11 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfdd1250 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,63,6C,61,6E,67,20,76,65,72,73,69,6F,6E,20,31,32,2E,30,2E,30,20,28,68,74,74,70,73,3A,2F,2F,67,69,74,68,75,62,2E,63,6F,6D,2F,6C,6C,76,6D,2F,6C,6C,76,6D,2D,70,72,6F,6A,65,63,74,2E,67,69,74,20,34,39,39,30,31,34,31,61,34,33,36,36,65,62,30,30,61,62,64,63,38,32,35,32,64,37,63,62,62,38,61,64,65,61,63,62,39,39,35,34,29,00] (106 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfdd1570 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd70f10 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,1B,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-4 Kind:3>]>,
      <MCAlignFragment<MCFragment 0xfdc5c20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0xfdd2370 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdabf90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdd2460 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd9f9d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdd2550 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdac180 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd971b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3ce0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd972a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3a50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97390 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd39b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97480 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3c40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97570 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd9fa70 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97660 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0xfd97750 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0xfdbf7d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd977b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbf8c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbf9b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfa50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfb40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfbe0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfcd0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfd70 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfe60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbff00 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfff0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc0090 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdc0180 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc0220 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdc0310 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc03b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0xfdc04a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdc0500 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(.text, Index:0, ),
           (.rodata.cst8, Index:0, ),
           (.LCPI0_0, Index:0, ),
           (.LCPI0_1, Index:0, ),
           (.LCPI0_2, Index:0, ),
           (.LCPI0_3, Index:0, ),
           (_Z5solvev, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (time, Index:0, ),
           (srand, Index:0, ),
           (.LBB0_1, Index:0, ),
           (rand, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI1_0, Index:0, ),
           (.LCPI1_1, Index:0, ),
           (.LCPI1_2, Index:0, ),
           (.LCPI1_3, Index:0, ),
           (main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB1_1, Index:0, ),
           (.L.str, Index:0, ),
           (printf, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.rodata.str1.1, Index:0, ),
           (.comment, Index:0, ),
           (.note.GNU-stack, Index:0, ),
           (.eh_frame, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
assembler backend - post-relaxation
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd5cd50 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0xfce6410 LayoutOrder:1 Offset:0 HasInstructions:0> (emit nops)
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCAlignFragment<MCFragment 0xfdc29f0 LayoutOrder:2 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdc2da0 LayoutOrder:3 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[41,56,53,50,45,31,F6,31,FF,E8,00,00,00,00,89,C7,E8,00,00,00,00,BB,80,96,98,00] (26 bytes),
        Fixups:[<MCFixup Offset:10 Value:time-4 Kind:136>,
                <MCFixup Offset:17 Value:srand-4 Kind:136>]>,
      <MCAlignFragment<MCFragment 0xfdc2f20 LayoutOrder:4 Offset:26 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdc3250 LayoutOrder:5 Offset:32 HasInstructions:1 BundlePadding:0>
        Contents:[E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,5E,05,00,00,00,00,F2,0F,10,0C,24,F2,0F,59,C9,F2,0F,11,0C,24,F2,0F,59,C0,F2,0F,58,04,24,F2,0F,10,0D,00,00,00,00,66,0F,2E,C8,41,83,DE,FF,83,C3,FF] (97 bytes),
        Fixups:[<MCFixup Offset:1 Value:rand-4 Kind:136>,
                <MCFixup Offset:26 Value:.LCPI0_0-4 Kind:128>,
                <MCFixup Offset:36 Value:rand-4 Kind:136>,
                <MCFixup Offset:51 Value:.LCPI0_0-4 Kind:128>,
                <MCFixup Offset:82 Value:.LCPI0_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0xfd329e0 LayoutOrder:6 Offset:129 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB0_1)> <MCOperand Imm:5>> (2 bytes)>,
      <MCDataFragment<MCFragment 0xfdce350 LayoutOrder:7 Offset:131 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,41,0F,2A,C6,F2,0F,5E,05,00,00,00,00,F2,0F,59,05,00,00,00,00,48,83,C4,08,5B,41,5E,C3] (32 bytes),
        Fixups:[<MCFixup Offset:12 Value:.LCPI0_2-4 Kind:128>,
                <MCFixup Offset:20 Value:.LCPI0_3-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0xfd97c60 LayoutOrder:8 Offset:163 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdd0c60 LayoutOrder:9 Offset:176 HasInstructions:1 BundlePadding:0>
        Contents:[41,56,53,50,45,31,F6,31,FF,E8,00,00,00,00,89,C7,E8,00,00,00,00,BB,80,96,98,00] (26 bytes),
        Fixups:[<MCFixup Offset:10 Value:time-4 Kind:136>,
                <MCFixup Offset:17 Value:srand-4 Kind:136>]>,
      <MCAlignFragment<MCFragment 0xfdc2a50 LayoutOrder:10 Offset:202 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdd0fe0 LayoutOrder:11 Offset:208 HasInstructions:1 BundlePadding:0>
        Contents:[E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,5E,05,00,00,00,00,F2,0F,10,0C,24,F2,0F,59,C9,F2,0F,11,0C,24,F2,0F,59,C0,F2,0F,58,04,24,F2,0F,10,0D,00,00,00,00,66,0F,2E,C8,41,83,DE,FF,83,C3,FF] (97 bytes),
        Fixups:[<MCFixup Offset:1 Value:rand-4 Kind:136>,
                <MCFixup Offset:26 Value:.LCPI1_0-4 Kind:128>,
                <MCFixup Offset:36 Value:rand-4 Kind:136>,
                <MCFixup Offset:51 Value:.LCPI1_0-4 Kind:128>,
                <MCFixup Offset:82 Value:.LCPI1_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0xfc72e50 LayoutOrder:12 Offset:305 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB1_1)> <MCOperand Imm:5>> (2 bytes)>,
      <MCDataFragment<MCFragment 0xfdd1160 LayoutOrder:13 Offset:307 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,41,0F,2A,C6,F2,0F,5E,05,00,00,00,00,F2,0F,59,05,00,00,00,00,BF,00,00,00,00,B0,01,E8,00,00,00,00,31,C0,48,83,C4,08,5B,41,5E,C3] (46 bytes),
        Fixups:[<MCFixup Offset:12 Value:.LCPI1_2-4 Kind:128>,
                <MCFixup Offset:20 Value:.LCPI1_3-4 Kind:128>,
                <MCFixup Offset:25 Value:.L.str Kind:3>,
                <MCFixup Offset:32 Value:printf-4 Kind:136>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd62fa0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0xfd797e0 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdbf330 LayoutOrder:2 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd79720 LayoutOrder:3 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf420 LayoutOrder:4 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,C0,FF,FF,FF,DF,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd79780 LayoutOrder:5 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf510 LayoutOrder:6 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd9e250 LayoutOrder:7 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf600 LayoutOrder:8 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd9e1f0 LayoutOrder:9 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2570 LayoutOrder:10 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd796c0 LayoutOrder:11 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2660 LayoutOrder:12 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,D0,12,63,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd82480 LayoutOrder:13 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2750 LayoutOrder:14 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfdc2840 LayoutOrder:15 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc28a0 LayoutOrder:16 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfdc2990 LayoutOrder:17 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0xfd880e0 LayoutOrder:18 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdc5c80 LayoutOrder:19 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd9fc90 LayoutOrder:20 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfd96480 LayoutOrder:21 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,C0,FF,FF,FF,DF,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfdc5bc0 LayoutOrder:22 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfd9f650 LayoutOrder:23 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd97d30 LayoutOrder:24 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2b20 LayoutOrder:25 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd88200 LayoutOrder:26 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2db0 LayoutOrder:27 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd881a0 LayoutOrder:28 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2ea0 LayoutOrder:29 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,D0,12,63,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd869a0 LayoutOrder:30 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2f90 LayoutOrder:31 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd87ee0 LayoutOrder:32 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd3080 LayoutOrder:33 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd88140 LayoutOrder:34 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd82710 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0A,CF,80,E2,89,92,25,6C,66,0A,00] (11 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfdd1250 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,63,6C,61,6E,67,20,76,65,72,73,69,6F,6E,20,31,32,2E,30,2E,30,20,28,68,74,74,70,73,3A,2F,2F,67,69,74,68,75,62,2E,63,6F,6D,2F,6C,6C,76,6D,2F,6C,6C,76,6D,2D,70,72,6F,6A,65,63,74,2E,67,69,74,20,34,39,39,30,31,34,31,61,34,33,36,36,65,62,30,30,61,62,64,63,38,32,35,32,64,37,63,62,62,38,61,64,65,61,63,62,39,39,35,34,29,00] (106 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfdd1570 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd70f10 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,1B,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-4 Kind:3>]>,
      <MCAlignFragment<MCFragment 0xfdc5c20 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0xfdd2370 LayoutOrder:2 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdabf90 LayoutOrder:3 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdd2460 LayoutOrder:4 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd9f9d0 LayoutOrder:5 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdd2550 LayoutOrder:6 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdac180 LayoutOrder:7 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd971b0 LayoutOrder:8 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3ce0 LayoutOrder:9 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd972a0 LayoutOrder:10 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3a50 LayoutOrder:11 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97390 LayoutOrder:12 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd39b0 LayoutOrder:13 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97480 LayoutOrder:14 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3c40 LayoutOrder:15 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97570 LayoutOrder:16 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd9fa70 LayoutOrder:17 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97660 LayoutOrder:18 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0xfd97750 LayoutOrder:19 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0xfdbf7d0 LayoutOrder:20 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd977b0 LayoutOrder:21 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbf8c0 LayoutOrder:22 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbf9b0 LayoutOrder:23 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfa50 LayoutOrder:24 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfb40 LayoutOrder:25 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfbe0 LayoutOrder:26 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfcd0 LayoutOrder:27 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfd70 LayoutOrder:28 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfe60 LayoutOrder:29 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbff00 LayoutOrder:30 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfff0 LayoutOrder:31 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc0090 LayoutOrder:32 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdc0180 LayoutOrder:33 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc0220 LayoutOrder:34 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdc0310 LayoutOrder:35 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc03b0 LayoutOrder:36 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0xfdc04a0 LayoutOrder:37 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdc0500 LayoutOrder:38 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(.text, Index:0, ),
           (.rodata.cst8, Index:0, ),
           (.LCPI0_0, Index:0, ),
           (.LCPI0_1, Index:0, ),
           (.LCPI0_2, Index:0, ),
           (.LCPI0_3, Index:0, ),
           (_Z5solvev, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (time, Index:0, ),
           (srand, Index:0, ),
           (.LBB0_1, Index:0, ),
           (rand, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI1_0, Index:0, ),
           (.LCPI1_1, Index:0, ),
           (.LCPI1_2, Index:0, ),
           (.LCPI1_3, Index:0, ),
           (main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB1_1, Index:0, ),
           (.L.str, Index:0, ),
           (printf, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.rodata.str1.1, Index:0, ),
           (.comment, Index:0, ),
           (.note.GNU-stack, Index:0, ),
           (.eh_frame, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
assembler backend - final-layout
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd5cd50 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0xfce6410 LayoutOrder:1 Offset:0 HasInstructions:0> (emit nops)
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCAlignFragment<MCFragment 0xfdc29f0 LayoutOrder:2 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdc2da0 LayoutOrder:3 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[41,56,53,50,45,31,F6,31,FF,E8,00,00,00,00,89,C7,E8,00,00,00,00,BB,80,96,98,00] (26 bytes),
        Fixups:[<MCFixup Offset:10 Value:time-4 Kind:136>,
                <MCFixup Offset:17 Value:srand-4 Kind:136>]>,
      <MCAlignFragment<MCFragment 0xfdc2f20 LayoutOrder:4 Offset:26 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdc3250 LayoutOrder:5 Offset:32 HasInstructions:1 BundlePadding:0>
        Contents:[E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,5E,05,00,00,00,00,F2,0F,10,0C,24,F2,0F,59,C9,F2,0F,11,0C,24,F2,0F,59,C0,F2,0F,58,04,24,F2,0F,10,0D,00,00,00,00,66,0F,2E,C8,41,83,DE,FF,83,C3,FF] (97 bytes),
        Fixups:[<MCFixup Offset:1 Value:rand-4 Kind:136>,
                <MCFixup Offset:26 Value:.LCPI0_0-4 Kind:128>,
                <MCFixup Offset:36 Value:rand-4 Kind:136>,
                <MCFixup Offset:51 Value:.LCPI0_0-4 Kind:128>,
                <MCFixup Offset:82 Value:.LCPI0_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0xfd329e0 LayoutOrder:6 Offset:129 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB0_1)> <MCOperand Imm:5>> (2 bytes)>,
      <MCDataFragment<MCFragment 0xfdce350 LayoutOrder:7 Offset:131 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,41,0F,2A,C6,F2,0F,5E,05,00,00,00,00,F2,0F,59,05,00,00,00,00,48,83,C4,08,5B,41,5E,C3] (32 bytes),
        Fixups:[<MCFixup Offset:12 Value:.LCPI0_2-4 Kind:128>,
                <MCFixup Offset:20 Value:.LCPI0_3-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0xfd97c60 LayoutOrder:8 Offset:163 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdd0c60 LayoutOrder:9 Offset:176 HasInstructions:1 BundlePadding:0>
        Contents:[41,56,53,50,45,31,F6,31,FF,E8,00,00,00,00,89,C7,E8,00,00,00,00,BB,80,96,98,00] (26 bytes),
        Fixups:[<MCFixup Offset:10 Value:time-4 Kind:136>,
                <MCFixup Offset:17 Value:srand-4 Kind:136>]>,
      <MCAlignFragment<MCFragment 0xfdc2a50 LayoutOrder:10 Offset:202 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0xfdd0fe0 LayoutOrder:11 Offset:208 HasInstructions:1 BundlePadding:0>
        Contents:[E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,E8,00,00,00,00,0F,57,C0,F2,0F,2A,C0,F2,0F,5E,05,00,00,00,00,F2,0F,10,0C,24,F2,0F,59,C9,F2,0F,11,0C,24,F2,0F,59,C0,F2,0F,58,04,24,F2,0F,10,0D,00,00,00,00,66,0F,2E,C8,41,83,DE,FF,83,C3,FF] (97 bytes),
        Fixups:[<MCFixup Offset:1 Value:rand-4 Kind:136>,
                <MCFixup Offset:26 Value:.LCPI1_0-4 Kind:128>,
                <MCFixup Offset:36 Value:rand-4 Kind:136>,
                <MCFixup Offset:51 Value:.LCPI1_0-4 Kind:128>,
                <MCFixup Offset:82 Value:.LCPI1_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0xfc72e50 LayoutOrder:12 Offset:305 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB1_1)> <MCOperand Imm:5>> (2 bytes)>,
      <MCDataFragment<MCFragment 0xfdd1160 LayoutOrder:13 Offset:307 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,41,0F,2A,C6,F2,0F,5E,05,00,00,00,00,F2,0F,59,05,00,00,00,00,BF,00,00,00,00,B0,01,E8,00,00,00,00,31,C0,48,83,C4,08,5B,41,5E,C3] (46 bytes),
        Fixups:[<MCFixup Offset:12 Value:.LCPI1_2-4 Kind:128>,
                <MCFixup Offset:20 Value:.LCPI1_3-4 Kind:128>,
                <MCFixup Offset:25 Value:.L.str Kind:3>,
                <MCFixup Offset:32 Value:printf-4 Kind:136>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd62fa0 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0xfd797e0 LayoutOrder:1 Offset:0 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdbf330 LayoutOrder:2 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd79720 LayoutOrder:3 Offset:0 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf420 LayoutOrder:4 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,C0,FF,FF,FF,DF,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd79780 LayoutOrder:5 Offset:8 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf510 LayoutOrder:6 Offset:8 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd9e250 LayoutOrder:7 Offset:8 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdbf600 LayoutOrder:8 Offset:8 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd9e1f0 LayoutOrder:9 Offset:16 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2570 LayoutOrder:10 Offset:16 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd796c0 LayoutOrder:11 Offset:16 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2660 LayoutOrder:12 Offset:16 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,D0,12,63,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd82480 LayoutOrder:13 Offset:24 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc2750 LayoutOrder:14 Offset:24 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfdc2840 LayoutOrder:15 Offset:24 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdc28a0 LayoutOrder:16 Offset:24 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfdc2990 LayoutOrder:17 Offset:32 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0xfd880e0 LayoutOrder:18 Offset:32 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdc5c80 LayoutOrder:19 Offset:32 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd9fc90 LayoutOrder:20 Offset:32 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfd96480 LayoutOrder:21 Offset:32 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,C0,FF,FF,FF,DF,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfdc5bc0 LayoutOrder:22 Offset:40 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfd9f650 LayoutOrder:23 Offset:40 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd97d30 LayoutOrder:24 Offset:40 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2b20 LayoutOrder:25 Offset:40 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd88200 LayoutOrder:26 Offset:48 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2db0 LayoutOrder:27 Offset:48 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd881a0 LayoutOrder:28 Offset:48 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2ea0 LayoutOrder:29 Offset:48 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,D0,12,63,41] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd869a0 LayoutOrder:30 Offset:56 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd2f90 LayoutOrder:31 Offset:56 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0xfd87ee0 LayoutOrder:32 Offset:56 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0xfdd3080 LayoutOrder:33 Offset:56 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0xfd88140 LayoutOrder:34 Offset:64 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd82710 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[0A,CF,80,E2,89,92,25,6C,66,0A,00] (11 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfdd1250 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,63,6C,61,6E,67,20,76,65,72,73,69,6F,6E,20,31,32,2E,30,2E,30,20,28,68,74,74,70,73,3A,2F,2F,67,69,74,68,75,62,2E,63,6F,6D,2F,6C,6C,76,6D,2F,6C,6C,76,6D,2D,70,72,6F,6A,65,63,74,2E,67,69,74,20,34,39,39,30,31,34,31,61,34,33,36,36,65,62,30,30,61,62,64,63,38,32,35,32,64,37,63,62,62,38,61,64,65,61,63,62,39,39,35,34,29,00] (106 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfdd1570 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0xfd70f10 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,1B,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-4 Kind:3>]>,
      <MCAlignFragment<MCFragment 0xfdc5c20 LayoutOrder:1 Offset:22 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0xfdd2370 LayoutOrder:2 Offset:24 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdabf90 LayoutOrder:3 Offset:41 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdd2460 LayoutOrder:4 Offset:42 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd9f9d0 LayoutOrder:5 Offset:44 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdd2550 LayoutOrder:6 Offset:45 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdac180 LayoutOrder:7 Offset:47 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd971b0 LayoutOrder:8 Offset:48 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3ce0 LayoutOrder:9 Offset:50 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd972a0 LayoutOrder:10 Offset:50 HasInstructions:0 BundlePadding:0>
        Contents:[83,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3a50 LayoutOrder:11 Offset:52 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97390 LayoutOrder:12 Offset:52 HasInstructions:0 BundlePadding:0>
        Contents:[8E,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd39b0 LayoutOrder:13 Offset:54 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97480 LayoutOrder:14 Offset:56 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdd3c40 LayoutOrder:15 Offset:58 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97570 LayoutOrder:16 Offset:59 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd9fa70 LayoutOrder:17 Offset:61 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfd97660 LayoutOrder:18 Offset:62 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0xfd97750 LayoutOrder:19 Offset:64 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0xfdbf7d0 LayoutOrder:20 Offset:64 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0xfd977b0 LayoutOrder:21 Offset:81 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbf8c0 LayoutOrder:22 Offset:82 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbf9b0 LayoutOrder:23 Offset:84 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfa50 LayoutOrder:24 Offset:85 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfb40 LayoutOrder:25 Offset:87 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfbe0 LayoutOrder:26 Offset:88 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfcd0 LayoutOrder:27 Offset:90 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbfd70 LayoutOrder:28 Offset:90 HasInstructions:0 BundlePadding:0>
        Contents:[83,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfe60 LayoutOrder:29 Offset:92 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdbff00 LayoutOrder:30 Offset:92 HasInstructions:0 BundlePadding:0>
        Contents:[8E,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdbfff0 LayoutOrder:31 Offset:94 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc0090 LayoutOrder:32 Offset:96 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdc0180 LayoutOrder:33 Offset:98 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc0220 LayoutOrder:34 Offset:99 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0xfdc0310 LayoutOrder:35 Offset:101 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0xfdc03b0 LayoutOrder:36 Offset:102 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0xfdc04a0 LayoutOrder:37 Offset:104 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0xfdc0500 LayoutOrder:38 Offset:104 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(.text, Index:0, ),
           (.rodata.cst8, Index:0, ),
           (.LCPI0_0, Index:0, ),
           (.LCPI0_1, Index:0, ),
           (.LCPI0_2, Index:0, ),
           (.LCPI0_3, Index:0, ),
           (_Z5solvev, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (time, Index:0, ),
           (srand, Index:0, ),
           (.LBB0_1, Index:0, ),
           (rand, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI1_0, Index:0, ),
           (.LCPI1_1, Index:0, ),
           (.LCPI1_2, Index:0, ),
           (.LCPI1_3, Index:0, ),
           (main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB1_1, Index:0, ),
           (.L.str, Index:0, ),
           (printf, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.rodata.str1.1, Index:0, ),
           (.comment, Index:0, ),
           (.note.GNU-stack, Index:0, ),
           (.eh_frame, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
