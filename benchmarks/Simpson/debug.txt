Args: clang (LLVM option parsing) -regalloc=basic -debug 
Args: clang 

Features:+64bit-mode,-32bit-mode,-16bit-mode,+sse2,+cx8,+fxsr,+mmx,+sse,+sse2,+x87
CPU:x86-64
TuneCPU:generic

Subtarget features: SSELevel 2, 3DNowLevel 1, 64bit 1
G_ADD (opcode 39): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SUB (opcode 40): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MUL (opcode 41): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIV (opcode 42): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UDIV (opcode 43): 1 type index, 0 imm indices
.. opcode 43 is aliased to 42
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SREM (opcode 44): 1 type index, 0 imm indices
.. opcode 44 is aliased to 42
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UREM (opcode 45): 1 type index, 0 imm indices
.. opcode 45 is aliased to 42
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_AND (opcode 46): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_OR (opcode 47): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_XOR (opcode 48): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_IMPLICIT_DEF (opcode 49): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PHI (opcode 50): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRAME_INDEX (opcode 51): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_GLOBAL_VALUE (opcode 52): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT (opcode 53): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 54): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT (opcode 55): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 56): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR (opcode 57): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR_TRUNC (opcode 58): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONCAT_VECTORS (opcode 59): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 60): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_INTTOPTR (opcode 61): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_BITCAST (opcode 62): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREEZE (opcode 63): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_TRUNC (opcode 64): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUND (opcode 65): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_LRINT (opcode 66): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUNDEVEN (opcode 67): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_READCYCLECOUNTER (opcode 68): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LOAD (opcode 69): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXTLOAD (opcode 70): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 71): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_LOAD (opcode 72): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_SEXTLOAD (opcode 73): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_ZEXTLOAD (opcode 74): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STORE (opcode 75): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_STORE (opcode 76): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 77): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 78): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 79): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 80): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 81): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 82): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 83): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 84): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 85): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 86): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 87): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 88): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 89): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FADD (opcode 90): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FSUB (opcode 91): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FENCE (opcode 92): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 93): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRINDIRECT (opcode 94): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 95): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 96): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 97): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_TRUNC (opcode 98): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 99): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCONSTANT (opcode 100): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VASTART (opcode 101): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VAARG (opcode 102): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT (opcode 103): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT_INREG (opcode 104): 1 type index, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_ZEXT (opcode 105): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHL (opcode 106): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_LSHR (opcode 107): 2 type indices, 0 imm indices
.. opcode 107 is aliased to 106
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_ASHR (opcode 108): 2 type indices, 0 imm indices
.. opcode 108 is aliased to 106
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FSHL (opcode 109): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSHR (opcode 110): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ICMP (opcode 111): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FCMP (opcode 112): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SELECT (opcode 113): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDO (opcode 114): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDE (opcode 115): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBO (opcode 116): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBE (opcode 117): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDO (opcode 118): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDE (opcode 119): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 120): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBE (opcode 121): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULO (opcode 122): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULO (opcode 123): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULH (opcode 124): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULH (opcode 125): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDSAT (opcode 126): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDSAT (opcode 127): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBSAT (opcode 128): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBSAT (opcode 129): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USHLSAT (opcode 130): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSHLSAT (opcode 131): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIX (opcode 132): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIX (opcode 133): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIXSAT (opcode 134): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIXSAT (opcode 135): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIX (opcode 136): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIX (opcode 137): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIXSAT (opcode 138): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIXSAT (opcode 139): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FADD (opcode 140): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSUB (opcode 141): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMUL (opcode 142): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMA (opcode 143): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAD (opcode 144): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FDIV (opcode 145): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREM (opcode 146): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOW (opcode 147): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPOWI (opcode 148): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP (opcode 149): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 150): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG (opcode 151): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 152): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG10 (opcode 153): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEG (opcode 154): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 155): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTRUNC (opcode 156): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPTOSI (opcode 157): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOUI (opcode 158): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SITOFP (opcode 159): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UITOFP (opcode 160): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FABS (opcode 161): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOPYSIGN (opcode 162): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCANONICALIZE (opcode 163): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM (opcode 164): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM (opcode 165): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM_IEEE (opcode 166): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM_IEEE (opcode 167): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINIMUM (opcode 168): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXIMUM (opcode 169): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTR_ADD (opcode 170): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRMASK (opcode 171): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMIN (opcode 172): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMAX (opcode 173): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMIN (opcode 174): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMAX (opcode 175): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ABS (opcode 176): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BR (opcode 177): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRJT (opcode 178): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 179): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 180): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 181): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ (opcode 182): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ_ZERO_UNDEF (opcode 183): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ (opcode 184): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ_ZERO_UNDEF (opcode 185): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTPOP (opcode 186): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 187): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BITREVERSE (opcode 188): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCEIL (opcode 189): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOS (opcode 190): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSIN (opcode 191): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSQRT (opcode 192): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FFLOOR (opcode 193): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRINT (opcode 194): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEARBYINT (opcode 195): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 196): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 197): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_JUMP_TABLE (opcode 198): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_DYN_STACKALLOC (opcode 199): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FADD (opcode 200): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSUB (opcode 201): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMUL (opcode 202): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FDIV (opcode 203): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FREM (opcode 204): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMA (opcode 205): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSQRT (opcode 206): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READ_REGISTER (opcode 207): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_WRITE_REGISTER (opcode 208): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY (opcode 209): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMMOVE (opcode 210): 3 type indices, 1 imm index
.. opcode 210 is aliased to 209
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_MEMSET (opcode 211): 3 type indices, 1 imm index
.. opcode 211 is aliased to 209
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_VECREDUCE_SEQ_FADD (opcode 212): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FMUL (opcode 213): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FADD (opcode 214): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMUL (opcode 215): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMAX (opcode 216): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMIN (opcode 217): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_ADD (opcode 218): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_MUL (opcode 219): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_AND (opcode 220): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_OR (opcode 221): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_XOR (opcode 222): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMAX (opcode 223): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMIN (opcode 224): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMAX (opcode 225): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMIN (opcode 226): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
Merging: for.inc into for.body
SROA function: _Z7simpsonPFddEddi
SROA alloca:   %odd = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %odd = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #6
  [0,4) slice #1 (splittable)
    used by:   store i32 3, i32* %odd, align 4, !tbaa !8
  [0,4) slice #2 (splittable)
    used by:   %21 = load i32, i32* %odd, align 4, !tbaa !8
  [0,4) slice #3 (splittable)
    used by:   %25 = load i32, i32* %odd, align 4, !tbaa !8
  [0,4) slice #4 (splittable)
    used by:   store i32 %add14, i32* %odd, align 4, !tbaa !8
  [0,4) slice #5 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %odd = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %odd.0..sroa_cast)
  rewriting [0,4) slice #1 (splittable)
    original:   store i32 3, i32* %odd, align 4, !tbaa !8
          to:   store i32 3, i32* %odd, align 4, !tbaa !8
  rewriting [0,4) slice #2 (splittable)
    original:   %21 = load i32, i32* %odd, align 4, !tbaa !8
          to:   %odd.0.load = load i32, i32* %odd, align 4
  rewriting [0,4) slice #3 (splittable)
    original:   %25 = load i32, i32* %odd, align 4, !tbaa !8
          to:   %odd.0.load24 = load i32, i32* %odd, align 4
  rewriting [0,4) slice #4 (splittable)
    original:   store i32 %add14, i32* %odd, align 4, !tbaa !8
          to:   store i32 %add14, i32* %odd, align 4, !tbaa !8
  rewriting [0,4) slice #5 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %odd.0..sroa_cast25)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #6
Deleting dead instruction:   %33 = bitcast i32* %odd to i8*
Deleting dead instruction:   store i32 %add14, i32* %odd, align 4, !tbaa !8
Deleting dead instruction:   %25 = load i32, i32* %odd, align 4, !tbaa !8
Deleting dead instruction:   %21 = load i32, i32* %odd, align 4, !tbaa !8
Deleting dead instruction:   store i32 3, i32* %odd, align 4, !tbaa !8
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #6
Deleting dead instruction:   %4 = bitcast i32* %odd to i8*
SROA alloca:   %even = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %even = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #6
  [0,4) slice #1 (splittable)
    used by:   store i32 2, i32* %even, align 4, !tbaa !8
  [0,4) slice #2 (splittable)
    used by:   %11 = load i32, i32* %even, align 4, !tbaa !8
  [0,4) slice #3 (splittable)
    used by:   %15 = load i32, i32* %even, align 4, !tbaa !8
  [0,4) slice #4 (splittable)
    used by:   %22 = load i32, i32* %even, align 4, !tbaa !8
  [0,4) slice #5 (splittable)
    used by:   store i32 %add13, i32* %even, align 4, !tbaa !8
  [0,4) slice #6 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %even = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %even.0..sroa_cast)
  rewriting [0,4) slice #1 (splittable)
    original:   store i32 2, i32* %even, align 4, !tbaa !8
          to:   store i32 2, i32* %even, align 4, !tbaa !8
  rewriting [0,4) slice #2 (splittable)
    original:   %11 = load i32, i32* %even, align 4, !tbaa !8
          to:   %even.0.load = load i32, i32* %even, align 4
  rewriting [0,4) slice #3 (splittable)
    original:   %15 = load i32, i32* %even, align 4, !tbaa !8
          to:   %even.0.load26 = load i32, i32* %even, align 4
  rewriting [0,4) slice #4 (splittable)
    original:   %22 = load i32, i32* %even, align 4, !tbaa !8
          to:   %even.0.load27 = load i32, i32* %even, align 4
  rewriting [0,4) slice #5 (splittable)
    original:   store i32 %add13, i32* %even, align 4, !tbaa !8
          to:   store i32 %add13, i32* %even, align 4, !tbaa !8
  rewriting [0,4) slice #6 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %even.0..sroa_cast28)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #6
Deleting dead instruction:   %30 = bitcast i32* %even to i8*
Deleting dead instruction:   store i32 %add13, i32* %even, align 4, !tbaa !8
Deleting dead instruction:   %22 = load i32, i32* %even, align 4, !tbaa !8
Deleting dead instruction:   %15 = load i32, i32* %even, align 4, !tbaa !8
Deleting dead instruction:   %11 = load i32, i32* %even, align 4, !tbaa !8
Deleting dead instruction:   store i32 2, i32* %even, align 4, !tbaa !8
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #6
Deleting dead instruction:   %3 = bitcast i32* %even to i8*
SROA alloca:   %sum_odd = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %sum_odd = alloca double, align 8
  [0,8) slice #0
    used by:   store double %call, double* %sum_odd, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %18 = load double, double* %sum_odd, align 8, !tbaa !6
  [0,8) slice #2
    used by:   store double %add12, double* %sum_odd, align 8, !tbaa !6
  [0,8) slice #3
    used by:   %25 = load double, double* %sum_odd, align 8, !tbaa !6
  [0,8) slice #4 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
  [0,8) slice #5 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %26) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %sum_odd = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %call, double* %sum_odd, align 8, !tbaa !6
          to:   store double %call, double* %sum_odd, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %18 = load double, double* %sum_odd, align 8, !tbaa !6
          to:   %sum_odd.0. = load double, double* %sum_odd, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   store double %add12, double* %sum_odd, align 8, !tbaa !6
          to:   store double %add12, double* %sum_odd, align 8, !tbaa !6
  rewriting [0,8) slice #3
    original:   %25 = load double, double* %sum_odd, align 8, !tbaa !6
          to:   %sum_odd.0.29 = load double, double* %sum_odd, align 8, !tbaa !6
  rewriting [0,8) slice #4 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %sum_odd.0..sroa_cast)
  rewriting [0,8) slice #5 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %26) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %sum_odd.0..sroa_cast30)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %26) #6
Deleting dead instruction:   %26 = bitcast double* %sum_odd to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
Deleting dead instruction:   %2 = bitcast double* %sum_odd to i8*
Deleting dead instruction:   %24 = load double, double* %sum_odd, align 8, !tbaa !6
Deleting dead instruction:   store double %add12, double* %sum_odd, align 8, !tbaa !6
Deleting dead instruction:   %17 = load double, double* %sum_odd, align 8, !tbaa !6
Deleting dead instruction:   store double %call, double* %sum_odd, align 8, !tbaa !6
SROA alloca:   %sum_even = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %sum_even = alloca double, align 8
  [0,8) slice #0
    used by:   store double 0.000000e+00, double* %sum_even, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %13 = load double, double* %sum_even, align 8, !tbaa !6
  [0,8) slice #2
    used by:   store double %add7, double* %sum_even, align 8, !tbaa !6
  [0,8) slice #3
    used by:   %22 = load double, double* %sum_even, align 8, !tbaa !6
  [0,8) slice #4 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  [0,8) slice #5 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %sum_even = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double 0.000000e+00, double* %sum_even, align 8, !tbaa !6
          to:   store double 0.000000e+00, double* %sum_even, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %13 = load double, double* %sum_even, align 8, !tbaa !6
          to:   %sum_even.0. = load double, double* %sum_even, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   store double %add7, double* %sum_even, align 8, !tbaa !6
          to:   store double %add7, double* %sum_even, align 8, !tbaa !6
  rewriting [0,8) slice #3
    original:   %22 = load double, double* %sum_even, align 8, !tbaa !6
          to:   %sum_even.0.31 = load double, double* %sum_even, align 8, !tbaa !6
  rewriting [0,8) slice #4 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %sum_even.0..sroa_cast)
  rewriting [0,8) slice #5 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %sum_even.0..sroa_cast32)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #6
Deleting dead instruction:   %23 = bitcast double* %sum_even to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
Deleting dead instruction:   %1 = bitcast double* %sum_even to i8*
Deleting dead instruction:   %21 = load double, double* %sum_even, align 8, !tbaa !6
Deleting dead instruction:   store double %add7, double* %sum_even, align 8, !tbaa !6
Deleting dead instruction:   %12 = load double, double* %sum_even, align 8, !tbaa !6
Deleting dead instruction:   store double 0.000000e+00, double* %sum_even, align 8, !tbaa !6
SROA alloca:   %h = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %h = alloca double, align 8
  [0,8) slice #0
    used by:   store double %div1, double* %h, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %7 = load double, double* %h, align 8, !tbaa !6
  [0,8) slice #2
    used by:   %11 = load double, double* %h, align 8, !tbaa !6
  [0,8) slice #3
    used by:   %14 = load double, double* %h, align 8, !tbaa !6
  [0,8) slice #4
    used by:   %15 = load double, double* %h, align 8, !tbaa !6
  [0,8) slice #5 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  [0,8) slice #6 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %h = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %div1, double* %h, align 8, !tbaa !6
          to:   store double %div1, double* %h, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %7 = load double, double* %h, align 8, !tbaa !6
          to:   %h.0. = load double, double* %h, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   %11 = load double, double* %h, align 8, !tbaa !6
          to:   %h.0.33 = load double, double* %h, align 8, !tbaa !6
  rewriting [0,8) slice #3
    original:   %14 = load double, double* %h, align 8, !tbaa !6
          to:   %h.0.34 = load double, double* %h, align 8, !tbaa !6
  rewriting [0,8) slice #4
    original:   %15 = load double, double* %h, align 8, !tbaa !6
          to:   %h.0.35 = load double, double* %h, align 8, !tbaa !6
  rewriting [0,8) slice #5 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %h.0..sroa_cast)
  rewriting [0,8) slice #6 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %h.0..sroa_cast36)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #6
Deleting dead instruction:   %20 = bitcast double* %h to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
Deleting dead instruction:   %0 = bitcast double* %h to i8*
Deleting dead instruction:   %14 = load double, double* %h, align 8, !tbaa !6
Deleting dead instruction:   %13 = load double, double* %h, align 8, !tbaa !6
Deleting dead instruction:   %10 = load double, double* %h, align 8, !tbaa !6
Deleting dead instruction:   %6 = load double, double* %h, align 8, !tbaa !6
Deleting dead instruction:   store double %div1, double* %h, align 8, !tbaa !6
SROA alloca:   %n.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %n.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %n, i32* %n.addr, align 4, !tbaa !8
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %n.addr, align 4, !tbaa !8
  [0,4) slice #2 (splittable)
    used by:   store i32 %mul, i32* %n.addr, align 4, !tbaa !8
  [0,4) slice #3 (splittable)
    used by:   %3 = load i32, i32* %n.addr, align 4, !tbaa !8
  [0,4) slice #4 (splittable)
    used by:   %6 = load i32, i32* %n.addr, align 4, !tbaa !8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %n.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %n, i32* %n.addr, align 4, !tbaa !8
          to:   store i32 %n, i32* %n.addr, align 4, !tbaa !8
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %n.addr, align 4, !tbaa !8
          to:   %n.addr.0.load = load i32, i32* %n.addr, align 4
  rewriting [0,4) slice #2 (splittable)
    original:   store i32 %mul, i32* %n.addr, align 4, !tbaa !8
          to:   store i32 %mul, i32* %n.addr, align 4, !tbaa !8
  rewriting [0,4) slice #3 (splittable)
    original:   %3 = load i32, i32* %n.addr, align 4, !tbaa !8
          to:   %n.addr.0.load37 = load i32, i32* %n.addr, align 4
  rewriting [0,4) slice #4 (splittable)
    original:   %6 = load i32, i32* %n.addr, align 4, !tbaa !8
          to:   %n.addr.0.load38 = load i32, i32* %n.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %6 = load i32, i32* %n.addr, align 4, !tbaa !8
Deleting dead instruction:   %3 = load i32, i32* %n.addr, align 4, !tbaa !8
Deleting dead instruction:   store i32 %mul, i32* %n.addr, align 4, !tbaa !8
Deleting dead instruction:   %0 = load i32, i32* %n.addr, align 4, !tbaa !8
Deleting dead instruction:   store i32 %n, i32* %n.addr, align 4, !tbaa !8
SROA alloca:   %b.addr = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %b.addr = alloca double, align 8
  [0,8) slice #0
    used by:   store double %b, double* %b.addr, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %0 = load double, double* %b.addr, align 8, !tbaa !6
  [0,8) slice #2
    used by:   %11 = load double, double* %b.addr, align 8, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %b.addr = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %b, double* %b.addr, align 8, !tbaa !6
          to:   store double %b, double* %b.addr, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %0 = load double, double* %b.addr, align 8, !tbaa !6
          to:   %b.addr.0. = load double, double* %b.addr, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   %11 = load double, double* %b.addr, align 8, !tbaa !6
          to:   %b.addr.0.39 = load double, double* %b.addr, align 8, !tbaa !6
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %11 = load double, double* %b.addr, align 8, !tbaa !6
Deleting dead instruction:   %0 = load double, double* %b.addr, align 8, !tbaa !6
Deleting dead instruction:   store double %b, double* %b.addr, align 8, !tbaa !6
SROA alloca:   %a.addr = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %a.addr = alloca double, align 8
  [0,8) slice #0
    used by:   store double %a, double* %a.addr, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %0 = load double, double* %a.addr, align 8, !tbaa !6
  [0,8) slice #2
    used by:   %2 = load double, double* %a.addr, align 8, !tbaa !6
  [0,8) slice #3
    used by:   %4 = load double, double* %a.addr, align 8, !tbaa !6
  [0,8) slice #4
    used by:   %6 = load double, double* %a.addr, align 8, !tbaa !6
  [0,8) slice #5
    used by:   %8 = load double, double* %a.addr, align 8, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %a.addr = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %a, double* %a.addr, align 8, !tbaa !6
          to:   store double %a, double* %a.addr, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %0 = load double, double* %a.addr, align 8, !tbaa !6
          to:   %a.addr.0. = load double, double* %a.addr, align 8, !tbaa !6
  rewriting [0,8) slice #2
    original:   %2 = load double, double* %a.addr, align 8, !tbaa !6
          to:   %a.addr.0.40 = load double, double* %a.addr, align 8, !tbaa !6
  rewriting [0,8) slice #3
    original:   %4 = load double, double* %a.addr, align 8, !tbaa !6
          to:   %a.addr.0.41 = load double, double* %a.addr, align 8, !tbaa !6
  rewriting [0,8) slice #4
    original:   %6 = load double, double* %a.addr, align 8, !tbaa !6
          to:   %a.addr.0.42 = load double, double* %a.addr, align 8, !tbaa !6
  rewriting [0,8) slice #5
    original:   %8 = load double, double* %a.addr, align 8, !tbaa !6
          to:   %a.addr.0.43 = load double, double* %a.addr, align 8, !tbaa !6
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %8 = load double, double* %a.addr, align 8, !tbaa !6
Deleting dead instruction:   %6 = load double, double* %a.addr, align 8, !tbaa !6
Deleting dead instruction:   %4 = load double, double* %a.addr, align 8, !tbaa !6
Deleting dead instruction:   %2 = load double, double* %a.addr, align 8, !tbaa !6
Deleting dead instruction:   %0 = load double, double* %a.addr, align 8, !tbaa !6
Deleting dead instruction:   store double %a, double* %a.addr, align 8, !tbaa !6
SROA alloca:   %f.addr = alloca double (double)*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %f.addr = alloca double (double)*, align 8
  [0,8) slice #0
    used by:   store double (double)* %f, double (double)** %f.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %1 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  [0,8) slice #3
    used by:   %2 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  [0,8) slice #4
    used by:   %3 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  [0,8) slice #5
    used by:   %4 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %f.addr = alloca double (double)*, align 8
  rewriting [0,8) slice #0
    original:   store double (double)* %f, double (double)** %f.addr, align 8, !tbaa !2
          to:   store double (double)* %f, double (double)** %f.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
          to:   %f.addr.0. = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %1 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
          to:   %f.addr.0.44 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  rewriting [0,8) slice #3
    original:   %2 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
          to:   %f.addr.0.45 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  rewriting [0,8) slice #4
    original:   %3 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
          to:   %f.addr.0.46 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  rewriting [0,8) slice #5
    original:   %4 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
          to:   %f.addr.0.47 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %4 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
Deleting dead instruction:   %3 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
Deleting dead instruction:   %2 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
Deleting dead instruction:   %1 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load double (double)*, double (double)** %f.addr, align 8, !tbaa !2
Deleting dead instruction:   store double (double)* %f, double (double)** %f.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in for.body
EarlyCSE CVP: Add conditional value for 'cmp' as i1 false in for.end
SROA function: _Z4funcd
SROA alloca:   %x.addr = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %x.addr = alloca double, align 8
  [0,8) slice #0
    used by:   store double %x, double* %x.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load double, double* %x.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %x.addr = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %x, double* %x.addr, align 8, !tbaa !2
          to:   store double %x, double* %x.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load double, double* %x.addr, align 8, !tbaa !2
          to:   %x.addr.0. = load double, double* %x.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load double, double* %x.addr, align 8, !tbaa !2
Deleting dead instruction:   store double %x, double* %x.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
SROA alloca:   %__y.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__y.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__y, i32* %__y.addr, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %1 = load i32, i32* %__y.addr, align 4, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__y.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__y, i32* %__y.addr, align 4, !tbaa !6
          to:   store i32 %__y, i32* %__y.addr, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %1 = load i32, i32* %__y.addr, align 4, !tbaa !6
          to:   %__y.addr.0.load = load i32, i32* %__y.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i32, i32* %__y.addr, align 4, !tbaa !6
Deleting dead instruction:   store i32 %__y, i32* %__y.addr, align 4, !tbaa !6
SROA alloca:   %__x.addr = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__x.addr = alloca double, align 8
  [0,8) slice #0
    used by:   store double %__x, double* %__x.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load double, double* %__x.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__x.addr = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %__x, double* %__x.addr, align 8, !tbaa !2
          to:   store double %__x, double* %__x.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load double, double* %__x.addr, align 8, !tbaa !2
          to:   %__x.addr.0. = load double, double* %__x.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load double, double* %__x.addr, align 8, !tbaa !2
Deleting dead instruction:   store double %__x, double* %__x.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: __cxx_global_var_init
Merging: for.inc into for.body
Merging: for.end into for.cond.cleanup
SROA function: main
SROA alloca:   %agg.tmp13 = alloca %"struct.std::_Setw", align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %agg.tmp13 = alloca %"struct.std::_Setw", align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %call14, i32* %coerce.dive15, align 4
  [0,4) slice #1 (splittable)
    used by:   %15 = load i32, i32* %coerce.dive16, align 4
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %agg.tmp13.sroa.0 = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %call14, i32* %coerce.dive15, align 4
          to:   store i32 %call14, i32* %agg.tmp13.sroa.0, align 4
  rewriting [0,4) slice #1 (splittable)
    original:   %15 = load i32, i32* %coerce.dive16, align 4
          to:   %agg.tmp13.sroa.0.0.load = load i32, i32* %agg.tmp13.sroa.0, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %15 = load i32, i32* %coerce.dive16, align 4
Deleting dead instruction:   %coerce.dive16 = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %agg.tmp13, i32 0, i32 0
Deleting dead instruction:   store i32 %call14, i32* %coerce.dive15, align 4
Deleting dead instruction:   %coerce.dive15 = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %agg.tmp13, i32 0, i32 0
Deleting dead instruction:   %agg.tmp13 = alloca %"struct.std::_Setw", align 4
SROA alloca:   %agg.tmp8 = alloca %"struct.std::_Setprecision", align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %agg.tmp8 = alloca %"struct.std::_Setprecision", align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %call9, i32* %coerce.dive10, align 4
  [0,4) slice #1 (splittable)
    used by:   %14 = load i32, i32* %coerce.dive11, align 4
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %agg.tmp8.sroa.0 = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %call9, i32* %coerce.dive10, align 4
          to:   store i32 %call9, i32* %agg.tmp8.sroa.0, align 4
  rewriting [0,4) slice #1 (splittable)
    original:   %14 = load i32, i32* %coerce.dive11, align 4
          to:   %agg.tmp8.sroa.0.0.load = load i32, i32* %agg.tmp8.sroa.0, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %14 = load i32, i32* %coerce.dive11, align 4
Deleting dead instruction:   %coerce.dive11 = getelementptr inbounds %"struct.std::_Setprecision", %"struct.std::_Setprecision"* %agg.tmp8, i32 0, i32 0
Deleting dead instruction:   store i32 %call9, i32* %coerce.dive10, align 4
Deleting dead instruction:   %coerce.dive10 = getelementptr inbounds %"struct.std::_Setprecision", %"struct.std::_Setprecision"* %agg.tmp8, i32 0, i32 0
Deleting dead instruction:   %agg.tmp8 = alloca %"struct.std::_Setprecision", align 4
SROA alloca:   %agg.tmp = alloca %"struct.std::_Setw", align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %agg.tmp = alloca %"struct.std::_Setw", align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %call2, i32* %coerce.dive, align 4
  [0,4) slice #1 (splittable)
    used by:   %12 = load i32, i32* %coerce.dive3, align 4
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %agg.tmp.sroa.0 = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %call2, i32* %coerce.dive, align 4
          to:   store i32 %call2, i32* %agg.tmp.sroa.0, align 4
  rewriting [0,4) slice #1 (splittable)
    original:   %12 = load i32, i32* %coerce.dive3, align 4
          to:   %agg.tmp.sroa.0.0.load = load i32, i32* %agg.tmp.sroa.0, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %12 = load i32, i32* %coerce.dive3, align 4
Deleting dead instruction:   %coerce.dive3 = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %agg.tmp, i32 0, i32 0
Deleting dead instruction:   store i32 %call2, i32* %coerce.dive, align 4
Deleting dead instruction:   %coerce.dive = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %agg.tmp, i32 0, i32 0
Deleting dead instruction:   %agg.tmp = alloca %"struct.std::_Setw", align 4
SROA alloca:   %s = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %s = alloca double, align 8
  [0,8) slice #0
    used by:   store double %call, double* %s, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %13 = load double, double* %s, align 8, !tbaa !2
  [0,8) slice #2 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %s = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %call, double* %s, align 8, !tbaa !2
          to:   store double %call, double* %s, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %13 = load double, double* %s, align 8, !tbaa !2
          to:   %s.0. = load double, double* %s, align 8, !tbaa !2
  rewriting [0,8) slice #2 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %s.0..sroa_cast)
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %s.0..sroa_cast20)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #6
Deleting dead instruction:   %14 = bitcast double* %s to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #6
Deleting dead instruction:   %8 = bitcast double* %s to i8*
Deleting dead instruction:   %12 = load double, double* %s, align 8, !tbaa !2
Deleting dead instruction:   store double %call, double* %s, align 8, !tbaa !2
SROA alloca:   %n = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %n = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #6
  [0,4) slice #1 (splittable)
    used by:   store i32 2, i32* %n, align 4, !tbaa !6
  [0,4) slice #2 (splittable)
    used by:   %3 = load i32, i32* %n, align 4, !tbaa !6
  [0,4) slice #3 (splittable)
    used by:   %10 = load i32, i32* %n, align 4, !tbaa !6
  [0,4) slice #4 (splittable)
    used by:   %11 = load i32, i32* %n, align 4, !tbaa !6
  [0,4) slice #5 (splittable)
    used by:   %12 = load i32, i32* %n, align 4, !tbaa !6
  [0,4) slice #6 (splittable)
    used by:   store i32 %mul, i32* %n, align 4, !tbaa !6
  [0,4) slice #7 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %n = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %n.0..sroa_cast)
  rewriting [0,4) slice #1 (splittable)
    original:   store i32 2, i32* %n, align 4, !tbaa !6
          to:   store i32 2, i32* %n, align 4, !tbaa !6
  rewriting [0,4) slice #2 (splittable)
    original:   %3 = load i32, i32* %n, align 4, !tbaa !6
          to:   %n.0.load = load i32, i32* %n, align 4
  rewriting [0,4) slice #3 (splittable)
    original:   %10 = load i32, i32* %n, align 4, !tbaa !6
          to:   %n.0.load21 = load i32, i32* %n, align 4
  rewriting [0,4) slice #4 (splittable)
    original:   %11 = load i32, i32* %n, align 4, !tbaa !6
          to:   %n.0.load22 = load i32, i32* %n, align 4
  rewriting [0,4) slice #5 (splittable)
    original:   %12 = load i32, i32* %n, align 4, !tbaa !6
          to:   %n.0.load23 = load i32, i32* %n, align 4
  rewriting [0,4) slice #6 (splittable)
    original:   store i32 %mul, i32* %n, align 4, !tbaa !6
          to:   store i32 %mul, i32* %n, align 4, !tbaa !6
  rewriting [0,4) slice #7 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %n.0..sroa_cast24)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #6
Deleting dead instruction:   %4 = bitcast i32* %n to i8*
Deleting dead instruction:   store i32 %mul, i32* %n, align 4, !tbaa !6
Deleting dead instruction:   %11 = load i32, i32* %n, align 4, !tbaa !6
Deleting dead instruction:   %10 = load i32, i32* %n, align 4, !tbaa !6
Deleting dead instruction:   %9 = load i32, i32* %n, align 4, !tbaa !6
Deleting dead instruction:   %3 = load i32, i32* %n, align 4, !tbaa !6
Deleting dead instruction:   store i32 2, i32* %n, align 4, !tbaa !6
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #6
Deleting dead instruction:   %2 = bitcast i32* %n to i8*
SROA alloca:   %b = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %b = alloca double, align 8
  [0,8) slice #0
    used by:   store double 1.000000e+00, double* %b, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %6 = load double, double* %b, align 8, !tbaa !2
  [0,8) slice #2 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %b = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double 1.000000e+00, double* %b, align 8, !tbaa !2
          to:   store double 1.000000e+00, double* %b, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %6 = load double, double* %b, align 8, !tbaa !2
          to:   %b.0. = load double, double* %b, align 8, !tbaa !2
  rewriting [0,8) slice #2 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %b.0..sroa_cast)
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %b.0..sroa_cast25)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #6
Deleting dead instruction:   %2 = bitcast double* %b to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
Deleting dead instruction:   %1 = bitcast double* %b to i8*
Deleting dead instruction:   %4 = load double, double* %b, align 8, !tbaa !2
Deleting dead instruction:   store double 1.000000e+00, double* %b, align 8, !tbaa !2
SROA alloca:   %a = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %a = alloca double, align 8
  [0,8) slice #0
    used by:   store double 0.000000e+00, double* %a, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %3 = load double, double* %a, align 8, !tbaa !2
  [0,8) slice #2 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %1) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %a = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double 0.000000e+00, double* %a, align 8, !tbaa !2
          to:   store double 0.000000e+00, double* %a, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %3 = load double, double* %a, align 8, !tbaa !2
          to:   %a.0. = load double, double* %a, align 8, !tbaa !2
  rewriting [0,8) slice #2 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %a.0..sroa_cast)
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %1) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %a.0..sroa_cast26)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %1) #6
Deleting dead instruction:   %1 = bitcast double* %a to i8*
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
Deleting dead instruction:   %0 = bitcast double* %a to i8*
Deleting dead instruction:   %1 = load double, double* %a, align 8, !tbaa !2
Deleting dead instruction:   store double 0.000000e+00, double* %a, align 8, !tbaa !2
SROA alloca:   %retval = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %retval = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 0, i32* %retval, align 4
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %retval, align 4
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %retval = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 0, i32* %retval, align 4
          to:   store i32 0, i32* %retval, align 4
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %retval, align 4
          to:   %retval.0.load = load i32, i32* %retval, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %retval, align 4
Deleting dead instruction:   store i32 0, i32* %retval, align 4
Promoting allocas with mem2reg...
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in for.body
EarlyCSE CVP: Add conditional value for 'cmp' as i1 false in for.cond.cleanup
SROA function: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
SROA alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   %__os.addr.0. = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   %__os.addr.0.1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
SROA alloca:   %__f = alloca %"struct.std::_Setw", align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__f = alloca %"struct.std::_Setw", align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__f.coerce, i32* %coerce.dive, align 4
  [0,4) slice #1 (splittable)
    used by:   %4 = load i32, i32* %_M_n, align 4, !tbaa !8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__f.sroa.0 = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__f.coerce, i32* %coerce.dive, align 4
          to:   store i32 %__f.coerce, i32* %__f.sroa.0, align 4
  rewriting [0,4) slice #1 (splittable)
    original:   %4 = load i32, i32* %_M_n, align 4, !tbaa !8
          to:   %__f.sroa.0.0.load = load i32, i32* %__f.sroa.0, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %4 = load i32, i32* %_M_n, align 4, !tbaa !8
Deleting dead instruction:   %_M_n = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %__f, i32 0, i32 0
Deleting dead instruction:   store i32 %__f.coerce, i32* %coerce.dive, align 4
Deleting dead instruction:   %coerce.dive = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %__f, i32 0, i32 0
Deleting dead instruction:   %__f = alloca %"struct.std::_Setw", align 4
Promoting allocas with mem2reg...
SROA function: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
SROA alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   %__os.addr.0. = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   %__os.addr.0.1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
SROA alloca:   %__f = alloca %"struct.std::_Setprecision", align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__f = alloca %"struct.std::_Setprecision", align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__f.coerce, i32* %coerce.dive, align 4
  [0,4) slice #1 (splittable)
    used by:   %4 = load i32, i32* %_M_n, align 4, !tbaa !8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__f.sroa.0 = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__f.coerce, i32* %coerce.dive, align 4
          to:   store i32 %__f.coerce, i32* %__f.sroa.0, align 4
  rewriting [0,4) slice #1 (splittable)
    original:   %4 = load i32, i32* %_M_n, align 4, !tbaa !8
          to:   %__f.sroa.0.0.load = load i32, i32* %__f.sroa.0, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %4 = load i32, i32* %_M_n, align 4, !tbaa !8
Deleting dead instruction:   %_M_n = getelementptr inbounds %"struct.std::_Setprecision", %"struct.std::_Setprecision"* %__f, i32 0, i32 0
Deleting dead instruction:   store i32 %__f.coerce, i32* %coerce.dive, align 4
Deleting dead instruction:   %coerce.dive = getelementptr inbounds %"struct.std::_Setprecision", %"struct.std::_Setprecision"* %__f, i32 0, i32 0
Deleting dead instruction:   %__f = alloca %"struct.std::_Setprecision", align 4
Promoting allocas with mem2reg...
SROA function: _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
SROA alloca:   %__s.addr = alloca i8*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__s.addr = alloca i8*, align 8
  [0,8) slice #0
    used by:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load i8*, i8** %__s.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %7 = load i8*, i8** %__s.addr, align 8, !tbaa !2
  [0,8) slice #3
    used by:   %8 = load i8*, i8** %__s.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__s.addr = alloca i8*, align 8
  rewriting [0,8) slice #0
    original:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
          to:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load i8*, i8** %__s.addr, align 8, !tbaa !2
          to:   %__s.addr.0. = load i8*, i8** %__s.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %7 = load i8*, i8** %__s.addr, align 8, !tbaa !2
          to:   %__s.addr.0.2 = load i8*, i8** %__s.addr, align 8, !tbaa !2
  rewriting [0,8) slice #3
    original:   %8 = load i8*, i8** %__s.addr, align 8, !tbaa !2
          to:   %__s.addr.0.3 = load i8*, i8** %__s.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %8 = load i8*, i8** %__s.addr, align 8, !tbaa !2
Deleting dead instruction:   %7 = load i8*, i8** %__s.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load i8*, i8** %__s.addr, align 8, !tbaa !2
Deleting dead instruction:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
SROA alloca:   %__out.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__out.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %__out, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %5 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
  [0,8) slice #3
    used by:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__out.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %__out, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %__out, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
          to:   %__out.addr.0. = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %5 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
          to:   %__out.addr.0.4 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
  rewriting [0,8) slice #3
    original:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
          to:   %__out.addr.0.5 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %6 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
Deleting dead instruction:   %5 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::basic_ostream"* %__out, %"class.std::basic_ostream"** %__out.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
EarlyCSE CVP: Add conditional value for 'tobool' as i1 true in if.else
EarlyCSE CVP: Add conditional value for 'tobool' as i1 false in if.then
SROA function: _ZSt4setwi
SROA alloca:   %__n.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__n.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %__n.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__n.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
          to:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %__n.addr, align 4, !tbaa !2
          to:   %__n.addr.0.load = load i32, i32* %__n.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %__n.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
SROA alloca:   %retval = alloca %"struct.std::_Setw", align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %retval = alloca %"struct.std::_Setw", align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__n.addr.0.load, i32* %_M_n, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %coerce.dive, align 4
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %retval.sroa.0 = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__n.addr.0.load, i32* %_M_n, align 4, !tbaa !6
          to:   store i32 %__n.addr.0.load, i32* %retval.sroa.0, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %coerce.dive, align 4
          to:   %retval.sroa.0.0.load = load i32, i32* %retval.sroa.0, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %coerce.dive, align 4
Deleting dead instruction:   %coerce.dive = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %retval, i32 0, i32 0
Deleting dead instruction:   store i32 %__n.addr.0.load, i32* %_M_n, align 4, !tbaa !6
Deleting dead instruction:   %_M_n = getelementptr inbounds %"struct.std::_Setw", %"struct.std::_Setw"* %retval, i32 0, i32 0
Deleting dead instruction:   %retval = alloca %"struct.std::_Setw", align 4
Promoting allocas with mem2reg...
SROA function: _ZNSolsEPFRSt8ios_baseS0_E
SROA alloca:   %__pf.addr = alloca %"class.std::ios_base"* (%"class.std::ios_base"*)*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__pf.addr = alloca %"class.std::ios_base"* (%"class.std::ios_base"*)*, align 8
  [0,8) slice #0
    used by:   store %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::ios_base"* (%"class.std::ios_base"*)*, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__pf.addr = alloca %"class.std::ios_base"* (%"class.std::ios_base"*)*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
          to:   store %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::ios_base"* (%"class.std::ios_base"*)*, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
          to:   %__pf.addr.0. = load %"class.std::ios_base"* (%"class.std::ios_base"*)*, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load %"class.std::ios_base"* (%"class.std::ios_base"*)*, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf, %"class.std::ios_base"* (%"class.std::ios_base"*)** %__pf.addr, align 8, !tbaa !2
SROA alloca:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZSt5fixedRSt8ios_base
SROA alloca:   %__base.addr = alloca %"class.std::ios_base"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__base.addr = alloca %"class.std::ios_base"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::ios_base"* %__base, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__base.addr = alloca %"class.std::ios_base"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::ios_base"* %__base, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
          to:   store %"class.std::ios_base"* %__base, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
          to:   %__base.addr.0. = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
          to:   %__base.addr.0.1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load %"class.std::ios_base"*, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::ios_base"* %__base, %"class.std::ios_base"** %__base.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZSt12setprecisioni
SROA alloca:   %__n.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__n.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %__n.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__n.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
          to:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %__n.addr, align 4, !tbaa !2
          to:   %__n.addr.0.load = load i32, i32* %__n.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %__n.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__n, i32* %__n.addr, align 4, !tbaa !2
SROA alloca:   %retval = alloca %"struct.std::_Setprecision", align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %retval = alloca %"struct.std::_Setprecision", align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__n.addr.0.load, i32* %_M_n, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %coerce.dive, align 4
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %retval.sroa.0 = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__n.addr.0.load, i32* %_M_n, align 4, !tbaa !6
          to:   store i32 %__n.addr.0.load, i32* %retval.sroa.0, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %coerce.dive, align 4
          to:   %retval.sroa.0.0.load = load i32, i32* %retval.sroa.0, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %coerce.dive, align 4
Deleting dead instruction:   %coerce.dive = getelementptr inbounds %"struct.std::_Setprecision", %"struct.std::_Setprecision"* %retval, i32 0, i32 0
Deleting dead instruction:   store i32 %__n.addr.0.load, i32* %_M_n, align 4, !tbaa !6
Deleting dead instruction:   %_M_n = getelementptr inbounds %"struct.std::_Setprecision", %"struct.std::_Setprecision"* %retval, i32 0, i32 0
Deleting dead instruction:   %retval = alloca %"struct.std::_Setprecision", align 4
Promoting allocas with mem2reg...
SROA function: _ZNSolsEd
SROA alloca:   %__f.addr = alloca double, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__f.addr = alloca double, align 8
  [0,8) slice #0
    used by:   store double %__f, double* %__f.addr, align 8, !tbaa !6
  [0,8) slice #1
    used by:   %0 = load double, double* %__f.addr, align 8, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__f.addr = alloca double, align 8
  rewriting [0,8) slice #0
    original:   store double %__f, double* %__f.addr, align 8, !tbaa !6
          to:   store double %__f, double* %__f.addr, align 8, !tbaa !6
  rewriting [0,8) slice #1
    original:   %0 = load double, double* %__f.addr, align 8, !tbaa !6
          to:   %__f.addr.0. = load double, double* %__f.addr, align 8, !tbaa !6
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load double, double* %__f.addr, align 8, !tbaa !6
Deleting dead instruction:   store double %__f, double* %__f.addr, align 8, !tbaa !6
SROA alloca:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZNSolsEPFRSoS_E
SROA alloca:   %__pf.addr = alloca %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__pf.addr = alloca %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)*, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__pf.addr = alloca %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)*, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
          to:   %__pf.addr.0. = load %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)*, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)*, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)** %__pf.addr, align 8, !tbaa !2
SROA alloca:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::basic_ostream"* %this, %"class.std::basic_ostream"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
SROA alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   %__os.addr.0. = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   %__os.addr.0.3 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
SROA alloca:   %__old = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__old = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #6
  [0,4) slice #1 (splittable)
    used by:   store i32 %1, i32* %__old, align 4, !tbaa !6
  [0,4) slice #2 (splittable)
    used by:   %5 = load i32, i32* %__old, align 4, !tbaa !6
  [0,4) slice #3 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__old = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %__old.0..sroa_cast)
  rewriting [0,4) slice #1 (splittable)
    original:   store i32 %1, i32* %__old, align 4, !tbaa !6
          to:   store i32 %1, i32* %__old, align 4, !tbaa !6
  rewriting [0,4) slice #2 (splittable)
    original:   %5 = load i32, i32* %__old, align 4, !tbaa !6
          to:   %__old.0.load = load i32, i32* %__old, align 4
  rewriting [0,4) slice #3 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %__old.0..sroa_cast7)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #6
Deleting dead instruction:   %6 = bitcast i32* %__old to i8*
Deleting dead instruction:   %5 = load i32, i32* %__old, align 4, !tbaa !6
Deleting dead instruction:   store i32 %1, i32* %__old, align 4, !tbaa !6
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #6
Deleting dead instruction:   %0 = bitcast i32* %__old to i8*
SROA alloca:   %__mask.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__mask.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__mask, i32* %__mask.addr, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %1 = load i32, i32* %__mask.addr, align 4, !tbaa !6
  [0,4) slice #2 (splittable)
    used by:   %3 = load i32, i32* %__mask.addr, align 4, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__mask.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__mask, i32* %__mask.addr, align 4, !tbaa !6
          to:   store i32 %__mask, i32* %__mask.addr, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %1 = load i32, i32* %__mask.addr, align 4, !tbaa !6
          to:   %__mask.addr.0.load = load i32, i32* %__mask.addr, align 4
  rewriting [0,4) slice #2 (splittable)
    original:   %3 = load i32, i32* %__mask.addr, align 4, !tbaa !6
          to:   %__mask.addr.0.load8 = load i32, i32* %__mask.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %3 = load i32, i32* %__mask.addr, align 4, !tbaa !6
Deleting dead instruction:   %1 = load i32, i32* %__mask.addr, align 4, !tbaa !6
Deleting dead instruction:   store i32 %__mask, i32* %__mask.addr, align 4, !tbaa !6
SROA alloca:   %__fmtfl.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__fmtfl.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__fmtfl, i32* %__fmtfl.addr, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %1 = load i32, i32* %__fmtfl.addr, align 4, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__fmtfl.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__fmtfl, i32* %__fmtfl.addr, align 4, !tbaa !6
          to:   store i32 %__fmtfl, i32* %__fmtfl.addr, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %1 = load i32, i32* %__fmtfl.addr, align 4, !tbaa !6
          to:   %__fmtfl.addr.0.load = load i32, i32* %__fmtfl.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i32, i32* %__fmtfl.addr, align 4, !tbaa !6
Deleting dead instruction:   store i32 %__fmtfl, i32* %__fmtfl.addr, align 4, !tbaa !6
SROA alloca:   %this.addr = alloca %"class.std::ios_base"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::ios_base"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::ios_base"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
EarlyCSE CSE:   %_M_flags2 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3  to:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
EarlyCSE CSE:   %_M_flags5 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3  to:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
SROA function: _ZStaNRSt13_Ios_FmtflagsS_
SROA alloca:   %__b.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__b.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %2 = load i32, i32* %__b.addr, align 4, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__b.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
          to:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %2 = load i32, i32* %__b.addr, align 4, !tbaa !6
          to:   %__b.addr.0.load = load i32, i32* %__b.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %2 = load i32, i32* %__b.addr, align 4, !tbaa !6
Deleting dead instruction:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
SROA alloca:   %__a.addr = alloca i32*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__a.addr = alloca i32*, align 8
  [0,8) slice #0
    used by:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load i32*, i32** %__a.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %2 = load i32*, i32** %__a.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__a.addr = alloca i32*, align 8
  rewriting [0,8) slice #0
    original:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
          to:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load i32*, i32** %__a.addr, align 8, !tbaa !2
          to:   %__a.addr.0. = load i32*, i32** %__a.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %2 = load i32*, i32** %__a.addr, align 8, !tbaa !2
          to:   %__a.addr.0.1 = load i32*, i32** %__a.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %2 = load i32*, i32** %__a.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load i32*, i32** %__a.addr, align 8, !tbaa !2
Deleting dead instruction:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZStcoSt13_Ios_Fmtflags
SROA alloca:   %__a.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__a.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__a.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
          to:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
          to:   %__a.addr.0.load = load i32, i32* %__a.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZStoRRSt13_Ios_FmtflagsS_
SROA alloca:   %__b.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__b.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %2 = load i32, i32* %__b.addr, align 4, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__b.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
          to:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %2 = load i32, i32* %__b.addr, align 4, !tbaa !6
          to:   %__b.addr.0.load = load i32, i32* %__b.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %2 = load i32, i32* %__b.addr, align 4, !tbaa !6
Deleting dead instruction:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !6
SROA alloca:   %__a.addr = alloca i32*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__a.addr = alloca i32*, align 8
  [0,8) slice #0
    used by:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load i32*, i32** %__a.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %2 = load i32*, i32** %__a.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__a.addr = alloca i32*, align 8
  rewriting [0,8) slice #0
    original:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
          to:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load i32*, i32** %__a.addr, align 8, !tbaa !2
          to:   %__a.addr.0. = load i32*, i32** %__a.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %2 = load i32*, i32** %__a.addr, align 8, !tbaa !2
          to:   %__a.addr.0.1 = load i32*, i32** %__a.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %2 = load i32*, i32** %__a.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load i32*, i32** %__a.addr, align 8, !tbaa !2
Deleting dead instruction:   store i32* %__a, i32** %__a.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZStanSt13_Ios_FmtflagsS_
SROA alloca:   %__b.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__b.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__b.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
          to:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
          to:   %__b.addr.0.load = load i32, i32* %__b.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
SROA alloca:   %__a.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__a.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__a.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
          to:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
          to:   %__a.addr.0.load = load i32, i32* %__a.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZStorSt13_Ios_FmtflagsS_
SROA alloca:   %__b.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__b.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__b.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
          to:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
          to:   %__b.addr.0.load = load i32, i32* %__b.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
SROA alloca:   %__a.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__a.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__a.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
          to:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
          to:   %__a.addr.0.load = load i32, i32* %__a.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
SROA alloca:   %__state.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__state.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__state, i32* %__state.addr, align 4, !tbaa !6
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %__state.addr, align 4, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__state.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__state, i32* %__state.addr, align 4, !tbaa !6
          to:   store i32 %__state, i32* %__state.addr, align 4, !tbaa !6
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %__state.addr, align 4, !tbaa !6
          to:   %__state.addr.0.load = load i32, i32* %__state.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %__state.addr, align 4, !tbaa !6
Deleting dead instruction:   store i32 %__state, i32* %__state.addr, align 4, !tbaa !6
SROA alloca:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZNSt11char_traitsIcE6lengthEPKc
SROA alloca:   %__s.addr = alloca i8*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__s.addr = alloca i8*, align 8
  [0,8) slice #0
    used by:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load i8*, i8** %__s.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__s.addr = alloca i8*, align 8
  rewriting [0,8) slice #0
    original:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
          to:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load i8*, i8** %__s.addr, align 8, !tbaa !2
          to:   %__s.addr.0. = load i8*, i8** %__s.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i8*, i8** %__s.addr, align 8, !tbaa !2
Deleting dead instruction:   store i8* %__s, i8** %__s.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZStorSt12_Ios_IostateS_
SROA alloca:   %__b.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__b.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__b.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
          to:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
          to:   %__b.addr.0.load = load i32, i32* %__b.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i32, i32* %__b.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__b, i32* %__b.addr, align 4, !tbaa !2
SROA alloca:   %__a.addr = alloca i32, align 4
  Rewriting FCA loads and stores...
Slices of alloca:   %__a.addr = alloca i32, align 4
  [0,4) slice #0 (splittable)
    used by:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  [0,4) slice #1 (splittable)
    used by:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,4) to:   %__a.addr = alloca i32, align 4
  rewriting [0,4) slice #0 (splittable)
    original:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
          to:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
  rewriting [0,4) slice #1 (splittable)
    original:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
          to:   %__a.addr.0.load = load i32, i32* %__a.addr, align 4
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load i32, i32* %__a.addr, align 4, !tbaa !2
Deleting dead instruction:   store i32 %__a, i32* %__a.addr, align 4, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
SROA alloca:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZNSt8ios_base5widthEl
SROA alloca:   %__old = alloca i64, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__old = alloca i64, align 8
  [0,8) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  [0,8) slice #1 (splittable)
    used by:   store i64 %1, i64* %__old, align 8, !tbaa !6
  [0,8) slice #2 (splittable)
    used by:   %3 = load i64, i64* %__old, align 8, !tbaa !6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__old = alloca i64, align 8
  rewriting [0,8) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %__old.0..sroa_cast)
  rewriting [0,8) slice #1 (splittable)
    original:   store i64 %1, i64* %__old, align 8, !tbaa !6
          to:   store i64 %1, i64* %__old, align 8, !tbaa !6
  rewriting [0,8) slice #2 (splittable)
    original:   %3 = load i64, i64* %__old, align 8, !tbaa !6
          to:   %__old.0.load = load i64, i64* %__old, align 8
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %__old.0..sroa_cast3)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
Deleting dead instruction:   %4 = bitcast i64* %__old to i8*
Deleting dead instruction:   %3 = load i64, i64* %__old, align 8, !tbaa !6
Deleting dead instruction:   store i64 %1, i64* %__old, align 8, !tbaa !6
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
Deleting dead instruction:   %0 = bitcast i64* %__old to i8*
SROA alloca:   %__wide.addr = alloca i64, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__wide.addr = alloca i64, align 8
  [0,8) slice #0 (splittable)
    used by:   store i64 %__wide, i64* %__wide.addr, align 8, !tbaa !6
  [0,8) slice #1 (splittable)
    used by:   %1 = load i64, i64* %__wide.addr, align 8, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__wide.addr = alloca i64, align 8
  rewriting [0,8) slice #0 (splittable)
    original:   store i64 %__wide, i64* %__wide.addr, align 8, !tbaa !6
          to:   store i64 %__wide, i64* %__wide.addr, align 8, !tbaa !6
  rewriting [0,8) slice #1 (splittable)
    original:   %1 = load i64, i64* %__wide.addr, align 8, !tbaa !6
          to:   %__wide.addr.0.load = load i64, i64* %__wide.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i64, i64* %__wide.addr, align 8, !tbaa !6
Deleting dead instruction:   store i64 %__wide, i64* %__wide.addr, align 8, !tbaa !6
SROA alloca:   %this.addr = alloca %"class.std::ios_base"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::ios_base"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::ios_base"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
EarlyCSE CSE:   %_M_width2 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2  to:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2
SROA function: _ZNSt8ios_base9precisionEl
SROA alloca:   %__old = alloca i64, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__old = alloca i64, align 8
  [0,8) slice #0 (splittable)
    used by:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  [0,8) slice #1 (splittable)
    used by:   store i64 %1, i64* %__old, align 8, !tbaa !6
  [0,8) slice #2 (splittable)
    used by:   %3 = load i64, i64* %__old, align 8, !tbaa !6
  [0,8) slice #3 (splittable)
    used by:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__old = alloca i64, align 8
  rewriting [0,8) slice #0 (splittable)
    original:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
          to:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %__old.0..sroa_cast)
  rewriting [0,8) slice #1 (splittable)
    original:   store i64 %1, i64* %__old, align 8, !tbaa !6
          to:   store i64 %1, i64* %__old, align 8, !tbaa !6
  rewriting [0,8) slice #2 (splittable)
    original:   %3 = load i64, i64* %__old, align 8, !tbaa !6
          to:   %__old.0.load = load i64, i64* %__old, align 8
  rewriting [0,8) slice #3 (splittable)
    original:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
          to:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %__old.0..sroa_cast3)
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
Deleting dead instruction:   %4 = bitcast i64* %__old to i8*
Deleting dead instruction:   %3 = load i64, i64* %__old, align 8, !tbaa !6
Deleting dead instruction:   store i64 %1, i64* %__old, align 8, !tbaa !6
Deleting dead instruction:   call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
Deleting dead instruction:   %0 = bitcast i64* %__old to i8*
SROA alloca:   %__prec.addr = alloca i64, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__prec.addr = alloca i64, align 8
  [0,8) slice #0 (splittable)
    used by:   store i64 %__prec, i64* %__prec.addr, align 8, !tbaa !6
  [0,8) slice #1 (splittable)
    used by:   %1 = load i64, i64* %__prec.addr, align 8, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__prec.addr = alloca i64, align 8
  rewriting [0,8) slice #0 (splittable)
    original:   store i64 %__prec, i64* %__prec.addr, align 8, !tbaa !6
          to:   store i64 %__prec, i64* %__prec.addr, align 8, !tbaa !6
  rewriting [0,8) slice #1 (splittable)
    original:   %1 = load i64, i64* %__prec.addr, align 8, !tbaa !6
          to:   %__prec.addr.0.load = load i64, i64* %__prec.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i64, i64* %__prec.addr, align 8, !tbaa !6
Deleting dead instruction:   store i64 %__prec, i64* %__prec.addr, align 8, !tbaa !6
SROA alloca:   %this.addr = alloca %"class.std::ios_base"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::ios_base"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::ios_base"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::ios_base"*, %"class.std::ios_base"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::ios_base"* %this, %"class.std::ios_base"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
EarlyCSE CSE:   %_M_precision2 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1  to:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1
SROA function: _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
SROA alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__os.addr = alloca %"class.std::basic_ostream"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
          to:   %__os.addr.0. = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %0 = load %"class.std::basic_ostream"*, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::basic_ostream"* %__os, %"class.std::basic_ostream"** %__os.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
SROA alloca:   %__c.addr = alloca i8, align 1
  Rewriting FCA loads and stores...
Slices of alloca:   %__c.addr = alloca i8, align 1
  [0,1) slice #0 (splittable)
    used by:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
  [0,1) slice #1 (splittable)
    used by:   %1 = load i8, i8* %__c.addr, align 1, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,1) to:   %__c.addr = alloca i8, align 1
  rewriting [0,1) slice #0 (splittable)
    original:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
          to:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
  rewriting [0,1) slice #1 (splittable)
    original:   %1 = load i8, i8* %__c.addr, align 1, !tbaa !6
          to:   %__c.addr.0.load = load i8, i8* %__c.addr, align 1
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load i8, i8* %__c.addr, align 1, !tbaa !6
Deleting dead instruction:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
SROA alloca:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::basic_ios"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::basic_ios"*, %"class.std::basic_ios"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::basic_ios"* %this, %"class.std::basic_ios"** %this.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
SROA function: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
SROA alloca:   %__f.addr = alloca %"class.std::ctype"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %__f.addr = alloca %"class.std::ctype"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::ctype"* %__f, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
  [0,8) slice #2
    used by:   %1 = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %__f.addr = alloca %"class.std::ctype"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::ctype"* %__f, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
          to:   store %"class.std::ctype"* %__f, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
          to:   %__f.addr.0. = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
  rewriting [0,8) slice #2
    original:   %1 = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
          to:   %__f.addr.0.1 = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %1 = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
Deleting dead instruction:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
Deleting dead instruction:   store %"class.std::ctype"* %__f, %"class.std::ctype"** %__f.addr, align 8, !tbaa !2
Promoting allocas with mem2reg...
EarlyCSE CVP: Add conditional value for 'tobool' as i1 true in if.end
EarlyCSE CVP: Add conditional value for 'tobool' as i1 false in if.then
SROA function: _ZNKSt5ctypeIcE5widenEc
SROA alloca:   %__c.addr = alloca i8, align 1
  Rewriting FCA loads and stores...
Slices of alloca:   %__c.addr = alloca i8, align 1
  [0,1) slice #0 (splittable)
    used by:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
  [0,1) slice #1 (splittable)
    used by:   %1 = load i8, i8* %__c.addr, align 1, !tbaa !6
  [0,1) slice #2 (splittable)
    used by:   %3 = load i8, i8* %__c.addr, align 1, !tbaa !6
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,1) to:   %__c.addr = alloca i8, align 1
  rewriting [0,1) slice #0 (splittable)
    original:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
          to:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
  rewriting [0,1) slice #1 (splittable)
    original:   %1 = load i8, i8* %__c.addr, align 1, !tbaa !6
          to:   %__c.addr.0.load = load i8, i8* %__c.addr, align 1
  rewriting [0,1) slice #2 (splittable)
    original:   %3 = load i8, i8* %__c.addr, align 1, !tbaa !6
          to:   %__c.addr.0.load2 = load i8, i8* %__c.addr, align 1
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %3 = load i8, i8* %__c.addr, align 1, !tbaa !6
Deleting dead instruction:   %1 = load i8, i8* %__c.addr, align 1, !tbaa !6
Deleting dead instruction:   store i8 %__c, i8* %__c.addr, align 1, !tbaa !6
SROA alloca:   %this.addr = alloca %"class.std::ctype"*, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %this.addr = alloca %"class.std::ctype"*, align 8
  [0,8) slice #0
    used by:   store %"class.std::ctype"* %this, %"class.std::ctype"** %this.addr, align 8, !tbaa !2
  [0,8) slice #1
    used by:   %this1 = load %"class.std::ctype"*, %"class.std::ctype"** %this.addr, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,8) to:   %this.addr = alloca %"class.std::ctype"*, align 8
  rewriting [0,8) slice #0
    original:   store %"class.std::ctype"* %this, %"class.std::ctype"** %this.addr, align 8, !tbaa !2
          to:   store %"class.std::ctype"* %this, %"class.std::ctype"** %this.addr, align 8, !tbaa !2
  rewriting [0,8) slice #1
    original:   %this1 = load %"class.std::ctype"*, %"class.std::ctype"** %this.addr, align 8
          to:   %this.addr.0.this1 = load %"class.std::ctype"*, %"class.std::ctype"** %this.addr, align 8
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %this1 = load %"class.std::ctype"*, %"class.std::ctype"** %this.addr, align 8
Deleting dead instruction:   store %"class.std::ctype"* %this, %"class.std::ctype"** %this.addr, align 8, !tbaa !2
SROA alloca:   %retval = alloca i8, align 1
  Rewriting FCA loads and stores...
Slices of alloca:   %retval = alloca i8, align 1
  [0,1) slice #0 (splittable)
    used by:   store i8 %1, i8* %retval, align 1
  [0,1) slice #1 (splittable)
    used by:   store i8 %call, i8* %retval, align 1
  [0,1) slice #2 (splittable)
    used by:   %4 = load i8, i8* %retval, align 1
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,1) to:   %retval = alloca i8, align 1
  rewriting [0,1) slice #0 (splittable)
    original:   store i8 %1, i8* %retval, align 1
          to:   store i8 %1, i8* %retval, align 1
  rewriting [0,1) slice #1 (splittable)
    original:   store i8 %call, i8* %retval, align 1
          to:   store i8 %call, i8* %retval, align 1
  rewriting [0,1) slice #2 (splittable)
    original:   %4 = load i8, i8* %retval, align 1
          to:   %retval.0.load = load i8, i8* %retval, align 1
  Speculating PHIs
  Speculating Selects
Deleting dead instruction:   %4 = load i8, i8* %retval, align 1
Deleting dead instruction:   store i8 %call, i8* %retval, align 1
Deleting dead instruction:   store i8 %1, i8* %retval, align 1
Promoting allocas with mem2reg...
EarlyCSE CVP: Add conditional value for 'tobool' as i1 true in if.then
EarlyCSE CVP: Add conditional value for 'tobool' as i1 false in if.end
SROA function: _GLOBAL__sub_I_Simpson.cpp
Visiting   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
Rename Stack is empty
Current DFS numbers are (1,6)
Rename Stack is empty
Current DFS numbers are (2,3)
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (2,3)
Found replacement   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0) for   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] in   %conv3 = sitofp i32 %even.0 to double
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (2,3)
Found replacement   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0) for   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] in   %add13 = add nsw i32 %even.0, 2
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (4,5)
Visiting   %mul = mul nsw i32 %div, 2
Rename Stack is empty
Current DFS numbers are (0,7)
Rename Stack is empty
Current DFS numbers are (1,6)
Rename Stack is empty
Current DFS numbers are (2,3)
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (4,5)
Marking Block Executable: entry
markOverdefined: double (double)* %f
markOverdefined: double %a
markOverdefined: double %b
markOverdefined: i32 %n
Marking Block Executable: entry
markOverdefined: double %x
Marking Block Executable: entry
markOverdefined: double %__x
markOverdefined: i32 %__y
Visiting   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
Rename Stack is empty
Current DFS numbers are (1,6)
Rename Stack is empty
Current DFS numbers are (2,3)
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (2,3)
Found replacement   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0) for   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ] in   %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (2,3)
Found replacement   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0) for   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ] in   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (2,3)
Found replacement   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0) for   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ] in   %mul = mul nsw i32 %n.0, 2
Rename Stack Top DFS numbers are (2,3)
Current DFS numbers are (4,5)
Marking Block Executable: entry
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os
markOverdefined: i32 %__f.coerce
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os
markOverdefined: i32 %__f.coerce
Visiting i8* %__s
Rename Stack is empty
Current DFS numbers are (0,7)
Rename Stack is empty
Current DFS numbers are (1,2)
Rename Stack Top DFS numbers are (1,2)
Current DFS numbers are (1,2)
Found replacement   %__s.0 = call i8* @llvm.ssa.copy.140736427712736(i8* %__s) for i8* %__s in   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s)
Rename Stack Top DFS numbers are (1,2)
Current DFS numbers are (1,2)
Found replacement   %__s.0 = call i8* @llvm.ssa.copy.140736427712736(i8* %__s) for i8* %__s in   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s, i64 %call)
Rename Stack Top DFS numbers are (1,2)
Current DFS numbers are (5,6)
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__out
markOverdefined: i8* %__s
Marking Block Executable: entry
markOverdefined: i32 %__n
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %this
markOverdefined: %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %__base
Marking Block Executable: entry
markOverdefined: i32 %__n
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %this
markOverdefined: double %__f
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %this
markOverdefined: %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %this
markOverdefined: i32 %__fmtfl
markOverdefined: i32 %__mask
Marking Block Executable: entry
markOverdefined: i32* %__a
markOverdefined: i32 %__b
Marking Block Executable: entry
markOverdefined: i32 %__a
Marking Block Executable: entry
markOverdefined: i32* %__a
markOverdefined: i32 %__b
Marking Block Executable: entry
markOverdefined: i32 %__a
markOverdefined: i32 %__b
Marking Block Executable: entry
markOverdefined: i32 %__a
markOverdefined: i32 %__b
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ios"* %this
markOverdefined: i32 %__state
Marking Block Executable: entry
markOverdefined: i8* %__s
Marking Block Executable: entry
markOverdefined: i32 %__a
markOverdefined: i32 %__b
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ios"* %this
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %this
markOverdefined: i64 %__wide
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %this
markOverdefined: i64 %__prec
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ios"* %this
markOverdefined: i8 %__c
Visiting %"class.std::ctype"* %__f
Rename Stack is empty
Current DFS numbers are (0,5)
Rename Stack is empty
Current DFS numbers are (1,2)
Rename Stack Top DFS numbers are (1,2)
Current DFS numbers are (1,2)
Found replacement   %__f.0 = call %"class.std::ctype"* @llvm.ssa.copy.140736443612080(%"class.std::ctype"* %__f) for %"class.std::ctype"* %__f in   ret %"class.std::ctype"* %__f
Rename Stack Top DFS numbers are (1,2)
Current DFS numbers are (3,4)
Marking Block Executable: entry
markOverdefined: %"class.std::ctype"* %__f
Marking Block Executable: entry
markOverdefined: %"class.std::ctype"* %this
markOverdefined: i8 %__c
Marking Block Executable: entry

Popped off OI-WL: i8 %__c

Popped off OI-WL: %"class.std::ctype"* %this
markOverdefined:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8

Popped off OI-WL:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8
Merged overdefined into   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
markOverdefined:   %tobool = icmp ne i8 %0, 0

Popped off OI-WL:   %tobool = icmp ne i8 %0, 0
Marking Block Executable: if.then
Marking Block Executable: if.end

Popped off OI-WL: %"class.std::ctype"* %__f
Merged overdefined into   %__f.0 = call %"class.std::ctype"* @llvm.ssa.copy.140736443612080(%"class.std::ctype"* %__f) : overdefined
markOverdefined:   %tobool = icmp ne %"class.std::ctype"* %__f, null

Popped off OI-WL:   %tobool = icmp ne %"class.std::ctype"* %__f, null
Marking Block Executable: if.end
Marking Block Executable: if.then

Popped off OI-WL:   %__f.0 = call %"class.std::ctype"* @llvm.ssa.copy.140736443612080(%"class.std::ctype"* %__f)

Popped off OI-WL: i8 %__c
Merged overdefined into   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c) : overdefined

Popped off OI-WL:   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)

Popped off OI-WL: %"class.std::basic_ios"* %this
markOverdefined:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5

Popped off OI-WL:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5
Merged overdefined into   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
Merged overdefined into   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0) : overdefined

Popped off OI-WL:   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)

Popped off OI-WL: %"class.std::basic_ostream"* %__os
Merged overdefined into   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) : overdefined

Popped off OI-WL:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)

Popped off OI-WL: i64 %__prec

Popped off OI-WL: %"class.std::ios_base"* %this
markOverdefined:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1

Popped off OI-WL:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1
Merged overdefined into   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2

Popped off OI-WL: i64 %__wide

Popped off OI-WL: %"class.std::ios_base"* %this
markOverdefined:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2

Popped off OI-WL:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2
Merged overdefined into   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2

Popped off OI-WL: %"class.std::basic_ios"* %this
markOverdefined:   %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*
markOverdefined:   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5

Popped off OI-WL:   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5
Merged overdefined into   %1 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %1 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2

Popped off OI-WL: i32 %__b
markOverdefined:   %or = or i32 %__a, %__b

Popped off OI-WL:   %or = or i32 %__a, %__b

Popped off OI-WL: i32 %__a

Popped off OI-WL: i8* %__s
Merged overdefined into   %call = call i64 @strlen(i8* %__s) #14 : overdefined

Popped off OI-WL:   %call = call i64 @strlen(i8* %__s) #14

Popped off OI-WL: i32 %__state
Merged overdefined into   %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %call, i32 %__state) : overdefined

Popped off OI-WL:   %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %call, i32 %__state)

Popped off OI-WL: %"class.std::basic_ios"* %this
Merged overdefined into   %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this) : overdefined

Popped off OI-WL:   %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this)

Popped off OI-WL: i32 %__b
markOverdefined:   %or = or i32 %__a, %__b

Popped off OI-WL:   %or = or i32 %__a, %__b

Popped off OI-WL: i32 %__a

Popped off OI-WL: i32 %__b
markOverdefined:   %and = and i32 %__a, %__b

Popped off OI-WL:   %and = and i32 %__a, %__b

Popped off OI-WL: i32 %__a

Popped off OI-WL: i32 %__b
Merged overdefined into   %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b) : overdefined

Popped off OI-WL:   %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)

Popped off OI-WL: i32* %__a
Merged overdefined into   %0 = load i32, i32* %__a, align 4, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %__a, align 4, !tbaa !2

Popped off OI-WL: i32 %__a
Merged overdefined into   %neg = xor i32 %__a, -1 : overdefined

Popped off OI-WL:   %neg = xor i32 %__a, -1

Popped off OI-WL: i32 %__b
Merged overdefined into   %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b) : overdefined

Popped off OI-WL:   %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)

Popped off OI-WL: i32* %__a
Merged overdefined into   %0 = load i32, i32* %__a, align 4, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %__a, align 4, !tbaa !2

Popped off OI-WL: i32 %__mask
Merged overdefined into   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask) : overdefined
Merged overdefined into   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask) : overdefined

Popped off OI-WL:   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
Merged overdefined into   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4) : overdefined

Popped off OI-WL:   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)

Popped off OI-WL:   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
Merged overdefined into   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call) : overdefined

Popped off OI-WL:   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)

Popped off OI-WL: i32 %__fmtfl

Popped off OI-WL: %"class.std::ios_base"* %this
markOverdefined:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3

Popped off OI-WL:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
Merged overdefined into   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2

Popped off OI-WL: %"class.std::basic_ostream"* %__os
Merged overdefined into   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %call) : overdefined
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*

Popped off OI-WL:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
Merged overdefined into   %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10) : overdefined

Popped off OI-WL:   %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10)

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off OI-WL:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %call)
Merged overdefined into   %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1) : overdefined

Popped off OI-WL:   %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1)

Popped off OI-WL: %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf
Merged overdefined into   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) : overdefined

Popped off OI-WL:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)

Popped off OI-WL: %"class.std::basic_ostream"* %this

Popped off OI-WL: double %__f
Merged overdefined into   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) : overdefined

Popped off OI-WL:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)

Popped off OI-WL: %"class.std::basic_ostream"* %this

Popped off OI-WL: i32 %__n

Popped off OI-WL: %"class.std::ios_base"* %__base
Merged overdefined into   %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260) : overdefined

Popped off OI-WL:   %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260)

Popped off OI-WL: %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf
Merged overdefined into   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3) : overdefined

Popped off OI-WL:   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)

Popped off OI-WL: %"class.std::basic_ostream"* %this
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*

Popped off OI-WL: i32 %__n

Popped off OI-WL: i8* %__s
Merged overdefined into   %__s.0 = call i8* @llvm.ssa.copy.140736427712736(i8* %__s) : overdefined
markOverdefined:   %tobool = icmp ne i8* %__s, null

Popped off OI-WL:   %tobool = icmp ne i8* %__s, null
Marking Block Executable: if.else
Marking Block Executable: if.then

Popped off OI-WL:   %__s.0 = call i8* @llvm.ssa.copy.140736427712736(i8* %__s)
Merged overdefined into   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s.0, i64 %call) : overdefined
Merged overdefined into   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s.0) : overdefined

Popped off OI-WL:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s.0)

Popped off OI-WL:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s.0, i64 %call)

Popped off OI-WL: %"class.std::basic_ostream"* %__out
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*

Popped off OI-WL:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*

Popped off OI-WL: i32 %__f.coerce
markOverdefined:   %conv = sext i32 %__f.coerce to i64

Popped off OI-WL:   %conv = sext i32 %__f.coerce to i64
Merged overdefined into   %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv) : overdefined

Popped off OI-WL:   %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)

Popped off OI-WL: %"class.std::basic_ostream"* %__os
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off OI-WL: i32 %__f.coerce
markOverdefined:   %conv = sext i32 %__f.coerce to i64

Popped off OI-WL:   %conv = sext i32 %__f.coerce to i64
Merged overdefined into   %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv) : overdefined

Popped off OI-WL:   %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)

Popped off OI-WL: %"class.std::basic_ostream"* %__os
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off OI-WL: i32 %__y
markOverdefined:   %conv = sitofp i32 %__y to double

Popped off OI-WL:   %conv = sitofp i32 %__y to double
markOverdefined:   %call = call double @pow(double %__x, double %conv) #14

Popped off OI-WL:   %call = call double @pow(double %__x, double %conv) #14

Popped off OI-WL: double %__x

Popped off OI-WL: double %x
Merged overdefined into   %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4) : overdefined

Popped off OI-WL:   %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
Merged overdefined into ; Function Attrs: uwtable mustprogress
define dso_local double @_Z4funcd(double %x) #0 {
entry:
  %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
  ret double %call
}
 : overdefined

Popped off OI-WL: ; Function Attrs: uwtable mustprogress
define dso_local double @_Z4funcd(double %x) #0 {
entry:
  %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
  ret double %call
}


Popped off OI-WL: i32 %n
Merged overdefined into   %add = add nsw i32 %n, 1 : overdefined

Popped off OI-WL:   %add = add nsw i32 %n, 1
Merged constantrange<-1073741824, 1073741824> into   %div = sdiv i32 %add, 2 : constantrange<-1073741824, 1073741824>

Popped off OI-WL: double %b
markOverdefined:   %sub = fsub double %b, %a

Popped off OI-WL:   %sub = fsub double %b, %a

Popped off OI-WL: double %a

Popped off OI-WL: double (double)* %f
Merged overdefined into   %call = call double %f(double %add2) : overdefined

Popped off OI-WL:   %call = call double %f(double %add2)

Popped off I-WL:   %div = sdiv i32 %add, 2
Merged constantrange<-2147483648, 2147483647> into   %mul = mul nsw i32 %div, 2 : constantrange<-2147483648, 2147483647>

Popped off I-WL:   %mul = mul nsw i32 %div, 2
markOverdefined:   %conv = sitofp i32 %mul to double

Popped off BBWL: 
if.then:                                          ; preds = %entry
  %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
  call void @_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 1)
  br label %if.end

Marking Block Executable: if.end

Popped off BBWL: 
if.end:                                           ; preds = %if.else, %if.then
  ret %"class.std::basic_ostream"* %__out


Popped off BBWL: 
if.else:                                          ; preds = %entry
  %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s.0)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s.0, i64 %call)
  br label %if.end

Marking Edge Executable: if.else -> if.end

Popped off BBWL: 
if.then:                                          ; preds = %entry
  call void @_ZSt16__throw_bad_castv() #14
  unreachable


Popped off BBWL: 
if.end:                                           ; preds = %entry
  ret %"class.std::ctype"* %__f.0


Popped off BBWL: 
if.end:                                           ; preds = %entry
  call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
  %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
  %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
  %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
  %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
  %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
  br label %return

markOverdefined:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
Merged overdefined into   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9 : overdefined
markOverdefined:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
Merged overdefined into   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8 : overdefined
Merged overdefined into   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) : overdefined
Marking Block Executable: return

Popped off BBWL: 
return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
  ret i8 %retval.0

Merged overdefined into   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] : overdefined

Popped off BBWL: 
if.then:                                          ; preds = %entry
  %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9
  %idxprom = zext i8 %__c to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
  br label %return

markOverdefined:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9
markOverdefined:   %idxprom = zext i8 %__c to i64
markOverdefined:   %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom
Merged overdefined into   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 : overdefined
Marking Edge Executable: if.then -> return

Popped off BBWL: 
entry:
  call void @__cxx_global_var_init()
  ret void

Marking Block Executable: entry

Popped off BBWL: 
entry:
  call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #14
  ret void

Merged overdefined into   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #14 : overdefined

Popped off BBWL: 
entry:
  %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8
  %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %if.then, label %if.end


Popped off BBWL: 
entry:
  %tobool = icmp ne %"class.std::ctype"* %__f, null
  %__f.0 = call %"class.std::ctype"* @llvm.ssa.copy.140736443612080(%"class.std::ctype"* %__f)
  br i1 %tobool, label %if.end, label %if.then


Popped off BBWL: 
entry:
  %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5
  %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
  %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)
  %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)
  ret i8 %call2


Popped off BBWL: 
entry:
  %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
  ret %"class.std::basic_ostream"* %call


Popped off BBWL: 
entry:
  %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1
  %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
  store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
  ret i64 %0


Popped off BBWL: 
entry:
  %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2
  %0 = load i64, i64* %_M_width, align 8, !tbaa !2
  store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
  ret i64 %0


Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*
  %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5
  %1 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
  ret i32 %1


Popped off BBWL: 
entry:
  %or = or i32 %__a, %__b
  ret i32 %or


Popped off BBWL: 
entry:
  %call = call i64 @strlen(i8* %__s) #14
  ret i64 %call


Popped off BBWL: 
entry:
  %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this)
  %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %call, i32 %__state)
  call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %call2)
  ret void


Popped off BBWL: 
entry:
  %or = or i32 %__a, %__b
  ret i32 %or


Popped off BBWL: 
entry:
  %and = and i32 %__a, %__b
  ret i32 %and


Popped off BBWL: 
entry:
  %0 = load i32, i32* %__a, align 4, !tbaa !2
  %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
  store i32 %call, i32* %__a, align 4, !tbaa !2
  ret i32* %__a


Popped off BBWL: 
entry:
  %neg = xor i32 %__a, -1
  ret i32 %neg


Popped off BBWL: 
entry:
  %0 = load i32, i32* %__a, align 4, !tbaa !2
  %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
  store i32 %call, i32* %__a, align 4, !tbaa !2
  ret i32* %__a


Popped off BBWL: 
entry:
  %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
  %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
  %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
  %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)
  %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
  %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)
  ret i32 %0


Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
  %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %call)
  %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1)
  ret %"class.std::basic_ostream"* %call2


Popped off BBWL: 
entry:
  %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
  ret %"class.std::basic_ostream"* %call


Popped off BBWL: 
entry:
  %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
  ret %"class.std::basic_ostream"* %call


Popped off BBWL: 
entry:
  ret i32 %__n


Popped off BBWL: 
entry:
  %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260)
  ret %"class.std::ios_base"* %__base


Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %this to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %this to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
  %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
  ret %"class.std::basic_ostream"* %this


Popped off BBWL: 
entry:
  ret i32 %__n


Popped off BBWL: 
entry:
  %tobool = icmp ne i8* %__s, null
  %__s.0 = call i8* @llvm.ssa.copy.140736427712736(i8* %__s)
  br i1 %tobool, label %if.else, label %if.then


Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
  %conv = sext i32 %__f.coerce to i64
  %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
  ret %"class.std::basic_ostream"* %__os


Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
  %conv = sext i32 %__f.coerce to i64
  %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
  ret %"class.std::basic_ostream"* %__os


Popped off BBWL: 
entry:
  br label %for.cond

Marking Block Executable: for.cond

Popped off BBWL: 
for.cond:                                         ; preds = %for.body, %entry
  %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
  %cmp = icmp sle i32 %n.0, 65536
  %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0)
  br i1 %cmp, label %for.body, label %for.cond.cleanup

Merged constantrange<2, 3> into   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ] : constantrange<2, 3>
Merged constantrange<-1, 0> into   %cmp = icmp sle i32 %n.0, 65536 : constantrange<-1, 0>
Merged constantrange incl. undef <2, 3> into   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0) : constantrange incl. undef <2, 3>
Marking Block Executable: for.body

Popped off BBWL: 
for.body:                                         ; preds = %for.cond
  %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0.0)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
  %call2 = call i32 @_ZSt4setwi(i32 6)
  %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
  %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0.0)
  %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
  %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
  %call9 = call i32 @_ZSt12setprecisioni(i32 16)
  %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
  %call14 = call i32 @_ZSt4setwi(i32 20)
  %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
  %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
  %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
  %mul = mul nsw i32 %n.0.0, 2
  br label %for.cond, !llvm.loop !2

Merged overdefined into   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0)) : overdefined
Merged overdefined into   %call2 = call i32 @_ZSt4setwi(i32 6) : overdefined
Merged overdefined into   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2) : overdefined
Merged overdefined into   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0.0) : overdefined
Merged overdefined into   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0)) : overdefined
Merged overdefined into   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base) : overdefined
Merged overdefined into   %call9 = call i32 @_ZSt12setprecisioni(i32 16) : overdefined
Merged overdefined into   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9) : overdefined
Merged overdefined into   %call14 = call i32 @_ZSt4setwi(i32 20) : overdefined
Merged overdefined into   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14) : overdefined
Merged overdefined into   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call) : overdefined
Merged overdefined into   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_) : overdefined
Merged constantrange<4, 5> into   %mul = mul nsw i32 %n.0.0, 2 : constantrange<4, 5>
Marking Edge Executable: for.body -> for.cond
Merged constantrange<2, 5> into   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ] : constantrange<2, 5>

Popped off BBWL: 
entry:
  %conv = sitofp i32 %__y to double
  %call = call double @pow(double %__x, double %conv) #14
  ret double %call


Popped off BBWL: 
entry:
  %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
  ret double %call


Popped off BBWL: 
entry:
  %add = add nsw i32 %n, 1
  %div = sdiv i32 %add, 2
  %mul = mul nsw i32 %div, 2
  %sub = fsub double %b, %a
  %conv = sitofp i32 %mul to double
  %div1 = fdiv double %sub, %conv
  %add2 = fadd double %a, %div1
  %call = call double %f(double %add2)
  br label %for.cond

markOverdefined:   %div1 = fdiv double %sub, %conv
markOverdefined:   %add2 = fadd double %a, %div1
Marking Block Executable: for.cond

Popped off BBWL: 
for.cond:                                         ; preds = %for.body, %entry
  %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
  %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
  %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
  %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
  %cmp = icmp slt i32 %even.0, %mul
  %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0)
  br i1 %cmp, label %for.body, label %for.end

Merged constant<double 0.000000e+00> into   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ] : constant<double 0.000000e+00>
Merged overdefined into   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ] : overdefined
Merged constantrange<2, 3> into   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] : constantrange<2, 3>
Merged constantrange<3, 4> into   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] : constantrange<3, 4>
markOverdefined:   %cmp = icmp slt i32 %even.0, %mul
Merged constantrange incl. undef <2, 3> into   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0) : constantrange incl. undef <2, 3>
Marking Block Executable: for.body
Marking Block Executable: for.end

Popped off BBWL: 
for.end:                                          ; preds = %for.cond
  %call15 = call double %f(double %a)
  %call16 = call double %f(double %b)
  %add17 = fadd double %call15, %call16
  %mul18 = fmul double 2.000000e+00, %sum_even.0
  %add19 = fadd double %add17, %mul18
  %mul20 = fmul double 4.000000e+00, %sum_odd.0
  %add21 = fadd double %add19, %mul20
  %mul22 = fmul double %div1, %add21
  %div23 = fdiv double %mul22, 3.000000e+00
  ret double %div23

Merged overdefined into   %call15 = call double %f(double %a) : overdefined
Merged overdefined into   %call16 = call double %f(double %b) : overdefined
markOverdefined:   %add17 = fadd double %call15, %call16
Merged constant<double 0.000000e+00> into   %mul18 = fmul double 2.000000e+00, %sum_even.0 : constant<double 0.000000e+00>
markOverdefined:   %add19 = fadd double %add17, %mul18
markOverdefined:   %mul20 = fmul double 4.000000e+00, %sum_odd.0
markOverdefined:   %add21 = fadd double %add19, %mul20
markOverdefined:   %mul22 = fmul double %div1, %add21
markOverdefined:   %div23 = fdiv double %mul22, 3.000000e+00
Merged overdefined into ; Function Attrs: uwtable mustprogress
define dso_local double @_Z7simpsonPFddEddi(double (double)* %f, double %a, double %b, i32 %n) #0 {
entry:
  %add = add nsw i32 %n, 1
  %div = sdiv i32 %add, 2
  %mul = mul nsw i32 %div, 2
  %sub = fsub double %b, %a
  %conv = sitofp i32 %mul to double
  %div1 = fdiv double %sub, %conv
  %add2 = fadd double %a, %div1
  %call = call double %f(double %add2)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
  %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
  %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
  %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
  %cmp = icmp slt i32 %even.0, %mul
  %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %conv3 = sitofp i32 %even.0.0 to double
  %mul4 = fmul double %conv3, %div1
  %add5 = fadd double %a, %mul4
  %call6 = call double %f(double %add5)
  %add7 = fadd double %sum_even.0, %call6
  %conv8 = sitofp i32 %odd.0 to double
  %mul9 = fmul double %conv8, %div1
  %add10 = fadd double %a, %mul9
  %call11 = call double %f(double %add10)
  %add12 = fadd double %sum_odd.0, %call11
  %add13 = add nsw i32 %even.0.0, 2
  %add14 = add nsw i32 %odd.0, 2
  br label %for.cond, !llvm.loop !2

for.end:                                          ; preds = %for.cond
  %call15 = call double %f(double %a)
  %call16 = call double %f(double %b)
  %add17 = fadd double %call15, %call16
  %mul18 = fmul double 2.000000e+00, %sum_even.0
  %add19 = fadd double %add17, %mul18
  %mul20 = fmul double 4.000000e+00, %sum_odd.0
  %add21 = fadd double %add19, %mul20
  %mul22 = fmul double %div1, %add21
  %div23 = fdiv double %mul22, 3.000000e+00
  ret double %div23
}
 : overdefined

Popped off BBWL: 
for.body:                                         ; preds = %for.cond
  %conv3 = sitofp i32 %even.0.0 to double
  %mul4 = fmul double %conv3, %div1
  %add5 = fadd double %a, %mul4
  %call6 = call double %f(double %add5)
  %add7 = fadd double %sum_even.0, %call6
  %conv8 = sitofp i32 %odd.0 to double
  %mul9 = fmul double %conv8, %div1
  %add10 = fadd double %a, %mul9
  %call11 = call double %f(double %add10)
  %add12 = fadd double %sum_odd.0, %call11
  %add13 = add nsw i32 %even.0.0, 2
  %add14 = add nsw i32 %odd.0, 2
  br label %for.cond, !llvm.loop !2

markConstant: double 2.000000e+00:   %conv3 = sitofp i32 %even.0.0 to double
markOverdefined:   %mul4 = fmul double %conv3, %div1
markOverdefined:   %add5 = fadd double %a, %mul4
Merged overdefined into   %call6 = call double %f(double %add5) : overdefined
markOverdefined:   %add7 = fadd double %sum_even.0, %call6
markConstant: double 3.000000e+00:   %conv8 = sitofp i32 %odd.0 to double
markOverdefined:   %mul9 = fmul double %conv8, %div1
markOverdefined:   %add10 = fadd double %a, %mul9
Merged overdefined into   %call11 = call double %f(double %add10) : overdefined
markOverdefined:   %add12 = fadd double %sum_odd.0, %call11
Merged constantrange<4, 5> into   %add13 = add nsw i32 %even.0.0, 2 : constantrange<4, 5>
Merged constantrange<5, 6> into   %add14 = add nsw i32 %odd.0, 2 : constantrange<5, 6>
Marking Edge Executable: for.body -> for.cond
Merged overdefined into   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ] : overdefined
Merged constantrange<2, 5> into   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] : constantrange<2, 5>
Merged constantrange<3, 6> into   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] : constantrange<3, 6>

Popped off OI-WL:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
markOverdefined:   %mul18 = fmul double 2.000000e+00, %sum_even.0

Popped off OI-WL:   %mul18 = fmul double 2.000000e+00, %sum_even.0

Popped off OI-WL:   %add12 = fadd double %sum_odd.0, %call11

Popped off OI-WL:   %call11 = call double %f(double %add10)

Popped off OI-WL:   %add10 = fadd double %a, %mul9

Popped off OI-WL:   %mul9 = fmul double %conv8, %div1

Popped off OI-WL:   %add7 = fadd double %sum_even.0, %call6

Popped off OI-WL:   %call6 = call double %f(double %add5)

Popped off OI-WL:   %add5 = fadd double %a, %mul4

Popped off OI-WL:   %mul4 = fmul double %conv3, %div1

Popped off OI-WL: ; Function Attrs: uwtable mustprogress
define dso_local double @_Z7simpsonPFddEddi(double (double)* %f, double %a, double %b, i32 %n) #0 {
entry:
  %add = add nsw i32 %n, 1
  %div = sdiv i32 %add, 2
  %mul = mul nsw i32 %div, 2
  %sub = fsub double %b, %a
  %conv = sitofp i32 %mul to double
  %div1 = fdiv double %sub, %conv
  %add2 = fadd double %a, %div1
  %call = call double %f(double %add2)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
  %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
  %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
  %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
  %cmp = icmp slt i32 %even.0, %mul
  %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %conv3 = sitofp i32 %even.0.0 to double
  %mul4 = fmul double %conv3, %div1
  %add5 = fadd double %a, %mul4
  %call6 = call double %f(double %add5)
  %add7 = fadd double %sum_even.0, %call6
  %conv8 = sitofp i32 %odd.0 to double
  %mul9 = fmul double %conv8, %div1
  %add10 = fadd double %a, %mul9
  %call11 = call double %f(double %add10)
  %add12 = fadd double %sum_odd.0, %call11
  %add13 = add nsw i32 %even.0.0, 2
  %add14 = add nsw i32 %odd.0, 2
  br label %for.cond, !llvm.loop !2

for.end:                                          ; preds = %for.cond
  %call15 = call double %f(double %a)
  %call16 = call double %f(double %b)
  %add17 = fadd double %call15, %call16
  %mul18 = fmul double 2.000000e+00, %sum_even.0
  %add19 = fadd double %add17, %mul18
  %mul20 = fmul double 4.000000e+00, %sum_odd.0
  %add21 = fadd double %add19, %mul20
  %mul22 = fmul double %div1, %add21
  %div23 = fdiv double %mul22, 3.000000e+00
  ret double %div23
}

Merged overdefined into   %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0.0) : overdefined

Popped off OI-WL:   %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0.0)

Popped off OI-WL:   %div23 = fdiv double %mul22, 3.000000e+00

Popped off OI-WL:   %mul22 = fmul double %div1, %add21

Popped off OI-WL:   %add21 = fadd double %add19, %mul20

Popped off OI-WL:   %mul20 = fmul double 4.000000e+00, %sum_odd.0

Popped off OI-WL:   %add19 = fadd double %add17, %mul18

Popped off OI-WL:   %add17 = fadd double %call15, %call16

Popped off OI-WL:   %call16 = call double %f(double %b)

Popped off OI-WL:   %call15 = call double %f(double %a)

Popped off OI-WL:   %cmp = icmp slt i32 %even.0, %mul

Popped off OI-WL:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]

Popped off OI-WL:   %add2 = fadd double %a, %div1

Popped off OI-WL:   %div1 = fdiv double %sub, %conv

Popped off OI-WL:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)

Popped off OI-WL:   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)

Popped off OI-WL:   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)

Popped off OI-WL:   %call14 = call i32 @_ZSt4setwi(i32 20)

Popped off OI-WL:   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)

Popped off OI-WL:   %call9 = call i32 @_ZSt12setprecisioni(i32 16)

Popped off OI-WL:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)

Popped off OI-WL:   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))

Popped off OI-WL:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0.0)

Popped off OI-WL:   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)

Popped off OI-WL:   %call2 = call i32 @_ZSt4setwi(i32 6)

Popped off OI-WL:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))

Popped off OI-WL:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #14

Popped off OI-WL:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8

Popped off OI-WL:   %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom

Popped off OI-WL:   %idxprom = zext i8 %__c to i64

Popped off OI-WL:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9

Popped off OI-WL:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]

Popped off OI-WL:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)

Popped off OI-WL:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8

Popped off OI-WL:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6

Popped off OI-WL:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9

Popped off OI-WL:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***

Popped off OI-WL:   %conv = sitofp i32 %mul to double

Popped off I-WL:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
Merged constantrange<5, 8> into   %add14 = add nsw i32 %odd.0, 2 : constantrange<5, 8>
markOverdefined:   %conv8 = sitofp i32 %odd.0 to double

Popped off I-WL:   %add14 = add nsw i32 %odd.0, 2
Merged constantrange<3, 8> into   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] : constantrange<3, 8>

Popped off I-WL:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
Merged constantrange<5, 10> into   %add14 = add nsw i32 %odd.0, 2 : constantrange<5, 10>

Popped off I-WL:   %add14 = add nsw i32 %odd.0, 2
Merged constantrange<3, 10> into   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] : overdefined

Popped off I-WL:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
Merged constantrange incl. undef <2, 5> into   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0) : constantrange incl. undef <2, 5>

Popped off I-WL:   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0)
Merged constantrange<4, 7> into   %add13 = add nsw i32 %even.0.0, 2 : constantrange<4, 7>
markOverdefined:   %conv3 = sitofp i32 %even.0.0 to double

Popped off I-WL:   %add13 = add nsw i32 %even.0.0, 2
Merged constantrange<2, 7> into   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] : constantrange<2, 7>

Popped off I-WL:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
Merged constantrange incl. undef <2, 7> into   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0) : constantrange incl. undef <2, 7>

Popped off I-WL:   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0)
Merged constantrange<4, 9> into   %add13 = add nsw i32 %even.0.0, 2 : constantrange<4, 9>

Popped off I-WL:   %add13 = add nsw i32 %even.0.0, 2
Merged constantrange<2, 9> into   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] : overdefined

Popped off I-WL:   %add14 = add nsw i32 %odd.0, 2

Popped off I-WL:   %add13 = add nsw i32 %even.0.0, 2

Popped off I-WL:   %conv8 = sitofp i32 %odd.0 to double

Popped off I-WL:   %conv3 = sitofp i32 %even.0.0 to double

Popped off I-WL:   %mul18 = fmul double 2.000000e+00, %sum_even.0

Popped off I-WL:   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0)

Popped off I-WL:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]

Popped off I-WL:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]

Popped off I-WL:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]

Popped off I-WL:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
Merged constantrange incl. undef <2, 5> into   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0) : constantrange incl. undef <2, 5>

Popped off I-WL:   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0)
Merged constantrange<4, 9> into   %mul = mul nsw i32 %n.0.0, 2 : constantrange<4, 9>

Popped off I-WL:   %mul = mul nsw i32 %n.0.0, 2
Merged constantrange<2, 9> into   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ] : constantrange<2, 9>

Popped off I-WL:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
Merged constantrange incl. undef <2, 9> into   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0) : constantrange incl. undef <2, 9>

Popped off I-WL:   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0)
Merged constantrange<4, 17> into   %mul = mul nsw i32 %n.0.0, 2 : constantrange<4, 17>

Popped off I-WL:   %mul = mul nsw i32 %n.0.0, 2
Merged constantrange<2, 17> into   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ] : overdefined

Popped off I-WL:   %mul = mul nsw i32 %n.0.0, 2

Popped off I-WL:   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0)

Popped off I-WL:   %cmp = icmp sle i32 %n.0, 65536

Popped off I-WL:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]

Popped off OI-WL:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
Merged constantrange incl. undef <-2147483648, 65537> into   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0) : constantrange incl. undef <-2147483648, 65537>
markOverdefined:   %cmp = icmp sle i32 %n.0, 65536

Popped off OI-WL:   %cmp = icmp sle i32 %n.0, 65536
Marking Block Executable: for.cond.cleanup

Popped off OI-WL:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
Merged constantrange incl. undef <-2147483648, 2147483646> into   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0) : constantrange incl. undef <-2147483648, 2147483646>

Popped off OI-WL:   %conv3 = sitofp i32 %even.0.0 to double

Popped off OI-WL:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
Merged overdefined into   %add14 = add nsw i32 %odd.0, 2 : overdefined

Popped off OI-WL:   %add14 = add nsw i32 %odd.0, 2

Popped off OI-WL:   %conv8 = sitofp i32 %odd.0 to double

Popped off I-WL:   %even.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %even.0)
Merged constantrange<-2147483646, -2147483648> into   %add13 = add nsw i32 %even.0.0, 2 : constantrange<-2147483646, -2147483648>

Popped off I-WL:   %add13 = add nsw i32 %even.0.0, 2

Popped off I-WL:   %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0)
Merged overdefined into   %mul = mul nsw i32 %n.0.0, 2 : overdefined

Popped off BBWL: 
for.cond.cleanup:                                 ; preds = %for.cond
  ret i32 0

Merged constantrange<0, 1> into ; Function Attrs: norecurse uwtable mustprogress
define dso_local i32 @main() #7 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
  %cmp = icmp sle i32 %n.0, 65536
  %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0)
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret i32 0

for.body:                                         ; preds = %for.cond
  %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0.0)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
  %call2 = call i32 @_ZSt4setwi(i32 6)
  %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
  %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0.0)
  %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
  %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
  %call9 = call i32 @_ZSt12setprecisioni(i32 16)
  %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
  %call14 = call i32 @_ZSt4setwi(i32 20)
  %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
  %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
  %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
  %mul = mul nsw i32 %n.0.0, 2
  br label %for.cond, !llvm.loop !4
}
 : constantrange<0, 1>

Popped off OI-WL:   %mul = mul nsw i32 %n.0.0, 2

Popped off I-WL: ; Function Attrs: norecurse uwtable mustprogress
define dso_local i32 @main() #7 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
  %cmp = icmp sle i32 %n.0, 65536
  %n.0.0 = call i32 @llvm.ssa.copy.140736427570520(i32 %n.0)
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret i32 0

for.body:                                         ; preds = %for.cond
  %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0.0)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
  %call2 = call i32 @_ZSt4setwi(i32 6)
  %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
  %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0.0)
  %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
  %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
  %call9 = call i32 @_ZSt12setprecisioni(i32 16)
  %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
  %call14 = call i32 @_ZSt4setwi(i32 20)
  %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
  %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
  %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
  %mul = mul nsw i32 %n.0.0, 2
  br label %for.cond, !llvm.loop !4
}

RESOLVING UNDEFS
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry

Popped off BBWL: 
entry:
  call void @__cxx_global_var_init()
  ret void
Marking Block Executable: entry

Popped off BBWL: 
entry:
  call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #13
  ret void

Popped off BBWL: 
entry:
  %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8
  %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %if.then, label %if.end
Marking Edge Executable: entry -> if.then
Marking Block Executable: if.then
Marking Edge Executable: entry -> if.end
Marking Block Executable: if.end

Popped off BBWL: 
if.end:                                           ; preds = %entry
  call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
  %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
  %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
  %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
  %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
  %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
  br label %return
Marking Edge Executable: if.end -> return
Marking Block Executable: return

Popped off BBWL: 
return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
  ret i8 %retval.0

Popped off BBWL: 
if.then:                                          ; preds = %entry
  %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9
  %idxprom = zext i8 %__c to i64
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
  br label %return
Marking Edge Executable: if.then -> return

Popped off BBWL: 
entry:
  %tobool = icmp ne %"class.std::ctype"* %__f, null
  br i1 %tobool, label %if.end, label %if.then
Marking Edge Executable: entry -> if.end
Marking Block Executable: if.end
Marking Edge Executable: entry -> if.then
Marking Block Executable: if.then

Popped off BBWL: 
if.then:                                          ; preds = %entry
  call void @_ZSt16__throw_bad_castv() #13
  unreachable

Popped off BBWL: 
if.end:                                           ; preds = %entry
  ret %"class.std::ctype"* %__f

Popped off BBWL: 
entry:
  %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5
  %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
  %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)
  %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)
  ret i8 %call2

Popped off BBWL: 
entry:
  %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
  ret %"class.std::basic_ostream"* %call

Popped off BBWL: 
entry:
  %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1
  %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
  store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
  ret i64 %0

Popped off BBWL: 
entry:
  %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2
  %0 = load i64, i64* %_M_width, align 8, !tbaa !2
  store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
  ret i64 %0

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*
  %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5
  %1 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
  ret i32 %1

Popped off BBWL: 
entry:
  %or = or i32 %__a, %__b
  ret i32 %or

Popped off BBWL: 
entry:
  %call = call i64 @strlen(i8* %__s) #13
  ret i64 %call

Popped off BBWL: 
entry:
  %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this)
  %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %call, i32 %__state)
  call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %call2)
  ret void

Popped off BBWL: 
entry:
  %or = or i32 %__a, %__b
  ret i32 %or

Popped off BBWL: 
entry:
  %and = and i32 %__a, %__b
  ret i32 %and

Popped off BBWL: 
entry:
  %0 = load i32, i32* %__a, align 4, !tbaa !2
  %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
  store i32 %call, i32* %__a, align 4, !tbaa !2
  ret i32* %__a

Popped off BBWL: 
entry:
  %neg = xor i32 %__a, -1
  ret i32 %neg

Popped off BBWL: 
entry:
  %0 = load i32, i32* %__a, align 4, !tbaa !2
  %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
  store i32 %call, i32* %__a, align 4, !tbaa !2
  ret i32* %__a

Popped off BBWL: 
entry:
  %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
  %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
  %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
  %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)
  %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
  %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)
  ret i32 %0

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
  %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %call)
  %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1)
  ret %"class.std::basic_ostream"* %call2

Popped off BBWL: 
entry:
  %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
  ret %"class.std::basic_ostream"* %call

Popped off BBWL: 
entry:
  %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
  ret %"class.std::basic_ostream"* %call

Popped off BBWL: 
entry:
  ret i32 %__n

Popped off BBWL: 
entry:
  %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260)
  ret %"class.std::ios_base"* %__base

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %this to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %this to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
  %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
  ret %"class.std::basic_ostream"* %this

Popped off BBWL: 
entry:
  ret i32 %__n

Popped off BBWL: 
entry:
  %tobool = icmp ne i8* %__s, null
  br i1 %tobool, label %if.else, label %if.then
Marking Edge Executable: entry -> if.else
Marking Block Executable: if.else
Marking Edge Executable: entry -> if.then
Marking Block Executable: if.then

Popped off BBWL: 
if.then:                                          ; preds = %entry
  %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
  call void @_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 1)
  br label %if.end
Marking Edge Executable: if.then -> if.end
Marking Block Executable: if.end

Popped off BBWL: 
if.end:                                           ; preds = %if.else, %if.then
  ret %"class.std::basic_ostream"* %__out

Popped off BBWL: 
if.else:                                          ; preds = %entry
  %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s, i64 %call)
  br label %if.end
Marking Edge Executable: if.else -> if.end

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
  %conv = sext i32 %__f.coerce to i64
  %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
  ret %"class.std::basic_ostream"* %__os

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
  %conv = sext i32 %__f.coerce to i64
  %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
  ret %"class.std::basic_ostream"* %__os

Popped off BBWL: 
entry:
  br label %for.cond
Marking Edge Executable: entry -> for.cond
Marking Block Executable: for.cond

Popped off BBWL: 
for.cond:                                         ; preds = %for.body, %entry
  %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
  %cmp = icmp sle i32 %n.0, 65536
  br i1 %cmp, label %for.body, label %for.cond.cleanup
Marking Edge Executable: for.cond -> for.body
Marking Block Executable: for.body
Marking Edge Executable: for.cond -> for.cond.cleanup
Marking Block Executable: for.cond.cleanup

Popped off BBWL: 
for.cond.cleanup:                                 ; preds = %for.cond
  ret i32 0

Popped off BBWL: 
for.body:                                         ; preds = %for.cond
  %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
  %call2 = call i32 @_ZSt4setwi(i32 6)
  %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
  %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)
  %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
  %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
  %call9 = call i32 @_ZSt12setprecisioni(i32 16)
  %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
  %call14 = call i32 @_ZSt4setwi(i32 20)
  %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
  %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
  %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
  %mul = mul nsw i32 %n.0, 2
  br label %for.cond, !llvm.loop !2
Marking Edge Executable: for.body -> for.cond

Popped off BBWL: 
entry:
  %conv = sitofp i32 %__y to double
  %call = call double @pow(double %__x, double %conv) #13
  ret double %call

Popped off BBWL: 
entry:
  %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
  ret double %call

Popped off BBWL: 
entry:
  %add = add nsw i32 %n, 1
  %div = sdiv i32 %add, 2
  %mul = mul nsw i32 %div, 2
  %sub = fsub double %b, %a
  %conv = sitofp i32 %mul to double
  %div1 = fdiv double %sub, %conv
  %add2 = fadd double %a, %div1
  %call = call double %f(double %add2)
  br label %for.cond
Marking Edge Executable: entry -> for.cond
Marking Block Executable: for.cond

Popped off BBWL: 
for.cond:                                         ; preds = %for.body, %entry
  %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
  %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
  %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
  %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
  %cmp = icmp slt i32 %even.0, %mul
  br i1 %cmp, label %for.body, label %for.end
Marking Edge Executable: for.cond -> for.body
Marking Block Executable: for.body
Marking Edge Executable: for.cond -> for.end
Marking Block Executable: for.end

Popped off BBWL: 
for.end:                                          ; preds = %for.cond
  %call15 = call double %f(double %a)
  %call16 = call double %f(double %b)
  %add17 = fadd double %call15, %call16
  %mul18 = fmul double 2.000000e+00, %sum_even.0
  %add19 = fadd double %add17, %mul18
  %mul20 = fmul double 4.000000e+00, %sum_odd.0
  %add21 = fadd double %add19, %mul20
  %mul22 = fmul double %div1, %add21
  %div23 = fdiv double %mul22, 3.000000e+00
  ret double %div23

Popped off BBWL: 
for.body:                                         ; preds = %for.cond
  %conv3 = sitofp i32 %even.0 to double
  %mul4 = fmul double %conv3, %div1
  %add5 = fadd double %a, %mul4
  %call6 = call double %f(double %add5)
  %add7 = fadd double %sum_even.0, %call6
  %conv8 = sitofp i32 %odd.0 to double
  %mul9 = fmul double %conv8, %div1
  %add10 = fadd double %a, %mul9
  %call11 = call double %f(double %add10)
  %add12 = fadd double %sum_odd.0, %call11
  %add13 = add nsw i32 %even.0, 2
  %add14 = add nsw i32 %odd.0, 2
  br label %for.cond, !llvm.loop !2
Marking Edge Executable: for.body -> for.cond

Popped off V-WL:   %add14 = add nsw i32 %odd.0, 2

Popped off V-WL:   %add13 = add nsw i32 %even.0, 2

Popped off V-WL:   %add12 = fadd double %sum_odd.0, %call11

Popped off V-WL:   %call11 = call double %f(double %add10)

Popped off V-WL:   %add10 = fadd double %a, %mul9

Popped off V-WL:   %mul9 = fmul double %conv8, %div1

Popped off V-WL:   %conv8 = sitofp i32 %odd.0 to double

Popped off V-WL:   %add7 = fadd double %sum_even.0, %call6

Popped off V-WL:   %call6 = call double %f(double %add5)

Popped off V-WL:   %add5 = fadd double %a, %mul4

Popped off V-WL:   %mul4 = fmul double %conv3, %div1

Popped off V-WL:   %conv3 = sitofp i32 %even.0 to double

Popped off V-WL: ; Function Attrs: uwtable mustprogress
define dso_local double @_Z7simpsonPFddEddi(double (double)* %f, double %a, double %b, i32 %n) #0 {
entry:
  %add = add nsw i32 %n, 1
  %div = sdiv i32 %add, 2
  %mul = mul nsw i32 %div, 2
  %sub = fsub double %b, %a
  %conv = sitofp i32 %mul to double
  %div1 = fdiv double %sub, %conv
  %add2 = fadd double %a, %div1
  %call = call double %f(double %add2)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
  %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
  %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
  %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
  %cmp = icmp slt i32 %even.0, %mul
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %conv3 = sitofp i32 %even.0 to double
  %mul4 = fmul double %conv3, %div1
  %add5 = fadd double %a, %mul4
  %call6 = call double %f(double %add5)
  %add7 = fadd double %sum_even.0, %call6
  %conv8 = sitofp i32 %odd.0 to double
  %mul9 = fmul double %conv8, %div1
  %add10 = fadd double %a, %mul9
  %call11 = call double %f(double %add10)
  %add12 = fadd double %sum_odd.0, %call11
  %add13 = add nsw i32 %even.0, 2
  %add14 = add nsw i32 %odd.0, 2
  br label %for.cond, !llvm.loop !2

for.end:                                          ; preds = %for.cond
  %call15 = call double %f(double %a)
  %call16 = call double %f(double %b)
  %add17 = fadd double %call15, %call16
  %mul18 = fmul double 2.000000e+00, %sum_even.0
  %add19 = fadd double %add17, %mul18
  %mul20 = fmul double 4.000000e+00, %sum_odd.0
  %add21 = fadd double %add19, %mul20
  %mul22 = fmul double %div1, %add21
  %div23 = fdiv double %mul22, 3.000000e+00
  ret double %div23
}


Popped off V-WL:   %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)

Popped off V-WL:   %div23 = fdiv double %mul22, 3.000000e+00

Popped off V-WL:   %mul22 = fmul double %div1, %add21

Popped off V-WL:   %add21 = fadd double %add19, %mul20

Popped off V-WL:   %mul20 = fmul double 4.000000e+00, %sum_odd.0

Popped off V-WL:   %add19 = fadd double %add17, %mul18

Popped off V-WL:   %mul18 = fmul double 2.000000e+00, %sum_even.0

Popped off V-WL:   %add17 = fadd double %call15, %call16

Popped off V-WL:   %call16 = call double %f(double %b)

Popped off V-WL:   %call15 = call double %f(double %a)

Popped off V-WL:   %cmp = icmp slt i32 %even.0, %mul

Popped off V-WL:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]

Popped off V-WL:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]

Popped off V-WL:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]

Popped off V-WL:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]

Popped off V-WL:   %call = call double %f(double %add2)

Popped off V-WL:   %add2 = fadd double %a, %div1

Popped off V-WL:   %div1 = fdiv double %sub, %conv

Popped off V-WL:   %conv = sitofp i32 %mul to double

Popped off V-WL:   %sub = fsub double %b, %a

Popped off V-WL:   %mul = mul nsw i32 %div, 2

Popped off V-WL:   %div = sdiv i32 %add, 2

Popped off V-WL:   %add = add nsw i32 %n, 1

Popped off V-WL: ; Function Attrs: uwtable mustprogress
define dso_local double @_Z4funcd(double %x) #0 {
entry:
  %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
  ret double %call
}


Popped off V-WL:   %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)

Popped off V-WL:   %call = call double @pow(double %__x, double %conv) #13

Popped off V-WL:   %conv = sitofp i32 %__y to double

Popped off V-WL:   %mul = mul nsw i32 %n.0, 2

Popped off V-WL:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)

Popped off V-WL:   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)

Popped off V-WL:   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)

Popped off V-WL:   %call14 = call i32 @_ZSt4setwi(i32 20)

Popped off V-WL:   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)

Popped off V-WL:   %call9 = call i32 @_ZSt12setprecisioni(i32 16)

Popped off V-WL:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)

Popped off V-WL:   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))

Popped off V-WL:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)

Popped off V-WL:   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)

Popped off V-WL:   %call2 = call i32 @_ZSt4setwi(i32 6)

Popped off V-WL:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))

Popped off V-WL: ; Function Attrs: norecurse uwtable mustprogress
define dso_local i32 @main() #7 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
  %cmp = icmp sle i32 %n.0, 65536
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  ret i32 0

for.body:                                         ; preds = %for.cond
  %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
  %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
  %call2 = call i32 @_ZSt4setwi(i32 6)
  %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
  %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)
  %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
  %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
  %call9 = call i32 @_ZSt12setprecisioni(i32 16)
  %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
  %call14 = call i32 @_ZSt4setwi(i32 20)
  %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
  %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
  %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
  %mul = mul nsw i32 %n.0, 2
  br label %for.cond, !llvm.loop !4
}


Popped off V-WL:   %cmp = icmp sle i32 %n.0, 65536

Popped off V-WL:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]

Popped off V-WL:   %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)

Popped off V-WL:   %conv = sext i32 %__f.coerce to i64

Popped off V-WL:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off V-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off V-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off V-WL:   %vbase.offset = load i64, i64* %1, align 8

Popped off V-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off V-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off V-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2

Popped off V-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off V-WL:   %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)

Popped off V-WL:   %conv = sext i32 %__f.coerce to i64

Popped off V-WL:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off V-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off V-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off V-WL:   %vbase.offset = load i64, i64* %1, align 8

Popped off V-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off V-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off V-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2

Popped off V-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off V-WL:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s, i64 %call)

Popped off V-WL:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s)

Popped off V-WL:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*

Popped off V-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off V-WL:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*

Popped off V-WL:   %vbase.offset = load i64, i64* %1, align 8

Popped off V-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off V-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off V-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2

Popped off V-WL:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**

Popped off V-WL:   %tobool = icmp ne i8* %__s, null

Popped off V-WL:   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)

Popped off V-WL:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off V-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off V-WL:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*

Popped off V-WL:   %vbase.offset = load i64, i64* %1, align 8

Popped off V-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off V-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off V-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2

Popped off V-WL:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**

Popped off V-WL:   %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260)

Popped off V-WL:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)

Popped off V-WL:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)

Popped off V-WL:   %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1)

Popped off V-WL:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %call)

Popped off V-WL:   %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10)

Popped off V-WL:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*

Popped off V-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off V-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off V-WL:   %vbase.offset = load i64, i64* %1, align 8

Popped off V-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off V-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off V-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2

Popped off V-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off V-WL:   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)

Popped off V-WL:   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)

Popped off V-WL:   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)

Popped off V-WL:   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)

Popped off V-WL:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2

Popped off V-WL:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3

Popped off V-WL:   %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)

Popped off V-WL:   %0 = load i32, i32* %__a, align 4, !tbaa !2

Popped off V-WL:   %neg = xor i32 %__a, -1

Popped off V-WL:   %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)

Popped off V-WL:   %0 = load i32, i32* %__a, align 4, !tbaa !2

Popped off V-WL:   %and = and i32 %__a, %__b

Popped off V-WL:   %or = or i32 %__a, %__b

Popped off V-WL:   %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %call, i32 %__state)

Popped off V-WL:   %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this)

Popped off V-WL:   %call = call i64 @strlen(i8* %__s) #13

Popped off V-WL:   %or = or i32 %__a, %__b

Popped off V-WL:   %1 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2

Popped off V-WL:   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5

Popped off V-WL:   %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*

Popped off V-WL:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2

Popped off V-WL:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2

Popped off V-WL:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2

Popped off V-WL:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1

Popped off V-WL:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)

Popped off V-WL:   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)

Popped off V-WL:   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)

Popped off V-WL:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2

Popped off V-WL:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5

Popped off V-WL:   %tobool = icmp ne %"class.std::ctype"* %__f, null

Popped off V-WL:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8

Popped off V-WL:   %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom

Popped off V-WL:   %idxprom = zext i8 %__c to i64

Popped off V-WL:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9

Popped off V-WL:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]

Popped off V-WL:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)

Popped off V-WL:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8

Popped off V-WL:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6

Popped off V-WL:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9

Popped off V-WL:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***

Popped off V-WL:   %tobool = icmp ne i8 %0, 0

Popped off V-WL:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2

Popped off V-WL:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8

Popped off V-WL:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #13
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _GLOBAL__sub_I_Simpson.cpp ----

Computing probabilities for entry

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - entry: float = 1.0, int = 8

GLOBAL DEAD: ; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

GLOBAL DEAD: ; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1

Optimizing Global Constructor: ; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_Simpson.cpp() #2 section ".text.startup" {
entry:
  call fastcc void @__cxx_global_var_init()
  ret void
}

Trying to evaluate BB: 
entry:
  call fastcc void @__cxx_global_var_init()
  ret void

Evaluating Instruction:   call fastcc void @__cxx_global_var_init()
Trying to evaluate BB: 
entry:
  call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #12
  ret void

Evaluating Instruction:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
Can not constant fold function call.
Failed to evaluate function.
Optimizing Global Constructor: ; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_Simpson.cpp() #2 section ".text.startup" {
entry:
  call fastcc void @__cxx_global_var_init()
  ret void
}

Trying to evaluate BB: 
entry:
  call fastcc void @__cxx_global_var_init()
  ret void

Evaluating Instruction:   call fastcc void @__cxx_global_var_init()
Trying to evaluate BB: 
entry:
  call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #12
  ret void

Evaluating Instruction:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
Can not constant fold function call.
Failed to evaluate function.
DeadArgumentEliminationPass - Deleting dead varargs
DeadArgumentEliminationPass - Determining liveness
DeadArgumentEliminationPass - Intrinsically live fn: _Z7simpsonPFddEddi
DeadArgumentEliminationPass - Intrinsically live fn: _Z4funcd
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
DeadArgumentEliminationPass - Inspecting callers for fn: __cxx_global_var_init
DeadArgumentEliminationPass - Inspecting args for fn: __cxx_global_var_init
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt8ios_base4InitC1Ev
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt8ios_base4InitD1Ev
DeadArgumentEliminationPass - Intrinsically live fn: __cxa_atexit
DeadArgumentEliminationPass - Intrinsically live fn: main
DeadArgumentEliminationPass - Intrinsically live fn: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
DeadArgumentEliminationPass - Intrinsically live fn: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
DeadArgumentEliminationPass - Intrinsically live fn: _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt4setwi
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSolsEi
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSolsEPFRSt8ios_baseS0_E
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt5fixedRSt8ios_base
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt12setprecisioni
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSolsEd
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSolsEPFRSoS_E
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
DeadArgumentEliminationPass - Intrinsically live fn: pow
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
DeadArgumentEliminationPass - Intrinsically live fn: _ZStaNRSt13_Ios_FmtflagsS_
DeadArgumentEliminationPass - Intrinsically live fn: _ZStcoSt13_Ios_Fmtflags
DeadArgumentEliminationPass - Intrinsically live fn: _ZStoRRSt13_Ios_FmtflagsS_
DeadArgumentEliminationPass - Intrinsically live fn: _ZStanSt13_Ios_FmtflagsS_
DeadArgumentEliminationPass - Intrinsically live fn: _ZStorSt13_Ios_FmtflagsS_
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt11char_traitsIcE6lengthEPKc
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate
DeadArgumentEliminationPass - Intrinsically live fn: _ZStorSt12_Ios_IostateS_
DeadArgumentEliminationPass - Intrinsically live fn: _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
DeadArgumentEliminationPass - Intrinsically live fn: strlen
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt8ios_base5widthEl
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSt8ios_base9precisionEl
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSo9_M_insertIdEERSoT_
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSo3putEc
DeadArgumentEliminationPass - Intrinsically live fn: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
DeadArgumentEliminationPass - Intrinsically live fn: _ZNSo5flushEv
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
DeadArgumentEliminationPass - Intrinsically live fn: _ZNKSt5ctypeIcE5widenEc
DeadArgumentEliminationPass - Intrinsically live fn: _ZSt16__throw_bad_castv
DeadArgumentEliminationPass - Intrinsically live fn: _ZNKSt5ctypeIcE13_M_widen_initEv
DeadArgumentEliminationPass - Inspecting callers for fn: _GLOBAL__sub_I_Simpson.cpp
DeadArgumentEliminationPass - Intrinsically live fn: _GLOBAL__sub_I_Simpson.cpp


INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %add14 = add nsw i32 %odd.0, 2
IC: ADD:   %add13 = add nsw i32 %even.0, 2
IC: ADD:   %add12 = fadd double %sum_odd.0, %call11
IC: ADD:   %call11 = call double %f(double %add10)
IC: ADD:   %add10 = fadd double %a, %mul9
IC: ADD:   %mul9 = fmul double %conv8, %div1
IC: ADD:   %conv8 = sitofp i32 %odd.0 to double
IC: ADD:   %add7 = fadd double %sum_even.0, %call6
IC: ADD:   %call6 = call double %f(double %add5)
IC: ADD:   %add5 = fadd double %a, %mul4
IC: ADD:   %mul4 = fmul double %conv3, %div1
IC: ADD:   %conv3 = sitofp i32 %even.0 to double
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %add19, %mul20
IC: ADD:   %mul20 = fmul double 4.000000e+00, %sum_odd.0
IC: ADD:   %add19 = fadd double %add17, %mul18
IC: ADD:   %mul18 = fmul double 2.000000e+00, %sum_even.0
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = call double %f(double %b)
IC: ADD:   %call15 = call double %f(double %a)
IC: ADD:   br i1 %cmp, label %for.body, label %for.end
IC: ADD:   %cmp = icmp slt i32 %even.0, %mul
IC: ADD:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: ADD:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: ADD:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: ADD:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: ADD:   br label %for.cond
IC: ADD:   %call = call double %f(double %add2)
IC: ADD:   %add2 = fadd double %a, %div1
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = mul nsw i32 %div, 2
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = mul nsw i32 %div, 2
IC: Old =   %mul = mul nsw i32 %div, 2
    New =   <badref> = shl nsw i32 %div, 1
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ERASE   %0 = mul nsw i32 %div, 2
IC: ADD DEFERRED:   %div = sdiv i32 %add, 2
IC: ADD:   %div = sdiv i32 %add, 2
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %a, %div1
IC: Mod =   %add2 = fadd double %a, %div1
    New =   %add2 = fadd double %div1, %a
IC: ADD:   %add2 = fadd double %div1, %a
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = call double %f(double %add2)
IC: Visiting:   br label %for.cond
IC: Visiting:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: Visiting:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: Visiting:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: Visiting:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: Visiting:   %cmp = icmp slt i32 %even.0, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end
IC: Visiting:   %call15 = call double %f(double %a)
IC: Visiting:   %call16 = call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %mul18 = fmul double 2.000000e+00, %sum_even.0
IC: Mod =   %mul18 = fmul double 2.000000e+00, %sum_even.0
    New =   %mul18 = fmul double %sum_even.0, 2.000000e+00
IC: ADD:   %mul18 = fmul double %sum_even.0, 2.000000e+00
IC: Visiting:   %mul18 = fmul double %sum_even.0, 2.000000e+00
IC: Visiting:   %add19 = fadd double %add17, %mul18
IC: Visiting:   %mul20 = fmul double 4.000000e+00, %sum_odd.0
IC: Mod =   %mul20 = fmul double 4.000000e+00, %sum_odd.0
    New =   %mul20 = fmul double %sum_odd.0, 4.000000e+00
IC: ADD:   %mul20 = fmul double %sum_odd.0, 4.000000e+00
IC: Visiting:   %mul20 = fmul double %sum_odd.0, 4.000000e+00
IC: Visiting:   %add21 = fadd double %add19, %mul20
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %conv3 = sitofp i32 %even.0 to double
IC: Visiting:   %mul4 = fmul double %conv3, %div1
IC: Mod =   %mul4 = fmul double %conv3, %div1
    New =   %mul4 = fmul double %div1, %conv3
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %a, %mul4
IC: Mod =   %add5 = fadd double %a, %mul4
    New =   %add5 = fadd double %mul4, %a
IC: ADD:   %add5 = fadd double %mul4, %a
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.0, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.0 to double
IC: Visiting:   %mul9 = fmul double %conv8, %div1
IC: Mod =   %mul9 = fmul double %conv8, %div1
    New =   %mul9 = fmul double %div1, %conv8
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %a, %mul9
IC: Mod =   %add10 = fadd double %a, %mul9
    New =   %add10 = fadd double %mul9, %a
IC: ADD:   %add10 = fadd double %mul9, %a
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.0, %call11
IC: Visiting:   %add13 = add nsw i32 %even.0, 2
IC: Mod =   %add13 = add nsw i32 %even.0, 2
    New =   %add13 = add nuw nsw i32 %even.0, 2
IC: ADD:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: ADD:   %add13 = add nuw nsw i32 %even.0, 2
IC: Visiting:   %add13 = add nuw nsw i32 %even.0, 2
IC: Visiting:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: Visiting:   %add14 = add nsw i32 %odd.0, 2
IC: Mod =   %add14 = add nsw i32 %odd.0, 2
    New =   %add14 = add nuw nsw i32 %odd.0, 2
IC: ADD:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: ADD:   %add14 = add nuw nsw i32 %odd.0, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.0, 2
IC: Visiting:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: Visiting:   br label %for.cond, !llvm.loop !2


INSTCOMBINE ITERATION #2 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %add14 = add nuw nsw i32 %odd.0, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.0, 2
IC: ADD:   %add12 = fadd double %sum_odd.0, %call11
IC: ADD:   %call11 = call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.0 to double
IC: ADD:   %add7 = fadd double %sum_even.0, %call6
IC: ADD:   %call6 = call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.0 to double
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %add19, %mul20
IC: ADD:   %mul20 = fmul double %sum_odd.0, 4.000000e+00
IC: ADD:   %add19 = fadd double %add17, %mul18
IC: ADD:   %mul18 = fmul double %sum_even.0, 2.000000e+00
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = call double %f(double %b)
IC: ADD:   %call15 = call double %f(double %a)
IC: ADD:   br i1 %cmp, label %for.body, label %for.end
IC: ADD:   %cmp = icmp slt i32 %even.0, %mul
IC: ADD:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: ADD:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: ADD:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: ADD:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: ADD:   br label %for.cond
IC: ADD:   %call = call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = call double %f(double %add2)
IC: Visiting:   br label %for.cond
IC: Visiting:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: Visiting:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: Visiting:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: Visiting:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: Visiting:   %cmp = icmp slt i32 %even.0, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end
IC: Visiting:   %call15 = call double %f(double %a)
IC: Visiting:   %call16 = call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %mul18 = fmul double %sum_even.0, 2.000000e+00
IC: Visiting:   %add19 = fadd double %add17, %mul18
IC: Visiting:   %mul20 = fmul double %sum_odd.0, 4.000000e+00
IC: Visiting:   %add21 = fadd double %add19, %mul20
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %conv3 = sitofp i32 %even.0 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.0, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.0 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.0, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.0, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.0, 2
IC: Visiting:   br label %for.cond, !llvm.loop !2


INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call
IC: ADD:   %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
IC: Visiting:   %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
IC: Visiting:   ret double %call


INSTCOMBINE ITERATION #1 on _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
IC: ADD:   ret double %call
IC: ADD:   %call = call double @pow(double %__x, double %conv) #12
IC: ADD:   %conv = sitofp i32 %__y to double
IC: Visiting:   %conv = sitofp i32 %__y to double
IC: Visiting:   %call = call double @pow(double %__x, double %conv) #12
IC: Visiting:   ret double %call


INSTCOMBINE ITERATION #1 on __cxx_global_var_init
IC: ConstFold operand of:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #12
    Old = i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0)
    New = i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0)
IC: ADD:   ret void
IC: ADD:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* @__dso_handle) #12
IC: ADD:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* @__dso_handle) #12
IC: Mod =   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* @__dso_handle) #12
    New =   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #12
IC: ADD:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #12
IC: Visiting:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #12
IC: Visiting:   ret void


INSTCOMBINE ITERATION #2 on __cxx_global_var_init
IC: ADD:   ret void
IC: ADD:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #12
IC: ADD:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #12
IC: Visiting:   ret void


INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %mul = mul nsw i32 %n.0, 2
IC: ADD:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
IC: ADD:   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
IC: ADD:   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
IC: ADD:   %call14 = call i32 @_ZSt4setwi(i32 20)
IC: ADD:   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
IC: ADD:   %call9 = call i32 @_ZSt12setprecisioni(i32 16)
IC: ADD:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
IC: ADD:   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
IC: ADD:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)
IC: ADD:   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
IC: ADD:   %call2 = call i32 @_ZSt4setwi(i32 6)
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
IC: ADD:   %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: ADD:   %cmp = icmp sle i32 %n.0, 65536
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: ADD:   br label %for.cond
IC: Visiting:   br label %for.cond
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   %cmp = icmp sle i32 %n.0, 65536
IC: Old =   %cmp = icmp sle i32 %n.0, 65536
    New =   <badref> = icmp slt i32 %n.0, 65537
IC: ADD:   %cmp = icmp slt i32 %n.0, 65537
IC: ERASE   %0 = icmp sle i32 %n.0, 65536
IC: ADD DEFERRED:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   %cmp = icmp slt i32 %n.0, 65537
IC: Old =   %cmp = icmp slt i32 %n.0, 65537
    New =   <badref> = icmp ult i32 %n.0, 65537
IC: ADD:   %cmp = icmp ult i32 %n.0, 65537
IC: ERASE   %0 = icmp slt i32 %n.0, 65537
IC: ADD DEFERRED:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   %cmp = icmp ult i32 %n.0, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: Visiting:   ret i32 0
IC: Visiting:   %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
IC: Mod =   %call = call double @_Z7simpsonPFddEddi(double (double)* @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
    New =   %call = call double @_Z7simpsonPFddEddi(double (double)* nonnull @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
IC: ADD:   %call = call double @_Z7simpsonPFddEddi(double (double)* nonnull @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
IC: Visiting:   %call = call double @_Z7simpsonPFddEddi(double (double)* nonnull @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
IC: Visiting:   %call2 = call i32 @_ZSt4setwi(i32 6)
IC: Visiting:   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
IC: Visiting:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)
IC: Visiting:   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
IC: Visiting:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
IC: Mod =   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* @_ZSt5fixedRSt8ios_base)
    New =   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* nonnull @_ZSt5fixedRSt8ios_base)
IC: ADD:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* nonnull @_ZSt5fixedRSt8ios_base)
IC: Visiting:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* nonnull @_ZSt5fixedRSt8ios_base)
IC: Visiting:   %call9 = call i32 @_ZSt12setprecisioni(i32 16)
IC: Visiting:   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
IC: Visiting:   %call14 = call i32 @_ZSt4setwi(i32 20)
IC: Visiting:   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
IC: Visiting:   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
IC: Visiting:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
IC: Mod =   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
    New =   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* nonnull @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
IC: ADD:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* nonnull @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
IC: Visiting:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* nonnull @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
IC: Visiting:   %mul = mul nsw i32 %n.0, 2
IC: Old =   %mul = mul nsw i32 %n.0, 2
    New =   <badref> = shl nsw i32 %n.0, 1
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: ADD:   %mul = shl nsw i32 %n.0, 1
IC: ERASE   %0 = mul nsw i32 %n.0, 2
IC: ADD DEFERRED:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   %mul = shl nsw i32 %n.0, 1
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   br label %for.cond, !llvm.loop !2


INSTCOMBINE ITERATION #2 on main
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %mul = shl nsw i32 %n.0, 1
IC: ADD:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* nonnull @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
IC: ADD:   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
IC: ADD:   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
IC: ADD:   %call14 = call i32 @_ZSt4setwi(i32 20)
IC: ADD:   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
IC: ADD:   %call9 = call i32 @_ZSt12setprecisioni(i32 16)
IC: ADD:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* nonnull @_ZSt5fixedRSt8ios_base)
IC: ADD:   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
IC: ADD:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)
IC: ADD:   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
IC: ADD:   %call2 = call i32 @_ZSt4setwi(i32 6)
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
IC: ADD:   %call = call double @_Z7simpsonPFddEddi(double (double)* nonnull @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: ADD:   %cmp = icmp ult i32 %n.0, 65537
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: ADD:   br label %for.cond
IC: Visiting:   br label %for.cond
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %for.body ]
IC: Visiting:   %cmp = icmp ult i32 %n.0, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: Visiting:   ret i32 0
IC: Visiting:   %call = call double @_Z7simpsonPFddEddi(double (double)* nonnull @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
IC: Visiting:   %call2 = call i32 @_ZSt4setwi(i32 6)
IC: Visiting:   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1, i32 %call2)
IC: Visiting:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call4, i32 %n.0)
IC: Visiting:   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
IC: Visiting:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call6, %"class.std::ios_base"* (%"class.std::ios_base"*)* nonnull @_ZSt5fixedRSt8ios_base)
IC: Visiting:   %call9 = call i32 @_ZSt12setprecisioni(i32 16)
IC: Visiting:   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call7, i32 %call9)
IC: Visiting:   %call14 = call i32 @_ZSt4setwi(i32 20)
IC: Visiting:   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call12, i32 %call14)
IC: Visiting:   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call17, double %call)
IC: Visiting:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* nonnull @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
IC: Visiting:   %mul = shl nsw i32 %n.0, 1
IC: Visiting:   br label %for.cond, !llvm.loop !2


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
IC: Visiting:   ret %"class.std::basic_ostream"* %__os


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
IC: Visiting:   ret %"class.std::basic_ostream"* %__os


INSTCOMBINE ITERATION #1 on _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
IC: ADD:   br label %if.end
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s, i64 %call)
IC: ADD:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s)
IC: ADD:   ret %"class.std::basic_ostream"* %__out
IC: ADD:   br label %if.end
IC: ADD:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 1)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: ADD:   br i1 %tobool, label %if.else, label %if.then
IC: ADD:   %tobool = icmp ne i8* %__s, null
IC: Visiting:   %tobool = icmp ne i8* %__s, null
IC: Mod =   %tobool = icmp ne i8* %__s, null
    New =   %tobool.not = icmp eq i8* %__s, null
IC: ADD:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.else
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 1)
IC: Visiting:   br label %if.end
IC: Visiting:   ret %"class.std::basic_ostream"* %__out
IC: Visiting:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s)
IC: Mod =   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* %__s)
    New =   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* nonnull %__s)
IC: ADD:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* nonnull %__s)
IC: Visiting:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* nonnull %__s)
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s, i64 %call)
IC: Mod =   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* %__s, i64 %call)
    New =   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call)
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call)
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call)
IC: Visiting:   br label %if.end


INSTCOMBINE ITERATION #2 on _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
IC: ADD:   br label %if.end
IC: ADD:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 1)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: ADD:   ret %"class.std::basic_ostream"* %__out
IC: ADD:   br label %if.end
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call)
IC: ADD:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* nonnull %__s)
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.else
IC: ADD:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.else
IC: Visiting:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* nonnull %__s)
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call)
IC: Visiting:   br label %if.end
IC: Visiting:   ret %"class.std::basic_ostream"* %__out
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 1)
IC: Visiting:   br label %if.end


INSTCOMBINE ITERATION #1 on _ZSt4setwi
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSt8ios_baseS0_E
IC: ADD:   ret %"class.std::basic_ostream"* %this
IC: ADD:   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: Visiting:   ret %"class.std::basic_ostream"* %this


INSTCOMBINE ITERATION #1 on _ZSt5fixedRSt8ios_base
IC: ADD:   ret %"class.std::ios_base"* %__base
IC: ADD:   %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260)
IC: Visiting:   %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260)
IC: Visiting:   ret %"class.std::ios_base"* %__base


INSTCOMBINE ITERATION #1 on _ZSt12setprecisioni
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n


INSTCOMBINE ITERATION #1 on _ZNSolsEd
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   ret %"class.std::basic_ostream"* %call


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSoS_E
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   ret %"class.std::basic_ostream"* %call


INSTCOMBINE ITERATION #1 on _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   ret %"class.std::basic_ostream"* %call2
IC: ADD:   %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1)
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %call)
IC: ADD:   %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10)
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %call)
IC: Visiting:   %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1)
IC: Visiting:   ret %"class.std::basic_ostream"* %call2


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
IC: ADD:   ret i32 %0
IC: ADD:   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)
IC: ADD:   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
IC: ADD:   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)
IC: ADD:   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
IC: ADD:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: ADD:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
IC: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
IC: Mod =   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 3
    New =   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: ADD:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: Visiting:   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
IC: Visiting:   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)
IC: Visiting:   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
IC: Visiting:   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)
IC: Visiting:   ret i32 %0


INSTCOMBINE ITERATION #2 on _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
IC: ADD:   ret i32 %0
IC: ADD:   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)
IC: ADD:   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
IC: ADD:   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)
IC: ADD:   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
IC: ADD:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: ADD:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: Visiting:   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
IC: Visiting:   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call)
IC: Visiting:   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
IC: Visiting:   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)
IC: Visiting:   ret i32 %0


INSTCOMBINE ITERATION #1 on _ZStaNRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %call, i32* %__a, align 4, !tbaa !2
IC: ADD:   %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
IC: Visiting:   store i32 %call, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a


INSTCOMBINE ITERATION #1 on _ZStcoSt13_Ios_Fmtflags
IC: ADD:   ret i32 %neg
IC: ADD:   %neg = xor i32 %__a, -1
IC: Visiting:   %neg = xor i32 %__a, -1
IC: Visiting:   ret i32 %neg


INSTCOMBINE ITERATION #1 on _ZStoRRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %call, i32* %__a, align 4, !tbaa !2
IC: ADD:   %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
IC: Visiting:   store i32 %call, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a


INSTCOMBINE ITERATION #1 on _ZStanSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %and
IC: ADD:   %and = and i32 %__a, %__b
IC: Visiting:   %and = and i32 %__a, %__b
IC: Visiting:   ret i32 %and


INSTCOMBINE ITERATION #1 on _ZStorSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__a, %__b
IC: Visiting:   %or = or i32 %__a, %__b
IC: Visiting:   ret i32 %or


INSTCOMBINE ITERATION #1 on _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
IC: ADD:   ret void
IC: ADD:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %call2)
IC: ADD:   %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %call, i32 %__state)
IC: ADD:   %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this)
IC: Visiting:   %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this)
IC: Visiting:   %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %call, i32 %__state)
IC: Visiting:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %call2)
IC: Visiting:   ret void


INSTCOMBINE ITERATION #1 on _ZNSt11char_traitsIcE6lengthEPKc
IC: ADD:   ret i64 %call
IC: ADD:   %call = call i64 @strlen(i8* %__s) #12
IC: Visiting:   %call = call i64 @strlen(i8* %__s) #12
IC: Visiting:   ret i64 %call


INSTCOMBINE ITERATION #1 on _ZStorSt12_Ios_IostateS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__a, %__b
IC: Visiting:   %or = or i32 %__a, %__b
IC: Visiting:   ret i32 %or


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
IC: ADD:   ret i32 %1
IC: ADD:   %1 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5
IC: ADD:   %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*
IC: Visiting:   %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*
IC: Old =   %0 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*
    New =   <badref> = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 0
IC: ADD:   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 0
IC: ERASE   %1 = bitcast %"class.std::basic_ios"* %this to %"class.std::ios_base"*
IC: Visiting:   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 0
IC: Mod =   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 0
    New =   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0
IC: ADD:   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0
IC: Visiting:   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5
IC: Mod =   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i32 0, i32 5
    New =   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i64 0, i32 5
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i64 0, i32 5
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i64 0, i32 5
IC: Old =   %_M_streambuf_state = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i64 0, i32 5
    New =   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: ERASE   %1 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %0, i64 0, i32 5
IC: ADD DEFERRED:   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0
IC: ERASE   %0 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: Visiting:   ret i32 %0


INSTCOMBINE ITERATION #2 on _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
IC: ADD:   ret i32 %0
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: Visiting:   ret i32 %0


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base5widthEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2
IC: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2
IC: Mod =   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 2
    New =   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: ADD:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   ret i64 %0


INSTCOMBINE ITERATION #2 on _ZNSt8ios_base5widthEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   ret i64 %0


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base9precisionEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1
IC: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1
IC: Mod =   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i32 0, i32 1
    New =   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: ADD:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   ret i64 %0


INSTCOMBINE ITERATION #2 on _ZNSt8ios_base9precisionEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   ret i64 %0


INSTCOMBINE ITERATION #1 on _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   ret %"class.std::basic_ostream"* %call


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
IC: ADD:   ret i8 %call2
IC: ADD:   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)
IC: ADD:   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)
IC: ADD:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: ADD:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5
IC: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5
IC: Mod =   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i32 0, i32 5
    New =   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: ADD:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: Visiting:   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)
IC: Visiting:   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)
IC: Visiting:   ret i8 %call2


INSTCOMBINE ITERATION #2 on _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
IC: ADD:   ret i8 %call2
IC: ADD:   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)
IC: ADD:   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)
IC: ADD:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: ADD:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: Visiting:   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)
IC: Visiting:   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call, i8 signext %__c)
IC: Visiting:   ret i8 %call2


INSTCOMBINE ITERATION #1 on _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
IC: ADD:   ret %"class.std::ctype"* %__f
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #12
IC: ADD:   br i1 %tobool, label %if.end, label %if.then
IC: ADD:   %tobool = icmp ne %"class.std::ctype"* %__f, null
IC: Visiting:   %tobool = icmp ne %"class.std::ctype"* %__f, null
IC: Mod =   %tobool = icmp ne %"class.std::ctype"* %__f, null
    New =   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: ADD:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.end
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #12
IC: Visiting:   unreachable
IC: Visiting:   ret %"class.std::ctype"* %__f


INSTCOMBINE ITERATION #2 on _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #12
IC: ADD:   ret %"class.std::ctype"* %__f
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.end
IC: ADD:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.end
IC: Visiting:   ret %"class.std::ctype"* %__f
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #12
IC: Visiting:   unreachable


INSTCOMBINE ITERATION #1 on _ZNKSt5ctypeIcE5widenEc
IC: ADD:   br label %return
IC: ADD:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: ADD:   %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom
IC: ADD:   %idxprom = zext i8 %__c to i64
IC: ADD:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9
IC: ADD:   ret i8 %retval.0
IC: ADD:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: ADD:   br label %return
IC: ADD:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: ADD:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: ADD:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: ADD:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: ADD:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: ADD:   br i1 %tobool, label %if.then, label %if.end
IC: ADD:   %tobool = icmp ne i8 %0, 0
IC: ADD:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: ADD:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8
IC: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8
IC: Mod =   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 8
    New =   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: ADD:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: Visiting:   %tobool = icmp ne i8 %0, 0
IC: Mod =   %tobool = icmp ne i8 %0, 0
    New =   %tobool.not = icmp eq i8 %0, 0
IC: ADD:   %tobool.not = icmp eq i8 %0, 0
IC: Visiting:   %tobool.not = icmp eq i8 %0, 0
IC: Visiting:   br i1 %tobool.not, label %if.end, label %if.then
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: Visiting:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: Visiting:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: Visiting:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: Visiting:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: Visiting:   br label %return
IC: Visiting:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: Visiting:   ret i8 %retval.0
IC: Visiting:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9
IC: Mod =   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i32 0, i32 9
    New =   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9
IC: ADD:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9
IC: Visiting:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9
IC: Visiting:   %idxprom = zext i8 %__c to i64
IC: Visiting:   %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom
IC: Old =   %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom
    New =   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: ADD:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: ERASE   %1 = getelementptr inbounds [256 x i8], [256 x i8]* %_M_widen, i64 0, i64 %idxprom
IC: ADD DEFERRED:   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9
IC: ADD DEFERRED:   %idxprom = zext i8 %__c to i64
IC: ADD:   %idxprom = zext i8 %__c to i64
IC: ERASE   %_M_widen = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9
IC: Visiting:   %idxprom = zext i8 %__c to i64
IC: Visiting:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: Visiting:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: Visiting:   br label %return


INSTCOMBINE ITERATION #2 on _ZNKSt5ctypeIcE5widenEc
IC: ADD:   br label %return
IC: ADD:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: ADD:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: ADD:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: ADD:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: ADD:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: ADD:   ret i8 %retval.0
IC: ADD:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: ADD:   br label %return
IC: ADD:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: ADD:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: ADD:   %idxprom = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not, label %if.end, label %if.then
IC: ADD:   %tobool.not = icmp eq i8 %0, 0
IC: ADD:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: ADD:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: Visiting:   %tobool.not = icmp eq i8 %0, 0
IC: Visiting:   br i1 %tobool.not, label %if.end, label %if.then
IC: Visiting:   %idxprom = zext i8 %__c to i64
IC: Visiting:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: Visiting:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: Visiting:   br label %return
IC: Visiting:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: Visiting:   ret i8 %retval.0
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: Visiting:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: Visiting:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: Visiting:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: Visiting:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: Visiting:   br label %return


INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   call fastcc void @__cxx_global_var_init()
IC: Visiting:   call fastcc void @__cxx_global_var_init()
IC: Visiting:   ret void
Inliner visiting SCC: INDIRECTNODE: 0 call sites.
Inliner visiting SCC: _Z7simpsonPFddEddi: 5 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_Z7simpsonPFddEddi'<<0x7fffc1d49350>>  #uses=2
  CS<0x7fffc0cf9f40> calls external node
  CS<0x7fffc0cfade0> calls external node
  CS<0x7fffc0cfb400> calls external node
  CS<0x7fffc0cfbd10> calls external node
  CS<0x7fffc0cfbe90> calls external node

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _Z7simpsonPFddEddi
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in for.body
EarlyCSE CVP: Add conditional value for 'cmp' as i1 false in for.end
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_Z7simpsonPFddEddi'
LVI Getting block end value i32 %n at 'entry'
PUSH: i32 %n in entry
POP i32 %n in entry = overdefined
  Result = overdefined
LVI Getting block end value i32 1 at 'entry'
  Result = constantrange<1, 2>
LVI Getting value   %add = add nsw i32 %n, 1 at 'div'
  Result = overdefined
LVI Getting value   %add = add nsw i32 %n, 1 at 'div'
  Result = overdefined
LVI Getting block end value   %add = add nsw i32 %n, 1 at 'entry'
PUSH:   %add = add nsw i32 %n, 1 in entry
POP   %add = add nsw i32 %n, 1 in entry = constantrange<-2147483647, -2147483648>
  Result = constantrange<-2147483647, -2147483648>
LVI Getting block end value i32 2 at 'entry'
  Result = constantrange<2, 3>
LVI Getting block end value   %div = sdiv i32 %add, 2 at 'entry'
PUSH:   %div = sdiv i32 %add, 2 in entry
POP   %div = sdiv i32 %add, 2 in entry = constantrange<-1073741823, 1073741824>
  Result = constantrange<-1073741823, 1073741824>
LVI Getting block end value i32 1 at 'entry'
  Result = constantrange<1, 2>
LVI Getting edge value   %add7 = fadd double %sum_even.0, %call6 from 'for.body' to 'for.cond'
PUSH:   %add7 = fadd double %sum_even.0, %call6 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %add7 = fadd double %sum_even.0, %call6 in for.body = overdefined
  Result = overdefined
LVI Getting edge value   %call = call double %f(double %add2) from 'entry' to 'for.cond'
PUSH:   %call = call double %f(double %add2) in entry
 compute BB 'entry' - unknown inst def found.
POP   %call = call double %f(double %add2) in entry = overdefined
  Result = overdefined
LVI Getting edge value   %add12 = fadd double %sum_odd.0, %call11 from 'for.body' to 'for.cond'
PUSH:   %add12 = fadd double %sum_odd.0, %call11 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %add12 = fadd double %sum_odd.0, %call11 in for.body = overdefined
  Result = overdefined
LVI Getting edge value   %add13 = add nuw nsw i32 %even.0, 2 from 'for.body' to 'for.cond'
PUSH:   %add13 = add nuw nsw i32 %even.0, 2 in for.body
PUSH:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] in for.body
PUSH:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] in for.cond
 compute BB 'for.cond' - overdefined because of pred (local).
POP   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] in for.cond = overdefined
POP   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] in for.body = constantrange<-2147483648, 2147483647>
POP   %add13 = add nuw nsw i32 %even.0, 2 in for.body = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting edge value   %add14 = add nuw nsw i32 %odd.0, 2 from 'for.body' to 'for.cond'
PUSH:   %add14 = add nuw nsw i32 %odd.0, 2 in for.body
PUSH:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] in for.body
PUSH:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] in for.cond
 compute BB 'for.cond' - overdefined because of pred (local).
POP   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] in for.cond = overdefined
 compute BB 'for.body' - overdefined because of pred (non local).
POP   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] in for.body = overdefined
POP   %add14 = add nuw nsw i32 %odd.0, 2 in for.body = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting block end value   %div23 = fdiv double %mul22, 3.000000e+00 at 'for.end'
PUSH:   %div23 = fdiv double %mul22, 3.000000e+00 in for.end
 compute BB 'for.end' - unknown inst def found.
POP   %div23 = fdiv double %mul22, 3.000000e+00 in for.end = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.cond, !llvm.loop !2
IC: ADD:   %add14 = add nuw nsw i32 %odd.0, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.0, 2
IC: ADD:   %add12 = fadd double %sum_odd.0, %call11
IC: ADD:   %call11 = call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.0 to double
IC: ADD:   %add7 = fadd double %sum_even.0, %call6
IC: ADD:   %call6 = call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.0 to double
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %add19, %mul20
IC: ADD:   %mul20 = fmul double %sum_odd.0, 4.000000e+00
IC: ADD:   %add19 = fadd double %add17, %mul18
IC: ADD:   %mul18 = fmul double %sum_even.0, 2.000000e+00
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = call double %f(double %b)
IC: ADD:   %call15 = call double %f(double %a)
IC: ADD:   br i1 %cmp, label %for.body, label %for.end
IC: ADD:   %cmp = icmp slt i32 %even.0, %mul
IC: ADD:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: ADD:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: ADD:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: ADD:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: ADD:   br label %for.cond
IC: ADD:   %call = call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = call double %f(double %add2)
IC: Visiting:   br label %for.cond
IC: Visiting:   %sum_even.0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: Visiting:   %sum_odd.0 = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: Visiting:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ]
IC: Visiting:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ]
IC: Visiting:   %cmp = icmp slt i32 %even.0, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end
IC: Visiting:   %call15 = call double %f(double %a)
IC: Visiting:   %call16 = call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %mul18 = fmul double %sum_even.0, 2.000000e+00
IC: Visiting:   %add19 = fadd double %add17, %mul18
IC: Visiting:   %mul20 = fmul double %sum_odd.0, 4.000000e+00
IC: Visiting:   %add21 = fadd double %add19, %mul20
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %conv3 = sitofp i32 %even.0 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.0, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.0 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.0, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.0, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.0, 2
IC: Visiting:   br label %for.cond, !llvm.loop !2
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %for.cond
4: %entry
5: %for.body
Found roots: %for.end 
---- Branch Probability Info : _Z7simpsonPFddEddi ----

BPI: SCC 1: for.body for.cond
Computing probabilities for for.body
Computing probabilities for for.end
Computing probabilities for for.cond
eraseBlock for.cond
set edge for.cond -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.cond -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for entry

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: entry
 - 1: for.cond
 - 2: for.end
 - 3: for.body
loop-detection
 - loop = for.cond
 - loop = for.cond: member = for.body
compute-mass-in-loop: for.cond*
 - node: for.cond
  => [ local  ] weight = 2080374784, succ = for.body
  => [  exit  ] weight = 67108864, succ = for.end
  => mass:  ffffffffffffffff
  => assign 07ffffffffffffff (f800000000000000) [exit] to for.end
  => assign f800000000000000 (0000000000000000) to for.body
 - node: for.body
  => [backedge] weight = 2147483648
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) [back] to for.cond
compute-loop-scale: for.cond*
 - exit-mass = 07ffffffffffffff (ffffffffffffffff - f800000000000000)
 - scale = 32.0
packaging-loop: for.cond*
 - node: for.cond
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.cond
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.cond
 - node: for.cond
  => [ local  ] weight = 576460752303423487, succ = for.end
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.cond*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - for.cond: 1.0 => 32.0
 - for.body: 0.96875 => 31.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
 - for.cond: float = 32.0, scaled = 256.0, int = 256
 - for.end: float = 1.0, scaled = 8.0, int = 8
 - for.body: float = 31.0, scaled = 248.0, int = 248
block-frequency-info: _Z7simpsonPFddEddi
 - entry: float = 1.0, int = 8
 - for.cond: float = 32.0, int = 256
 - for.body: float = 31.0, int = 248
 - for.end: float = 1.0, int = 8

Marked as tail call candidate:   %call = call double %f(double %add2)
Marked as tail call candidate:   %call15 = call double %f(double %a)
Marked as tail call candidate:   %call16 = call double %f(double %b)
Marked as tail call candidate:   %call6 = call double %f(double %add5)
Marked as tail call candidate:   %call11 = call double %f(double %add10)
Calculated Rank[f] = 3
Calculated Rank[a] = 4
Calculated Rank[b] = 5
Calculated Rank[n] = 6
Combine negations for:   %add = add nsw i32 %n, 1
LINEARIZE:   %add = add nsw i32 %n, 1
OPERAND: i32 %n (1)
ADD LEAF: i32 %n (1)
OPERAND: i32 1 (1)
ADD USES LEAF: i32 1 (1)
RAIn:	add i32	[ %n, #6] [ 1, #0] 
RAOut:	add i32	[ %n, #6] [ 1, #0] 
Combine negations for:   %div = sdiv i32 %add, 2
Combine negations for:   %mul = shl nsw i32 %div, 1
Combine negations for:   %sub = fsub double %b, %a
Combine negations for:   %div1 = fdiv double %sub, %conv
Calculated Rank[sub] = 6
Calculated Rank[add] = 7
Calculated Rank[div] = 8
Calculated Rank[mul] = 9
Calculated Rank[conv] = 10
Calculated Rank[div1] = 11
Combine negations for:   %add2 = fadd double %a, %div1
Combine negations for:   %add17 = fadd double %call15, %call16
Combine negations for:   %mul18 = fmul double %sum_even.0, 2.000000e+00
Calculated Rank[mul18] = 524290
Calculated Rank[add17] = 589827
Combine negations for:   %add19 = fadd double %mul18, %add17
Combine negations for:   %mul20 = fmul double %sum_odd.0, 4.000000e+00
Calculated Rank[mul20] = 524291
Calculated Rank[add19] = 589828
Combine negations for:   %add21 = fadd double %mul20, %add19
Calculated Rank[add21] = 589829
Combine negations for:   %mul22 = fmul double %div1, %add21
Combine negations for:   %div23 = fdiv double %mul22, 3.000000e+00
Calculated Rank[conv3] = 524292
Combine negations for:   %mul4 = fmul double %div1, %conv3
Calculated Rank[mul4] = 524293
Combine negations for:   %add5 = fadd double %a, %mul4
Combine negations for:   %add7 = fadd double %sum_even.0, %call6
Calculated Rank[conv8] = 524293
Combine negations for:   %mul9 = fmul double %div1, %conv8
Calculated Rank[mul9] = 524294
Combine negations for:   %add10 = fadd double %a, %mul9
Combine negations for:   %add12 = fadd double %sum_odd.0, %call11
Combine negations for:   %add13 = add nuw nsw i32 %even.0, 2
LINEARIZE:   %add13 = add nuw nsw i32 %even.0, 2
OPERAND:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] (1)
ADD USES LEAF:   %even.0 = phi i32 [ 2, %entry ], [ %add13, %for.body ] (1)
OPERAND: i32 2 (1)
ADD USES LEAF: i32 2 (1)
RAIn:	add i32	[ %even.0, #524291] [ 2, #0] 
RAOut:	add i32	[ %even.0, #524291] [ 2, #0] 
Combine negations for:   %add14 = add nuw nsw i32 %odd.0, 2
LINEARIZE:   %add14 = add nuw nsw i32 %odd.0, 2
OPERAND:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] (1)
ADD USES LEAF:   %odd.0 = phi i32 [ 3, %entry ], [ %add14, %for.body ] (1)
OPERAND: i32 2 (1)
ADD USES LEAF: i32 2 (1)
RAIn:	add i32	[ %odd.0, #524292] [ 2, #0] 
RAOut:	add i32	[ %odd.0, #524292] [ 2, #0] 
LoopRotation: rotating Loop at depth 1 containing: %for.cond<header><exiting>,%for.body<latch>
  Inserted PHI:   %sum_even.049 = phi double [ 0.000000e+00, %entry ], [ %sum_even.0, %for.cond ]
  Inserted PHI:   %sum_odd.050 = phi double [ %call, %entry ], [ %sum_odd.0, %for.cond ]
  Inserted PHI:   %even.051 = phi i32 [ 2, %entry ], [ %even.0, %for.cond ]
  Inserted PHI:   %odd.052 = phi i32 [ 3, %entry ], [ %odd.0, %for.cond ]
Inserting edge %entry -> %for.end
	Reachable %entry -> %for.end
		NCA == %entry
Mark %for.endas affected, CurrentLevel 2
Updating NCD = %entry
	IDom(%for.end) = %entry
Inserting edge %entry -> %for.body
	Reachable %entry -> %for.body
		NCA == %entry
Mark %for.bodyas affected, CurrentLevel 2
	Successor %for.cond, level = 1
Updating NCD = %entry
	IDom(%for.body) = %entry
Deleting edge %entry -> %for.cond
	NCD %entry, ToIDom %entry
IsReachableFromIDom %for.cond
	Pred %for.body
	Support %entry
	%for.cond is reachable from support %entry
Deleting reachable %entry -> %for.cond
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Inserting edge %entry -> %entry.for.body_crit_edge
Inserting %entry -> (unreachable) %entry.for.body_crit_edge
After adding unreachable nodes
Inserted %entry -> (prev unreachable) %entry.for.body_crit_edge
Inserting edge %entry.for.body_crit_edge -> %for.body
	Reachable %entry.for.body_crit_edge -> %for.body
		NCA == %entry
Deleting edge %entry -> %for.body
	NCD %entry, ToIDom %entry
IsReachableFromIDom %for.body
	Pred %entry.for.body_crit_edge
	Support %entry
	%for.body is reachable from support %entry
Deleting reachable %entry -> %for.body
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Inserting edge %for.cond -> %for.cond.for.end_crit_edge
Inserting %for.cond -> (unreachable) %for.cond.for.end_crit_edge
After adding unreachable nodes
Inserted %for.cond -> (prev unreachable) %for.cond.for.end_crit_edge
Inserting edge %for.cond.for.end_crit_edge -> %for.end
	Reachable %for.cond.for.end_crit_edge -> %for.end
		NCA == %entry
Deleting edge %for.cond -> %for.end
	NCD %entry, ToIDom %entry
Deleting reachable %for.cond -> %for.end
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Merging: for.cond into for.body
Inserting edge %for.body -> %for.body
	Reachable %for.body -> %for.body
		NCA == %for.body
Inserting edge %for.body -> %for.cond.for.end_crit_edge
	Reachable %for.body -> %for.cond.for.end_crit_edge
		NCA == %for.body
Mark %for.cond.for.end_crit_edgeas affected, CurrentLevel 4
	Successor %for.end, level = 1
Updating NCD = %for.body
	IDom(%for.cond.for.end_crit_edge) = %for.body
Deleting edge %for.cond -> %for.body
Deleting edge %for.cond -> %for.cond.for.end_crit_edge
	NCD %for.body, ToIDom %for.body
Deleting reachable %for.cond -> %for.cond.for.end_crit_edge
	Rebuilding subtree
	Top of subtree: %for.body
	Running Semi-NCA
Deleting edge %for.body -> %for.cond
	NCD %for.body, ToIDom %for.body
IsReachableFromIDom %for.cond
Deleting unreachable subtree %for.cond
Erasing node %for.cond
LoopRotation: into Loop at depth 1 containing: %for.body<header><latch><exiting>
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.
Looking to fold for.body.lr.ph into for.body
Killing Trivial BB: 

for.body.lr.ph:                                   ; preds = %entry
  br label %for.body
Looking to fold for.cond.for.end_crit_edge into for.end
Killing Trivial BB: 

for.cond.for.end_crit_edge:                       ; preds = %for.body
  %split = phi double [ %add7, %for.body ]
  %split53 = phi double [ %add12, %for.body ]
  br label %for.end


INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %a, %mul9
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %a, %mul4
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %mul18, %add17
IC: ADD:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: ADD:   br i1 %cmp48, label %for.body, label %for.end
IC: ADD:   %cmp48 = icmp slt i32 2, %mul
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %a, %div1
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %a, %div1
IC: Mod =   %add2 = fadd double %a, %div1
    New =   %add2 = fadd double %div1, %a
IC: ADD:   %add2 = fadd double %div1, %a
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp slt i32 2, %mul
IC: Old =   %cmp48 = icmp sgt i32 %mul, 2
    New =   <badref> = icmp sgt i32 %div, 1
IC: ADD:   %cmp48 = icmp sgt i32 %div, 1
IC: ERASE   %0 = icmp sgt i32 %mul, 2
IC: ADD DEFERRED:   %mul = shl nsw i32 %div, 1
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %cmp48 = icmp sgt i32 %div, 1
IC: Old =   %cmp48 = icmp sgt i32 %div, 1
    New =   <badref> = icmp sge i32 %add, 4
IC: ADD:   %cmp48 = icmp sge i32 %add, 4
IC: ERASE   %0 = icmp sgt i32 %div, 1
IC: ADD DEFERRED:   %div = sdiv i32 %add, 2
IC: ADD:   %div = sdiv i32 %add, 2
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %cmp48 = icmp sge i32 %add, 4
IC: Old =   %cmp48 = icmp sge i32 %add, 4
    New =   <badref> = icmp sgt i32 %add, 3
IC: ADD:   %cmp48 = icmp sgt i32 %add, 3
IC: ERASE   %0 = icmp sge i32 %add, 4
IC: ADD DEFERRED:   %add = add nsw i32 %n, 1
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %cmp48 = icmp sgt i32 %add, 3
IC: Old =   %cmp48 = icmp sgt i32 %add, 3
    New =   <badref> = icmp sge i32 %n, 3
IC: ADD:   %cmp48 = icmp sge i32 %n, 3
IC: ERASE   %0 = icmp sgt i32 %add, 3
IC: ADD DEFERRED:   %add = add nsw i32 %n, 1
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %cmp48 = icmp sge i32 %n, 3
IC: Old =   %cmp48 = icmp sge i32 %n, 3
    New =   <badref> = icmp sgt i32 %n, 2
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ERASE   %0 = icmp sge i32 %n, 3
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
IC: Visiting:   %add19 = fadd double %mul18, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %a, %mul4
IC: Mod =   %add5 = fadd double %a, %mul4
    New =   %add5 = fadd double %mul4, %a
IC: ADD:   %add5 = fadd double %mul4, %a
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %a, %mul9
IC: Mod =   %add10 = fadd double %a, %mul9
    New =   %add10 = fadd double %mul9, %a
IC: ADD:   %add10 = fadd double %mul9, %a
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2


INSTCOMBINE ITERATION #2 on _Z7simpsonPFddEddi
IC: ADD:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %mul18, %add17
IC: ADD:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: ADD:   br i1 %cmp48, label %for.body, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.body ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.body ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
IC: Visiting:   %add19 = fadd double %mul18, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end, !llvm.loop !2
LoopSimplify: Creating pre-header for.body.preheader
LoopSimplify: Creating dedicated exit block for.end.loopexit
loop-idiom Scanning: F[_Z7simpsonPFddEddi] Countable Loop %for.body
Analyzing Loop for deletion: Loop at depth 1 containing: %for.body<header><latch><exiting>
Loop is not invariant, cannot delete.
Loop Unroll: F[_Z7simpsonPFddEddi] Loop %for.body
  Loop Size = 16
  will not try to unroll loop with runtime trip count -unroll-runtime not given
SROA function: _Z7simpsonPFddEddi
Instruction Merger
GVN iteration: 0
GVN removed:   %add7.lcssa = phi double [ %add7, %for.body ]
GVN removed:   %add12.lcssa = phi double [ %add12, %for.body ]
GVN iteration: 1
SCCP on function '_Z7simpsonPFddEddi'
Marking Block Executable: entry
markOverdefined: double (double)* %f
markOverdefined: double %a
markOverdefined: double %b
markOverdefined: i32 %n

Popped off OI-WL: i32 %n
markOverdefined:   %cmp48 = icmp sgt i32 %n, 2
Merged overdefined into   %add = add nsw i32 %n, 1 : overdefined

Popped off OI-WL:   %add = add nsw i32 %n, 1
Merged constantrange<-1073741824, 1073741824> into   %div = sdiv i32 %add, 2 : constantrange<-1073741824, 1073741824>

Popped off OI-WL:   %cmp48 = icmp sgt i32 %n, 2
Marking Block Executable: for.body.preheader
Marking Block Executable: for.end

Popped off OI-WL: double %b
markOverdefined:   %sub = fsub double %b, %a
Merged overdefined into   %call16 = tail call double %f(double %b) : overdefined

Popped off OI-WL:   %call16 = tail call double %f(double %b)

Popped off OI-WL:   %sub = fsub double %b, %a

Popped off OI-WL: double %a
Merged overdefined into   %call15 = tail call double %f(double %a) : overdefined

Popped off OI-WL:   %call15 = tail call double %f(double %a)
markOverdefined:   %add17 = fadd double %call15, %call16

Popped off OI-WL:   %add17 = fadd double %call15, %call16

Popped off OI-WL: double (double)* %f
Merged overdefined into   %call = tail call double %f(double %add2) : overdefined

Popped off OI-WL:   %call = tail call double %f(double %add2)
Merged overdefined into   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ] : overdefined

Popped off OI-WL:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
markOverdefined:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00

Popped off OI-WL:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00

Popped off I-WL:   %div = sdiv i32 %add, 2
Merged overdefined into   %mul = shl nsw i32 %div, 1 : overdefined

Popped off BBWL: 
for.end:                                          ; preds = %for.end.loopexit, %entry
  %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]
  %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
  %call15 = tail call double %f(double %a)
  %call16 = tail call double %f(double %b)
  %add17 = fadd double %call15, %call16
  %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
  %add19 = fadd double %mul18, %add17
  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
  %add21 = fadd double %mul20, %add19
  %mul22 = fmul double %div1, %add21
  %div23 = fdiv double %mul22, 3.000000e+00
  ret double %div23

Merged constant<double 0.000000e+00> into   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ] : constant<double 0.000000e+00>
Merged constant<double 0.000000e+00> into   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00 : constant<double 0.000000e+00>
markOverdefined:   %add19 = fadd double %mul18, %add17
markOverdefined:   %add21 = fadd double %mul20, %add19

Popped off BBWL: 
for.body.preheader:                               ; preds = %entry
  br label %for.body

Marking Block Executable: for.body

Popped off BBWL: 
for.body:                                         ; preds = %for.body.preheader, %for.body
  %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
  %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
  %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
  %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
  %conv3 = sitofp i32 %even.051 to double
  %mul4 = fmul double %div1, %conv3
  %add5 = fadd double %mul4, %a
  %call6 = tail call double %f(double %add5)
  %add7 = fadd double %sum_even.049, %call6
  %conv8 = sitofp i32 %odd.052 to double
  %mul9 = fmul double %div1, %conv8
  %add10 = fadd double %mul9, %a
  %call11 = tail call double %f(double %add10)
  %add12 = fadd double %sum_odd.050, %call11
  %add13 = add nuw nsw i32 %even.051, 2
  %add14 = add nuw nsw i32 %odd.052, 2
  %cmp = icmp slt i32 %add13, %mul
  br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2

Merged constantrange<3, 4> into   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ] : constantrange<3, 4>
Merged constantrange<2, 3> into   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ] : constantrange<2, 3>
Merged overdefined into   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ] : overdefined
Merged constant<double 0.000000e+00> into   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ] : constant<double 0.000000e+00>
markConstant: double 2.000000e+00:   %conv3 = sitofp i32 %even.051 to double
Merged overdefined into   %call6 = tail call double %f(double %add5) : overdefined
markOverdefined:   %add7 = fadd double %sum_even.049, %call6
markConstant: double 3.000000e+00:   %conv8 = sitofp i32 %odd.052 to double
Merged overdefined into   %call11 = tail call double %f(double %add10) : overdefined
markOverdefined:   %add12 = fadd double %sum_odd.050, %call11
Merged constantrange<4, 5> into   %add13 = add nuw nsw i32 %even.051, 2 : constantrange<4, 5>
Merged constantrange<5, 6> into   %add14 = add nuw nsw i32 %odd.052, 2 : constantrange<5, 6>
markOverdefined:   %cmp = icmp slt i32 %add13, %mul
Marking Edge Executable: for.body -> for.body
Merged constantrange<3, 6> into   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ] : constantrange<3, 6>
Merged constantrange<2, 5> into   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ] : constantrange<2, 5>
Merged overdefined into   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ] : overdefined
Marking Block Executable: for.end.loopexit

Popped off BBWL: 
for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

Marking Edge Executable: for.end.loopexit -> for.end
Merged overdefined into   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ] : overdefined

Popped off BBWL: 
entry:
  %add = add nsw i32 %n, 1
  %div = sdiv i32 %add, 2
  %mul = shl nsw i32 %div, 1
  %sub = fsub double %b, %a
  %conv = sitofp i32 %mul to double
  %div1 = fdiv double %sub, %conv
  %add2 = fadd double %div1, %a
  %call = tail call double %f(double %add2)
  %cmp48 = icmp sgt i32 %n, 2
  br i1 %cmp48, label %for.body.preheader, label %for.end

markOverdefined:   %conv = sitofp i32 %mul to double
markOverdefined:   %div1 = fdiv double %sub, %conv
markOverdefined:   %add2 = fadd double %div1, %a

Popped off OI-WL:   %add2 = fadd double %div1, %a

Popped off OI-WL:   %div1 = fdiv double %sub, %conv
markOverdefined:   %mul4 = fmul double %div1, %conv3
markOverdefined:   %mul9 = fmul double %div1, %conv8
markOverdefined:   %mul22 = fmul double %div1, %add21

Popped off OI-WL:   %mul22 = fmul double %div1, %add21
markOverdefined:   %div23 = fdiv double %mul22, 3.000000e+00

Popped off OI-WL:   %div23 = fdiv double %mul22, 3.000000e+00

Popped off OI-WL:   %mul9 = fmul double %div1, %conv8
markOverdefined:   %add10 = fadd double %mul9, %a

Popped off OI-WL:   %add10 = fadd double %mul9, %a

Popped off OI-WL:   %mul4 = fmul double %div1, %conv3
markOverdefined:   %add5 = fadd double %mul4, %a

Popped off OI-WL:   %add5 = fadd double %mul4, %a

Popped off OI-WL:   %conv = sitofp i32 %mul to double

Popped off OI-WL:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]
markOverdefined:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00

Popped off OI-WL:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00

Popped off OI-WL:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]

Popped off OI-WL:   %cmp = icmp slt i32 %add13, %mul

Popped off OI-WL:   %add12 = fadd double %sum_odd.050, %call11

Popped off OI-WL:   %call11 = tail call double %f(double %add10)

Popped off OI-WL:   %add7 = fadd double %sum_even.049, %call6

Popped off OI-WL:   %call6 = tail call double %f(double %add5)

Popped off OI-WL:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]

Popped off OI-WL:   %add21 = fadd double %mul20, %add19

Popped off OI-WL:   %add19 = fadd double %mul18, %add17

Popped off OI-WL:   %mul = shl nsw i32 %div, 1

Popped off I-WL:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
Merged constantrange<4, 7> into   %add13 = add nuw nsw i32 %even.051, 2 : constantrange<4, 7>
markOverdefined:   %conv3 = sitofp i32 %even.051 to double

Popped off I-WL:   %add13 = add nuw nsw i32 %even.051, 2
Merged constantrange<2, 7> into   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ] : constantrange<2, 7>

Popped off I-WL:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
Merged constantrange<4, 9> into   %add13 = add nuw nsw i32 %even.051, 2 : constantrange<4, 9>

Popped off I-WL:   %add13 = add nuw nsw i32 %even.051, 2
Merged constantrange<2, 9> into   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ] : overdefined

Popped off I-WL:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
markOverdefined:   %conv8 = sitofp i32 %odd.052 to double
Merged constantrange<5, 8> into   %add14 = add nuw nsw i32 %odd.052, 2 : constantrange<5, 8>

Popped off I-WL:   %add14 = add nuw nsw i32 %odd.052, 2
Merged constantrange<3, 8> into   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ] : constantrange<3, 8>

Popped off I-WL:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
Merged constantrange<5, 10> into   %add14 = add nuw nsw i32 %odd.052, 2 : constantrange<5, 10>

Popped off I-WL:   %add14 = add nuw nsw i32 %odd.052, 2
Merged constantrange<3, 10> into   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ] : overdefined

Popped off I-WL:   %add14 = add nuw nsw i32 %odd.052, 2

Popped off I-WL:   %add13 = add nuw nsw i32 %even.051, 2

Popped off I-WL:   %conv8 = sitofp i32 %odd.052 to double

Popped off I-WL:   %conv3 = sitofp i32 %even.051 to double

Popped off I-WL:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]

Popped off I-WL:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]

Popped off I-WL:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]

Popped off I-WL:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00

Popped off I-WL:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]

Popped off OI-WL:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
Merged overdefined into   %add14 = add nuw nsw i32 %odd.052, 2 : overdefined

Popped off OI-WL:   %add14 = add nuw nsw i32 %odd.052, 2

Popped off OI-WL:   %conv8 = sitofp i32 %odd.052 to double

Popped off OI-WL:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
Merged overdefined into   %add13 = add nuw nsw i32 %even.051, 2 : overdefined

Popped off OI-WL:   %add13 = add nuw nsw i32 %even.051, 2

Popped off OI-WL:   %conv3 = sitofp i32 %even.051 to double
RESOLVING UNDEFs
DemandedBits: Root:   %call = tail call double %f(double %add2)
DemandedBits: Root:   br i1 %cmp48, label %for.body.preheader, label %for.end
DemandedBits: Root:   br label %for.body
DemandedBits: Root:   %call6 = tail call double %f(double %add5)
DemandedBits: Root:   %call11 = tail call double %f(double %add10)
DemandedBits: Root:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
DemandedBits: Root:   br label %for.end
DemandedBits: Root:   %call15 = tail call double %f(double %a)
DemandedBits: Root:   %call16 = tail call double %f(double %b)
DemandedBits: Root:   ret double %div23
DemandedBits: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
DemandedBits: Visiting:   %mul22 = fmul double %div1, %add21
DemandedBits: Visiting:   %add21 = fadd double %mul20, %add19
DemandedBits: Visiting:   %add19 = fadd double %mul18, %add17
DemandedBits: Visiting:   %add17 = fadd double %call15, %call16
DemandedBits: Visiting:   %call16 = tail call double %f(double %b)
DemandedBits: Visiting:   %call15 = tail call double %f(double %a)
DemandedBits: Visiting:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
DemandedBits: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]
DemandedBits: Visiting:   %add7 = fadd double %sum_even.049, %call6
DemandedBits: Visiting:   %call6 = tail call double %f(double %add5)
DemandedBits: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
DemandedBits: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
DemandedBits: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
DemandedBits: Visiting:   %add12 = fadd double %sum_odd.050, %call11
DemandedBits: Visiting:   %call11 = tail call double %f(double %add10)
DemandedBits: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
DemandedBits: Visiting:   %call = tail call double %f(double %add2)
DemandedBits: Visiting:   %div1 = fdiv double %sub, %conv
DemandedBits: Visiting:   %conv = sitofp i32 %mul to double
DemandedBits: Visiting:   %mul = shl nsw i32 %div, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %div = sdiv i32 %add, 2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %add = add nsw i32 %n, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %sub = fsub double %b, %a
DemandedBits: Visiting:   %cmp = icmp slt i32 %add13, %mul Alive Out: 0x1
DemandedBits: Visiting:   %add13 = add nuw nsw i32 %even.051, 2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %add10 = fadd double %mul9, %a
DemandedBits: Visiting:   %mul9 = fmul double %div1, %conv8
DemandedBits: Visiting:   %conv8 = sitofp i32 %odd.052 to double
DemandedBits: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %add5 = fadd double %mul4, %a
DemandedBits: Visiting:   %mul4 = fmul double %div1, %conv3
DemandedBits: Visiting:   %conv3 = sitofp i32 %even.051 to double
DemandedBits: Visiting:   %cmp48 = icmp sgt i32 %n, 2 Alive Out: 0x1
DemandedBits: Visiting:   %add2 = fadd double %div1, %a


INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: ADD:   br label %for.body
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %mul18, %add17
IC: ADD:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
IC: ADD DEFERRED:   %0 = phi double 
IC: ADD DEFERRED:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Replacing   %mul18 = fmul double %0, 2.000000e+00
    with   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Mod =   %mul18 = fmul double %sum_even.0.lcssa, 2.000000e+00
    New =   %mul18 = fmul double %0, 2.000000e+00
IC: ERASE   %mul18 = fmul double %0, 2.000000e+00
IC: ADD DEFERRED:   %0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]
IC: ERASE   %0 = phi double [ 0.000000e+00, %entry ], [ %add7, %for.end.loopexit ]
IC: ADD DEFERRED:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %phi.bo = fmul double %add7, 2.000000e+00
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   br label %for.body
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   br label %for.end


INSTCOMBINE ITERATION #2 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7, 2.000000e+00
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: ADD:   br label %for.body
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   br label %for.body
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end
Jump threading on function '_Z7simpsonPFddEddi'
LVI Getting value i32 %n at ''
  Result = overdefined
LVI Getting block end value i32 %n at 'entry'
PUSH: i32 %n in entry
POP i32 %n in entry = overdefined
  Result = overdefined
LVI Getting block end value i32 1 at 'entry'
  Result = constantrange<1, 2>
LVI Getting value   %add = add nsw i32 %n, 1 at 'div'
  Result = overdefined
LVI Getting value   %add = add nsw i32 %n, 1 at 'div'
  Result = overdefined
LVI Getting block end value   %add = add nsw i32 %n, 1 at 'entry'
PUSH:   %add = add nsw i32 %n, 1 in entry
POP   %add = add nsw i32 %n, 1 in entry = constantrange<-2147483647, -2147483648>
  Result = constantrange<-2147483647, -2147483648>
LVI Getting block end value i32 2 at 'entry'
  Result = constantrange<2, 3>
LVI Getting block end value   %div = sdiv i32 %add, 2 at 'entry'
PUSH:   %div = sdiv i32 %add, 2 in entry
POP   %div = sdiv i32 %add, 2 in entry = constantrange<-1073741823, 1073741824>
  Result = constantrange<-1073741823, 1073741824>
LVI Getting block end value i32 1 at 'entry'
  Result = constantrange<1, 2>
LVI Getting block end value i32 %n at 'entry'
  Result = overdefined
LVI Getting edge value   %add14 = add nuw nsw i32 %odd.052, 2 from 'for.body' to 'for.body'
PUSH:   %add14 = add nuw nsw i32 %odd.052, 2 in for.body
PUSH:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ] in for.body
 compute BB 'for.body' - overdefined because of pred (local).
POP   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ] in for.body = overdefined
POP   %add14 = add nuw nsw i32 %odd.052, 2 in for.body = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting edge value   %add13 = add nuw nsw i32 %even.051, 2 from 'for.body' to 'for.body'
PUSH:   %add13 = add nuw nsw i32 %even.051, 2 in for.body
PUSH:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ] in for.body
POP   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ] in for.body = constantrange<-2147483648, 2147483647>
POP   %add13 = add nuw nsw i32 %even.051, 2 in for.body = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting edge value   %add12 = fadd double %sum_odd.050, %call11 from 'for.body' to 'for.body'
PUSH:   %add12 = fadd double %sum_odd.050, %call11 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %add12 = fadd double %sum_odd.050, %call11 in for.body = overdefined
  Result = overdefined
LVI Getting edge value   %call = tail call double %f(double %add2) from 'for.body.preheader' to 'for.body'
PUSH:   %call = tail call double %f(double %add2) in for.body.preheader
PUSH:   %call = tail call double %f(double %add2) in entry
 compute BB 'entry' - unknown inst def found.
POP   %call = tail call double %f(double %add2) in entry = overdefined
 compute BB 'for.body.preheader' - overdefined because of pred (non local).
POP   %call = tail call double %f(double %add2) in for.body.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %add7 = fadd double %sum_even.049, %call6 from 'for.body' to 'for.body'
PUSH:   %add7 = fadd double %sum_even.049, %call6 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %add7 = fadd double %sum_even.049, %call6 in for.body = overdefined
  Result = overdefined
LVI Getting edge value   %phi.bo = fmul double %add7, 2.000000e+00 from 'for.end.loopexit' to 'for.end'
PUSH:   %phi.bo = fmul double %add7, 2.000000e+00 in for.end.loopexit
 compute BB 'for.end.loopexit' - unknown inst def found.
POP   %phi.bo = fmul double %add7, 2.000000e+00 in for.end.loopexit = overdefined
  Result = overdefined
LVI Getting edge value   %call = tail call double %f(double %add2) from 'entry' to 'for.end'
  Result = overdefined
LVI Getting edge value   %add12 = fadd double %sum_odd.050, %call11 from 'for.end.loopexit' to 'for.end'
PUSH:   %add12 = fadd double %sum_odd.050, %call11 in for.end.loopexit
 compute BB 'for.end.loopexit' - overdefined because of pred (non local).
POP   %add12 = fadd double %sum_odd.050, %call11 in for.end.loopexit = overdefined
  Result = overdefined
LVI Getting block end value   %div23 = fdiv double %mul22, 3.000000e+00 at 'for.end'
PUSH:   %div23 = fdiv double %mul22, 3.000000e+00 in for.end
 compute BB 'for.end' - unknown inst def found.
POP   %div23 = fdiv double %mul22, 3.000000e+00 in for.end = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %entry
4: %for.end.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.end 
mark live:   %call = tail call double %f(double %add2)
mark block live: entry
mark live:   %call6 = tail call double %f(double %add5)
mark block live: for.body
mark live:   %call11 = tail call double %f(double %add10)
mark live:   %call15 = tail call double %f(double %a)
mark block live: for.end
mark live:   %call16 = tail call double %f(double %b)
mark live:   ret double %div23
mark live:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
mark block live: for.end.loopexit
mark live:   br label %for.end
post-dom root child is a return: for.end
work live:   br label %for.end
work live:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
mark live:   %cmp = icmp slt i32 %add13, %mul
work live:   %cmp = icmp slt i32 %add13, %mul
mark live:   %add13 = add nuw nsw i32 %even.051, 2
mark live:   %mul = shl nsw i32 %div, 1
work live:   %mul = shl nsw i32 %div, 1
mark live:   %div = sdiv i32 %add, 2
work live:   %div = sdiv i32 %add, 2
mark live:   %add = add nsw i32 %n, 1
work live:   %add = add nsw i32 %n, 1
work live:   %add13 = add nuw nsw i32 %even.051, 2
mark live:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
work live:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
work live:   ret double %div23
mark live:   %div23 = fdiv double %mul22, 3.000000e+00
work live:   %div23 = fdiv double %mul22, 3.000000e+00
mark live:   %mul22 = fmul double %div1, %add21
work live:   %mul22 = fmul double %div1, %add21
mark live:   %div1 = fdiv double %sub, %conv
mark live:   %add21 = fadd double %mul20, %add19
work live:   %add21 = fadd double %mul20, %add19
mark live:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
mark live:   %add19 = fadd double %sum_even.0.lcssa, %add17
work live:   %add19 = fadd double %sum_even.0.lcssa, %add17
mark live:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
mark live:   %add17 = fadd double %call15, %call16
work live:   %add17 = fadd double %call15, %call16
work live:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
mark live:   %phi.bo = fmul double %add7, 2.000000e+00
work live:   %phi.bo = fmul double %add7, 2.000000e+00
mark live:   %add7 = fadd double %sum_even.049, %call6
work live:   %add7 = fadd double %sum_even.049, %call6
mark live:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
work live:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
work live:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
mark live:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
work live:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
mark live:   %add12 = fadd double %sum_odd.050, %call11
work live:   %add12 = fadd double %sum_odd.050, %call11
mark live:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
work live:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
work live:   %div1 = fdiv double %sub, %conv
mark live:   %sub = fsub double %b, %a
mark live:   %conv = sitofp i32 %mul to double
work live:   %conv = sitofp i32 %mul to double
work live:   %sub = fsub double %b, %a
work live:   %call16 = tail call double %f(double %b)
work live:   %call15 = tail call double %f(double %a)
work live:   %call11 = tail call double %f(double %add10)
mark live:   %add10 = fadd double %mul9, %a
work live:   %add10 = fadd double %mul9, %a
mark live:   %mul9 = fmul double %div1, %conv8
work live:   %mul9 = fmul double %div1, %conv8
mark live:   %conv8 = sitofp i32 %odd.052 to double
work live:   %conv8 = sitofp i32 %odd.052 to double
mark live:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
work live:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
mark live:   %add14 = add nuw nsw i32 %odd.052, 2
work live:   %add14 = add nuw nsw i32 %odd.052, 2
work live:   %call6 = tail call double %f(double %add5)
mark live:   %add5 = fadd double %mul4, %a
work live:   %add5 = fadd double %mul4, %a
mark live:   %mul4 = fmul double %div1, %conv3
work live:   %mul4 = fmul double %div1, %conv3
mark live:   %conv3 = sitofp i32 %even.051 to double
work live:   %conv3 = sitofp i32 %even.051 to double
work live:   %call = tail call double %f(double %add2)
mark live:   %add2 = fadd double %div1, %a
work live:   %add2 = fadd double %div1, %a
new live blocks:
	entry
	for.body
	for.end
	for.end.loopexit
	for.body.preheader
dead terminator blocks:
	entry
	for.body.preheader
live control in: entry
mark live:   br i1 %cmp48, label %for.body.preheader, label %for.end
mark block live: for.body.preheader
mark live:   br label %for.body
work live:   br label %for.body
work live:   br i1 %cmp48, label %for.body.preheader, label %for.end
mark live:   %cmp48 = icmp sgt i32 %n, 2
work live:   %cmp48 = icmp sgt i32 %n, 2
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.
Looking to fold for.body.preheader into for.body
Killing Trivial BB: 

for.body.preheader:                               ; preds = %entry
  br label %for.body


INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7.lcssa, 2.000000e+00
IC: ADD:   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD:   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %add7.lcssa = phi double [ %add7, %for.body ]
IC: Replacing   %add7.lcssa = phi double [ %add7, %for.body ]
    with   %add7 = fadd double %sum_even.049, %call6
IC: Mod =   %add7.lcssa = phi double [ %add7, %for.body ]
    New =   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ERASE   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ADD DEFERRED:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: Replacing   %add12.lcssa = phi double [ %add12, %for.body ]
    with   %add12 = fadd double %sum_odd.050, %call11
IC: Mod =   %add12.lcssa = phi double [ %add12, %for.body ]
    New =   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ERASE   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD DEFERRED:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end


INSTCOMBINE ITERATION #2 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7, 2.000000e+00
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_Z7simpsonPFddEddi'<<0x7fffc1d49350>>  #uses=2
  CS<0x7fffc0cf9f40> calls external node
  CS<0x7fffc0cfade0> calls external node
  CS<0x7fffc0cfb400> calls external node
  CS<0x7fffc0cfbd10> calls external node
  CS<0x7fffc0cfbe90> calls external node

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: pow: 0 call sites.
Inliner visiting SCC: _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_'<<0x7fffc1c856a0>>  #uses=2
  CS<0x7fffc1c46880> calls function 'pow'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_'
LVI Getting block end value   %call = call double @pow(double %__x, double %conv) #13 at 'entry'
PUSH:   %call = call double @pow(double %__x, double %conv) #13 in entry
 compute BB 'entry' - unknown inst def found.
POP   %call = call double @pow(double %__x, double %conv) #13 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
IC: ADD:   ret double %call
IC: ADD:   %call = call double @pow(double %__x, double %conv) #13
IC: ADD:   %conv = sitofp i32 %__y to double
IC: Visiting:   %conv = sitofp i32 %__y to double
IC: Visiting:   %call = call double @pow(double %__x, double %conv) #13
IC: Visiting:   ret double %call
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_ ----

Computing probabilities for entry

block-frequency: _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
==============================================================================================================================================================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   %call = call double @pow(double %__x, double %conv) #13
Calculated Rank[__x] = 3
Calculated Rank[__y] = 4


INSTCOMBINE ITERATION #1 on _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
IC: ADD:   ret double %call
IC: ADD:   %call = tail call double @pow(double %__x, double %conv) #13
IC: ADD:   %conv = sitofp i32 %__y to double
IC: Visiting:   %conv = sitofp i32 %__y to double
IC: Visiting:   %call = tail call double @pow(double %__x, double %conv) #13
IC: Visiting:   ret double %call
SROA function: _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
Instruction Merger
GVN iteration: 0
SCCP on function '_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_'
Marking Block Executable: entry
markOverdefined: double %__x
markOverdefined: i32 %__y

Popped off OI-WL: i32 %__y
markOverdefined:   %conv = sitofp i32 %__y to double

Popped off OI-WL:   %conv = sitofp i32 %__y to double
markOverdefined:   %call = tail call double @pow(double %__x, double %conv) #13

Popped off OI-WL:   %call = tail call double @pow(double %__x, double %conv) #13

Popped off OI-WL: double %__x

Popped off BBWL: 
entry:
  %conv = sitofp i32 %__y to double
  %call = tail call double @pow(double %__x, double %conv) #13
  ret double %call

RESOLVING UNDEFs
DemandedBits: Root:   %call = tail call double @pow(double %__x, double %conv) #13
DemandedBits: Root:   ret double %call
DemandedBits: Visiting:   %call = tail call double @pow(double %__x, double %conv) #13
DemandedBits: Visiting:   %conv = sitofp i32 %__y to double


INSTCOMBINE ITERATION #1 on _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
IC: ADD:   ret double %call
IC: ADD:   %call = tail call double @pow(double %__x, double %conv) #13
IC: ADD:   %conv = sitofp i32 %__y to double
IC: Visiting:   %conv = sitofp i32 %__y to double
IC: Visiting:   %call = tail call double @pow(double %__x, double %conv) #13
IC: Visiting:   ret double %call
Jump threading on function '_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_'
LVI Getting block end value   %call = tail call double @pow(double %__x, double %conv) #13 at 'entry'
PUSH:   %call = tail call double @pow(double %__x, double %conv) #13 in entry
 compute BB 'entry' - unknown inst def found.
POP   %call = tail call double @pow(double %__x, double %conv) #13 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   %call = tail call double @pow(double %__x, double %conv) #13
mark block live: entry
mark live:   ret double %call
post-dom root child is a return: entry
work live:   ret double %call
work live:   %call = tail call double @pow(double %__x, double %conv) #13
mark live:   %conv = sitofp i32 %__y to double
work live:   %conv = sitofp i32 %__y to double
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_
IC: ADD:   ret double %call
IC: ADD:   %call = tail call double @pow(double %__x, double %conv) #13
IC: ADD:   %conv = sitofp i32 %__y to double
IC: Visiting:   %conv = sitofp i32 %__y to double
IC: Visiting:   %call = tail call double @pow(double %__x, double %conv) #13
IC: Visiting:   ret double %call
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_'<<0x7fffc1c856a0>>  #uses=2
  CS<0x7fffc1c46880> calls function 'pow'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_Z4funcd'<<0x7fffc1c835d0>>  #uses=1
  CS<0x7fffc0e79ea0> calls function '_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _Z4funcd: 1 call sites.
      Analyzing call of _ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_... (caller:_Z4funcd)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 3
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call = call double @_ZSt3powIdiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_Xsr3std12__is_integerIS2_EE7__valueEE6__typeENS4_IS3_Xsr3std12__is_integerIS3_EE7__valueEE6__typeEE6__typeES2_S3_(double %x, i32 4)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_Z4funcd'<<0x7fffc1c835d0>>  #uses=1
  CS<0x7fffc1c91120> calls function 'pow'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Adding nofree attr to fn _Z4funcd
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_Z4funcd'<<0x7fffc1c835d0>>  #uses=1
  CS<0x7fffc1c91120> calls function 'pow'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _Z4funcd
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_Z4funcd'
LVI Getting block end value   %call.i = call double @pow(double %x, double 4.000000e+00) #14 at 'entry'
PUSH:   %call.i = call double @pow(double %x, double 4.000000e+00) #14 in entry
 compute BB 'entry' - unknown inst def found.
POP   %call.i = call double @pow(double %x, double 4.000000e+00) #14 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call.i
IC: ADD:   %call.i = call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   %call.i = call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   ret double %call.i
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _Z4funcd ----

Computing probabilities for entry

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   %call.i = call double @pow(double %x, double 4.000000e+00) #14
Calculated Rank[x] = 3


INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call.i
IC: ADD:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   ret double %call.i
SROA function: _Z4funcd
Instruction Merger
GVN iteration: 0
SCCP on function '_Z4funcd'
Marking Block Executable: entry
markOverdefined: double %x

Popped off OI-WL: double %x
markOverdefined:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14

Popped off OI-WL:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14

Popped off BBWL: 
entry:
  %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
  ret double %call.i

RESOLVING UNDEFs
DemandedBits: Root:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
DemandedBits: Root:   ret double %call.i
DemandedBits: Visiting:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14


INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call.i
IC: ADD:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   ret double %call.i
Jump threading on function '_Z4funcd'
LVI Getting block end value   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14 at 'entry'
PUSH:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14 in entry
 compute BB 'entry' - unknown inst def found.
POP   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
mark block live: entry
mark live:   ret double %call.i
post-dom root child is a return: entry
work live:   ret double %call.i
work live:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call.i
IC: ADD:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #14
IC: Visiting:   ret double %call.i
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_Z4funcd'<<0x7fffc1c835d0>>  #uses=1
  CS<0x7fffc1c91120> calls function 'pow'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNSt8ios_base4InitC1Ev: 0 call sites.
Inliner visiting SCC: _ZNSt8ios_base4InitD1Ev: 0 call sites.
Inliner visiting SCC: __cxa_atexit: 0 call sites.
Inliner visiting SCC: _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv'<<0x7fffc0cfae60>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv'
LVI Getting block end value   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 at 'entry'
PUSH:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry
POP   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
IC: ADD:   ret i32 %0
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: Visiting:   ret i32 %0
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv ----

Computing probabilities for entry

block-frequency: _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
================================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
 - entry: float = 1.0, int = 8

Calculated Rank[this] = 3


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
IC: ADD:   ret i32 %0
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: Visiting:   ret i32 %0
SROA function: _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
Instruction Merger
GVN iteration: 0
GVN: load i32 %0 has unknown dependence
SCCP on function '_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ios"* %this

Popped off OI-WL: %"class.std::basic_ios"* %this
markOverdefined:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5

Popped off OI-WL:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
Merged overdefined into   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2

Popped off BBWL: 
entry:
  %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
  %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
  ret i32 %0

RESOLVING UNDEFs
DemandedBits: Root:   ret i32 %0
DemandedBits: Visiting:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
IC: ADD:   ret i32 %0
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: Visiting:   ret i32 %0
Jump threading on function '_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv'
LVI Getting block end value   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 at 'entry'
PUSH:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry
POP   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i32 %0
mark block live: entry
post-dom root child is a return: entry
work live:   ret i32 %0
mark live:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
work live:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
mark live:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
work live:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv
IC: ADD:   ret i32 %0
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state, align 8, !tbaa !2
IC: Visiting:   ret i32 %0
Inliner visiting SCC: _ZStorSt12_Ios_IostateS_: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStorSt12_Ios_IostateS_'<<0x7fffc0e7af70>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStorSt12_Ios_IostateS_
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStorSt12_Ios_IostateS_'
LVI Getting block end value   %or = or i32 %__a, %__b at 'entry'
PUSH:   %or = or i32 %__a, %__b in entry
PUSH: i32 %__a in entry
PUSH: i32 %__b in entry
POP i32 %__b in entry = overdefined
POP i32 %__a in entry = overdefined
POP   %or = or i32 %__a, %__b in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZStorSt12_Ios_IostateS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__a, %__b
IC: Visiting:   %or = or i32 %__a, %__b
IC: Visiting:   ret i32 %or
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStorSt12_Ios_IostateS_ ----

Computing probabilities for entry

block-frequency: _ZStorSt12_Ios_IostateS_
=========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStorSt12_Ios_IostateS_
 - entry: float = 1.0, int = 8

Calculated Rank[__a] = 3
Calculated Rank[__b] = 4
Combine negations for:   %or = or i32 %__a, %__b
LINEARIZE:   %or = or i32 %__a, %__b
OPERAND: i32 %__a (1)
ADD LEAF: i32 %__a (1)
OPERAND: i32 %__b (1)
ADD LEAF: i32 %__b (1)
RAIn:	or i32	[ %__a, #3] [ %__b, #4] 
RAOut:	or i32	[ %__b, #4] [ %__a, #3] 
RA:   %or = or i32 %__a, %__b
TO:   %or = or i32 %__b, %__a


INSTCOMBINE ITERATION #1 on _ZStorSt12_Ios_IostateS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__b, %__a
IC: Visiting:   %or = or i32 %__b, %__a
IC: Visiting:   ret i32 %or
SROA function: _ZStorSt12_Ios_IostateS_
Instruction Merger
GVN iteration: 0
SCCP on function '_ZStorSt12_Ios_IostateS_'
Marking Block Executable: entry
markOverdefined: i32 %__a
markOverdefined: i32 %__b

Popped off OI-WL: i32 %__b
markOverdefined:   %or = or i32 %__b, %__a

Popped off OI-WL:   %or = or i32 %__b, %__a

Popped off OI-WL: i32 %__a

Popped off BBWL: 
entry:
  %or = or i32 %__b, %__a
  ret i32 %or

RESOLVING UNDEFs
DemandedBits: Root:   ret i32 %or
DemandedBits: Visiting:   %or = or i32 %__b, %__a Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _ZStorSt12_Ios_IostateS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__b, %__a
IC: Visiting:   %or = or i32 %__b, %__a
IC: Visiting:   ret i32 %or
Jump threading on function '_ZStorSt12_Ios_IostateS_'
LVI Getting block end value   %or = or i32 %__b, %__a at 'entry'
PUSH:   %or = or i32 %__b, %__a in entry
PUSH: i32 %__b in entry
PUSH: i32 %__a in entry
POP i32 %__a in entry = overdefined
POP i32 %__b in entry = overdefined
POP   %or = or i32 %__b, %__a in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i32 %or
mark block live: entry
post-dom root child is a return: entry
work live:   ret i32 %or
mark live:   %or = or i32 %__b, %__a
work live:   %or = or i32 %__b, %__a
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStorSt12_Ios_IostateS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__b, %__a
IC: Visiting:   %or = or i32 %__b, %__a
IC: Visiting:   ret i32 %or
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStorSt12_Ios_IostateS_'<<0x7fffc0e7af70>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate: 0 call sites.
Inliner visiting SCC: _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate: 2 call sites.
      Analyzing call of _ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv... (caller:_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 3
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call = call i32 @_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv(%"class.std::basic_ios"* nonnull dereferenceable(264) %this)
      Analyzing call of _ZStorSt12_Ios_IostateS_... (caller:_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call2 = call i32 @_ZStorSt12_Ios_IostateS_(i32 %0, i32 %__state)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate'<<0x7fffc1d51bf0>>  #uses=2
  CS<0x7fffc1baf0b0> calls function '_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate'
LVI Getting block end value   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 at 'entry'
PUSH:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry
POP   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>


INSTCOMBINE ITERATION #1 on _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
IC: ADD:   ret void
IC: ADD:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: ADD:   %or.i = or i32 %__state, %0
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: Visiting:   %or.i = or i32 %__state, %0
IC: Mod =   %or.i = or i32 %__state, %0
    New =   %or.i = or i32 %0, %__state
IC: ADD:   %or.i = or i32 %0, %__state
IC: Visiting:   %or.i = or i32 %0, %__state
IC: Visiting:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: Visiting:   ret void


INSTCOMBINE ITERATION #2 on _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
IC: ADD:   ret void
IC: ADD:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: ADD:   %or.i = or i32 %0, %__state
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__state
IC: Visiting:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: Visiting:   ret void
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate ----

Computing probabilities for entry

block-frequency: _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
===============================================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
Calculated Rank[this] = 3
Calculated Rank[__state] = 4
Combine negations for:   %or.i = or i32 %__state, %0
LINEARIZE:   %or.i = or i32 %__state, %0
OPERAND: i32 %__state (1)
ADD LEAF: i32 %__state (1)
OPERAND:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2 (1)
ADD LEAF:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2 (1)
RAIn:	or i32	[ %__state, #4] [ %0, #327681] 
RAOut:	or i32	[ %0, #327681] [ %__state, #4] 
RA:   %or.i = or i32 %__state, %0
TO:   %or.i = or i32 %0, %__state


INSTCOMBINE ITERATION #1 on _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
IC: ADD:   ret void
IC: ADD:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: ADD:   %or.i = or i32 %0, %__state
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__state
IC: Visiting:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: Visiting:   ret void
SROA function: _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
Instruction Merger
GVN iteration: 0
GVN: load i32 %0 has unknown dependence
SCCP on function '_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ios"* %this
markOverdefined: i32 %__state

Popped off OI-WL: i32 %__state

Popped off OI-WL: %"class.std::basic_ios"* %this
markOverdefined:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5

Popped off OI-WL:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
Merged overdefined into   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
markOverdefined:   %or.i = or i32 %0, %__state

Popped off OI-WL:   %or.i = or i32 %0, %__state

Popped off BBWL: 
entry:
  %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
  %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
  %or.i = or i32 %0, %__state
  tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
  ret void

RESOLVING UNDEFs
DemandedBits: Root:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
DemandedBits: Root:   ret void
DemandedBits: Visiting:   %or.i = or i32 %0, %__state Alive Out: 0xffffffff
DemandedBits: Visiting:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5


INSTCOMBINE ITERATION #1 on _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
IC: ADD:   ret void
IC: ADD:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: ADD:   %or.i = or i32 %0, %__state
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__state
IC: Visiting:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: Visiting:   ret void
Jump threading on function '_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate'
LVI Getting block end value   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 at 'entry'
PUSH:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry
POP   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
mark block live: entry
mark live:   ret void
post-dom root child is a return: entry
work live:   ret void
work live:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
mark live:   %or.i = or i32 %0, %__state
work live:   %or.i = or i32 %0, %__state
mark live:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
work live:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
mark live:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
work live:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate
IC: ADD:   ret void
IC: ADD:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: ADD:   %or.i = or i32 %0, %__state
IC: ADD:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: ADD:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %_M_streambuf_state.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 0, i32 5
IC: Visiting:   %0 = load i32, i32* %_M_streambuf_state.i, align 8, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__state
IC: Visiting:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %this, i32 %or.i)
IC: Visiting:   ret void
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate'<<0x7fffc1d51bf0>>  #uses=2
  CS<0x7fffc1baf0b0> calls function '_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: strlen: 0 call sites.
Inliner visiting SCC: _ZNSt11char_traitsIcE6lengthEPKc: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt11char_traitsIcE6lengthEPKc'<<0x7fffc1d51c70>>  #uses=2
  CS<0x7fffc1c858d0> calls function 'strlen'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZNSt11char_traitsIcE6lengthEPKc
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSt11char_traitsIcE6lengthEPKc'
LVI Getting block end value   %call = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 at 'entry'
PUSH:   %call = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 in entry
 compute BB 'entry' - unknown inst def found.
POP   %call = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZNSt11char_traitsIcE6lengthEPKc
IC: ADD:   ret i64 %call
IC: ADD:   %call = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   ret i64 %call
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSt11char_traitsIcE6lengthEPKc ----

Computing probabilities for entry

block-frequency: _ZNSt11char_traitsIcE6lengthEPKc
=================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSt11char_traitsIcE6lengthEPKc
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   %call = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
Calculated Rank[__s] = 3


INSTCOMBINE ITERATION #1 on _ZNSt11char_traitsIcE6lengthEPKc
IC: ADD:   ret i64 %call
IC: ADD:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   ret i64 %call
SROA function: _ZNSt11char_traitsIcE6lengthEPKc
Instruction Merger
GVN iteration: 0
SCCP on function '_ZNSt11char_traitsIcE6lengthEPKc'
Marking Block Executable: entry
markOverdefined: i8* %__s

Popped off OI-WL: i8* %__s
Merged overdefined into   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 : overdefined

Popped off OI-WL:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15

Popped off BBWL: 
entry:
  %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
  ret i64 %call

RESOLVING UNDEFs
DemandedBits: Root:   ret i64 %call
DemandedBits: Visiting:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 Alive Out: 0xffffffffffffffff


INSTCOMBINE ITERATION #1 on _ZNSt11char_traitsIcE6lengthEPKc
IC: ADD:   ret i64 %call
IC: ADD:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   ret i64 %call
Jump threading on function '_ZNSt11char_traitsIcE6lengthEPKc'
LVI Getting block end value   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 at 'entry'
PUSH:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 in entry
 compute BB 'entry' - unknown inst def found.
POP   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i64 %call
mark block live: entry
post-dom root child is a return: entry
work live:   ret i64 %call
mark live:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
work live:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSt11char_traitsIcE6lengthEPKc
IC: ADD:   ret i64 %call
IC: ADD:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   ret i64 %call
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt11char_traitsIcE6lengthEPKc'<<0x7fffc1d51c70>>  #uses=2
  CS<0x7fffc1c858d0> calls function 'strlen'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l: 0 call sites.
Inliner visiting SCC: _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc: 2 call sites.
      Analyzing call of _ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate... (caller:_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 5
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 10
      Threshold: 337
    Inlining (cost=10, threshold=337), Call:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 1)
      Analyzing call of _ZNSt11char_traitsIcE6lengthEPKc... (caller:_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 0
      Threshold: 337
    Inlining (cost=0, threshold=337), Call:   %call = call i64 @_ZNSt11char_traitsIcE6lengthEPKc(i8* nonnull %__s)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc'<<0x7fffc15291c0>>  #uses=3
  CS<0x7fffc0e79ea0> calls function '_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate'
  CS<0x7fffc1b8e1d0> calls function 'strlen'
  CS<0x7fffc1ba5e70> calls function '_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
EarlyCSE CVP: Add conditional value for 'tobool.not' as i1 true in if.then
EarlyCSE CVP: Add conditional value for 'tobool.not' as i1 false in if.else
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc'
LVI Getting value i8* %__s at ''
  Result = overdefined
LVI Getting block end value i8* %__s at 'entry'
PUSH: i8* %__s in entry
POP i8* %__s in entry = overdefined
  Result = overdefined
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__out to i8** at 'if.then'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8** in if.then
POP   %0 = bitcast %"class.std::basic_ostream"* %__out to i8** in if.then = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'if.then'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in if.then
 compute BB 'if.then' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in if.then = overdefined
  Result = overdefined
LVI Getting block end value   %_M_streambuf_state.i.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 0, i32 5 at 'if.then'
PUSH:   %_M_streambuf_state.i.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 0, i32 5 in if.then
POP   %_M_streambuf_state.i.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 0, i32 5 in if.then = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value %"class.std::basic_ostream"* %__out at 'if.end'
PUSH: %"class.std::basic_ostream"* %__out in if.end
PUSH: %"class.std::basic_ostream"* %__out in if.else
PUSH: %"class.std::basic_ostream"* %__out in entry
POP %"class.std::basic_ostream"* %__out in entry = overdefined
 compute BB 'if.else' - overdefined because of pred (non local).
POP %"class.std::basic_ostream"* %__out in if.else = overdefined
 compute BB 'if.end' - overdefined because of pred (non local).
POP %"class.std::basic_ostream"* %__out in if.end = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
IC: ADD:   br label %if.end
IC: ADD:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: ADD:   %or.i.i = or i32 %4, 1
IC: ADD:   %4 = load i32, i32* %_M_streambuf_state.i.i, align 8, !tbaa !5
IC: ADD:   %_M_streambuf_state.i.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 0, i32 5
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: ADD:   ret %"class.std::basic_ostream"* %__out
IC: ADD:   br label %if.end
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: ADD:   %call.i = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.else
IC: ADD:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.else
IC: Visiting:   %call.i = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: Visiting:   br label %if.end
IC: Visiting:   ret %"class.std::basic_ostream"* %__out
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %_M_streambuf_state.i.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 0, i32 5
IC: ADD DEFERRED:   %4 = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: Old =   %4 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 0, i32 5
    New =   <badref> = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: ADD:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: ERASE   %5 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 0, i32 5
IC: ADD DEFERRED:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: Visiting:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: Visiting:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: Visiting:   %or.i.i = or i32 %5, 1
IC: Visiting:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: Visiting:   br label %if.end


INSTCOMBINE ITERATION #2 on _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
IC: ADD:   br label %if.end
IC: ADD:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: ADD:   %or.i.i = or i32 %5, 1
IC: ADD:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: ADD:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: ADD:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: ADD:   ret %"class.std::basic_ostream"* %__out
IC: ADD:   br label %if.end
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: ADD:   %call.i = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.else
IC: ADD:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.else
IC: Visiting:   %call.i = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: Visiting:   br label %if.end
IC: Visiting:   ret %"class.std::basic_ostream"* %__out
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: Visiting:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: Visiting:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: Visiting:   %or.i.i = or i32 %5, 1
IC: Visiting:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: Visiting:   br label %if.end
		Looking for trivial roots
Found a new trivial root: %if.end
Last visited node: %if.else
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.end
3: %if.then
4: %entry
5: %if.else
Found roots: %if.end 
---- Branch Probability Info : _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ----

Computing probabilities for if.end
Computing probabilities for if.then
Computing probabilities for if.else
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge entry -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%

block-frequency: _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
========================================================================
reverse-post-order-traversal
 - 0: entry
 - 1: if.else
 - 2: if.then
 - 3: if.end
loop-detection
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 805306368, succ = if.then
  => [ local  ] weight = 1342177280, succ = if.else
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to if.else
  => assign 6000000000000000 (0000000000000000) to if.then
 - node: if.else
  => [ local  ] weight = 2147483648, succ = if.end
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to if.end
 - node: if.then
  => [ local  ] weight = 2147483648, succ = if.end
  => mass:  6000000000000000
  => assign 6000000000000000 (0000000000000000) to if.end
 - node: if.end
  => mass:  ffffffffffffffff
float-to-int: min = 0.375, max = 1.0, factor = 21.33333333
 - entry: float = 1.0, scaled = 21.33333333, int = 21
 - if.else: float = 0.625, scaled = 13.33333333, int = 13
 - if.then: float = 0.375, scaled = 8.0, int = 8
 - if.end: float = 1.0, scaled = 21.33333333, int = 21
block-frequency-info: _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
 - entry: float = 1.0, int = 21
 - if.then: float = 0.375, int = 8
 - if.else: float = 0.625, int = 13
 - if.end: float = 1.0, int = 21

Marked as tail call candidate:   %call.i = call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
Marked as tail call candidate:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
Marked as tail call candidate:   call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
Calculated Rank[__out] = 3
Calculated Rank[__s] = 4
Combine negations for:   %or.i.i = or i32 %5, 1
LINEARIZE:   %or.i.i = or i32 %5, 1
OPERAND:   %5 = load i32, i32* %4, align 8, !tbaa !5 (1)
ADD LEAF:   %5 = load i32, i32* %4, align 8, !tbaa !5 (1)
OPERAND: i32 1 (1)
ADD USES LEAF: i32 1 (1)
RAIn:	or i32	[ %5, #458755] [ 1, #0] 
RAOut:	or i32	[ %5, #458755] [ 1, #0] 


INSTCOMBINE ITERATION #1 on _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
IC: ADD:   br label %if.end
IC: ADD:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: ADD:   %or.i.i = or i32 %5, 1
IC: ADD:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: ADD:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: ADD:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: ADD:   ret %"class.std::basic_ostream"* %__out
IC: ADD:   br label %if.end
IC: ADD:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: ADD:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.else
IC: ADD:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.else
IC: Visiting:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: Visiting:   br label %if.end
IC: Visiting:   ret %"class.std::basic_ostream"* %__out
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: Visiting:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: Visiting:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: Visiting:   %or.i.i = or i32 %5, 1
IC: Visiting:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: Visiting:   br label %if.end
SROA function: _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
Instruction Merger
GVN iteration: 0
GVN: non-local load i8* %vtable has unknown dependencies
GVN: non-local load i64 %vbase.offset has unknown dependencies
GVN: non-local load i32 %5 has unknown dependencies
SCCP on function '_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__out
markOverdefined: i8* %__s

Popped off OI-WL: i8* %__s
markOverdefined:   %tobool.not = icmp eq i8* %__s, null

Popped off OI-WL:   %tobool.not = icmp eq i8* %__s, null
Marking Block Executable: if.then
Marking Block Executable: if.else

Popped off OI-WL: %"class.std::basic_ostream"* %__out
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
Merged overdefined into   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i) : overdefined

Popped off OI-WL:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
markOverdefined:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*

Popped off OI-WL:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*

Popped off OI-WL:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
markOverdefined:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*

Popped off OI-WL:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
Merged overdefined into   %5 = load i32, i32* %4, align 8, !tbaa !5 : overdefined

Popped off OI-WL:   %5 = load i32, i32* %4, align 8, !tbaa !5
Merged constantrange<1, 0> into   %or.i.i = or i32 %5, 1 : constantrange<1, 0>

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*

Popped off I-WL:   %or.i.i = or i32 %5, 1

Popped off BBWL: 
if.else:                                          ; preds = %entry
  %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
  %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
  br label %if.end

Merged overdefined into   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 : overdefined
Marking Block Executable: if.end

Popped off BBWL: 
if.end:                                           ; preds = %if.else, %if.then
  ret %"class.std::basic_ostream"* %__out


Popped off BBWL: 
if.then:                                          ; preds = %entry
  %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
  %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
  %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
  %5 = load i32, i32* %4, align 8, !tbaa !5
  %or.i.i = or i32 %5, 1
  tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
  br label %if.end

Marking Edge Executable: if.then -> if.end

Popped off BBWL: 
entry:
  %tobool.not = icmp eq i8* %__s, null
  br i1 %tobool.not, label %if.then, label %if.else


Popped off OI-WL:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
RESOLVING UNDEFs
DemandedBits: Root:   br i1 %tobool.not, label %if.then, label %if.else
DemandedBits: Root:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
DemandedBits: Root:   br label %if.end
DemandedBits: Root:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
DemandedBits: Root:   br label %if.end
DemandedBits: Root:   ret %"class.std::basic_ostream"* %__out
DemandedBits: Visiting:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %or.i.i = or i32 %5, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %5 = load i32, i32* %4, align 8, !tbaa !5 Alive Out: 0xfffffffe
DemandedBits: Visiting:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
DemandedBits: Visiting:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
DemandedBits: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
DemandedBits: Visiting:   %vbase.offset = load i64, i64* %1, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
DemandedBits: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
DemandedBits: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
DemandedBits: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
DemandedBits: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
DemandedBits: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
DemandedBits: Visiting:   %tobool.not = icmp eq i8* %__s, null Alive Out: 0x1


INSTCOMBINE ITERATION #1 on _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
IC: ADD:   br label %if.end
IC: ADD:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: ADD:   %or.i.i = or i32 %5, 1
IC: ADD:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: ADD:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: ADD:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: ADD:   ret %"class.std::basic_ostream"* %__out
IC: ADD:   br label %if.end
IC: ADD:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: ADD:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.else
IC: ADD:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.else
IC: Visiting:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: Visiting:   br label %if.end
IC: Visiting:   ret %"class.std::basic_ostream"* %__out
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: Visiting:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: Visiting:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: Visiting:   %or.i.i = or i32 %5, 1
IC: Visiting:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: Visiting:   br label %if.end
Jump threading on function '_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc'
LVI Getting value i8* %__s at ''
  Result = overdefined
LVI Getting block end value i8* %__s at 'entry'
PUSH: i8* %__s in entry
POP i8* %__s in entry = overdefined
  Result = overdefined
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__out to i8** at 'if.then'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8** in if.then
POP   %0 = bitcast %"class.std::basic_ostream"* %__out to i8** in if.then = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'if.then'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in if.then
 compute BB 'if.then' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in if.then = overdefined
  Result = overdefined
LVI Getting block end value   %4 = bitcast i8* %_M_streambuf_state.i.i to i32* at 'if.then'
PUSH:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32* in if.then
POP   %4 = bitcast i8* %_M_streambuf_state.i.i to i32* in if.then = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value %"class.std::basic_ostream"* %__out at 'if.end'
PUSH: %"class.std::basic_ostream"* %__out in if.end
PUSH: %"class.std::basic_ostream"* %__out in if.else
PUSH: %"class.std::basic_ostream"* %__out in entry
POP %"class.std::basic_ostream"* %__out in entry = overdefined
 compute BB 'if.else' - overdefined because of pred (non local).
POP %"class.std::basic_ostream"* %__out in if.else = overdefined
 compute BB 'if.end' - overdefined because of pred (non local).
POP %"class.std::basic_ostream"* %__out in if.end = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %if.end
Last visited node: %if.else
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.end
3: %if.then
4: %entry
5: %if.else
Found roots: %if.end 
mark live:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
mark block live: if.then
mark live:   br label %if.end
mark live:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
mark block live: if.else
mark live:   br label %if.end
mark live:   ret %"class.std::basic_ostream"* %__out
mark block live: if.end
post-dom root child is a return: if.end
work live:   ret %"class.std::basic_ostream"* %__out
work live:   br label %if.end
work live:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
mark live:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
work live:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
work live:   br label %if.end
work live:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
mark live:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
mark live:   %or.i.i = or i32 %5, 1
work live:   %or.i.i = or i32 %5, 1
mark live:   %5 = load i32, i32* %4, align 8, !tbaa !5
work live:   %5 = load i32, i32* %4, align 8, !tbaa !5
mark live:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
work live:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
mark live:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
work live:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
mark live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
work live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
mark live:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
mark live:   %vbase.offset = load i64, i64* %1, align 8
work live:   %vbase.offset = load i64, i64* %1, align 8
mark live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
work live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
mark live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
work live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
mark live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
work live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
mark live:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
work live:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
work live:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
work live:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
new live blocks:
	if.then
	if.else
	if.end
dead terminator blocks:
	entry
live control in: entry
mark live:   br i1 %tobool.not, label %if.then, label %if.else
work live:   br i1 %tobool.not, label %if.then, label %if.else
mark live:   %tobool.not = icmp eq i8* %__s, null
work live:   %tobool.not = icmp eq i8* %__s, null
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
IC: ADD:   br label %if.end
IC: ADD:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: ADD:   %or.i.i = or i32 %5, 1
IC: ADD:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: ADD:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: ADD:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: ADD:   ret %"class.std::basic_ostream"* %__out
IC: ADD:   br label %if.end
IC: ADD:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: ADD:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.else
IC: ADD:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   %tobool.not = icmp eq i8* %__s, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.else
IC: Visiting:   %call.i = tail call i64 @strlen(i8* nonnull dereferenceable(1) %__s) #15
IC: Visiting:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %__out, i8* nonnull %__s, i64 %call.i)
IC: Visiting:   br label %if.end
IC: Visiting:   ret %"class.std::basic_ostream"* %__out
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__out to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__out to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %_M_streambuf_state.i.i = getelementptr inbounds i8, i8* %add.ptr, i64 32
IC: Visiting:   %4 = bitcast i8* %_M_streambuf_state.i.i to i32*
IC: Visiting:   %5 = load i32, i32* %4, align 8, !tbaa !5
IC: Visiting:   %or.i.i = or i32 %5, 1
IC: Visiting:   tail call void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i32 %or.i.i)
IC: Visiting:   br label %if.end
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc'<<0x7fffc15291c0>>  #uses=3
  CS<0x7fffc0e79ea0> calls function '_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate'
  CS<0x7fffc1b8e1d0> calls function 'strlen'
  CS<0x7fffc1ba5e70> calls function '_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZSt4setwi: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt4setwi'<<0x7fffc1c8adb0>>  #uses=3

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZSt4setwi
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZSt4setwi'
LVI Getting block end value i32 %__n at 'entry'
PUSH: i32 %__n in entry
POP i32 %__n in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZSt4setwi
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZSt4setwi ----

Computing probabilities for entry

block-frequency: _ZSt4setwi
===========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZSt4setwi
 - entry: float = 1.0, int = 8

Calculated Rank[__n] = 3


INSTCOMBINE ITERATION #1 on _ZSt4setwi
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
SROA function: _ZSt4setwi
Instruction Merger
GVN iteration: 0
SCCP on function '_ZSt4setwi'
Marking Block Executable: entry
markOverdefined: i32 %__n

Popped off OI-WL: i32 %__n

Popped off BBWL: 
entry:
  ret i32 %__n

RESOLVING UNDEFs
DemandedBits: Root:   ret i32 %__n


INSTCOMBINE ITERATION #1 on _ZSt4setwi
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
Jump threading on function '_ZSt4setwi'
LVI Getting block end value i32 %__n at 'entry'
PUSH: i32 %__n in entry
POP i32 %__n in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i32 %__n
mark block live: entry
post-dom root child is a return: entry
work live:   ret i32 %__n
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZSt4setwi
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
Inliner visiting SCC: _ZNSt8ios_base5widthEl: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt8ios_base5widthEl'<<0x7fffc1ba5880>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZNSt8ios_base5widthEl
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSt8ios_base5widthEl'
LVI Getting block end value   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 at 'entry'
PUSH:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 in entry
POP   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 at 'entry'
  Result = notconstant<i64* null>
LVI Getting block end value   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base5widthEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSt8ios_base5widthEl ----

Computing probabilities for entry

block-frequency: _ZNSt8ios_base5widthEl
=======================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSt8ios_base5widthEl
 - entry: float = 1.0, int = 8

Calculated Rank[this] = 3
Calculated Rank[__wide] = 4


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base5widthEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
SROA function: _ZNSt8ios_base5widthEl
Instruction Merger
GVN iteration: 0
GVN: load i64 %0 has unknown dependence
SCCP on function '_ZNSt8ios_base5widthEl'
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %this
markOverdefined: i64 %__wide

Popped off OI-WL: i64 %__wide

Popped off OI-WL: %"class.std::ios_base"* %this
markOverdefined:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2

Popped off OI-WL:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
Merged overdefined into   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2

Popped off BBWL: 
entry:
  %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
  %0 = load i64, i64* %_M_width, align 8, !tbaa !2
  store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
  ret i64 %0

RESOLVING UNDEFs
DemandedBits: Root:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
DemandedBits: Root:   ret i64 %0
DemandedBits: Visiting:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base5widthEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
Jump threading on function '_ZNSt8ios_base5widthEl'
LVI Getting block end value   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 at 'entry'
PUSH:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 in entry
POP   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2 at 'entry'
  Result = notconstant<i64* null>
LVI Getting block end value   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i64, i64* %_M_width, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
mark block live: entry
mark live:   ret i64 %0
post-dom root child is a return: entry
work live:   ret i64 %0
mark live:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
work live:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
mark live:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
work live:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
work live:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i64 %__wide, i64* %_M_width, align 8, !tbaa !2)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base5widthEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: ADD:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %_M_width = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 2
IC: Visiting:   %0 = load i64, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   store i64 %__wide, i64* %_M_width, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
Inliner visiting SCC: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw: 1 call sites.
      Analyzing call of _ZNSt8ios_base5widthEl... (caller:_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 4
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call = call i64 @_ZNSt8ios_base5widthEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw'<<0x7fffc16918b0>>  #uses=3

CGSCCPASSMGR: SCC Refresh didn't change call graph.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw'<<0x7fffc16918b0>>  #uses=3

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
EarlyCSE DCE:   %4 = load i64, i64* %_M_width.i, align 8, !tbaa !5
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw'
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting value i32 %__f.coerce at 'conv'
  Result = overdefined
LVI Getting block end value   %_M_width.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 2 at 'entry'
PUSH:   %_M_width.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 2 in entry
POP   %_M_width.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 2 in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value %"class.std::basic_ostream"* %__os at 'entry'
PUSH: %"class.std::basic_ostream"* %__os in entry
POP %"class.std::basic_ostream"* %__os in entry = overdefined
  Result = notconstant<%"class.std::basic_ostream"* null>


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %_M_width.i, align 8, !tbaa !5
IC: ADD:   %_M_width.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 2
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_width.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 2
IC: ADD DEFERRED:   %4 = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: Old =   %4 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 2
    New =   <badref> = bitcast i8* %_M_width.i to i64*
IC: ADD:   %4 = bitcast i8* %_M_width.i to i64*
IC: ERASE   %5 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 2
IC: ADD DEFERRED:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ERASE   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD DEFERRED:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: Visiting:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %_M_width.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os


INSTCOMBINE ITERATION #2 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_width.i to i64*
IC: ADD:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: Visiting:   %3 = bitcast i8* %_M_width.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw ----

Computing probabilities for entry

block-frequency: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
================================================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
 - entry: float = 1.0, int = 8

Calculated Rank[__os] = 3
Calculated Rank[__f.coerce] = 4


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_width.i to i64*
IC: ADD:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: Visiting:   %3 = bitcast i8* %_M_width.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
SROA function: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
Instruction Merger
GVN iteration: 0
GVN: load i8* %vtable has unknown dependence
GVN: load i64 %vbase.offset has unknown dependence
SCCP on function '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os
markOverdefined: i32 %__f.coerce

Popped off OI-WL: i32 %__f.coerce
markOverdefined:   %conv = sext i32 %__f.coerce to i64

Popped off OI-WL:   %conv = sext i32 %__f.coerce to i64

Popped off OI-WL: %"class.std::basic_ostream"* %__os
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16

Popped off OI-WL:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
markOverdefined:   %3 = bitcast i8* %_M_width.i to i64*

Popped off OI-WL:   %3 = bitcast i8* %_M_width.i to i64*

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %conv = sext i32 %__f.coerce to i64
  %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
  %3 = bitcast i8* %_M_width.i to i64*
  store i64 %conv, i64* %3, align 8, !tbaa !5
  ret %"class.std::basic_ostream"* %__os

RESOLVING UNDEFs
DemandedBits: Root:   store i64 %conv, i64* %3, align 8, !tbaa !5
DemandedBits: Root:   ret %"class.std::basic_ostream"* %__os
DemandedBits: Visiting:   %3 = bitcast i8* %_M_width.i to i64*
DemandedBits: Visiting:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
DemandedBits: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
DemandedBits: Visiting:   %vbase.offset = load i64, i64* %1, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
DemandedBits: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
DemandedBits: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
DemandedBits: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
DemandedBits: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
DemandedBits: Visiting:   %conv = sext i32 %__f.coerce to i64 Alive Out: 0xffffffffffffffff


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_width.i to i64*
IC: ADD:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: Visiting:   %3 = bitcast i8* %_M_width.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
Jump threading on function '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw'
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting value i32 %__f.coerce at 'conv'
  Result = overdefined
LVI Getting block end value   %3 = bitcast i8* %_M_width.i to i64* at 'entry'
PUSH:   %3 = bitcast i8* %_M_width.i to i64* in entry
POP   %3 = bitcast i8* %_M_width.i to i64* in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value %"class.std::basic_ostream"* %__os at 'entry'
PUSH: %"class.std::basic_ostream"* %__os in entry
POP %"class.std::basic_ostream"* %__os in entry = overdefined
  Result = notconstant<%"class.std::basic_ostream"* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i64 %conv, i64* %3, align 8, !tbaa !5
mark block live: entry
mark live:   ret %"class.std::basic_ostream"* %__os
post-dom root child is a return: entry
work live:   ret %"class.std::basic_ostream"* %__os
work live:   store i64 %conv, i64* %3, align 8, !tbaa !5
mark live:   %conv = sext i32 %__f.coerce to i64
mark live:   %3 = bitcast i8* %_M_width.i to i64*
work live:   %3 = bitcast i8* %_M_width.i to i64*
mark live:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
work live:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
mark live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
work live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
mark live:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
mark live:   %vbase.offset = load i64, i64* %1, align 8
work live:   %vbase.offset = load i64, i64* %1, align 8
mark live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
work live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
mark live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
work live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
mark live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
work live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
mark live:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
work live:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
work live:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
work live:   %conv = sext i32 %__f.coerce to i64
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i64 %conv, i64* %3, align 8, !tbaa !5)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_width.i to i64*
IC: ADD:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_width.i = getelementptr inbounds i8, i8* %add.ptr, i64 16
IC: Visiting:   %3 = bitcast i8* %_M_width.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw'<<0x7fffc16918b0>>  #uses=3

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNSolsEi: 0 call sites.
Inliner visiting SCC: _ZNSolsEPFRSt8ios_baseS0_E: 1 call sites.
SROA function: _ZNSolsEPFRSt8ios_baseS0_E
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSolsEPFRSt8ios_baseS0_E'
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %this to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %this to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %this to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting block end value %"class.std::basic_ostream"* %this at 'entry'
PUSH: %"class.std::basic_ostream"* %this in entry
POP %"class.std::basic_ostream"* %this in entry = overdefined
  Result = notconstant<%"class.std::basic_ostream"* null>


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSt8ios_baseS0_E
IC: ADD:   ret %"class.std::basic_ostream"* %this
IC: ADD:   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: Visiting:   ret %"class.std::basic_ostream"* %this
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSolsEPFRSt8ios_baseS0_E ----

Computing probabilities for entry

block-frequency: _ZNSolsEPFRSt8ios_baseS0_E
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSolsEPFRSt8ios_baseS0_E
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   %call = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
Calculated Rank[this] = 3
Calculated Rank[__pf] = 4


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSt8ios_baseS0_E
IC: ADD:   ret %"class.std::basic_ostream"* %this
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: Visiting:   ret %"class.std::basic_ostream"* %this
SROA function: _ZNSolsEPFRSt8ios_baseS0_E
Instruction Merger
GVN iteration: 0
GVN: load i8* %vtable has unknown dependence
GVN: load i64 %vbase.offset has unknown dependence
SCCP on function '_ZNSolsEPFRSt8ios_baseS0_E'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %this
markOverdefined: %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf

Popped off OI-WL: %"class.std::ios_base"* (%"class.std::ios_base"*)* %__pf
Merged overdefined into   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3) : overdefined

Popped off OI-WL:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)

Popped off OI-WL: %"class.std::basic_ostream"* %this
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %this to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %this to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
  %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
  ret %"class.std::basic_ostream"* %this

RESOLVING UNDEFs
DemandedBits: Root:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
DemandedBits: Root:   ret %"class.std::basic_ostream"* %this
DemandedBits: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
DemandedBits: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
DemandedBits: Visiting:   %vbase.offset = load i64, i64* %1, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
DemandedBits: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
DemandedBits: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
DemandedBits: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
DemandedBits: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSt8ios_baseS0_E
IC: ADD:   ret %"class.std::basic_ostream"* %this
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: Visiting:   ret %"class.std::basic_ostream"* %this
Jump threading on function '_ZNSolsEPFRSt8ios_baseS0_E'
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %this to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %this to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %this to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting block end value %"class.std::basic_ostream"* %this at 'entry'
PUSH: %"class.std::basic_ostream"* %this in entry
POP %"class.std::basic_ostream"* %this in entry = overdefined
  Result = notconstant<%"class.std::basic_ostream"* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
mark block live: entry
mark live:   ret %"class.std::basic_ostream"* %this
post-dom root child is a return: entry
work live:   ret %"class.std::basic_ostream"* %this
work live:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
mark live:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
work live:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
mark live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
work live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
mark live:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
mark live:   %vbase.offset = load i64, i64* %1, align 8
work live:   %vbase.offset = load i64, i64* %1, align 8
mark live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
work live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
mark live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
work live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
mark live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
work live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
mark live:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
work live:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
work live:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSt8ios_baseS0_E
IC: ADD:   ret %"class.std::basic_ostream"* %this
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %this to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %this to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* %__pf(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %3)
IC: Visiting:   ret %"class.std::basic_ostream"* %this
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSolsEPFRSt8ios_baseS0_E'<<0x7fffc1c859b0>>  #uses=2
  CS<0x7fffc1c88b10> calls external node

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZSt12setprecisioni: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt12setprecisioni'<<0x7fffc1baebc0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZSt12setprecisioni
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZSt12setprecisioni'
LVI Getting block end value i32 %__n at 'entry'
PUSH: i32 %__n in entry
POP i32 %__n in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZSt12setprecisioni
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZSt12setprecisioni ----

Computing probabilities for entry

block-frequency: _ZSt12setprecisioni
====================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZSt12setprecisioni
 - entry: float = 1.0, int = 8

Calculated Rank[__n] = 3


INSTCOMBINE ITERATION #1 on _ZSt12setprecisioni
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
SROA function: _ZSt12setprecisioni
Instruction Merger
GVN iteration: 0
SCCP on function '_ZSt12setprecisioni'
Marking Block Executable: entry
markOverdefined: i32 %__n

Popped off OI-WL: i32 %__n

Popped off BBWL: 
entry:
  ret i32 %__n

RESOLVING UNDEFs
DemandedBits: Root:   ret i32 %__n


INSTCOMBINE ITERATION #1 on _ZSt12setprecisioni
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
Jump threading on function '_ZSt12setprecisioni'
LVI Getting block end value i32 %__n at 'entry'
PUSH: i32 %__n in entry
POP i32 %__n in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i32 %__n
mark block live: entry
post-dom root child is a return: entry
work live:   ret i32 %__n
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZSt12setprecisioni
IC: ADD:   ret i32 %__n
IC: Visiting:   ret i32 %__n
Inliner visiting SCC: _ZNSt8ios_base9precisionEl: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt8ios_base9precisionEl'<<0x7fffc1d51b70>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZNSt8ios_base9precisionEl
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSt8ios_base9precisionEl'
LVI Getting block end value   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 at 'entry'
PUSH:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 in entry
POP   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 at 'entry'
  Result = notconstant<i64* null>
LVI Getting block end value   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base9precisionEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSt8ios_base9precisionEl ----

Computing probabilities for entry

block-frequency: _ZNSt8ios_base9precisionEl
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSt8ios_base9precisionEl
 - entry: float = 1.0, int = 8

Calculated Rank[this] = 3
Calculated Rank[__prec] = 4


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base9precisionEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
SROA function: _ZNSt8ios_base9precisionEl
Instruction Merger
GVN iteration: 0
GVN: load i64 %0 has unknown dependence
SCCP on function '_ZNSt8ios_base9precisionEl'
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %this
markOverdefined: i64 %__prec

Popped off OI-WL: i64 %__prec

Popped off OI-WL: %"class.std::ios_base"* %this
markOverdefined:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1

Popped off OI-WL:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
Merged overdefined into   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2

Popped off BBWL: 
entry:
  %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
  %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
  store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
  ret i64 %0

RESOLVING UNDEFs
DemandedBits: Root:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
DemandedBits: Root:   ret i64 %0
DemandedBits: Visiting:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base9precisionEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
Jump threading on function '_ZNSt8ios_base9precisionEl'
LVI Getting block end value   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 at 'entry'
PUSH:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 in entry
POP   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1 at 'entry'
  Result = notconstant<i64* null>
LVI Getting block end value   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
mark block live: entry
mark live:   ret i64 %0
post-dom root child is a return: entry
work live:   ret i64 %0
mark live:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
work live:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
mark live:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
work live:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
work live:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base9precisionEl
IC: ADD:   ret i64 %0
IC: ADD:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: ADD:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %_M_precision = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 1
IC: Visiting:   %0 = load i64, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   store i64 %__prec, i64* %_M_precision, align 8, !tbaa !2
IC: Visiting:   ret i64 %0
Inliner visiting SCC: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision: 1 call sites.
      Analyzing call of _ZNSt8ios_base9precisionEl... (caller:_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 4
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call = call i64 @_ZNSt8ios_base9precisionEl(%"class.std::ios_base"* nonnull dereferenceable(216) %3, i64 %conv)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision'<<0x7fffc1c85af0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision'<<0x7fffc1c85af0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
EarlyCSE DCE:   %4 = load i64, i64* %_M_precision.i, align 8, !tbaa !5
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision'
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting value i32 %__f.coerce at 'conv'
  Result = overdefined
LVI Getting block end value   %_M_precision.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 1 at 'entry'
PUSH:   %_M_precision.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 1 in entry
POP   %_M_precision.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 1 in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value %"class.std::basic_ostream"* %__os at 'entry'
PUSH: %"class.std::basic_ostream"* %__os in entry
POP %"class.std::basic_ostream"* %__os in entry = overdefined
  Result = notconstant<%"class.std::basic_ostream"* null>


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %_M_precision.i, align 8, !tbaa !5
IC: ADD:   %_M_precision.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 1
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_precision.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 1
IC: ADD DEFERRED:   %4 = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: Old =   %4 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 1
    New =   <badref> = bitcast i8* %_M_precision.i to i64*
IC: ADD:   %4 = bitcast i8* %_M_precision.i to i64*
IC: ERASE   %5 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %3, i64 0, i32 1
IC: ADD DEFERRED:   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ERASE   %3 = bitcast i8* %add.ptr to %"class.std::ios_base"*
IC: ADD DEFERRED:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: Visiting:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %_M_precision.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os


INSTCOMBINE ITERATION #2 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_precision.i to i64*
IC: ADD:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: Visiting:   %3 = bitcast i8* %_M_precision.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision ----

Computing probabilities for entry

block-frequency: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
=========================================================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
 - entry: float = 1.0, int = 8

Calculated Rank[__os] = 3
Calculated Rank[__f.coerce] = 4


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_precision.i to i64*
IC: ADD:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: Visiting:   %3 = bitcast i8* %_M_precision.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
SROA function: _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
Instruction Merger
GVN iteration: 0
GVN: load i8* %vtable has unknown dependence
GVN: load i64 %vbase.offset has unknown dependence
SCCP on function '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os
markOverdefined: i32 %__f.coerce

Popped off OI-WL: i32 %__f.coerce
markOverdefined:   %conv = sext i32 %__f.coerce to i64

Popped off OI-WL:   %conv = sext i32 %__f.coerce to i64

Popped off OI-WL: %"class.std::basic_ostream"* %__os
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8

Popped off OI-WL:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
markOverdefined:   %3 = bitcast i8* %_M_precision.i to i64*

Popped off OI-WL:   %3 = bitcast i8* %_M_precision.i to i64*

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %conv = sext i32 %__f.coerce to i64
  %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %3 = bitcast i8* %_M_precision.i to i64*
  store i64 %conv, i64* %3, align 8, !tbaa !5
  ret %"class.std::basic_ostream"* %__os

RESOLVING UNDEFs
DemandedBits: Root:   store i64 %conv, i64* %3, align 8, !tbaa !5
DemandedBits: Root:   ret %"class.std::basic_ostream"* %__os
DemandedBits: Visiting:   %3 = bitcast i8* %_M_precision.i to i64*
DemandedBits: Visiting:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
DemandedBits: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
DemandedBits: Visiting:   %vbase.offset = load i64, i64* %1, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
DemandedBits: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
DemandedBits: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
DemandedBits: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
DemandedBits: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
DemandedBits: Visiting:   %conv = sext i32 %__f.coerce to i64 Alive Out: 0xffffffffffffffff


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_precision.i to i64*
IC: ADD:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: Visiting:   %3 = bitcast i8* %_M_precision.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
Jump threading on function '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision'
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting value i32 %__f.coerce at 'conv'
  Result = overdefined
LVI Getting block end value   %3 = bitcast i8* %_M_precision.i to i64* at 'entry'
PUSH:   %3 = bitcast i8* %_M_precision.i to i64* in entry
POP   %3 = bitcast i8* %_M_precision.i to i64* in entry = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value %"class.std::basic_ostream"* %__os at 'entry'
PUSH: %"class.std::basic_ostream"* %__os in entry
POP %"class.std::basic_ostream"* %__os in entry = overdefined
  Result = notconstant<%"class.std::basic_ostream"* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i64 %conv, i64* %3, align 8, !tbaa !5
mark block live: entry
mark live:   ret %"class.std::basic_ostream"* %__os
post-dom root child is a return: entry
work live:   ret %"class.std::basic_ostream"* %__os
work live:   store i64 %conv, i64* %3, align 8, !tbaa !5
mark live:   %conv = sext i32 %__f.coerce to i64
mark live:   %3 = bitcast i8* %_M_precision.i to i64*
work live:   %3 = bitcast i8* %_M_precision.i to i64*
mark live:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
work live:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
mark live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
work live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
mark live:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
mark live:   %vbase.offset = load i64, i64* %1, align 8
work live:   %vbase.offset = load i64, i64* %1, align 8
mark live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
work live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
mark live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
work live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
mark live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
work live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
mark live:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
work live:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
work live:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
work live:   %conv = sext i32 %__f.coerce to i64
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i64 %conv, i64* %3, align 8, !tbaa !5)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision
IC: ADD:   ret %"class.std::basic_ostream"* %__os
IC: ADD:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_precision.i to i64*
IC: ADD:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: ADD:   %conv = sext i32 %__f.coerce to i64
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %conv = sext i32 %__f.coerce to i64
IC: Visiting:   %_M_precision.i = getelementptr inbounds i8, i8* %add.ptr, i64 8
IC: Visiting:   %3 = bitcast i8* %_M_precision.i to i64*
IC: Visiting:   store i64 %conv, i64* %3, align 8, !tbaa !5
IC: Visiting:   ret %"class.std::basic_ostream"* %__os
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision'<<0x7fffc1c85af0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNSo9_M_insertIdEERSoT_: 0 call sites.
Inliner visiting SCC: _ZNSolsEd: 0 call sites.
SROA function: _ZNSolsEd
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSolsEd'
LVI Getting block end value   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) at 'entry'
PUSH:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) in entry
POP   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) in entry = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>


INSTCOMBINE ITERATION #1 on _ZNSolsEd
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSolsEd ----

Computing probabilities for entry

block-frequency: _ZNSolsEd
==========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSolsEd
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
Calculated Rank[this] = 3
Calculated Rank[__f] = 4


INSTCOMBINE ITERATION #1 on _ZNSolsEd
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
SROA function: _ZNSolsEd
Instruction Merger
GVN iteration: 0
SCCP on function '_ZNSolsEd'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %this
markOverdefined: double %__f

Popped off OI-WL: double %__f
Merged overdefined into   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) : overdefined

Popped off OI-WL:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)

Popped off OI-WL: %"class.std::basic_ostream"* %this

Popped off BBWL: 
entry:
  %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
  ret %"class.std::basic_ostream"* %call

RESOLVING UNDEFs
DemandedBits: Root:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
DemandedBits: Root:   ret %"class.std::basic_ostream"* %call
DemandedBits: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)


INSTCOMBINE ITERATION #1 on _ZNSolsEd
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
Jump threading on function '_ZNSolsEd'
LVI Getting block end value   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) at 'entry'
PUSH:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) in entry
POP   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f) in entry = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
mark block live: entry
mark live:   ret %"class.std::basic_ostream"* %call
post-dom root child is a return: entry
work live:   ret %"class.std::basic_ostream"* %call
work live:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSolsEd
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %this, double %__f)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSolsEd'<<0x7fffc1c87e60>>  #uses=2
  CS<0x7fffc1c8ac10> calls function '_ZNSo9_M_insertIdEERSoT_'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNSolsEPFRSoS_E: 1 call sites.
SROA function: _ZNSolsEPFRSoS_E
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSolsEPFRSoS_E'
LVI Getting block end value   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) at 'entry'
PUSH:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) in entry
POP   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) in entry = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSoS_E
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSolsEPFRSoS_E ----

Computing probabilities for entry

block-frequency: _ZNSolsEPFRSoS_E
=================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSolsEPFRSoS_E
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
Calculated Rank[this] = 3
Calculated Rank[__pf] = 4


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSoS_E
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
SROA function: _ZNSolsEPFRSoS_E
Instruction Merger
GVN iteration: 0
SCCP on function '_ZNSolsEPFRSoS_E'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %this
markOverdefined: %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf

Popped off OI-WL: %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* %__pf
Merged overdefined into   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) : overdefined

Popped off OI-WL:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)

Popped off OI-WL: %"class.std::basic_ostream"* %this

Popped off BBWL: 
entry:
  %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
  ret %"class.std::basic_ostream"* %call

RESOLVING UNDEFs
DemandedBits: Root:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
DemandedBits: Root:   ret %"class.std::basic_ostream"* %call
DemandedBits: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSoS_E
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
Jump threading on function '_ZNSolsEPFRSoS_E'
LVI Getting block end value   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) at 'entry'
PUSH:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) in entry
POP   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this) in entry = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
mark block live: entry
mark live:   ret %"class.std::basic_ostream"* %call
post-dom root child is a return: entry
work live:   ret %"class.std::basic_ostream"* %call
work live:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSolsEPFRSoS_E
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* %__pf(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %this)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSolsEPFRSoS_E'<<0x7fffc1c8a7b0>>  #uses=2
  CS<0x7fffc0c6b7e0> calls external node

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: main: 12 call sites.
      Analyzing call of _Z7simpsonPFddEddi... (caller:main)
      NumConstantArgs: 3
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 9
      NumInstructions: 41
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -765
      Threshold: 225
    Inlining (cost=-765, threshold=225), Call:   %call = call double @_Z7simpsonPFddEddi(double (double)* nonnull @_Z4funcd, double 0.000000e+00, double 1.000000e+00, i32 %n.0)
      Analyzing call of _Z4funcd... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call16.i = call double @_Z4funcd(double 1.000000e+00)
      Analyzing call of _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc... (caller:main)
      NumConstantArgs: 2
      NumConstantOffsetPtrArgs: 2
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 4
      NumInstructions: 6
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 40
      Threshold: 487
    Inlining (cost=40, threshold=487), Call:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0))
      Analyzing call of _ZSt4setwi... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 1
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call2 = call i32 @_ZSt4setwi(i32 6)
      Analyzing call of _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw... (caller:main)
      NumConstantArgs: 2
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 9
      NumInstructions: 12
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -25
      Threshold: 487
    Inlining (cost=-25, threshold=487), Call:   %call4 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i32 6)
      Analyzing call of _Z4funcd... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call15.i = call double @_Z4funcd(double 0.000000e+00)
      Analyzing call of _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 2
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 4
      NumInstructions: 6
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 40
      Threshold: 487
    Inlining (cost=40, threshold=487), Call:   %call6 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0))
      Analyzing call of _ZNSolsEPFRSt8ios_baseS0_E... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 2
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 7
      NumInstructions: 10
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -497
      Threshold: 337
    Inlining (cost=-497, threshold=337), Call:   %call7 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSt8ios_baseS0_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, %"class.std::ios_base"* (%"class.std::ios_base"*)* nonnull @_ZSt5fixedRSt8ios_base)
      Analyzing call of _ZSt5fixedRSt8ios_base... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 10
      Threshold: 487
    Inlining (cost=10, threshold=487), Call:   %call.i35 = call nonnull align 8 dereferenceable(216) %"class.std::ios_base"* @_ZSt5fixedRSt8ios_base(%"class.std::ios_base"* nonnull align 8 dereferenceable(216) %5)
      Analyzing call of _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_... (caller:main)
      NumConstantArgs: 2
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 7
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 115
      Threshold: 337
    Inlining (cost=115, threshold=337), Call:   %call.i36 = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %5, i32 4, i32 260)
      Analyzing call of _ZStoRRSt13_Ios_FmtflagsS_... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 4
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 10
      Threshold: 487
    Inlining (cost=10, threshold=487), Call:   %call6.i38 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags.i, i32 %call4.i)
      Analyzing call of _ZStorSt13_Ios_FmtflagsS_... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call.i39 = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %7, i32 %call4.i)
      Analyzing call of _ZStanSt13_Ios_FmtflagsS_... (caller:main)
      NumConstantArgs: 2
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -40
      Threshold: 487
    Inlining (cost=-40, threshold=487), Call:   %call4.i = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 4, i32 260)
      Analyzing call of _ZStaNRSt13_Ios_FmtflagsS_... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 4
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 10
      Threshold: 487
    Inlining (cost=10, threshold=487), Call:   %call3.i = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags.i, i32 %call.i37)
      Analyzing call of _ZStanSt13_Ios_FmtflagsS_... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call.i40 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %7, i32 %call.i37)
      Analyzing call of _ZStcoSt13_Ios_Fmtflags... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call.i37 = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 260)
      Analyzing call of _ZSt12setprecisioni... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 1
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call9 = call i32 @_ZSt12setprecisioni(i32 16)
      Analyzing call of _Z4funcd... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call11.i = call double @_Z4funcd(double %add10.i)
      Analyzing call of _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 9
      NumInstructions: 12
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -25
      Threshold: 487
    Inlining (cost=-25, threshold=487), Call:   %call12 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St13_Setprecision(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i32 16)
      Analyzing call of _Z4funcd... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call6.i = call double @_Z4funcd(double %add5.i)
      Analyzing call of _ZSt4setwi... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 1
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call14 = call i32 @_ZSt4setwi(i32 20)
      Analyzing call of _Z4funcd... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 337
    Inlining (cost=-30, threshold=337), Call:   %call.i = call double @_Z4funcd(double %add2.i)
      Analyzing call of _ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 9
      NumInstructions: 12
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -25
      Threshold: 487
    Inlining (cost=-25, threshold=487), Call:   %call17 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZStlsIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_St5_Setw(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i32 20)
      Analyzing call of _ZNSolsEPFRSoS_E... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 2
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -427
      Threshold: 337
    Inlining (cost=-427, threshold=337), Call:   %call19 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEPFRSoS_E(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call18, %"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* nonnull @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
      Analyzing call of _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 7
      NumInstructions: 12
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 90
      Threshold: 487
    Inlining (cost=90, threshold=487), Call:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call18)
      Analyzing call of _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 0
      Threshold: 487
    Inlining (cost=0, threshold=487), Call:   %call2.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1.i58)
      Analyzing call of _ZNSolsEd... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 0
      Threshold: 337
    Inlining (cost=0, threshold=337), Call:   %call18 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEd(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
      Analyzing call of _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 5
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 40
      Threshold: 337
    Inlining (cost=40, threshold=337), Call:   %call.i57 = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %20, i8 signext 10)
      Analyzing call of _ZNKSt5ctypeIcE5widenEc... (caller:main)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 9
      NumInstructions: 17
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 40
      Threshold: 225
    Inlining (cost=40, threshold=225), Call:   %call2.i = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %call.i60, i8 signext 10)
      Analyzing call of _ZSt13__check_facetISt5ctypeIcEERKT_PS3_... (caller:main)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 5
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 5
      Threshold: 325
    Inlining (cost=5, threshold=325), Call:   %call.i60 = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %21)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: 'main'<<0x7fffc0cfb110>>  #uses=1
  CS<0x7fffc1c890a0> calls function 'pow'
  CS<0x7fffc1d6b450> calls function '_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l'
  CS<0x7fffc1c6bab0> calls function 'strlen'
  CS<0x7fffc0fca110> calls function 'pow'
  CS<0x7fffc1bae2a0> calls function '_ZNSolsEi'
  CS<0x7fffc1d73d50> calls function '_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l'
  CS<0x7fffc16981f0> calls function 'strlen'
  CS<0x7fffc0cfe800> calls function 'pow'
  CS<0x7fffc14f1ea0> calls function 'pow'
  CS<0x7fffc1c91230> calls function 'pow'
  CS<0x7fffc1d72820> calls function '_ZNSo5flushEv'
  CS<0x7fffc1cac1f0> calls function '_ZNSo9_M_insertIdEERSoT_'
  CS<0x7fffc1ca9400> calls external node
  CS<0x7fffc14f22d0> calls function '_ZNSo3putEc'
  CS<0x7fffc1bae500> calls function '_ZSt16__throw_bad_castv'
  CS<0x7fffc1d788e0> calls function '_ZNKSt5ctypeIcE13_M_widen_initEv'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: main
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in for.body
EarlyCSE CVP: Add conditional value for 'cmp.i' as i1 false in for.end.loopexit.i
EarlyCSE Simplify:   %call.i.i28 = call double @pow(double 0.000000e+00, double 4.000000e+00) #15  to: double 0.000000e+00
EarlyCSE Simplify:   %call.i.i = call double @pow(double 1.000000e+00, double 4.000000e+00) #15  to: double 1.000000e+00
EarlyCSE Simplify:   %add17.i = fadd double 0.000000e+00, 1.000000e+00  to: double 1.000000e+00
EarlyCSE DCE:   %6 = load i32, i32* %_M_flags.i, align 8, !tbaa !17
EarlyCSE CSE LOAD:   %7 = load i32, i32* %_M_flags.i, align 4, !tbaa !17  to:   store i32 %and.i, i32* %_M_flags.i, align 4, !tbaa !17
EarlyCSE DEAD STORE:   store i32 %and.i, i32* %_M_flags.i, align 4, !tbaa !17  due to:   store i32 %or.i, i32* %_M_flags.i, align 4, !tbaa !17
EarlyCSE CSE:   %7 = bitcast %"class.std::basic_ostream"* %call5 to i8**  to:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
EarlyCSE CSE LOAD:   %vtable.i42 = load i8*, i8** %2, align 8, !tbaa !4  to:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
EarlyCSE CSE:   %vbase.offset.ptr.i43 = getelementptr i8, i8* %vtable.i31, i64 -24  to:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
EarlyCSE CSE:   %7 = bitcast i8* %vbase.offset.ptr.i32 to i64*  to:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
EarlyCSE CSE:   %7 = bitcast %"class.std::basic_ostream"* %call5 to i8*  to:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
EarlyCSE CSE:   %8 = bitcast %"class.std::basic_ostream"* %call5 to i8**  to:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
EarlyCSE CSE LOAD:   %vtable.i48 = load i8*, i8** %2, align 8, !tbaa !4  to:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
EarlyCSE CSE:   %vbase.offset.ptr.i49 = getelementptr i8, i8* %vtable.i31, i64 -24  to:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
EarlyCSE CSE:   %8 = bitcast i8* %vbase.offset.ptr.i32 to i64*  to:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
EarlyCSE CSE:   %8 = bitcast %"class.std::basic_ostream"* %call5 to i8*  to:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
EarlyCSE CVP: Add conditional value for 'tobool.not.i63' as i1 true in if.then.i64
EarlyCSE CVP: Add conditional value for 'tobool.not.i63' as i1 false in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
EarlyCSE CVP: Add conditional value for 'tobool.not.i' as i1 true in if.end.i
EarlyCSE CVP: Add conditional value for 'tobool.not.i' as i1 false in if.then.i
EarlyCSE CVP: Add conditional value for 'cmp' as i1 false in for.cond.cleanup
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function 'main'
LVI Getting value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at ''
  Result = overdefined
LVI Getting edge value i32 2 from 'entry' to 'for.cond'
  Result = constantrange<2, 3>
LVI Getting edge value   %mul = shl nsw i32 %n.0, 1 from '_ZNKSt5ctypeIcE5widenEc.exit' to 'for.cond'
PUSH:   %mul = shl nsw i32 %n.0, 1 in _ZNKSt5ctypeIcE5widenEc.exit
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZNKSt5ctypeIcE5widenEc.exit
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in if.then.i
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _Z7simpsonPFddEddi.exit
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.cond
 compute BB 'for.cond' - overdefined because of pred (local).
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.cond = overdefined
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body = constantrange<0, 65537>
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.end.loopexit.i
PUSH:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body.i
 compute BB 'for.body.i' - overdefined because of pred (non local).
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body.i = overdefined
 compute BB 'for.end.loopexit.i' - overdefined because of pred (non local).
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.end.loopexit.i = overdefined
 compute BB '_Z7simpsonPFddEddi.exit' - overdefined because of pred (non local).
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _Z7simpsonPFddEddi.exit = overdefined
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit' - overdefined because of pred (non local).
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = overdefined
 compute BB 'if.then.i' - overdefined because of pred (non local).
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in if.then.i = overdefined
 compute BB '_ZNKSt5ctypeIcE5widenEc.exit' - overdefined because of pred (non local).
POP   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZNKSt5ctypeIcE5widenEc.exit = overdefined
POP   %mul = shl nsw i32 %n.0, 1 in _ZNKSt5ctypeIcE5widenEc.exit = overdefined
  Result = overdefined
LVI Getting value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at ''
  Result = overdefined
LVI Getting edge value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] from 'for.cond' to 'for.body'
  Result = constantrange<0, 65537>
LVI Getting edge value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] from 'for.cond' to 'for.body'
  Result = constantrange<0, 65537>
LVI Getting value   %13 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !19 at ''
  Result = overdefined
LVI Getting block end value   %13 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !19 at '_Z7simpsonPFddEddi.exit'
PUSH:   %13 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !19 in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %13 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !19 in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting value   %14 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 at ''
  Result = overdefined
LVI Getting block end value   %14 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %14 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit' - unknown inst def found.
POP   %14 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = overdefined
  Result = overdefined
LVI Getting edge value   %mul = shl nsw i32 %n.0, 1 from '_ZNKSt5ctypeIcE5widenEc.exit' to 'for.cond'
  Result = overdefined
LVI Getting block end value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at 'for.cond'
  Result = overdefined
LVI Getting edge value i32 2 from 'entry' to 'for.cond'
  Result = constantrange<2, 3>
LVI Getting edge value   %mul = shl nsw i32 %n.0, 1 from '_ZNKSt5ctypeIcE5widenEc.exit' to 'for.cond'
  Result = overdefined
LVI Getting block end value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at 'for.body'
  Result = constantrange<0, 65537>
LVI Getting block end value i32 1 at 'for.body'
  Result = constantrange<1, 2>
LVI Getting value   %add.i = add nuw nsw i32 %n.0, 1 at 'div.i'
  Result = overdefined
LVI Getting value   %add.i = add nuw nsw i32 %n.0, 1 at 'div.i'
  Result = overdefined
LVI Getting block end value   %add.i = add nuw nsw i32 %n.0, 1 at 'for.body'
PUSH:   %add.i = add nuw nsw i32 %n.0, 1 in for.body
POP   %add.i = add nuw nsw i32 %n.0, 1 in for.body = constantrange<1, 65538>
  Result = constantrange<1, 65538>
LVI Getting block end value i32 2 at 'for.body'
  Result = constantrange<2, 3>
LVI Getting block end value   %div.i = sdiv i32 %add.i, 2 at 'for.body'
PUSH:   %div.i = sdiv i32 %add.i, 2 in for.body
POP   %div.i = sdiv i32 %add.i, 2 in for.body = constantrange<0, 32769>
  Result = constantrange<0, 32769>
LVI Getting block end value i32 1 at 'for.body'
  Result = constantrange<1, 2>
LVI Getting block end value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at 'for.body'
  Result = constantrange<0, 65537>
LVI Getting edge value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] from 'for.cond' to 'for.body'
  Result = constantrange<0, 65537>
LVI Getting edge value   %add14.i = add nuw nsw i32 %odd.052.i, 2 from 'for.body.i' to 'for.body.i'
PUSH:   %add14.i = add nuw nsw i32 %odd.052.i, 2 in for.body.i
PUSH:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ] in for.body.i
 compute BB 'for.body.i' - overdefined because of pred (local).
POP   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ] in for.body.i = overdefined
POP   %add14.i = add nuw nsw i32 %odd.052.i, 2 in for.body.i = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting edge value   %add13.i = add nuw nsw i32 %even.051.i, 2 from 'for.body.i' to 'for.body.i'
PUSH:   %add13.i = add nuw nsw i32 %even.051.i, 2 in for.body.i
PUSH:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ] in for.body.i
POP   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ] in for.body.i = constantrange<-2147483648, 2147483647>
POP   %add13.i = add nuw nsw i32 %even.051.i, 2 in for.body.i = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting edge value   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 from 'for.body.i' to 'for.body.i'
PUSH:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.body.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15 from 'for.body' to 'for.body.i'
PUSH:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15 in for.body = overdefined
  Result = overdefined
LVI Getting edge value   %add7.i = fadd double %sum_even.049.i, %call.i.i46 from 'for.body.i' to 'for.body.i'
PUSH:   %add7.i = fadd double %sum_even.049.i, %call.i.i46 in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %add7.i = fadd double %sum_even.049.i, %call.i.i46 in for.body.i = overdefined
  Result = overdefined
LVI Getting edge value   %phi.bo.i = fmul double %add7.i, 2.000000e+00 from 'for.end.loopexit.i' to '_Z7simpsonPFddEddi.exit'
PUSH:   %phi.bo.i = fmul double %add7.i, 2.000000e+00 in for.end.loopexit.i
 compute BB 'for.end.loopexit.i' - unknown inst def found.
POP   %phi.bo.i = fmul double %add7.i, 2.000000e+00 in for.end.loopexit.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15 from 'for.body' to '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting edge value   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 from 'for.end.loopexit.i' to '_Z7simpsonPFddEddi.exit'
PUSH:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.end.loopexit.i
 compute BB 'for.end.loopexit.i' - overdefined because of pred (non local).
POP   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.end.loopexit.i = overdefined
  Result = overdefined
LVI Getting block end value   %0 = bitcast i8* %vbase.offset.ptr.i to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %0 = bitcast i8* %vbase.offset.ptr.i to i64* in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %0 = bitcast i8* %vbase.offset.ptr.i to i64* in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting block end value   %1 = bitcast i8* %_M_width.i.i to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %1 = bitcast i8* %_M_width.i.i to i64* in _Z7simpsonPFddEddi.exit
POP   %1 = bitcast i8* %_M_width.i.i to i64* in _Z7simpsonPFddEddi.exit = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8** at '_Z7simpsonPFddEddi.exit'
PUSH:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8** in _Z7simpsonPFddEddi.exit
POP   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8** in _Z7simpsonPFddEddi.exit = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting block end value   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3 at '_Z7simpsonPFddEddi.exit'
PUSH:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3 in _Z7simpsonPFddEddi.exit
POP   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3 in _Z7simpsonPFddEddi.exit = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3 at '_Z7simpsonPFddEddi.exit'
  Result = notconstant<i32* null>
LVI Getting block end value   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* at '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting block end value   %7 = bitcast i8* %_M_precision.i.i to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %7 = bitcast i8* %_M_precision.i.i to i64* in _Z7simpsonPFddEddi.exit
POP   %7 = bitcast i8* %_M_precision.i.i to i64* in _Z7simpsonPFddEddi.exit = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* at '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting block end value   %8 = bitcast i8* %_M_width.i.i52 to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %8 = bitcast i8* %_M_width.i.i52 to i64* in _Z7simpsonPFddEddi.exit
POP   %8 = bitcast i8* %_M_width.i.i52 to i64* in _Z7simpsonPFddEddi.exit = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %9 = bitcast %"class.std::basic_ostream"* %call.i59 to i8** at '_Z7simpsonPFddEddi.exit'
PUSH:   %9 = bitcast %"class.std::basic_ostream"* %call.i59 to i8** in _Z7simpsonPFddEddi.exit
POP   %9 = bitcast %"class.std::basic_ostream"* %call.i59 to i8** in _Z7simpsonPFddEddi.exit = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %10 = bitcast i8* %vbase.offset.ptr.i54 to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %10 = bitcast i8* %vbase.offset.ptr.i54 to i64* in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %10 = bitcast i8* %vbase.offset.ptr.i54 to i64* in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting block end value   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %12, i64 0, i32 5 at '_Z7simpsonPFddEddi.exit'
PUSH:   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %12, i64 0, i32 5 in _Z7simpsonPFddEddi.exit
POP   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %12, i64 0, i32 5 in _Z7simpsonPFddEddi.exit = notconstant<%"class.std::ctype"** null>
  Result = notconstant<%"class.std::ctype"** null>
LVI Getting block end value   %13 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !19 at '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting block end value   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
POP   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %14 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
  Result = overdefined
LVI Getting block end value   %16 = bitcast %"class.std::ctype"* %13 to i8 (%"class.std::ctype"*, i8)*** at 'if.end.i'
PUSH:   %16 = bitcast %"class.std::ctype"* %13 to i8 (%"class.std::ctype"*, i8)*** in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %16 = bitcast %"class.std::ctype"* %13 to i8 (%"class.std::ctype"*, i8)*** in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6 at 'if.end.i'
PUSH:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6 in if.end.i
POP   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6 in if.end.i = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %15 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 from 'if.then.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %15 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 in if.then.i
 compute BB 'if.then.i' - unknown inst def found.
POP   %15 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 in if.then.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i62 = call signext i8 %17(%"class.std::ctype"* nonnull dereferenceable(570) %13, i8 signext 10) from 'if.end.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %call.i62 = call signext i8 %17(%"class.std::ctype"* nonnull dereferenceable(570) %13, i8 signext 10) in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %call.i62 = call signext i8 %17(%"class.std::ctype"* nonnull dereferenceable(570) %13, i8 signext 10) in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at '_ZNKSt5ctypeIcE5widenEc.exit'
  Result = overdefined
LVI Getting block end value i32 1 at '_ZNKSt5ctypeIcE5widenEc.exit'
  Result = constantrange<1, 2>
LVI Getting block end value   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 9, i64 10 at 'if.then.i'
PUSH:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 9, i64 10 in if.then.i
POP   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 9, i64 10 in if.then.i = notconstant<i8* null>
  Result = notconstant<i8* null>


INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = call signext i8 %17(%"class.std::ctype"* nonnull dereferenceable(570) %13, i8 signext 10)
IC: ADD:   %17 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %16, align 8, !tbaa !4
IC: ADD:   %16 = bitcast %"class.std::ctype"* %13 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %13)
IC: ADD:   br label %for.cond, !llvm.loop !25
IC: ADD:   %mul = shl nsw i32 %n.0, 1
IC: ADD:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %15, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %15 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %14, 0
IC: ADD:   %14 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %13, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %13, null
IC: ADD:   %13 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !19
IC: ADD:   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %12, i64 0, i32 5
IC: ADD:   %12 = bitcast i8* %add.ptr.i56 to %"class.std::basic_ios"*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds i8, i8* %11, i64 %vbase.offset.i55
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8*
IC: ADD:   %vbase.offset.i55 = load i64, i64* %10, align 8
IC: ADD:   %10 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %9, align 8, !tbaa !4
IC: ADD:   %9 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %8, align 8, !tbaa !7
IC: ADD:   %8 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %add.ptr.i51, i64 16
IC: ADD:   %add.ptr.i51 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i50
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %7, align 8, !tbaa !18
IC: ADD:   %7 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %add.ptr.i45, i64 8
IC: ADD:   %add.ptr.i45 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i44
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %_M_flags.i, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %_M_flags.i, align 4, !tbaa !17
IC: ADD:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3
IC: ADD:   %5 = bitcast i8* %add.ptr.i34 to %"class.std::ios_base"*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 %call.i.i29)
IC: ADD:   %call.i.i29 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0)) #15
IC: ADD:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* %add.ptr.i, i64 16
IC: ADD:   %add.ptr.i = getelementptr inbounds i8, i8* bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 %call.i.i27)
IC: ADD:   %call.i.i27 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0)) #15
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %mul20.i, %add19.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.0, 2
IC: ADD:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = add nuw nsw i32 %n.0, 1
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: ADD:   %cmp = icmp ult i32 %n.0, 65537
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.cond
IC: Visiting:   br label %for.cond
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %cmp = icmp ult i32 %n.0, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: Visiting:   ret i32 0
IC: Visiting:   %add.i = add nuw nsw i32 %n.0, 1
IC: Old =   %add.i = add nuw nsw i32 %n.0, 1
    New =   <badref> = or i32 %n.0, 1
IC: ADD:   %add.i = or i32 %n.0, 1
IC: ERASE   %0 = add nuw nsw i32 %n.0, 1
IC: ADD DEFERRED:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.0, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.0, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %mul20.i, %add19.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call.i.i27 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0)) #15
IC: Replacing   %call.i.i27 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0)) #15
    with i64 2
IC: ERASE   %call.i.i27 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0)) #15
IC: Visiting:   %call1.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %add.ptr.i = getelementptr inbounds i8, i8* bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8*), i64 %vbase.offset.i
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* %add.ptr.i, i64 16
IC: Mod =   %_M_width.i.i = getelementptr inbounds i8, i8* %add.ptr.i, i64 16
    New =   %_M_width.i.i = getelementptr inbounds i8, i8* %add.ptr.i, i64 %vbase.offset.i
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* %add.ptr.i, i64 %vbase.offset.i
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* %add.ptr.i, i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: Visiting:   %call.i.i29 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0)) #15
IC: Replacing   %call.i.i29 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0)) #15
    with i64 4
IC: ERASE   %call.i.i29 = call i64 @strlen(i8* nonnull dereferenceable(1) getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0)) #15
IC: Visiting:   %call1.i30 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %add.ptr.i34 to %"class.std::ios_base"*
IC: Visiting:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3
IC: ADD DEFERRED:   %6 = getelementptr inbounds i8, i8* %add.ptr.i34, i64 24
IC: Old =   %6 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3
    New =   <badref> = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %6 = bitcast i8* %_M_flags.i to i32*
IC: ERASE   %7 = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %5, i64 0, i32 3
IC: ADD DEFERRED:   %5 = bitcast i8* %add.ptr.i34 to %"class.std::ios_base"*
IC: ERASE   %5 = bitcast i8* %add.ptr.i34 to %"class.std::ios_base"*
IC: ADD DEFERRED:   %add.ptr.i34 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %add.ptr.i34 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %add.ptr.i34, i64 24
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %add.ptr.i34, i64 24
IC: Mod =   %_M_flags.i = getelementptr inbounds i8, i8* %add.ptr.i34, i64 24
    New =   %_M_flags.i = getelementptr inbounds i8, i8* %add.ptr.i34, i64 %vbase.offset.i33
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %add.ptr.i34, i64 %vbase.offset.i33
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %add.ptr.i34, i64 %vbase.offset.i33
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds i8, i8* %4, i64 24
IC: ADD DEFERRED:   %5 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Old =   %5 = getelementptr inbounds i8, i8* %4, i64 24
    New =   <badref> = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %5, i64 %vbase.offset.i33
IC: ADD:   %5 = bitcast i64* %add.ptr.i34 to i8*
IC: ERASE   %6 = getelementptr inbounds i8, i8* %4, i64 24
IC: ADD DEFERRED:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ADD:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: Visiting:   %5 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %5, i64 %vbase.offset.i33
IC: Visiting:   %6 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %7 = load i32, i32* %6, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %7, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %6, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i44
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %add.ptr.i45, i64 8
IC: Mod =   %_M_precision.i.i = getelementptr inbounds i8, i8* %add.ptr.i45, i64 8
    New =   %_M_precision.i.i = getelementptr inbounds i8, i8* %add.ptr.i45, i64 %vbase.offset.i44
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %add.ptr.i45, i64 %vbase.offset.i44
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %add.ptr.i45, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i50
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %add.ptr.i51, i64 16
IC: Mod =   %_M_width.i.i52 = getelementptr inbounds i8, i8* %add.ptr.i51, i64 16
    New =   %_M_width.i.i52 = getelementptr inbounds i8, i8* %add.ptr.i51, i64 %vbase.offset.i50
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %add.ptr.i51, i64 %vbase.offset.i50
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %add.ptr.i51, i64 %vbase.offset.i50
IC: Visiting:   %9 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %9, align 8, !tbaa !7
IC: Visiting:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %10 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %10, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %11 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %11, align 8
IC: Visiting:   %12 = bitcast %"class.std::basic_ostream"* %call.i59 to i8*
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds i8, i8* %12, i64 %vbase.offset.i55
IC: Visiting:   %13 = bitcast i8* %add.ptr.i56 to %"class.std::basic_ios"*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %13, i64 0, i32 5
IC: ADD DEFERRED:   %14 = getelementptr inbounds i8, i8* %add.ptr.i56, i64 240
IC: Old =   %14 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %13, i64 0, i32 5
    New =   <badref> = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ERASE   %15 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %13, i64 0, i32 5
IC: ADD DEFERRED:   %13 = bitcast i8* %add.ptr.i56 to %"class.std::basic_ios"*
IC: ERASE   %13 = bitcast i8* %add.ptr.i56 to %"class.std::basic_ios"*
IC: ADD DEFERRED:   %add.ptr.i56 = getelementptr inbounds i8, i8* %12, i64 %vbase.offset.i55
IC: ADD:   %add.ptr.i56 = getelementptr inbounds i8, i8* %12, i64 %vbase.offset.i55
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr.i56, i64 240
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr.i56, i64 240
IC: Mod =   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr.i56, i64 240
    New =   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr.i56, i64 %vbase.offset.i55
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr.i56, i64 %vbase.offset.i55
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr.i56, i64 %vbase.offset.i55
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds i8, i8* %12, i64 240
IC: ADD DEFERRED:   %13 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Old =   %13 = getelementptr inbounds i8, i8* %12, i64 240
    New =   <badref> = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ERASE   %14 = getelementptr inbounds i8, i8* %12, i64 240
IC: ADD DEFERRED:   %12 = bitcast %"class.std::basic_ostream"* %call.i59 to i8*
IC: ERASE   %12 = bitcast %"class.std::basic_ostream"* %call.i59 to i8*
IC: ADD DEFERRED:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %12 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %12, i64 %vbase.offset.i55
IC: Visiting:   %13 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %14 = load %"class.std::ctype"*, %"class.std::ctype"** %13, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %14, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %14, i64 0, i32 8
IC: Visiting:   %15 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %15, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %14, i64 0, i32 9, i64 10
IC: Visiting:   %16 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %16, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.0, 1
IC: Visiting:   br label %for.cond, !llvm.loop !25
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %14)
IC: Visiting:   %17 = bitcast %"class.std::ctype"* %14 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %17, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %18 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = call signext i8 %18(%"class.std::ctype"* nonnull dereferenceable(570) %14, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit


INSTCOMBINE ITERATION #2 on main
IC: ConstFold to: i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*) from:   %add.ptr.i = getelementptr inbounds i8, i8* bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8*), i64 16
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = call signext i8 %18(%"class.std::ctype"* nonnull dereferenceable(570) %14, i8 signext 10)
IC: ADD:   %18 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %17, align 8, !tbaa !4
IC: ADD:   %17 = bitcast %"class.std::ctype"* %14 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %14)
IC: ADD:   br label %for.cond, !llvm.loop !25
IC: ADD:   %mul = shl nsw i32 %n.0, 1
IC: ADD:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %16, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %16 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %14, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %15, 0
IC: ADD:   %15 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %14, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %14, null
IC: ADD:   %14 = load %"class.std::ctype"*, %"class.std::ctype"** %13, align 8, !tbaa !19
IC: ADD:   %13 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %12, i64 %vbase.offset.i55
IC: ADD:   %12 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %11, align 8
IC: ADD:   %11 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %10, align 8, !tbaa !4
IC: ADD:   %10 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %9, align 8, !tbaa !7
IC: ADD:   %9 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %add.ptr.i51, i64 %vbase.offset.i50
IC: ADD:   %add.ptr.i51 = getelementptr inbounds i8, i8* %4, i64 16
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %add.ptr.i45, i64 %vbase.offset.i44
IC: ADD:   %add.ptr.i45 = getelementptr inbounds i8, i8* %4, i64 8
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %6, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %7, -261
IC: ADD:   %7 = load i32, i32* %6, align 4, !tbaa !17
IC: ADD:   %6 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %5, i64 %vbase.offset.i33
IC: ADD:   %5 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %mul20.i, %add19.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.0, 2
IC: ADD:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.0, 1
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: ADD:   %cmp = icmp ult i32 %n.0, 65537
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.cond
IC: Visiting:   br label %for.cond
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %cmp = icmp ult i32 %n.0, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: Visiting:   ret i32 0
IC: Visiting:   %add.i = or i32 %n.0, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.0, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %mul20.i, %add19.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: Visiting:   %call1.i30 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %5 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %5, i64 %vbase.offset.i33
IC: Visiting:   %6 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %7 = load i32, i32* %6, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %7, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %6, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds i8, i8* %4, i64 8
IC: ADD DEFERRED:   %8 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Old =   %8 = getelementptr inbounds i8, i8* %4, i64 8
    New =   <badref> = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %8 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ERASE   %9 = getelementptr inbounds i8, i8* %4, i64 8
IC: ADD DEFERRED:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ADD:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: Visiting:   %8 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %8, i64 %vbase.offset.i44
IC: Visiting:   %9 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %9, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds i8, i8* %4, i64 16
IC: ADD DEFERRED:   %10 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Old =   %10 = getelementptr inbounds i8, i8* %4, i64 16
    New =   <badref> = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %10 = bitcast i64* %add.ptr.i51 to i8*
IC: ERASE   %11 = getelementptr inbounds i8, i8* %4, i64 16
IC: ADD DEFERRED:   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ERASE   %4 = bitcast %"class.std::basic_ostream"* %call5 to i8*
IC: ADD DEFERRED:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: ADD:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.0, 1
IC: Visiting:   br label %for.cond, !llvm.loop !25
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit


INSTCOMBINE ITERATION #3 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   br label %for.cond, !llvm.loop !25
IC: ADD:   %mul = shl nsw i32 %n.0, 1
IC: ADD:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %mul20.i, %add19.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.0, 2
IC: ADD:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.0, 1
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: ADD:   %cmp = icmp ult i32 %n.0, 65537
IC: ADD:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.cond
IC: Visiting:   br label %for.cond
IC: Visiting:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %cmp = icmp ult i32 %n.0, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup
IC: Visiting:   ret i32 0
IC: Visiting:   %add.i = or i32 %n.0, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.0, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %mul20.i, %add19.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
IC: Visiting:   %call1.i30 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.0, 1
IC: Visiting:   br label %for.cond, !llvm.loop !25
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %if.then.i
Found a new trivial root: %if.then.i64
Last visited node: %if.then.i64
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %for.cond
4: %entry
5: %_ZNKSt5ctypeIcE5widenEc.exit
6: %if.end.i
7: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
8: %_Z7simpsonPFddEddi.exit
9: %for.end.loopexit.i
10: %for.body.i
11: %for.body
12: %if.then.i
13: %if.then.i64
Found roots: %for.cond.cleanup %if.then.i64 
---- Branch Probability Info : main ----

BPI: SCC 2: if.then.i _ZNKSt5ctypeIcE5widenEc.exit if.end.i _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit _Z7simpsonPFddEddi.exit for.end.loopexit.i for.body.i for.body for.cond
Computing probabilities for if.then.i64
Computing probabilities for _ZNKSt5ctypeIcE5widenEc.exit
Computing probabilities for if.end.i
Computing probabilities for if.then.i
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for _Z7simpsonPFddEddi.exit
eraseBlock _Z7simpsonPFddEddi.exit
set edge _Z7simpsonPFddEddi.exit -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge _Z7simpsonPFddEddi.exit -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%
Computing probabilities for for.end.loopexit.i
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body.i -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body
Computing probabilities for for.cond.cleanup
Computing probabilities for for.cond
eraseBlock for.cond
set edge for.cond -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.cond -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.cond
 - 2: for.cond.cleanup
 - 3: for.body
 - 4: for.body.i
 - 5: for.end.loopexit.i
 - 6: _Z7simpsonPFddEddi.exit
 - 7: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - 8: if.then.i
 - 9: if.end.i
 - 10: _ZNKSt5ctypeIcE5widenEc.exit
 - 11: if.then.i64
loop-detection
 - loop = for.cond
 - loop = for.body.i
 - loop = for.cond: member = for.body
 - loop = for.cond: member = for.end.loopexit.i
 - loop = for.cond: member = _Z7simpsonPFddEddi.exit
 - loop = for.cond: member = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - loop = for.cond: member = if.then.i
 - loop = for.cond: member = if.end.i
 - loop = for.cond: member = _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit.i
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit.i
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-loop: for.cond*
 - node: for.cond
  => [ local  ] weight = 2080374784, succ = for.body
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign 07ffffffffffffff (f800000000000000) [exit] to for.cond.cleanup
  => assign f800000000000000 (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 1073741824, succ = for.body.i
  => [ local  ] weight = 1073741824, succ = _Z7simpsonPFddEddi.exit
  => mass:  f800000000000000
  => assign 7c00000000000000 (7c00000000000000) to for.body.i
  => assign 7c00000000000000 (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit.i
  => mass:  7c00000000000000
  => assign 7c00000000000000 (0000000000000000) to for.end.loopexit.i
 - node: for.end.loopexit.i
  => [ local  ] weight = 2147483648, succ = _Z7simpsonPFddEddi.exit
  => mass:  7c00000000000000
  => assign 7c00000000000000 (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: _Z7simpsonPFddEddi.exit
  => [  exit  ] weight = 2048, succ = if.then.i64
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => mass:  f800000000000000
  => assign f7fff08000000000 (00000f8000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => assign 00000f8000000000 (0000000000000000) [exit] to if.then.i64
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => [ local  ] weight = 805306368, succ = if.end.i
  => [ local  ] weight = 1342177280, succ = if.then.i
  => mass:  f7fff08000000000
  => assign 9afff65000000000 (5cfffa3000000000) to if.then.i
  => assign 5cfffa3000000000 (0000000000000000) to if.end.i
 - node: if.then.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  9afff65000000000
  => assign 9afff65000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: if.end.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  5cfffa3000000000
  => assign 5cfffa3000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: _ZNKSt5ctypeIcE5widenEc.exit
  => [backedge] weight = 2147483648
  => mass:  f7fff08000000000
  => assign f7fff08000000000 (0000000000000000) [back] to for.cond
compute-loop-scale: for.cond*
 - exit-mass = 08000f7fffffffff (ffffffffffffffff - f7fff08000000000)
 - scale = 31.99905398
packaging-loop: for.cond*
 - node: for.cond
 - node: for.body
 - node: for.body.i
 - node: for.end.loopexit.i
 - node: _Z7simpsonPFddEddi.exit
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - node: if.then.i
 - node: if.end.i
 - node: _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.cond
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.cond
 - node: for.cond
  => [ local  ] weight = 576460752303423487, succ = for.cond.cleanup
  => [ local  ] weight = 17042430230528, succ = if.then.i64
  => mass:  ffffffffffffffff
  => assign fffe1003ffffffff (0001effc00000000) to for.cond.cleanup
  => assign 0001effc00000000 (0000000000000000) to if.then.i64
 - node: for.cond.cleanup
  => mass:  fffe1003ffffffff
 - node: if.then.i64
  => mass:  0001effc00000000
unwrap-loop-package: for.cond*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - for.cond: 1.0 => 31.99905398
 - for.body: 0.96875 => 30.99908355
 - for.body.i: 32.0 => 1023.969727
 - for.end.loopexit.i: 0.484375 => 15.49954177
 - _Z7simpsonPFddEddi.exit: 0.96875 => 30.99908355
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: 0.9687490761 => 30.99905398
 - if.then.i: 0.6054681726 => 19.37440874
 - if.end.i: 0.3632809035 => 11.62464524
 - _ZNKSt5ctypeIcE5widenEc.exit: 0.9687490761 => 30.99905398
unwrap-loop-package: for.body.i*: mass = 7c00000000000000, scale = 1023.969727
  => combined-scale = 495.9853367
 - for.body.i: 1.0 => 495.9853367
float-to-int: min = 0.00002956297249, max = 495.9853367, factor = 270608.7828
 - entry: float = 1.0, scaled = 270608.7828, int = 270608
 - for.cond: float = 31.99905398, scaled = 8659225.049, int = 8659225
 - for.cond.cleanup: float = 0.999970437, scaled = 270600.7828, int = 270600
 - for.body: float = 30.99908355, scaled = 8388624.266, int = 8388624
 - for.body.i: float = 495.9853367, scaled = 134217988.3, int = 134217988
 - for.end.loopexit.i: float = 15.49954177, scaled = 4194312.133, int = 4194312
 - _Z7simpsonPFddEddi.exit: float = 30.99908355, scaled = 8388624.266, int = 8388624
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 30.99905398, scaled = 8388616.266, int = 8388616
 - if.then.i: float = 19.37440874, scaled = 5242885.166, int = 5242885
 - if.end.i: float = 11.62464524, scaled = 3145731.1, int = 3145731
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 30.99905398, scaled = 8388616.266, int = 8388616
 - if.then.i64: float = 0.00002956297249, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 270608
 - for.cond: float = 31.999, int = 8659225
 - for.cond.cleanup: float = 0.99997, int = 270600
 - for.body: float = 30.999, int = 8388624
 - for.body.i: float = 495.99, int = 134217988
 - for.end.loopexit.i: float = 15.5, int = 4194312
 - _Z7simpsonPFddEddi.exit: float = 30.999, int = 8388624
 - if.then.i64: float = 0.000029563, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 30.999, int = 8388616
 - if.then.i: float = 19.374, int = 5242885
 - if.end.i: float = 11.625, int = 3145731
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 30.999, int = 8388616

Marked as tail call candidate:   %call.i.i47 = call double @pow(double %add2.i, double 4.000000e+00) #15
Marked as tail call candidate:   %call1.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
Marked as tail call candidate:   %call5 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.0)
Marked as tail call candidate:   %call1.i30 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
Marked as tail call candidate:   %call.i59 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
Marked as tail call candidate:   %call1.i58 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
Marked as tail call candidate:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
Marked as tail call candidate:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
Marked as tail call candidate:   %call.i62 = call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
Marked as tail call candidate:   call void @_ZSt16__throw_bad_castv() #16
Marked as tail call candidate:   %call.i.i46 = call double @pow(double %add5.i, double 4.000000e+00) #15
Marked as tail call candidate:   %call.i.i41 = call double @pow(double %add10.i, double 4.000000e+00) #15
Combine negations for:   %add.i = or i32 %n.0, 1
LINEARIZE:   %add.i = or i32 %n.0, 1
OPERAND:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] (1)
ADD USES LEAF:   %n.0 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] (1)
OPERAND: i32 1 (1)
ADD USES LEAF: i32 1 (1)
RAIn:	or i32	[ %n.0, #262145] [ 1, #0] 
RAOut:	or i32	[ %n.0, #262145] [ 1, #0] 
Combine negations for:   %div.i = sdiv i32 %add.i, 2
Combine negations for:   %mul.i = shl nuw nsw i32 %div.i, 1
Combine negations for:   %div1.i = fdiv double 1.000000e+00, %conv.i
Combine negations for:   %add2.i = fadd double %div1.i, 0.000000e+00
Calculated Rank[conv3.i] = 458755
Calculated Rank[add.i] = 262146
Calculated Rank[div.i] = 262147
Calculated Rank[mul.i] = 262148
Calculated Rank[conv.i] = 262149
Calculated Rank[div1.i] = 262150
Combine negations for:   %mul4.i = fmul double %div1.i, %conv3.i
Combine negations for:   %add5.i = fadd double %mul4.i, 0.000000e+00
Combine negations for:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
Calculated Rank[conv8.i] = 458754
Combine negations for:   %mul9.i = fmul double %div1.i, %conv8.i
Combine negations for:   %add10.i = fadd double %mul9.i, 0.000000e+00
Combine negations for:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
Combine negations for:   %add13.i = add nuw nsw i32 %even.051.i, 2
LINEARIZE:   %add13.i = add nuw nsw i32 %even.051.i, 2
OPERAND:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ] (1)
ADD USES LEAF:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ] (1)
OPERAND: i32 2 (1)
ADD USES LEAF: i32 2 (1)
RAIn:	add i32	[ %even.051.i, #458754] [ 2, #0] 
RAOut:	add i32	[ %even.051.i, #458754] [ 2, #0] 
Combine negations for:   %add14.i = add nuw nsw i32 %odd.052.i, 2
LINEARIZE:   %add14.i = add nuw nsw i32 %odd.052.i, 2
OPERAND:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ] (1)
ADD USES LEAF:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ] (1)
OPERAND: i32 2 (1)
ADD USES LEAF: i32 2 (1)
RAIn:	add i32	[ %odd.052.i, #458753] [ 2, #0] 
RAOut:	add i32	[ %odd.052.i, #458753] [ 2, #0] 
Combine negations for:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
Combine negations for:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
Combine negations for:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
Calculated Rank[add19.i] = 589826
Calculated Rank[mul20.i] = 589827
Combine negations for:   %add21.i = fadd double %add19.i, %mul20.i
Calculated Rank[add21.i] = 589828
Combine negations for:   %mul22.i = fmul double %div1.i, %add21.i
Combine negations for:   %div23.i = fdiv double %mul22.i, 3.000000e+00
Combine negations for:   %and.i = and i32 %6, -261
LINEARIZE:   %and.i = and i32 %6, -261
OPERAND:   %6 = load i32, i32* %5, align 4, !tbaa !17 (1)
ADD LEAF:   %6 = load i32, i32* %5, align 4, !tbaa !17 (1)
OPERAND: i32 -261 (1)
ADD LEAF: i32 -261 (1)
RAIn:	and i32	[ %6, #589835] [ -261, #0] 
RAOut:	and i32	[ %6, #589835] [ -261, #0] 
Combine negations for:   %or.i = or i32 %and.i, 4
LINEARIZE:   %or.i = or i32 %and.i, 4
OPERAND:   %and.i = and i32 %6, -261 (1)
ADD LEAF:   %and.i = and i32 %6, -261 (1)
OPERAND: i32 4 (1)
ADD USES LEAF: i32 4 (1)
Calculated Rank[and.i] = 589836
RAIn:	or i32	[ %and.i, #589836] [ 4, #0] 
RAOut:	or i32	[ %and.i, #589836] [ 4, #0] 
Combine negations for:   %mul = shl nsw i32 %n.0, 1
LoopSimplify: Creating pre-header for.body.i.preheader
LoopRotation: rotating Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.body.i,%for.end.loopexit.i,%_Z7simpsonPFddEddi.exit<exiting>,%_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit,%if.then.i,%if.end.i,%_ZNKSt5ctypeIcE5widenEc.exit<latch>,%for.body.i.preheader
    Loop at depth 2 containing: %for.body.i<header><latch><exiting>
  Inserted PHI:   %n.066 = phi i32 [ 2, %entry ], [ %n.0, %for.cond ]
Inserting edge %entry -> %for.cond.cleanup
	Reachable %entry -> %for.cond.cleanup
		NCA == %entry
Mark %for.cond.cleanupas affected, CurrentLevel 2
Updating NCD = %entry
	IDom(%for.cond.cleanup) = %entry
Inserting edge %entry -> %for.body
	Reachable %entry -> %for.body
		NCA == %entry
Mark %for.bodyas affected, CurrentLevel 2
	Successor %_Z7simpsonPFddEddi.exit, level = 3
		Marking visited not affected %_Z7simpsonPFddEddi.exit
	Successor %for.body.i.preheader, level = 3
		Marking visited not affected %for.body.i.preheader
 Next: %for.body.i.preheader
	Successor %for.body.i, level = 4
		Marking visited not affected %for.body.i
 Next: %for.body.i
	Successor %for.end.loopexit.i, level = 5
		Marking visited not affected %for.end.loopexit.i
	Successor %for.body.i, level = 4
 Next: %for.end.loopexit.i
	Successor %_Z7simpsonPFddEddi.exit, level = 3
 Next: %_Z7simpsonPFddEddi.exit
	Successor %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit, level = 4
		Marking visited not affected %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
	Successor %if.then.i64, level = 4
		Marking visited not affected %if.then.i64
 Next: %if.then.i64
 Next: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
	Successor %if.then.i, level = 5
		Marking visited not affected %if.then.i
	Successor %if.end.i, level = 5
		Marking visited not affected %if.end.i
 Next: %if.end.i
	Successor %_ZNKSt5ctypeIcE5widenEc.exit, level = 5
		Marking visited not affected %_ZNKSt5ctypeIcE5widenEc.exit
 Next: %_ZNKSt5ctypeIcE5widenEc.exit
	Successor %for.cond, level = 1
 Next: %if.then.i
	Successor %_ZNKSt5ctypeIcE5widenEc.exit, level = 5
Updating NCD = %entry
	IDom(%for.body) = %entry
Deleting edge %entry -> %for.cond
	NCD %entry, ToIDom %entry
IsReachableFromIDom %for.cond
	Pred %_ZNKSt5ctypeIcE5widenEc.exit
	Support %entry
	%for.cond is reachable from support %entry
Deleting reachable %entry -> %for.cond
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
Deleting edge %entry -> %for.cond.cleanup
	NCD %entry, ToIDom %entry
IsReachableFromIDom %for.cond.cleanup
	Pred %for.cond
	Support %entry
	%for.cond.cleanup is reachable from support %entry
Deleting reachable %entry -> %for.cond.cleanup
	Rebuilding subtree
The entire tree needs to be rebuilt
Merging: for.cond into _ZNKSt5ctypeIcE5widenEc.exit
Inserting edge %_ZNKSt5ctypeIcE5widenEc.exit -> %for.body
	Reachable %_ZNKSt5ctypeIcE5widenEc.exit -> %for.body
		NCA == %for.body
Inserting edge %_ZNKSt5ctypeIcE5widenEc.exit -> %for.cond.cleanup
	Reachable %_ZNKSt5ctypeIcE5widenEc.exit -> %for.cond.cleanup
		NCA == %_ZNKSt5ctypeIcE5widenEc.exit
Mark %for.cond.cleanupas affected, CurrentLevel 6
Updating NCD = %_ZNKSt5ctypeIcE5widenEc.exit
	IDom(%for.cond.cleanup) = %_ZNKSt5ctypeIcE5widenEc.exit
Deleting edge %for.cond -> %for.body
Deleting edge %for.cond -> %for.cond.cleanup
	NCD %_ZNKSt5ctypeIcE5widenEc.exit, ToIDom %_ZNKSt5ctypeIcE5widenEc.exit
Deleting reachable %for.cond -> %for.cond.cleanup
	Rebuilding subtree
	Top of subtree: %_ZNKSt5ctypeIcE5widenEc.exit
	Running Semi-NCA
Deleting edge %_ZNKSt5ctypeIcE5widenEc.exit -> %for.cond
	NCD %_ZNKSt5ctypeIcE5widenEc.exit, ToIDom %_ZNKSt5ctypeIcE5widenEc.exit
IsReachableFromIDom %for.cond
Deleting unreachable subtree %for.cond
Erasing node %for.cond
LoopRotation: into Loop at depth 1 containing: %for.body<header>,%for.body.i,%for.end.loopexit.i,%_Z7simpsonPFddEddi.exit<exiting>,%_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit,%if.then.i,%if.end.i,%_ZNKSt5ctypeIcE5widenEc.exit<latch><exiting>,%for.body.i.preheader
    Loop at depth 2 containing: %for.body.i<header><latch><exiting>
Perform LICM on Loop with header at block for.body.i
LICM: Using MemorySSA.
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.
LICM sinking instruction:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
LICM sinking instruction:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
LICM sinking instruction:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
LICM sinking instruction:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
LICM sinking instruction:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
LICM sinking instruction:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
LICM sinking instruction:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
LICM sinking instruction:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
LICM sinking instruction:   %10 = bitcast i8* %_M_width.i.i52 to i64*
LICM sinking instruction:   %9 = bitcast i64* %add.ptr.i51 to i8*
LICM sinking instruction:   %8 = bitcast i8* %_M_precision.i.i to i64*
LICM sinking instruction:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
LICM sinking instruction:   %5 = bitcast i8* %_M_flags.i to i32*
LICM sinking instruction:   %4 = bitcast i64* %add.ptr.i34 to i8*
LICM sinking instruction:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
LICM sinking instruction:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
LICM sinking instruction:   %1 = bitcast i8* %_M_width.i.i to i64*
LICM sinking instruction:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
Looking to fold for.body.i.preheader into for.body.i
Killing Trivial BB: 

for.body.i.preheader:                             ; preds = %for.body
  br label %for.body.i


INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i.lcssa, 2.000000e+00
IC: ADD:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: Replacing   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    with   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Mod =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    New =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ERASE   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD DEFERRED:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Replacing   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    with   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Mod =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    New =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ERASE   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD DEFERRED:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit


INSTCOMBINE ITERATION #2 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit
LoopSimplify: Creating pre-header for.body.i.preheader
loop-idiom Scanning: F[main] Countable Loop %for.body.i
Analyzing Loop for deletion: Loop at depth 2 containing: %for.body.i<header><latch><exiting>
Loop is not invariant, cannot delete.
Loop Unroll: F[main] Loop %for.body.i
  Loop Size = 14
  will not try to unroll loop with runtime trip count -unroll-runtime not given
loop-idiom Scanning: F[main] Noncountable Loop %for.body
loop-idiom Performing shift-until-bittest idiom detection.
loop-idiom Bad block/backedge count.
loop-idiom shift-until-bittest idiom detection failed.
Analyzing Loop for deletion: Loop at depth 1 containing: %for.body<header>,%for.body.i,%for.end.loopexit.i,%_Z7simpsonPFddEddi.exit<exiting>,%_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit,%if.then.i,%if.end.i,%_ZNKSt5ctypeIcE5widenEc.exit<latch><exiting>,%for.body.i.preheader
    Loop at depth 2 containing: %for.body.i<header><latch><exiting>
Deletion requires at most one exit block.
Loop Unroll: F[main] Loop %for.body
  Loop Size = 93
  will not try to unroll partially because -unroll-allow-partial not given
SROA function: main
Instruction Merger
GVN iteration: 0
GVN removed:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
GVN removed:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
GVN: load i8* %vtable.i is clobbered by   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
GVN: load i64 %vbase.offset.i is clobbered by   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
GVN: load i8* %vtable.i31 is clobbered by   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
GVN: load i64 %vbase.offset.i33 is clobbered by   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
GVN: load i32 %6 is clobbered by   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
GVN: load i64 %vbase.offset.i44 is clobbered by   store i32 %or.i, i32* %5, align 4, !tbaa !17
GVN: load i64 %vbase.offset.i50 is clobbered by   store i64 16, i64* %8, align 8, !tbaa !18
GVN: load i8* %vtable.i53 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i64 %vbase.offset.i55 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load %"class.std::ctype"* %15 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i8 %16 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i8 %17 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i8 (%"class.std::ctype"*, i8)** %vtable.i61 is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
GVN: load i8 (%"class.std::ctype"*, i8)* %19 is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
GVN iteration: 1
GVN: load i8* %vtable.i is clobbered by   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
GVN: load i64 %vbase.offset.i is clobbered by   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
GVN: load i8* %vtable.i31 is clobbered by   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
GVN: load i64 %vbase.offset.i33 is clobbered by   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
GVN: load i32 %6 is clobbered by   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
GVN: load i64 %vbase.offset.i44 is clobbered by   store i32 %or.i, i32* %5, align 4, !tbaa !17
GVN: load i64 %vbase.offset.i50 is clobbered by   store i64 16, i64* %8, align 8, !tbaa !18
GVN: load i8* %vtable.i53 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i64 %vbase.offset.i55 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load %"class.std::ctype"* %15 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i8 %16 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i8 %17 is clobbered by   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
GVN: load i8 (%"class.std::ctype"*, i8)** %vtable.i61 is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
GVN: load i8 (%"class.std::ctype"*, i8)* %19 is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
SCCP on function 'main'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  br label %for.body

Marking Block Executable: for.body

Popped off BBWL: 
for.body:                                         ; preds = %entry, %_ZNKSt5ctypeIcE5widenEc.exit
  %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
  %add.i = or i32 %n.066, 1
  %div.i = sdiv i32 %add.i, 2
  %mul.i = shl nuw nsw i32 %div.i, 1
  %conv.i = sitofp i32 %mul.i to double
  %div1.i = fdiv double 1.000000e+00, %conv.i
  %add2.i = fadd double %div1.i, 0.000000e+00
  %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
  %cmp48.i = icmp sgt i32 %n.066, 2
  br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit

Merged constantrange<2, 3> into   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] : constantrange<2, 3>
Merged constantrange<3, 4> into   %add.i = or i32 %n.066, 1 : constantrange<3, 4>
Merged constantrange<1, 2> into   %div.i = sdiv i32 %add.i, 2 : constantrange<1, 2>
Merged constantrange<2, 3> into   %mul.i = shl nuw nsw i32 %div.i, 1 : constantrange<2, 3>
markConstant: double 2.000000e+00:   %conv.i = sitofp i32 %mul.i to double
Merged constant<double 5.000000e-01> into   %div1.i = fdiv double 1.000000e+00, %conv.i : constant<double 5.000000e-01>
Merged constant<double 5.000000e-01> into   %add2.i = fadd double %div1.i, 0.000000e+00 : constant<double 5.000000e-01>
markConstant: double 6.250000e-02:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
Merged constantrange<0, -1> into   %cmp48.i = icmp sgt i32 %n.066, 2 : constantrange<0, -1>
Marking Block Executable: _Z7simpsonPFddEddi.exit

Popped off BBWL: 
_Z7simpsonPFddEddi.exit:                          ; preds = %for.body, %for.end.loopexit.i
  %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
  %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
  %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
  %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
  %add21.i = fadd double %add19.i, %mul20.i
  %mul22.i = fmul double %div1.i, %add21.i
  %div23.i = fdiv double %mul22.i, 3.000000e+00
  %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
  %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
  %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
  %0 = bitcast i8* %vbase.offset.ptr.i to i64*
  %vbase.offset.i = load i64, i64* %0, align 8
  %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
  %1 = bitcast i8* %_M_width.i.i to i64*
  store i64 6, i64* %1, align 8, !tbaa !7
  %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
  %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
  %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
  %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
  %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
  %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
  %vbase.offset.i33 = load i64, i64* %3, align 8
  %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
  %4 = bitcast i64* %add.ptr.i34 to i8*
  %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
  %5 = bitcast i8* %_M_flags.i to i32*
  %6 = load i32, i32* %5, align 4, !tbaa !17
  %and.i = and i32 %6, -261
  %or.i = or i32 %and.i, 4
  store i32 %or.i, i32* %5, align 4, !tbaa !17
  %vbase.offset.i44 = load i64, i64* %3, align 8
  %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
  %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
  %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
  %8 = bitcast i8* %_M_precision.i.i to i64*
  store i64 16, i64* %8, align 8, !tbaa !18
  %vbase.offset.i50 = load i64, i64* %3, align 8
  %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
  %9 = bitcast i64* %add.ptr.i51 to i8*
  %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
  %10 = bitcast i8* %_M_width.i.i52 to i64*
  store i64 20, i64* %10, align 8, !tbaa !7
  %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
  %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
  %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
  %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
  %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
  %vbase.offset.i55 = load i64, i64* %12, align 8
  %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
  %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
  %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
  %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
  %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
  %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
  br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit

Merged constant<double 0.000000e+00> into   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ] : constant<double 0.000000e+00>
Merged constant<double 6.250000e-02> into   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ] : constant<double 6.250000e-02>
Merged constant<double 1.000000e+00> into   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00 : constant<double 1.000000e+00>
Merged constant<double 2.500000e-01> into   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00 : constant<double 2.500000e-01>
Merged constant<double 1.250000e+00> into   %add21.i = fadd double %add19.i, %mul20.i : constant<double 1.250000e+00>
Merged constant<double 6.250000e-01> into   %mul22.i = fmul double %div1.i, %add21.i : constant<double 6.250000e-01>
Merged constant<double 0x3FCAAAAAAAAAAAAB> into   %div23.i = fdiv double %mul22.i, 3.000000e+00 : constant<double 0x3FCAAAAAAAAAAAAB>
Merged overdefined into   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2) : overdefined
Merged overdefined into   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4 : overdefined
markOverdefined:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
markOverdefined:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
Merged overdefined into   %vbase.offset.i = load i64, i64* %0, align 8 : overdefined
markOverdefined:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
markOverdefined:   %1 = bitcast i8* %_M_width.i.i to i64*
Merged overdefined into   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066) : overdefined
Merged overdefined into   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4) : overdefined
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
Merged overdefined into   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4 : overdefined
markOverdefined:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
markOverdefined:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
Merged overdefined into   %vbase.offset.i33 = load i64, i64* %3, align 8 : overdefined
markOverdefined:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
markOverdefined:   %4 = bitcast i64* %add.ptr.i34 to i8*
markOverdefined:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
markOverdefined:   %5 = bitcast i8* %_M_flags.i to i32*
Merged overdefined into   %6 = load i32, i32* %5, align 4, !tbaa !17 : overdefined
Merged constantrange<0, -260> into   %and.i = and i32 %6, -261 : constantrange<0, -260>
Merged constantrange<4, 0> into   %or.i = or i32 %and.i, 4 : constantrange<4, 0>
Merged overdefined into   %vbase.offset.i44 = load i64, i64* %3, align 8 : overdefined
markOverdefined:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
markOverdefined:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
markOverdefined:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
markOverdefined:   %8 = bitcast i8* %_M_precision.i.i to i64*
Merged overdefined into   %vbase.offset.i50 = load i64, i64* %3, align 8 : overdefined
markOverdefined:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
markOverdefined:   %9 = bitcast i64* %add.ptr.i51 to i8*
markOverdefined:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
markOverdefined:   %10 = bitcast i8* %_M_width.i.i52 to i64*
Merged overdefined into   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i) : overdefined
markOverdefined:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
Merged overdefined into   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4 : overdefined
markOverdefined:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
markOverdefined:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
Merged overdefined into   %vbase.offset.i55 = load i64, i64* %12, align 8 : overdefined
markOverdefined:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
markOverdefined:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
markOverdefined:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
markOverdefined:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
Merged overdefined into   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19 : overdefined
markOverdefined:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
Marking Block Executable: if.then.i64
Marking Block Executable: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit

Popped off BBWL: 
_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:    ; preds = %_Z7simpsonPFddEddi.exit
  %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
  %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
  %tobool.not.i = icmp eq i8 %16, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i

markOverdefined:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
Merged overdefined into   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 : overdefined
markOverdefined:   %tobool.not.i = icmp eq i8 %16, 0
Marking Block Executable: if.end.i
Marking Block Executable: if.then.i

Popped off BBWL: 
if.then.i:                                        ; preds = %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
  %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
  br label %_ZNKSt5ctypeIcE5widenEc.exit

markOverdefined:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
Merged overdefined into   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 : overdefined
Marking Block Executable: _ZNKSt5ctypeIcE5widenEc.exit

Popped off BBWL: 
_ZNKSt5ctypeIcE5widenEc.exit:                     ; preds = %if.then.i, %if.end.i
  %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
  %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
  %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
  %mul = shl nsw i32 %n.066, 1
  %cmp = icmp ult i32 %mul, 65537
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25

Merged overdefined into   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ] : overdefined
Merged overdefined into   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i) : overdefined
Merged overdefined into   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58) : overdefined
Merged constantrange<4, 5> into   %mul = shl nsw i32 %n.066, 1 : constantrange<4, 5>
Merged constantrange<-1, 0> into   %cmp = icmp ult i32 %mul, 65537 : constantrange<-1, 0>
Marking Edge Executable: _ZNKSt5ctypeIcE5widenEc.exit -> for.body
Merged constantrange<2, 5> into   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] : constantrange<2, 5>

Popped off BBWL: 
if.end.i:                                         ; preds = %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
  %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
  %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
  %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
  %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
  %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
  br label %_ZNKSt5ctypeIcE5widenEc.exit

markOverdefined:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
Merged overdefined into   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4 : overdefined
markOverdefined:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
Merged overdefined into   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8 : overdefined
Merged overdefined into   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10) : overdefined
Marking Edge Executable: if.end.i -> _ZNKSt5ctypeIcE5widenEc.exit

Popped off BBWL: 
if.then.i64:                                      ; preds = %_Z7simpsonPFddEddi.exit
  tail call void @_ZSt16__throw_bad_castv() #16
  unreachable


Popped off OI-WL:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)

Popped off OI-WL:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8

Popped off OI-WL:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6

Popped off OI-WL:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4

Popped off OI-WL:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***

Popped off OI-WL:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)

Popped off OI-WL:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)

Popped off OI-WL:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]

Popped off OI-WL:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24

Popped off OI-WL:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10

Popped off OI-WL:   %tobool.not.i = icmp eq i8 %16, 0

Popped off OI-WL:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22

Popped off OI-WL:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8

Popped off OI-WL:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null

Popped off OI-WL:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19

Popped off OI-WL:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**

Popped off OI-WL:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55

Popped off OI-WL:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*

Popped off OI-WL:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4

Popped off OI-WL:   %vbase.offset.i55 = load i64, i64* %12, align 8

Popped off OI-WL:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*

Popped off OI-WL:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24

Popped off OI-WL:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4

Popped off OI-WL:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**

Popped off OI-WL:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)

Popped off OI-WL:   %10 = bitcast i8* %_M_width.i.i52 to i64*

Popped off OI-WL:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50

Popped off OI-WL:   %9 = bitcast i64* %add.ptr.i51 to i8*

Popped off OI-WL:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1

Popped off OI-WL:   %vbase.offset.i50 = load i64, i64* %3, align 8

Popped off OI-WL:   %8 = bitcast i8* %_M_precision.i.i to i64*

Popped off OI-WL:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44

Popped off OI-WL:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*

Popped off OI-WL:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1

Popped off OI-WL:   %vbase.offset.i44 = load i64, i64* %3, align 8

Popped off OI-WL:   %6 = load i32, i32* %5, align 4, !tbaa !17

Popped off OI-WL:   %5 = bitcast i8* %_M_flags.i to i32*

Popped off OI-WL:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33

Popped off OI-WL:   %4 = bitcast i64* %add.ptr.i34 to i8*

Popped off OI-WL:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2

Popped off OI-WL:   %vbase.offset.i33 = load i64, i64* %3, align 8

Popped off OI-WL:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*

Popped off OI-WL:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24

Popped off OI-WL:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**

Popped off OI-WL:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)

Popped off OI-WL:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)

Popped off OI-WL:   %1 = bitcast i8* %_M_width.i.i to i64*

Popped off OI-WL:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i

Popped off OI-WL:   %vbase.offset.i = load i64, i64* %0, align 8

Popped off OI-WL:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*

Popped off OI-WL:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24

Popped off OI-WL:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4

Popped off OI-WL:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)

Popped off I-WL:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
Merged constantrange<4, 9> into   %mul = shl nsw i32 %n.066, 1 : constantrange<4, 9>
markOverdefined:   %cmp48.i = icmp sgt i32 %n.066, 2
Merged constantrange<2, 0> into   %add.i = or i32 %n.066, 1 : constantrange<2, 0>

Popped off I-WL:   %add.i = or i32 %n.066, 1
Merged constantrange<-1073741824, 1073741824> into   %div.i = sdiv i32 %add.i, 2 : constantrange<-1073741824, 1073741824>

Popped off I-WL:   %div.i = sdiv i32 %add.i, 2
Merged overdefined into   %mul.i = shl nuw nsw i32 %div.i, 1 : overdefined

Popped off I-WL:   %mul = shl nsw i32 %n.066, 1
Merged constantrange<2, 9> into   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] : constantrange<2, 9>

Popped off I-WL:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
Merged constantrange<4, 17> into   %mul = shl nsw i32 %n.066, 1 : constantrange<4, 17>

Popped off I-WL:   %mul = shl nsw i32 %n.066, 1
Merged constantrange<2, 17> into   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] : overdefined

Popped off I-WL:   %cmp = icmp ult i32 %mul, 65537

Popped off I-WL:   %mul = shl nsw i32 %n.066, 1

Popped off I-WL:   %or.i = or i32 %and.i, 4

Popped off I-WL:   %and.i = and i32 %6, -261

Popped off I-WL:   %div23.i = fdiv double %mul22.i, 3.000000e+00

Popped off I-WL:   %mul22.i = fmul double %div1.i, %add21.i

Popped off I-WL:   %add21.i = fadd double %add19.i, %mul20.i

Popped off I-WL:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00

Popped off I-WL:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00

Popped off I-WL:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]

Popped off I-WL:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]

Popped off I-WL:   %cmp48.i = icmp sgt i32 %n.066, 2

Popped off I-WL:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15

Popped off I-WL:   %add2.i = fadd double %div1.i, 0.000000e+00

Popped off I-WL:   %div1.i = fdiv double 1.000000e+00, %conv.i

Popped off I-WL:   %conv.i = sitofp i32 %mul.i to double

Popped off I-WL:   %mul.i = shl nuw nsw i32 %div.i, 1

Popped off I-WL:   %div.i = sdiv i32 %add.i, 2

Popped off I-WL:   %add.i = or i32 %n.066, 1

Popped off I-WL:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]

Popped off OI-WL:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
Merged overdefined into   %mul = shl nsw i32 %n.066, 1 : overdefined
Merged constantrange<1, 0> into   %add.i = or i32 %n.066, 1 : constantrange<1, 0>

Popped off OI-WL:   %mul = shl nsw i32 %n.066, 1
markOverdefined:   %cmp = icmp ult i32 %mul, 65537

Popped off OI-WL:   %cmp = icmp ult i32 %mul, 65537
Marking Block Executable: for.cond.cleanup

Popped off OI-WL:   %mul.i = shl nuw nsw i32 %div.i, 1
markOverdefined:   %conv.i = sitofp i32 %mul.i to double

Popped off OI-WL:   %conv.i = sitofp i32 %mul.i to double
markOverdefined:   %div1.i = fdiv double 1.000000e+00, %conv.i

Popped off OI-WL:   %div1.i = fdiv double 1.000000e+00, %conv.i
markOverdefined:   %mul22.i = fmul double %div1.i, %add21.i
markOverdefined:   %add2.i = fadd double %div1.i, 0.000000e+00

Popped off OI-WL:   %add2.i = fadd double %div1.i, 0.000000e+00
markOverdefined:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15

Popped off OI-WL:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
Merged overdefined into   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ] : overdefined

Popped off OI-WL:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
markOverdefined:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00

Popped off OI-WL:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
markOverdefined:   %add21.i = fadd double %add19.i, %mul20.i

Popped off OI-WL:   %add21.i = fadd double %add19.i, %mul20.i

Popped off OI-WL:   %mul22.i = fmul double %div1.i, %add21.i
markOverdefined:   %div23.i = fdiv double %mul22.i, 3.000000e+00

Popped off OI-WL:   %div23.i = fdiv double %mul22.i, 3.000000e+00

Popped off OI-WL:   %cmp48.i = icmp sgt i32 %n.066, 2
Marking Block Executable: for.body.i.preheader

Popped off I-WL:   %add.i = or i32 %n.066, 1

Popped off BBWL: 
for.body.i.preheader:                             ; preds = %for.body
  br label %for.body.i

Marking Block Executable: for.body.i

Popped off BBWL: 
for.body.i:                                       ; preds = %for.body.i.preheader, %for.body.i
  %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
  %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
  %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
  %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
  %conv3.i = sitofp i32 %even.051.i to double
  %mul4.i = fmul double %div1.i, %conv3.i
  %add5.i = fadd double %mul4.i, 0.000000e+00
  %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
  %add7.i = fadd double %sum_even.049.i, %call.i.i46
  %conv8.i = sitofp i32 %odd.052.i to double
  %mul9.i = fmul double %div1.i, %conv8.i
  %add10.i = fadd double %mul9.i, 0.000000e+00
  %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
  %add12.i = fadd double %sum_odd.050.i, %call.i.i41
  %add13.i = add nuw nsw i32 %even.051.i, 2
  %add14.i = add nuw nsw i32 %odd.052.i, 2
  %cmp.i = icmp slt i32 %add13.i, %mul.i
  br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2

Merged constantrange<3, 4> into   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ] : constantrange<3, 4>
Merged constantrange<2, 3> into   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ] : constantrange<2, 3>
Merged overdefined into   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ] : overdefined
Merged constant<double 0.000000e+00> into   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ] : constant<double 0.000000e+00>
markConstant: double 2.000000e+00:   %conv3.i = sitofp i32 %even.051.i to double
markOverdefined:   %mul4.i = fmul double %div1.i, %conv3.i
markOverdefined:   %add5.i = fadd double %mul4.i, 0.000000e+00
markOverdefined:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
markOverdefined:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
markConstant: double 3.000000e+00:   %conv8.i = sitofp i32 %odd.052.i to double
markOverdefined:   %mul9.i = fmul double %div1.i, %conv8.i
markOverdefined:   %add10.i = fadd double %mul9.i, 0.000000e+00
markOverdefined:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
markOverdefined:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
Merged constantrange<4, 5> into   %add13.i = add nuw nsw i32 %even.051.i, 2 : constantrange<4, 5>
Merged constantrange<5, 6> into   %add14.i = add nuw nsw i32 %odd.052.i, 2 : constantrange<5, 6>
markOverdefined:   %cmp.i = icmp slt i32 %add13.i, %mul.i
Marking Edge Executable: for.body.i -> for.body.i
Merged constantrange<3, 6> into   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ] : constantrange<3, 6>
Merged constantrange<2, 5> into   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ] : constantrange<2, 5>
Merged overdefined into   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ] : overdefined
Marking Block Executable: for.end.loopexit.i

Popped off BBWL: 
for.end.loopexit.i:                               ; preds = %for.body.i
  %phi.bo.i = fmul double %add7.i, 2.000000e+00
  br label %_Z7simpsonPFddEddi.exit

markOverdefined:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
Marking Edge Executable: for.end.loopexit.i -> _Z7simpsonPFddEddi.exit
Merged overdefined into   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ] : overdefined

Popped off BBWL: 
for.cond.cleanup:                                 ; preds = %_ZNKSt5ctypeIcE5widenEc.exit
  ret i32 0


Popped off OI-WL:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
markOverdefined:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00

Popped off OI-WL:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00

Popped off OI-WL:   %phi.bo.i = fmul double %add7.i, 2.000000e+00

Popped off OI-WL:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]

Popped off OI-WL:   %cmp.i = icmp slt i32 %add13.i, %mul.i

Popped off OI-WL:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41

Popped off OI-WL:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15

Popped off OI-WL:   %add10.i = fadd double %mul9.i, 0.000000e+00

Popped off OI-WL:   %mul9.i = fmul double %div1.i, %conv8.i

Popped off OI-WL:   %add7.i = fadd double %sum_even.049.i, %call.i.i46

Popped off OI-WL:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15

Popped off OI-WL:   %add5.i = fadd double %mul4.i, 0.000000e+00

Popped off OI-WL:   %mul4.i = fmul double %div1.i, %conv3.i

Popped off OI-WL:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]

Popped off I-WL:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
Merged constantrange<4, 7> into   %add13.i = add nuw nsw i32 %even.051.i, 2 : constantrange<4, 7>
markOverdefined:   %conv3.i = sitofp i32 %even.051.i to double

Popped off I-WL:   %add13.i = add nuw nsw i32 %even.051.i, 2
Merged constantrange<2, 7> into   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ] : constantrange<2, 7>

Popped off I-WL:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
Merged constantrange<4, 9> into   %add13.i = add nuw nsw i32 %even.051.i, 2 : constantrange<4, 9>

Popped off I-WL:   %add13.i = add nuw nsw i32 %even.051.i, 2
Merged constantrange<2, 9> into   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ] : overdefined

Popped off I-WL:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
Merged constantrange<5, 8> into   %add14.i = add nuw nsw i32 %odd.052.i, 2 : constantrange<5, 8>
markOverdefined:   %conv8.i = sitofp i32 %odd.052.i to double

Popped off I-WL:   %add14.i = add nuw nsw i32 %odd.052.i, 2
Merged constantrange<3, 8> into   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ] : constantrange<3, 8>

Popped off I-WL:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
Merged constantrange<5, 10> into   %add14.i = add nuw nsw i32 %odd.052.i, 2 : constantrange<5, 10>

Popped off I-WL:   %add14.i = add nuw nsw i32 %odd.052.i, 2
Merged constantrange<3, 10> into   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ] : overdefined

Popped off I-WL:   %add14.i = add nuw nsw i32 %odd.052.i, 2

Popped off I-WL:   %add13.i = add nuw nsw i32 %even.051.i, 2

Popped off I-WL:   %conv8.i = sitofp i32 %odd.052.i to double

Popped off I-WL:   %conv3.i = sitofp i32 %even.051.i to double

Popped off I-WL:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]

Popped off I-WL:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]

Popped off I-WL:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]

Popped off OI-WL:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
Merged overdefined into   %add14.i = add nuw nsw i32 %odd.052.i, 2 : overdefined

Popped off OI-WL:   %add14.i = add nuw nsw i32 %odd.052.i, 2

Popped off OI-WL:   %conv8.i = sitofp i32 %odd.052.i to double

Popped off OI-WL:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
Merged overdefined into   %add13.i = add nuw nsw i32 %even.051.i, 2 : overdefined

Popped off OI-WL:   %add13.i = add nuw nsw i32 %even.051.i, 2

Popped off OI-WL:   %conv3.i = sitofp i32 %even.051.i to double
RESOLVING UNDEFs
DemandedBits: Root:   br label %for.body
DemandedBits: Root:   ret i32 0
DemandedBits: Root:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
DemandedBits: Root:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
DemandedBits: Root:   br label %for.body.i
DemandedBits: Root:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
DemandedBits: Root:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
DemandedBits: Root:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
DemandedBits: Root:   br label %_Z7simpsonPFddEddi.exit
DemandedBits: Root:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
DemandedBits: Root:   store i64 6, i64* %1, align 8, !tbaa !7
DemandedBits: Root:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
DemandedBits: Root:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
DemandedBits: Root:   store i32 %or.i, i32* %5, align 4, !tbaa !17
DemandedBits: Root:   store i64 16, i64* %8, align 8, !tbaa !18
DemandedBits: Root:   store i64 20, i64* %10, align 8, !tbaa !7
DemandedBits: Root:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
DemandedBits: Root:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
DemandedBits: Root:   tail call void @_ZSt16__throw_bad_castv() #16
DemandedBits: Root:   unreachable
DemandedBits: Root:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
DemandedBits: Root:   br label %_ZNKSt5ctypeIcE5widenEc.exit
DemandedBits: Root:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
DemandedBits: Root:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
DemandedBits: Root:   br label %_ZNKSt5ctypeIcE5widenEc.exit
DemandedBits: Root:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
DemandedBits: Root:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
DemandedBits: Root:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
DemandedBits: Visiting:   %cmp = icmp ult i32 %mul, 65537 Alive Out: 0x1
DemandedBits: Visiting:   %mul = shl nsw i32 %n.066, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
DemandedBits: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ] Alive Out: 0xff
DemandedBits: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 Alive Out: 0xff
DemandedBits: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
DemandedBits: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
DemandedBits: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10) Alive Out: 0xff
DemandedBits: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
DemandedBits: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
DemandedBits: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
DemandedBits: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
DemandedBits: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
DemandedBits: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
DemandedBits: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
DemandedBits: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
DemandedBits: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
DemandedBits: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
DemandedBits: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
DemandedBits: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
DemandedBits: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
DemandedBits: Visiting:   %tobool.not.i = icmp eq i8 %16, 0 Alive Out: 0x1
DemandedBits: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 Alive Out: 0xff
DemandedBits: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
DemandedBits: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null Alive Out: 0x1
DemandedBits: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
DemandedBits: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
DemandedBits: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
DemandedBits: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
DemandedBits: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
DemandedBits: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
DemandedBits: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
DemandedBits: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
DemandedBits: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
DemandedBits: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
DemandedBits: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
DemandedBits: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
DemandedBits: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
DemandedBits: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
DemandedBits: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
DemandedBits: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
DemandedBits: Visiting:   %conv.i = sitofp i32 %mul.i to double
DemandedBits: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %div.i = sdiv i32 %add.i, 2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %add.i = or i32 %n.066, 1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
DemandedBits: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
DemandedBits: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
DemandedBits: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
DemandedBits: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
DemandedBits: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
DemandedBits: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
DemandedBits: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
DemandedBits: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
DemandedBits: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
DemandedBits: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
DemandedBits: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
DemandedBits: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
DemandedBits: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
DemandedBits: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
DemandedBits: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
DemandedBits: Visiting:   %or.i = or i32 %and.i, 4 Alive Out: 0xffffffff
DemandedBits: Visiting:   %and.i = and i32 %6, -261 Alive Out: 0xfffffffb
DemandedBits: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17 Alive Out: 0xfffffefb
DemandedBits: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
DemandedBits: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
DemandedBits: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
DemandedBits: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
DemandedBits: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
DemandedBits: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
DemandedBits: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i Alive Out: 0x1
DemandedBits: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
DemandedBits: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
DemandedBits: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
DemandedBits: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
DemandedBits: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
DemandedBits: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
DemandedBits: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2 Alive Out: 0x1
DemandedBits: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00


INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: ADD:   br label %for.body.i
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   br label %for.body.i
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit
Jump threading on function 'main'
LVI Getting value   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at ''
  Result = overdefined
LVI Getting edge value i32 2 from 'entry' to 'for.body'
  Result = constantrange<2, 3>
LVI Getting edge value   %mul = shl nsw i32 %n.066, 1 from '_ZNKSt5ctypeIcE5widenEc.exit' to 'for.body'
PUSH:   %mul = shl nsw i32 %n.066, 1 in _ZNKSt5ctypeIcE5widenEc.exit
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZNKSt5ctypeIcE5widenEc.exit
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in if.then.i
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _Z7simpsonPFddEddi.exit
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body = constantrange<0, 65537>
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.end.loopexit.i
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body.i
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body.i.preheader
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body.i.preheader = constantrange<3, 65537>
 compute BB 'for.body.i' - overdefined because of pred (non local).
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.body.i = overdefined
 compute BB 'for.end.loopexit.i' - overdefined because of pred (non local).
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in for.end.loopexit.i = overdefined
 compute BB '_Z7simpsonPFddEddi.exit' - overdefined because of pred (non local).
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _Z7simpsonPFddEddi.exit = overdefined
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit' - overdefined because of pred (non local).
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = overdefined
 compute BB 'if.then.i' - overdefined because of pred (non local).
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in if.then.i = overdefined
 compute BB '_ZNKSt5ctypeIcE5widenEc.exit' - overdefined because of pred (non local).
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in _ZNKSt5ctypeIcE5widenEc.exit = overdefined
POP   %mul = shl nsw i32 %n.066, 1 in _ZNKSt5ctypeIcE5widenEc.exit = overdefined
  Result = constantrange<0, 65537>
LVI Getting value   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19 at ''
  Result = overdefined
LVI Getting block end value   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19 at '_Z7simpsonPFddEddi.exit'
PUSH:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19 in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19 in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting value   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 at ''
  Result = overdefined
LVI Getting block end value   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit' - unknown inst def found.
POP   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = overdefined
  Result = overdefined
LVI Getting value   %mul = shl nsw i32 %n.066, 1 at ''
  Result = overdefined
LVI Getting edge value   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] from 'if.then.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
  Result = overdefined
LVI Getting edge value   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] from 'if.end.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in if.end.i
 compute BB 'if.end.i' - overdefined because of pred (non local).
POP   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] in if.end.i = overdefined
  Result = overdefined
LVI Getting edge value   %mul = shl nsw i32 %n.066, 1 from '_ZNKSt5ctypeIcE5widenEc.exit' to 'for.body'
  Result = constantrange<0, 65537>
LVI Getting value   %add.i = or i32 %n.066, 1 at 'div.i'
  Result = overdefined
LVI Getting value   %add.i = or i32 %n.066, 1 at 'div.i'
  Result = overdefined
LVI Getting block end value   %add.i = or i32 %n.066, 1 at 'for.body'
PUSH:   %add.i = or i32 %n.066, 1 in for.body
POP   %add.i = or i32 %n.066, 1 in for.body = constantrange<1, 0>
  Result = constantrange<1, 0>
LVI Getting block end value i32 2 at 'for.body'
  Result = constantrange<2, 3>
LVI Getting block end value   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at 'for.body'
  Result = constantrange<0, 65537>
LVI Getting edge value i32 2 from 'entry' to 'for.body'
  Result = constantrange<2, 3>
LVI Getting edge value   %mul = shl nsw i32 %n.066, 1 from '_ZNKSt5ctypeIcE5widenEc.exit' to 'for.body'
  Result = constantrange<0, 65537>
LVI Getting edge value   %add14.i = add nuw nsw i32 %odd.052.i, 2 from 'for.body.i' to 'for.body.i'
PUSH:   %add14.i = add nuw nsw i32 %odd.052.i, 2 in for.body.i
PUSH:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ] in for.body.i
 compute BB 'for.body.i' - overdefined because of pred (local).
POP   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ] in for.body.i = overdefined
POP   %add14.i = add nuw nsw i32 %odd.052.i, 2 in for.body.i = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting edge value   %add13.i = add nuw nsw i32 %even.051.i, 2 from 'for.body.i' to 'for.body.i'
PUSH:   %add13.i = add nuw nsw i32 %even.051.i, 2 in for.body.i
PUSH:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ] in for.body.i
POP   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ] in for.body.i = constantrange<-2147483648, 2147483647>
POP   %add13.i = add nuw nsw i32 %even.051.i, 2 in for.body.i = constantrange<2, 0>
  Result = constantrange<2, 0>
LVI Getting edge value   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 from 'for.body.i' to 'for.body.i'
PUSH:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.body.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15 from 'for.body.i.preheader' to 'for.body.i'
PUSH:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15 in for.body.i.preheader
PUSH:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15 in for.body
 compute BB 'for.body' - unknown inst def found.
POP   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15 in for.body = overdefined
 compute BB 'for.body.i.preheader' - overdefined because of pred (non local).
POP   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15 in for.body.i.preheader = overdefined
  Result = overdefined
LVI Getting edge value   %add7.i = fadd double %sum_even.049.i, %call.i.i46 from 'for.body.i' to 'for.body.i'
PUSH:   %add7.i = fadd double %sum_even.049.i, %call.i.i46 in for.body.i
 compute BB 'for.body.i' - unknown inst def found.
POP   %add7.i = fadd double %sum_even.049.i, %call.i.i46 in for.body.i = overdefined
  Result = overdefined
LVI Getting edge value   %phi.bo.i = fmul double %add7.i, 2.000000e+00 from 'for.end.loopexit.i' to '_Z7simpsonPFddEddi.exit'
PUSH:   %phi.bo.i = fmul double %add7.i, 2.000000e+00 in for.end.loopexit.i
 compute BB 'for.end.loopexit.i' - unknown inst def found.
POP   %phi.bo.i = fmul double %add7.i, 2.000000e+00 in for.end.loopexit.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15 from 'for.body' to '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting edge value   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 from 'for.end.loopexit.i' to '_Z7simpsonPFddEddi.exit'
PUSH:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.end.loopexit.i
 compute BB 'for.end.loopexit.i' - overdefined because of pred (non local).
POP   %add12.i = fadd double %sum_odd.050.i, %call.i.i41 in for.end.loopexit.i = overdefined
  Result = overdefined
LVI Getting block end value   %0 = bitcast i8* %vbase.offset.ptr.i to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %0 = bitcast i8* %vbase.offset.ptr.i to i64* in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %0 = bitcast i8* %vbase.offset.ptr.i to i64* in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting block end value   %1 = bitcast i8* %_M_width.i.i to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %1 = bitcast i8* %_M_width.i.i to i64* in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %1 = bitcast i8* %_M_width.i.i to i64* in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting block end value   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8** at '_Z7simpsonPFddEddi.exit'
PUSH:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8** in _Z7simpsonPFddEddi.exit
POP   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8** in _Z7simpsonPFddEddi.exit = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting block end value   %5 = bitcast i8* %_M_flags.i to i32* at '_Z7simpsonPFddEddi.exit'
PUSH:   %5 = bitcast i8* %_M_flags.i to i32* in _Z7simpsonPFddEddi.exit
POP   %5 = bitcast i8* %_M_flags.i to i32* in _Z7simpsonPFddEddi.exit = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %5 = bitcast i8* %_M_flags.i to i32* at '_Z7simpsonPFddEddi.exit'
  Result = notconstant<i32* null>
LVI Getting block end value   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* at '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting block end value   %8 = bitcast i8* %_M_precision.i.i to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %8 = bitcast i8* %_M_precision.i.i to i64* in _Z7simpsonPFddEddi.exit
POP   %8 = bitcast i8* %_M_precision.i.i to i64* in _Z7simpsonPFddEddi.exit = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64* at '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting block end value   %10 = bitcast i8* %_M_width.i.i52 to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %10 = bitcast i8* %_M_width.i.i52 to i64* in _Z7simpsonPFddEddi.exit
POP   %10 = bitcast i8* %_M_width.i.i52 to i64* in _Z7simpsonPFddEddi.exit = notconstant<i64* null>
  Result = notconstant<i64* null>
LVI Getting block end value   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8** at '_Z7simpsonPFddEddi.exit'
PUSH:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8** in _Z7simpsonPFddEddi.exit
POP   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8** in _Z7simpsonPFddEddi.exit = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64* at '_Z7simpsonPFddEddi.exit'
PUSH:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64* in _Z7simpsonPFddEddi.exit
 compute BB '_Z7simpsonPFddEddi.exit' - unknown inst def found.
POP   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64* in _Z7simpsonPFddEddi.exit = overdefined
  Result = overdefined
LVI Getting block end value   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"** at '_Z7simpsonPFddEddi.exit'
PUSH:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"** in _Z7simpsonPFddEddi.exit
POP   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"** in _Z7simpsonPFddEddi.exit = notconstant<%"class.std::ctype"** null>
  Result = notconstant<%"class.std::ctype"** null>
LVI Getting block end value   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19 at '_Z7simpsonPFddEddi.exit'
  Result = overdefined
LVI Getting block end value   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
POP   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
  Result = overdefined
LVI Getting block end value   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)*** at 'if.end.i'
PUSH:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)*** in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)*** in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6 at 'if.end.i'
PUSH:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6 in if.end.i
POP   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6 in if.end.i = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 from 'if.then.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 in if.then.i
 compute BB 'if.then.i' - unknown inst def found.
POP   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24 in if.then.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10) from 'if.end.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10) in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10) in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ] at '_ZNKSt5ctypeIcE5widenEc.exit'
  Result = overdefined
LVI Getting block end value i32 1 at '_ZNKSt5ctypeIcE5widenEc.exit'
  Result = constantrange<1, 2>
LVI Getting block end value   %mul = shl nsw i32 %n.066, 1 at '_ZNKSt5ctypeIcE5widenEc.exit'
  Result = overdefined
LVI Getting block end value   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10 at 'if.then.i'
PUSH:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10 in if.then.i
POP   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10 in if.then.i = notconstant<i8* null>
  Result = notconstant<i8* null>
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %if.then.i
Found a new trivial root: %if.then.i64
Last visited node: %if.then.i64
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %_ZNKSt5ctypeIcE5widenEc.exit
4: %if.end.i
5: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
6: %_Z7simpsonPFddEddi.exit
7: %for.end.loopexit.i
8: %for.body.i
9: %for.body.i.preheader
10: %for.body
11: %entry
12: %if.then.i
13: %if.then.i64
Found roots: %for.cond.cleanup %if.then.i64 
mark live:   ret i32 0
mark block live: for.cond.cleanup
mark live:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
mark block live: for.body
mark live:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
mark block live: for.body.i
mark live:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
mark live:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
mark block live: _Z7simpsonPFddEddi.exit
mark live:   store i64 6, i64* %1, align 8, !tbaa !7
mark live:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
mark live:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
mark live:   store i32 %or.i, i32* %5, align 4, !tbaa !17
mark live:   store i64 16, i64* %8, align 8, !tbaa !18
mark live:   store i64 20, i64* %10, align 8, !tbaa !7
mark live:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
mark live:   tail call void @_ZSt16__throw_bad_castv() #16
mark block live: if.then.i64
mark live:   unreachable
mark live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
mark block live: if.end.i
mark live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
mark live:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
mark live:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
mark block live: _ZNKSt5ctypeIcE5widenEc.exit
mark live:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
mark live:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
mark block live: for.end.loopexit.i
mark live:   br label %_Z7simpsonPFddEddi.exit
mark live:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
post-dom root child is a return: for.cond.cleanup
mark live:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
mark block live: if.then.i
mark live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
mark block live: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
mark live:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
mark live:   br label %for.body.i
mark block live: for.body.i.preheader
mark live:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
mark live:   br label %for.body
mark block live: entry
work live:   br label %for.body
work live:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
mark live:   %cmp48.i = icmp sgt i32 %n.066, 2
work live:   %cmp48.i = icmp sgt i32 %n.066, 2
mark live:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
work live:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
mark live:   %mul = shl nsw i32 %n.066, 1
work live:   %mul = shl nsw i32 %n.066, 1
work live:   br label %for.body.i
work live:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
mark live:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
work live:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
mark live:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
work live:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
mark live:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
work live:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
mark live:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
work live:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
mark live:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
mark live:   %vbase.offset.i55 = load i64, i64* %12, align 8
work live:   %vbase.offset.i55 = load i64, i64* %12, align 8
mark live:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
work live:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
mark live:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
work live:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
mark live:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
work live:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
mark live:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
work live:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
work live:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
mark live:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
work live:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
work live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
work live:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
mark live:   %tobool.not.i = icmp eq i8 %16, 0
work live:   %tobool.not.i = icmp eq i8 %16, 0
mark live:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
work live:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
mark live:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
work live:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
work live:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
mark live:   %cmp = icmp ult i32 %mul, 65537
work live:   %cmp = icmp ult i32 %mul, 65537
work live:   br label %_Z7simpsonPFddEddi.exit
work live:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
mark live:   %cmp.i = icmp slt i32 %add13.i, %mul.i
work live:   %cmp.i = icmp slt i32 %add13.i, %mul.i
mark live:   %add13.i = add nuw nsw i32 %even.051.i, 2
mark live:   %mul.i = shl nuw nsw i32 %div.i, 1
work live:   %mul.i = shl nuw nsw i32 %div.i, 1
mark live:   %div.i = sdiv i32 %add.i, 2
work live:   %div.i = sdiv i32 %add.i, 2
mark live:   %add.i = or i32 %n.066, 1
work live:   %add.i = or i32 %n.066, 1
work live:   %add13.i = add nuw nsw i32 %even.051.i, 2
mark live:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
work live:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
work live:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
work live:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
mark live:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
work live:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
mark live:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
work live:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
mark live:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
work live:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
work live:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
mark live:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
work live:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
mark live:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
work live:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
mark live:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
work live:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
mark live:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
work live:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
work live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
work live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
work live:   unreachable
work live:   tail call void @_ZSt16__throw_bad_castv() #16
work live:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
mark live:   %div23.i = fdiv double %mul22.i, 3.000000e+00
work live:   %div23.i = fdiv double %mul22.i, 3.000000e+00
mark live:   %mul22.i = fmul double %div1.i, %add21.i
work live:   %mul22.i = fmul double %div1.i, %add21.i
mark live:   %div1.i = fdiv double 1.000000e+00, %conv.i
mark live:   %add21.i = fadd double %add19.i, %mul20.i
work live:   %add21.i = fadd double %add19.i, %mul20.i
mark live:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
mark live:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
work live:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
mark live:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
work live:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
mark live:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
work live:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
mark live:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
work live:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
work live:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
mark live:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
work live:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
mark live:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
work live:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
mark live:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
work live:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
mark live:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
work live:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
work live:   %div1.i = fdiv double 1.000000e+00, %conv.i
mark live:   %conv.i = sitofp i32 %mul.i to double
work live:   %conv.i = sitofp i32 %mul.i to double
work live:   store i64 20, i64* %10, align 8, !tbaa !7
mark live:   %10 = bitcast i8* %_M_width.i.i52 to i64*
work live:   %10 = bitcast i8* %_M_width.i.i52 to i64*
mark live:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
work live:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
mark live:   %9 = bitcast i64* %add.ptr.i51 to i8*
mark live:   %vbase.offset.i50 = load i64, i64* %3, align 8
work live:   %vbase.offset.i50 = load i64, i64* %3, align 8
mark live:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
work live:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
mark live:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
work live:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
mark live:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
work live:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
mark live:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
work live:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
work live:   %9 = bitcast i64* %add.ptr.i51 to i8*
mark live:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
work live:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
work live:   store i64 16, i64* %8, align 8, !tbaa !18
mark live:   %8 = bitcast i8* %_M_precision.i.i to i64*
work live:   %8 = bitcast i8* %_M_precision.i.i to i64*
mark live:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
work live:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
mark live:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
mark live:   %vbase.offset.i44 = load i64, i64* %3, align 8
work live:   %vbase.offset.i44 = load i64, i64* %3, align 8
work live:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
mark live:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
work live:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
work live:   store i32 %or.i, i32* %5, align 4, !tbaa !17
mark live:   %or.i = or i32 %and.i, 4
mark live:   %5 = bitcast i8* %_M_flags.i to i32*
work live:   %5 = bitcast i8* %_M_flags.i to i32*
mark live:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
work live:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
mark live:   %4 = bitcast i64* %add.ptr.i34 to i8*
mark live:   %vbase.offset.i33 = load i64, i64* %3, align 8
work live:   %vbase.offset.i33 = load i64, i64* %3, align 8
work live:   %4 = bitcast i64* %add.ptr.i34 to i8*
mark live:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
work live:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
work live:   %or.i = or i32 %and.i, 4
mark live:   %and.i = and i32 %6, -261
work live:   %and.i = and i32 %6, -261
mark live:   %6 = load i32, i32* %5, align 4, !tbaa !17
work live:   %6 = load i32, i32* %5, align 4, !tbaa !17
work live:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
work live:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
work live:   store i64 6, i64* %1, align 8, !tbaa !7
mark live:   %1 = bitcast i8* %_M_width.i.i to i64*
work live:   %1 = bitcast i8* %_M_width.i.i to i64*
mark live:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
work live:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
mark live:   %vbase.offset.i = load i64, i64* %0, align 8
work live:   %vbase.offset.i = load i64, i64* %0, align 8
mark live:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
work live:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
mark live:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
work live:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
mark live:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
work live:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
work live:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
work live:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
mark live:   %add10.i = fadd double %mul9.i, 0.000000e+00
work live:   %add10.i = fadd double %mul9.i, 0.000000e+00
mark live:   %mul9.i = fmul double %div1.i, %conv8.i
work live:   %mul9.i = fmul double %div1.i, %conv8.i
mark live:   %conv8.i = sitofp i32 %odd.052.i to double
work live:   %conv8.i = sitofp i32 %odd.052.i to double
mark live:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
work live:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
mark live:   %add14.i = add nuw nsw i32 %odd.052.i, 2
work live:   %add14.i = add nuw nsw i32 %odd.052.i, 2
work live:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
mark live:   %add5.i = fadd double %mul4.i, 0.000000e+00
work live:   %add5.i = fadd double %mul4.i, 0.000000e+00
mark live:   %mul4.i = fmul double %div1.i, %conv3.i
work live:   %mul4.i = fmul double %div1.i, %conv3.i
mark live:   %conv3.i = sitofp i32 %even.051.i to double
work live:   %conv3.i = sitofp i32 %even.051.i to double
work live:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
mark live:   %add2.i = fadd double %div1.i, 0.000000e+00
work live:   %add2.i = fadd double %div1.i, 0.000000e+00
work live:   ret i32 0
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 5 = MemoryDef(4) (  store i64 6, i64* %1, align 8, !tbaa !7)
  trying to get dominating access
   visiting 4 = MemoryDef(20) (  %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2))
  ... skip, barrier
  finished walk
Trying to eliminate MemoryDefs killed by 8 = MemoryDef(7) (  store i32 %or.i, i32* %5, align 4, !tbaa !17)
  trying to get dominating access
   visiting 7 = MemoryDef(6) (  %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4))
  ... skip, barrier
  finished walk
Trying to eliminate MemoryDefs killed by 9 = MemoryDef(8) (  store i64 16, i64* %8, align 8, !tbaa !18)
  trying to get dominating access
   visiting 8 = MemoryDef(7) (  store i32 %or.i, i32* %5, align 4, !tbaa !17)
   visiting 7 = MemoryDef(6) (  %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4))
  ... skip, barrier
  finished walk
Trying to eliminate MemoryDefs killed by 10 = MemoryDef(9) (  store i64 20, i64* %10, align 8, !tbaa !7)
  trying to get dominating access
   visiting 9 = MemoryDef(8) (  store i64 16, i64* %8, align 8, !tbaa !18)
   visiting 8 = MemoryDef(7) (  store i32 %or.i, i32* %5, align 4, !tbaa !17)
   ...  found a read clobber
  finished walk
Trying to eliminate MemoryDefs at the end of the function
Perform LICM on Loop with header at block for.body.i
LICM: Using MemorySSA.
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.
LICM sinking instruction:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
LICM sinking instruction:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
LICM sinking instruction:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
LICM sinking instruction:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
LICM sinking instruction:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
LICM sinking instruction:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
LICM sinking instruction:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
LICM sinking instruction:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
LICM sinking instruction:   %10 = bitcast i8* %_M_width.i.i52 to i64*
LICM sinking instruction:   %9 = bitcast i64* %add.ptr.i51 to i8*
LICM sinking instruction:   %8 = bitcast i8* %_M_precision.i.i to i64*
LICM sinking instruction:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
LICM sinking instruction:   %5 = bitcast i8* %_M_flags.i to i32*
LICM sinking instruction:   %4 = bitcast i64* %add.ptr.i34 to i8*
LICM sinking instruction:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
LICM sinking instruction:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
LICM sinking instruction:   %1 = bitcast i8* %_M_width.i.i to i64*
LICM sinking instruction:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
Looking to fold for.body.i.preheader into for.body.i
Killing Trivial BB: 

for.body.i.preheader:                             ; preds = %for.body
  br label %for.body.i


INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i.lcssa, 2.000000e+00
IC: ADD:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: Replacing   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    with   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Mod =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    New =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ERASE   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD DEFERRED:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Replacing   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    with   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Mod =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    New =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ERASE   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD DEFERRED:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit


INSTCOMBINE ITERATION #2 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #16
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #15
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #16
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #15
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #15
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: 'main'<<0x7fffc0cfb110>>  #uses=1
  CS<0x7fffc1b8d590> calls function 'pow'
  CS<0x7fffc1d6b450> calls function '_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l'
  CS<0x7fffc1d72300> calls function 'strlen'
  CS<0x7fffc0cf9c30> calls function 'pow'
  CS<0x7fffc1bae2a0> calls function '_ZNSolsEi'
  CS<0x7fffc1d73d50> calls function '_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l'
  CS<0x7fffc0cf87c0> calls function 'strlen'
  CS<0x7fffc0cfe800> calls function 'pow'
  CS<0x7fffc14f1ea0> calls function 'pow'
  CS<0x7fffc1c91230> calls function 'pow'
  CS<0x7fffc1d72820> calls function '_ZNSo5flushEv'
  CS<0x7fffc1cac1f0> calls function '_ZNSo9_M_insertIdEERSoT_'
  CS<0x7fffc1ca9400> calls external node
  CS<0x7fffc14f22d0> calls function '_ZNSo3putEc'
  CS<0x7fffc1bae500> calls function '_ZSt16__throw_bad_castv'
  CS<0x7fffc1d788e0> calls function '_ZNKSt5ctypeIcE13_M_widen_initEv'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZStcoSt13_Ios_Fmtflags: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStcoSt13_Ios_Fmtflags'<<0x7fffc1c8c4b0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStcoSt13_Ios_Fmtflags
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStcoSt13_Ios_Fmtflags'
LVI Getting block end value   %neg = xor i32 %__a, -1 at 'entry'
PUSH:   %neg = xor i32 %__a, -1 in entry
 compute BB 'entry' - overdefined (unknown binary operator).
POP   %neg = xor i32 %__a, -1 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZStcoSt13_Ios_Fmtflags
IC: ADD:   ret i32 %neg
IC: ADD:   %neg = xor i32 %__a, -1
IC: Visiting:   %neg = xor i32 %__a, -1
IC: Visiting:   ret i32 %neg
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStcoSt13_Ios_Fmtflags ----

Computing probabilities for entry

block-frequency: _ZStcoSt13_Ios_Fmtflags
========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStcoSt13_Ios_Fmtflags
 - entry: float = 1.0, int = 8

Calculated Rank[__a] = 3
Combine negations for:   %neg = xor i32 %__a, -1
LINEARIZE:   %neg = xor i32 %__a, -1
OPERAND: i32 %__a (1)
ADD LEAF: i32 %__a (1)
OPERAND: i32 -1 (1)
ADD LEAF: i32 -1 (1)
RAIn:	xor i32	[ %__a, #3] [ -1, #0] 
RAOut:	xor i32	[ %__a, #3] [ -1, #0] 


INSTCOMBINE ITERATION #1 on _ZStcoSt13_Ios_Fmtflags
IC: ADD:   ret i32 %neg
IC: ADD:   %neg = xor i32 %__a, -1
IC: Visiting:   %neg = xor i32 %__a, -1
IC: Visiting:   ret i32 %neg
SROA function: _ZStcoSt13_Ios_Fmtflags
Instruction Merger
GVN iteration: 0
SCCP on function '_ZStcoSt13_Ios_Fmtflags'
Marking Block Executable: entry
markOverdefined: i32 %__a

Popped off OI-WL: i32 %__a
Merged overdefined into   %neg = xor i32 %__a, -1 : overdefined

Popped off OI-WL:   %neg = xor i32 %__a, -1

Popped off BBWL: 
entry:
  %neg = xor i32 %__a, -1
  ret i32 %neg

RESOLVING UNDEFs
DemandedBits: Root:   ret i32 %neg
DemandedBits: Visiting:   %neg = xor i32 %__a, -1 Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _ZStcoSt13_Ios_Fmtflags
IC: ADD:   ret i32 %neg
IC: ADD:   %neg = xor i32 %__a, -1
IC: Visiting:   %neg = xor i32 %__a, -1
IC: Visiting:   ret i32 %neg
Jump threading on function '_ZStcoSt13_Ios_Fmtflags'
LVI Getting block end value   %neg = xor i32 %__a, -1 at 'entry'
PUSH:   %neg = xor i32 %__a, -1 in entry
 compute BB 'entry' - overdefined (unknown binary operator).
POP   %neg = xor i32 %__a, -1 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i32 %neg
mark block live: entry
post-dom root child is a return: entry
work live:   ret i32 %neg
mark live:   %neg = xor i32 %__a, -1
work live:   %neg = xor i32 %__a, -1
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStcoSt13_Ios_Fmtflags
IC: ADD:   ret i32 %neg
IC: ADD:   %neg = xor i32 %__a, -1
IC: Visiting:   %neg = xor i32 %__a, -1
IC: Visiting:   ret i32 %neg
Inliner visiting SCC: _ZStanSt13_Ios_FmtflagsS_: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStanSt13_Ios_FmtflagsS_'<<0x7fffc0cfe1e0>>  #uses=3

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStanSt13_Ios_FmtflagsS_
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStanSt13_Ios_FmtflagsS_'
LVI Getting block end value   %and = and i32 %__a, %__b at 'entry'
PUSH:   %and = and i32 %__a, %__b in entry
PUSH: i32 %__a in entry
PUSH: i32 %__b in entry
POP i32 %__b in entry = overdefined
POP i32 %__a in entry = overdefined
POP   %and = and i32 %__a, %__b in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZStanSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %and
IC: ADD:   %and = and i32 %__a, %__b
IC: Visiting:   %and = and i32 %__a, %__b
IC: Visiting:   ret i32 %and
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStanSt13_Ios_FmtflagsS_ ----

Computing probabilities for entry

block-frequency: _ZStanSt13_Ios_FmtflagsS_
==========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStanSt13_Ios_FmtflagsS_
 - entry: float = 1.0, int = 8

Calculated Rank[__a] = 3
Calculated Rank[__b] = 4
Combine negations for:   %and = and i32 %__a, %__b
LINEARIZE:   %and = and i32 %__a, %__b
OPERAND: i32 %__a (1)
ADD LEAF: i32 %__a (1)
OPERAND: i32 %__b (1)
ADD LEAF: i32 %__b (1)
RAIn:	and i32	[ %__a, #3] [ %__b, #4] 
RAOut:	and i32	[ %__b, #4] [ %__a, #3] 
RA:   %and = and i32 %__a, %__b
TO:   %and = and i32 %__b, %__a


INSTCOMBINE ITERATION #1 on _ZStanSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %and
IC: ADD:   %and = and i32 %__b, %__a
IC: Visiting:   %and = and i32 %__b, %__a
IC: Visiting:   ret i32 %and
SROA function: _ZStanSt13_Ios_FmtflagsS_
Instruction Merger
GVN iteration: 0
SCCP on function '_ZStanSt13_Ios_FmtflagsS_'
Marking Block Executable: entry
markOverdefined: i32 %__a
markOverdefined: i32 %__b

Popped off OI-WL: i32 %__b
markOverdefined:   %and = and i32 %__b, %__a

Popped off OI-WL:   %and = and i32 %__b, %__a

Popped off OI-WL: i32 %__a

Popped off BBWL: 
entry:
  %and = and i32 %__b, %__a
  ret i32 %and

RESOLVING UNDEFs
DemandedBits: Root:   ret i32 %and
DemandedBits: Visiting:   %and = and i32 %__b, %__a Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _ZStanSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %and
IC: ADD:   %and = and i32 %__b, %__a
IC: Visiting:   %and = and i32 %__b, %__a
IC: Visiting:   ret i32 %and
Jump threading on function '_ZStanSt13_Ios_FmtflagsS_'
LVI Getting block end value   %and = and i32 %__b, %__a at 'entry'
PUSH:   %and = and i32 %__b, %__a in entry
PUSH: i32 %__b in entry
PUSH: i32 %__a in entry
POP i32 %__a in entry = overdefined
POP i32 %__b in entry = overdefined
POP   %and = and i32 %__b, %__a in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i32 %and
mark block live: entry
post-dom root child is a return: entry
work live:   ret i32 %and
mark live:   %and = and i32 %__b, %__a
work live:   %and = and i32 %__b, %__a
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStanSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %and
IC: ADD:   %and = and i32 %__b, %__a
IC: Visiting:   %and = and i32 %__b, %__a
IC: Visiting:   ret i32 %and
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStanSt13_Ios_FmtflagsS_'<<0x7fffc0cfe1e0>>  #uses=3

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZStaNRSt13_Ios_FmtflagsS_: 1 call sites.
      Analyzing call of _ZStanSt13_Ios_FmtflagsS_... (caller:_ZStaNRSt13_Ios_FmtflagsS_)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStaNRSt13_Ios_FmtflagsS_'<<0x7fffc1c8a540>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStaNRSt13_Ios_FmtflagsS_'<<0x7fffc1c8a540>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStaNRSt13_Ios_FmtflagsS_
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStaNRSt13_Ios_FmtflagsS_'
LVI Getting block end value i32* %__a at 'entry'
PUSH: i32* %__a in entry
POP i32* %__a in entry = overdefined
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = notconstant<i32* null>


INSTCOMBINE ITERATION #1 on _ZStaNRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %and.i = and i32 %__b, %0
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %and.i = and i32 %__b, %0
IC: Mod =   %and.i = and i32 %__b, %0
    New =   %and.i = and i32 %0, %__b
IC: ADD:   %and.i = and i32 %0, %__b
IC: Visiting:   %and.i = and i32 %0, %__b
IC: Visiting:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a


INSTCOMBINE ITERATION #2 on _ZStaNRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %and.i = and i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %and.i = and i32 %0, %__b
IC: Visiting:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStaNRSt13_Ios_FmtflagsS_ ----

Computing probabilities for entry

block-frequency: _ZStaNRSt13_Ios_FmtflagsS_
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStaNRSt13_Ios_FmtflagsS_
 - entry: float = 1.0, int = 8

Calculated Rank[__a] = 3
Calculated Rank[__b] = 4
Combine negations for:   %and.i = and i32 %__b, %0
LINEARIZE:   %and.i = and i32 %__b, %0
OPERAND: i32 %__b (1)
ADD LEAF: i32 %__b (1)
OPERAND:   %0 = load i32, i32* %__a, align 4, !tbaa !2 (1)
ADD LEAF:   %0 = load i32, i32* %__a, align 4, !tbaa !2 (1)
RAIn:	and i32	[ %__b, #4] [ %0, #327681] 
RAOut:	and i32	[ %0, #327681] [ %__b, #4] 
RA:   %and.i = and i32 %__b, %0
TO:   %and.i = and i32 %0, %__b


INSTCOMBINE ITERATION #1 on _ZStaNRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %and.i = and i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %and.i = and i32 %0, %__b
IC: Visiting:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
SROA function: _ZStaNRSt13_Ios_FmtflagsS_
Instruction Merger
GVN iteration: 0
GVN: load i32 %0 has unknown dependence
SCCP on function '_ZStaNRSt13_Ios_FmtflagsS_'
Marking Block Executable: entry
markOverdefined: i32* %__a
markOverdefined: i32 %__b

Popped off OI-WL: i32 %__b

Popped off OI-WL: i32* %__a
Merged overdefined into   %0 = load i32, i32* %__a, align 4, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %__a, align 4, !tbaa !2
markOverdefined:   %and.i = and i32 %0, %__b

Popped off OI-WL:   %and.i = and i32 %0, %__b

Popped off BBWL: 
entry:
  %0 = load i32, i32* %__a, align 4, !tbaa !2
  %and.i = and i32 %0, %__b
  store i32 %and.i, i32* %__a, align 4, !tbaa !2
  ret i32* %__a

RESOLVING UNDEFs
DemandedBits: Root:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
DemandedBits: Root:   ret i32* %__a
DemandedBits: Visiting:   %and.i = and i32 %0, %__b Alive Out: 0xffffffff
DemandedBits: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2 Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _ZStaNRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %and.i = and i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %and.i = and i32 %0, %__b
IC: Visiting:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
Jump threading on function '_ZStaNRSt13_Ios_FmtflagsS_'
LVI Getting block end value i32* %__a at 'entry'
PUSH: i32* %__a in entry
POP i32* %__a in entry = overdefined
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = notconstant<i32* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
mark block live: entry
mark live:   ret i32* %__a
post-dom root child is a return: entry
work live:   ret i32* %__a
work live:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
mark live:   %and.i = and i32 %0, %__b
work live:   %and.i = and i32 %0, %__b
mark live:   %0 = load i32, i32* %__a, align 4, !tbaa !2
work live:   %0 = load i32, i32* %__a, align 4, !tbaa !2
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i32 %and.i, i32* %__a, align 4, !tbaa !2)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStaNRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %and.i = and i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %and.i = and i32 %0, %__b
IC: Visiting:   store i32 %and.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStaNRSt13_Ios_FmtflagsS_'<<0x7fffc1c8a540>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZStorSt13_Ios_FmtflagsS_: 0 call sites.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStorSt13_Ios_FmtflagsS_'<<0x7fffc0cfb1f0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStorSt13_Ios_FmtflagsS_
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStorSt13_Ios_FmtflagsS_'
LVI Getting block end value   %or = or i32 %__a, %__b at 'entry'
PUSH:   %or = or i32 %__a, %__b in entry
PUSH: i32 %__a in entry
PUSH: i32 %__b in entry
POP i32 %__b in entry = overdefined
POP i32 %__a in entry = overdefined
POP   %or = or i32 %__a, %__b in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZStorSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__a, %__b
IC: Visiting:   %or = or i32 %__a, %__b
IC: Visiting:   ret i32 %or
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStorSt13_Ios_FmtflagsS_ ----

Computing probabilities for entry

block-frequency: _ZStorSt13_Ios_FmtflagsS_
==========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStorSt13_Ios_FmtflagsS_
 - entry: float = 1.0, int = 8

Calculated Rank[__a] = 3
Calculated Rank[__b] = 4
Combine negations for:   %or = or i32 %__a, %__b
LINEARIZE:   %or = or i32 %__a, %__b
OPERAND: i32 %__a (1)
ADD LEAF: i32 %__a (1)
OPERAND: i32 %__b (1)
ADD LEAF: i32 %__b (1)
RAIn:	or i32	[ %__a, #3] [ %__b, #4] 
RAOut:	or i32	[ %__b, #4] [ %__a, #3] 
RA:   %or = or i32 %__a, %__b
TO:   %or = or i32 %__b, %__a


INSTCOMBINE ITERATION #1 on _ZStorSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__b, %__a
IC: Visiting:   %or = or i32 %__b, %__a
IC: Visiting:   ret i32 %or
SROA function: _ZStorSt13_Ios_FmtflagsS_
Instruction Merger
GVN iteration: 0
SCCP on function '_ZStorSt13_Ios_FmtflagsS_'
Marking Block Executable: entry
markOverdefined: i32 %__a
markOverdefined: i32 %__b

Popped off OI-WL: i32 %__b
markOverdefined:   %or = or i32 %__b, %__a

Popped off OI-WL:   %or = or i32 %__b, %__a

Popped off OI-WL: i32 %__a

Popped off BBWL: 
entry:
  %or = or i32 %__b, %__a
  ret i32 %or

RESOLVING UNDEFs
DemandedBits: Root:   ret i32 %or
DemandedBits: Visiting:   %or = or i32 %__b, %__a Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _ZStorSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__b, %__a
IC: Visiting:   %or = or i32 %__b, %__a
IC: Visiting:   ret i32 %or
Jump threading on function '_ZStorSt13_Ios_FmtflagsS_'
LVI Getting block end value   %or = or i32 %__b, %__a at 'entry'
PUSH:   %or = or i32 %__b, %__a in entry
PUSH: i32 %__b in entry
PUSH: i32 %__a in entry
POP i32 %__a in entry = overdefined
POP i32 %__b in entry = overdefined
POP   %or = or i32 %__b, %__a in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   ret i32 %or
mark block live: entry
post-dom root child is a return: entry
work live:   ret i32 %or
mark live:   %or = or i32 %__b, %__a
work live:   %or = or i32 %__b, %__a
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStorSt13_Ios_FmtflagsS_
IC: ADD:   ret i32 %or
IC: ADD:   %or = or i32 %__b, %__a
IC: Visiting:   %or = or i32 %__b, %__a
IC: Visiting:   ret i32 %or
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStorSt13_Ios_FmtflagsS_'<<0x7fffc0cfb1f0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZStoRRSt13_Ios_FmtflagsS_: 1 call sites.
      Analyzing call of _ZStorSt13_Ios_FmtflagsS_... (caller:_ZStoRRSt13_Ios_FmtflagsS_)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call = call i32 @_ZStorSt13_Ios_FmtflagsS_(i32 %0, i32 %__b)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStoRRSt13_Ios_FmtflagsS_'<<0x7fffc0cfc9c0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStoRRSt13_Ios_FmtflagsS_'<<0x7fffc0cfc9c0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZStoRRSt13_Ios_FmtflagsS_
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZStoRRSt13_Ios_FmtflagsS_'
LVI Getting block end value i32* %__a at 'entry'
PUSH: i32* %__a in entry
POP i32* %__a in entry = overdefined
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = notconstant<i32* null>


INSTCOMBINE ITERATION #1 on _ZStoRRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %or.i = or i32 %__b, %0
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %or.i = or i32 %__b, %0
IC: Mod =   %or.i = or i32 %__b, %0
    New =   %or.i = or i32 %0, %__b
IC: ADD:   %or.i = or i32 %0, %__b
IC: Visiting:   %or.i = or i32 %0, %__b
IC: Visiting:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a


INSTCOMBINE ITERATION #2 on _ZStoRRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %or.i = or i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__b
IC: Visiting:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZStoRRSt13_Ios_FmtflagsS_ ----

Computing probabilities for entry

block-frequency: _ZStoRRSt13_Ios_FmtflagsS_
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZStoRRSt13_Ios_FmtflagsS_
 - entry: float = 1.0, int = 8

Calculated Rank[__a] = 3
Calculated Rank[__b] = 4
Combine negations for:   %or.i = or i32 %__b, %0
LINEARIZE:   %or.i = or i32 %__b, %0
OPERAND: i32 %__b (1)
ADD LEAF: i32 %__b (1)
OPERAND:   %0 = load i32, i32* %__a, align 4, !tbaa !2 (1)
ADD LEAF:   %0 = load i32, i32* %__a, align 4, !tbaa !2 (1)
RAIn:	or i32	[ %__b, #4] [ %0, #327681] 
RAOut:	or i32	[ %0, #327681] [ %__b, #4] 
RA:   %or.i = or i32 %__b, %0
TO:   %or.i = or i32 %0, %__b


INSTCOMBINE ITERATION #1 on _ZStoRRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %or.i = or i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__b
IC: Visiting:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
SROA function: _ZStoRRSt13_Ios_FmtflagsS_
Instruction Merger
GVN iteration: 0
GVN: load i32 %0 has unknown dependence
SCCP on function '_ZStoRRSt13_Ios_FmtflagsS_'
Marking Block Executable: entry
markOverdefined: i32* %__a
markOverdefined: i32 %__b

Popped off OI-WL: i32 %__b

Popped off OI-WL: i32* %__a
Merged overdefined into   %0 = load i32, i32* %__a, align 4, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %__a, align 4, !tbaa !2
markOverdefined:   %or.i = or i32 %0, %__b

Popped off OI-WL:   %or.i = or i32 %0, %__b

Popped off BBWL: 
entry:
  %0 = load i32, i32* %__a, align 4, !tbaa !2
  %or.i = or i32 %0, %__b
  store i32 %or.i, i32* %__a, align 4, !tbaa !2
  ret i32* %__a

RESOLVING UNDEFs
DemandedBits: Root:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
DemandedBits: Root:   ret i32* %__a
DemandedBits: Visiting:   %or.i = or i32 %0, %__b Alive Out: 0xffffffff
DemandedBits: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2 Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _ZStoRRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %or.i = or i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__b
IC: Visiting:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
Jump threading on function '_ZStoRRSt13_Ios_FmtflagsS_'
LVI Getting block end value i32* %__a at 'entry'
PUSH: i32* %__a in entry
POP i32* %__a in entry = overdefined
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = overdefined
LVI Getting block end value i32* %__a at 'entry'
  Result = notconstant<i32* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
mark block live: entry
mark live:   ret i32* %__a
post-dom root child is a return: entry
work live:   ret i32* %__a
work live:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
mark live:   %or.i = or i32 %0, %__b
work live:   %or.i = or i32 %0, %__b
mark live:   %0 = load i32, i32* %__a, align 4, !tbaa !2
work live:   %0 = load i32, i32* %__a, align 4, !tbaa !2
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i32 %or.i, i32* %__a, align 4, !tbaa !2)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZStoRRSt13_Ios_FmtflagsS_
IC: ADD:   ret i32* %__a
IC: ADD:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: ADD:   %or.i = or i32 %0, %__b
IC: ADD:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %0 = load i32, i32* %__a, align 4, !tbaa !2
IC: Visiting:   %or.i = or i32 %0, %__b
IC: Visiting:   store i32 %or.i, i32* %__a, align 4, !tbaa !2
IC: Visiting:   ret i32* %__a
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZStoRRSt13_Ios_FmtflagsS_'<<0x7fffc0cfc9c0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_: 4 call sites.
      Analyzing call of _ZStcoSt13_Ios_Fmtflags... (caller:_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -30
      Threshold: 487
    Inlining (cost=-30, threshold=487), Call:   %call = call i32 @_ZStcoSt13_Ios_Fmtflags(i32 %__mask)
      Analyzing call of _ZStoRRSt13_Ios_FmtflagsS_... (caller:_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 4
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -25
      Threshold: 487
    Inlining (cost=-25, threshold=487), Call:   %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZStoRRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %call4)
      Analyzing call of _ZStanSt13_Ios_FmtflagsS_... (caller:_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -35
      Threshold: 487
    Inlining (cost=-35, threshold=487), Call:   %call4 = call i32 @_ZStanSt13_Ios_FmtflagsS_(i32 %__fmtfl, i32 %__mask)
      Analyzing call of _ZStaNRSt13_Ios_FmtflagsS_... (caller:_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 4
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -25
      Threshold: 487
    Inlining (cost=-25, threshold=487), Call:   %call3 = call nonnull align 4 dereferenceable(4) i32* @_ZStaNRSt13_Ios_FmtflagsS_(i32* nonnull align 4 dereferenceable(4) %_M_flags, i32 %neg.i)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_'<<0x7fffc1d51df0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_'<<0x7fffc1d51df0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
EarlyCSE CSE LOAD:   %1 = load i32, i32* %_M_flags, align 4, !tbaa !13  to:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
EarlyCSE CSE LOAD:   %1 = load i32, i32* %_M_flags, align 4, !tbaa !13  to:   store i32 %and.i.i, i32* %_M_flags, align 4, !tbaa !13
EarlyCSE DEAD STORE:   store i32 %and.i.i, i32* %_M_flags, align 4, !tbaa !13  due to:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_'
LVI Getting block end value   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 at 'entry'
PUSH:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 in entry
POP   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 at 'entry'
  Result = notconstant<i32* null>
LVI Getting block end value   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
IC: ADD:   ret i32 %0
IC: ADD:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: ADD:   %or.i.i = or i32 %and.i.i, %and.i
IC: ADD:   %and.i = and i32 %__mask, %__fmtfl
IC: ADD:   %and.i.i = and i32 %0, %neg.i
IC: ADD:   %neg.i = xor i32 %__mask, -1
IC: ADD:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: ADD:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: Visiting:   %neg.i = xor i32 %__mask, -1
IC: Visiting:   %and.i.i = and i32 %0, %neg.i
IC: Visiting:   %and.i = and i32 %__mask, %__fmtfl
IC: Visiting:   %or.i.i = or i32 %and.i.i, %and.i
IC: Visiting:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: Visiting:   ret i32 %0
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_ ----

Computing probabilities for entry

block-frequency: _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
=========================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
 - entry: float = 1.0, int = 8

Calculated Rank[this] = 3
Calculated Rank[__fmtfl] = 4
Calculated Rank[__mask] = 5
Combine negations for:   %neg.i = xor i32 %__mask, -1
LINEARIZE:   %neg.i = xor i32 %__mask, -1
OPERAND: i32 %__mask (1)
ADD USES LEAF: i32 %__mask (1)
OPERAND: i32 -1 (1)
ADD USES LEAF: i32 -1 (1)
RAIn:	xor i32	[ %__mask, #5] [ -1, #0] 
RAOut:	xor i32	[ %__mask, #5] [ -1, #0] 
Calculated Rank[neg.i] = 5
Combine negations for:   %and.i.i = and i32 %neg.i, %0
LINEARIZE:   %and.i.i = and i32 %neg.i, %0
OPERAND:   %neg.i = xor i32 %__mask, -1 (1)
ADD LEAF:   %neg.i = xor i32 %__mask, -1 (1)
OPERAND:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 (1)
ADD USES LEAF:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 (1)
RAIn:	and i32	[ %neg.i, #5] [ %0, #393217] 
RAOut:	and i32	[ %0, #393217] [ %neg.i, #5] 
RA:   %and.i.i = and i32 %neg.i, %0
TO:   %and.i.i = and i32 %0, %neg.i
Combine negations for:   %and.i = and i32 %__fmtfl, %__mask
LINEARIZE:   %and.i = and i32 %__fmtfl, %__mask
OPERAND: i32 %__fmtfl (1)
ADD LEAF: i32 %__fmtfl (1)
OPERAND: i32 %__mask (1)
ADD USES LEAF: i32 %__mask (1)
RAIn:	and i32	[ %__fmtfl, #4] [ %__mask, #5] 
RAOut:	and i32	[ %__mask, #5] [ %__fmtfl, #4] 
RA:   %and.i = and i32 %__fmtfl, %__mask
TO:   %and.i = and i32 %__mask, %__fmtfl
Calculated Rank[and.i] = 6
Calculated Rank[and.i.i] = 393218
Combine negations for:   %or.i.i = or i32 %and.i, %and.i.i
LINEARIZE:   %or.i.i = or i32 %and.i, %and.i.i
OPERAND:   %and.i = and i32 %__mask, %__fmtfl (1)
ADD LEAF:   %and.i = and i32 %__mask, %__fmtfl (1)
OPERAND:   %and.i.i = and i32 %0, %neg.i (1)
ADD LEAF:   %and.i.i = and i32 %0, %neg.i (1)
RAIn:	or i32	[ %and.i, #6] [ %and.i.i, #393218] 
RAOut:	or i32	[ %and.i.i, #393218] [ %and.i, #6] 
RA:   %or.i.i = or i32 %and.i, %and.i.i
TO:   %or.i.i = or i32 %and.i.i, %and.i


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
IC: ADD:   ret i32 %0
IC: ADD:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: ADD:   %or.i.i = or i32 %and.i.i, %and.i
IC: ADD:   %and.i = and i32 %__mask, %__fmtfl
IC: ADD:   %and.i.i = and i32 %0, %neg.i
IC: ADD:   %neg.i = xor i32 %__mask, -1
IC: ADD:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: ADD:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: Visiting:   %neg.i = xor i32 %__mask, -1
IC: Visiting:   %and.i.i = and i32 %0, %neg.i
IC: Visiting:   %and.i = and i32 %__mask, %__fmtfl
IC: Visiting:   %or.i.i = or i32 %and.i.i, %and.i
IC: Visiting:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: Visiting:   ret i32 %0
SROA function: _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
Instruction Merger
GVN iteration: 0
GVN: load i32 %0 has unknown dependence
SCCP on function '_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_'
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %this
markOverdefined: i32 %__fmtfl
markOverdefined: i32 %__mask

Popped off OI-WL: i32 %__mask
markOverdefined:   %and.i = and i32 %__mask, %__fmtfl
Merged overdefined into   %neg.i = xor i32 %__mask, -1 : overdefined

Popped off OI-WL:   %neg.i = xor i32 %__mask, -1

Popped off OI-WL:   %and.i = and i32 %__mask, %__fmtfl

Popped off OI-WL: i32 %__fmtfl

Popped off OI-WL: %"class.std::ios_base"* %this
markOverdefined:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3

Popped off OI-WL:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
Merged overdefined into   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
markOverdefined:   %and.i.i = and i32 %0, %neg.i

Popped off OI-WL:   %and.i.i = and i32 %0, %neg.i
markOverdefined:   %or.i.i = or i32 %and.i.i, %and.i

Popped off OI-WL:   %or.i.i = or i32 %and.i.i, %and.i

Popped off BBWL: 
entry:
  %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
  %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
  %neg.i = xor i32 %__mask, -1
  %and.i.i = and i32 %0, %neg.i
  %and.i = and i32 %__mask, %__fmtfl
  %or.i.i = or i32 %and.i.i, %and.i
  store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
  ret i32 %0

RESOLVING UNDEFs
DemandedBits: Root:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
DemandedBits: Root:   ret i32 %0
DemandedBits: Visiting:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
DemandedBits: Visiting:   %or.i.i = or i32 %and.i.i, %and.i Alive Out: 0xffffffff
DemandedBits: Visiting:   %and.i = and i32 %__mask, %__fmtfl Alive Out: 0xffffffff
DemandedBits: Visiting:   %and.i.i = and i32 %0, %neg.i Alive Out: 0xffffffff
DemandedBits: Visiting:   %neg.i = xor i32 %__mask, -1 Alive Out: 0xffffffff


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
IC: ADD:   ret i32 %0
IC: ADD:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: ADD:   %or.i.i = or i32 %and.i.i, %and.i
IC: ADD:   %and.i = and i32 %__mask, %__fmtfl
IC: ADD:   %and.i.i = and i32 %0, %neg.i
IC: ADD:   %neg.i = xor i32 %__mask, -1
IC: ADD:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: ADD:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: Visiting:   %neg.i = xor i32 %__mask, -1
IC: Visiting:   %and.i.i = and i32 %0, %neg.i
IC: Visiting:   %and.i = and i32 %__mask, %__fmtfl
IC: Visiting:   %or.i.i = or i32 %and.i.i, %and.i
IC: Visiting:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: Visiting:   ret i32 %0
Jump threading on function '_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_'
LVI Getting block end value   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 at 'entry'
PUSH:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 in entry
POP   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3 at 'entry'
  Result = notconstant<i32* null>
LVI Getting block end value   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
mark block live: entry
mark live:   ret i32 %0
post-dom root child is a return: entry
work live:   ret i32 %0
mark live:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
work live:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
mark live:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
work live:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
work live:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
mark live:   %or.i.i = or i32 %and.i.i, %and.i
work live:   %or.i.i = or i32 %and.i.i, %and.i
mark live:   %and.i.i = and i32 %0, %neg.i
mark live:   %and.i = and i32 %__mask, %__fmtfl
work live:   %and.i = and i32 %__mask, %__fmtfl
work live:   %and.i.i = and i32 %0, %neg.i
mark live:   %neg.i = xor i32 %__mask, -1
work live:   %neg.i = xor i32 %__mask, -1
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_
IC: ADD:   ret i32 %0
IC: ADD:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: ADD:   %or.i.i = or i32 %and.i.i, %and.i
IC: ADD:   %and.i = and i32 %__mask, %__fmtfl
IC: ADD:   %and.i.i = and i32 %0, %neg.i
IC: ADD:   %neg.i = xor i32 %__mask, -1
IC: ADD:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: ADD:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %_M_flags = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %this, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags, align 8, !tbaa !2
IC: Visiting:   %neg.i = xor i32 %__mask, -1
IC: Visiting:   %and.i.i = and i32 %0, %neg.i
IC: Visiting:   %and.i = and i32 %__mask, %__fmtfl
IC: Visiting:   %or.i.i = or i32 %and.i.i, %and.i
IC: Visiting:   store i32 %or.i.i, i32* %_M_flags, align 4, !tbaa !13
IC: Visiting:   ret i32 %0
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_'<<0x7fffc1d51df0>>  #uses=2

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZSt5fixedRSt8ios_base: 1 call sites.
      Analyzing call of _ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_... (caller:_ZSt5fixedRSt8ios_base)
      NumConstantArgs: 2
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 4
      NumInstructions: 8
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -25
      Threshold: 337
    Inlining (cost=-25, threshold=337), Call:   %call = call i32 @_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_(%"class.std::ios_base"* nonnull dereferenceable(216) %__base, i32 4, i32 260)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt5fixedRSt8ios_base'<<0x7fffc1d51d70>>  #uses=1

CGSCCPASSMGR: SCC Refresh didn't change call graph.
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt5fixedRSt8ios_base'<<0x7fffc1d51d70>>  #uses=1

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZSt5fixedRSt8ios_base
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZSt5fixedRSt8ios_base'
LVI Getting block end value   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 at 'entry'
PUSH:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 in entry
POP   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 at 'entry'
  Result = notconstant<i32* null>
LVI Getting block end value %"class.std::ios_base"* %__base at 'entry'
PUSH: %"class.std::ios_base"* %__base in entry
POP %"class.std::ios_base"* %__base in entry = overdefined
  Result = notconstant<%"class.std::ios_base"* null>


INSTCOMBINE ITERATION #1 on _ZSt5fixedRSt8ios_base
IC: ADD:   ret %"class.std::ios_base"* %__base
IC: ADD:   store i32 %or.i.i.i, i32* %_M_flags.i, align 4, !tbaa !13
IC: ADD:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: ADD:   %and.i.i.i = and i32 %0, -261
IC: ADD:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: ADD:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: Visiting:   %and.i.i.i = and i32 %0, -261
IC: Visiting:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: Visiting:   store i32 %or.i.i.i, i32* %_M_flags.i, align 4, !tbaa !13
IC: Visiting:   ret %"class.std::ios_base"* %__base
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZSt5fixedRSt8ios_base ----

Computing probabilities for entry

block-frequency: _ZSt5fixedRSt8ios_base
=======================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZSt5fixedRSt8ios_base
 - entry: float = 1.0, int = 8

Calculated Rank[__base] = 3
Combine negations for:   %and.i.i.i = and i32 %0, -261
LINEARIZE:   %and.i.i.i = and i32 %0, -261
OPERAND:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2 (1)
ADD LEAF:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2 (1)
OPERAND: i32 -261 (1)
ADD USES LEAF: i32 -261 (1)
RAIn:	and i32	[ %0, #262145] [ -261, #0] 
RAOut:	and i32	[ %0, #262145] [ -261, #0] 
Combine negations for:   %or.i.i.i = or i32 %and.i.i.i, 4
LINEARIZE:   %or.i.i.i = or i32 %and.i.i.i, 4
OPERAND:   %and.i.i.i = and i32 %0, -261 (1)
ADD LEAF:   %and.i.i.i = and i32 %0, -261 (1)
OPERAND: i32 4 (1)
ADD USES LEAF: i32 4 (1)
Calculated Rank[and.i.i.i] = 262146
RAIn:	or i32	[ %and.i.i.i, #262146] [ 4, #0] 
RAOut:	or i32	[ %and.i.i.i, #262146] [ 4, #0] 


INSTCOMBINE ITERATION #1 on _ZSt5fixedRSt8ios_base
IC: ADD:   ret %"class.std::ios_base"* %__base
IC: ADD:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
IC: ADD:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: ADD:   %and.i.i.i = and i32 %0, -261
IC: ADD:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: ADD:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: Visiting:   %and.i.i.i = and i32 %0, -261
IC: Visiting:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: Visiting:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
IC: Visiting:   ret %"class.std::ios_base"* %__base
SROA function: _ZSt5fixedRSt8ios_base
Instruction Merger
GVN iteration: 0
GVN: load i32 %0 has unknown dependence
SCCP on function '_ZSt5fixedRSt8ios_base'
Marking Block Executable: entry
markOverdefined: %"class.std::ios_base"* %__base

Popped off OI-WL: %"class.std::ios_base"* %__base
markOverdefined:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3

Popped off OI-WL:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
Merged overdefined into   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
Merged constantrange<0, -260> into   %and.i.i.i = and i32 %0, -261 : constantrange<0, -260>

Popped off I-WL:   %and.i.i.i = and i32 %0, -261
Merged constantrange<4, 0> into   %or.i.i.i = or i32 %and.i.i.i, 4 : constantrange<4, 0>

Popped off I-WL:   %or.i.i.i = or i32 %and.i.i.i, 4

Popped off BBWL: 
entry:
  %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
  %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
  %and.i.i.i = and i32 %0, -261
  %or.i.i.i = or i32 %and.i.i.i, 4
  store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
  ret %"class.std::ios_base"* %__base

RESOLVING UNDEFs
DemandedBits: Root:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
DemandedBits: Root:   ret %"class.std::ios_base"* %__base
DemandedBits: Visiting:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
DemandedBits: Visiting:   %or.i.i.i = or i32 %and.i.i.i, 4 Alive Out: 0xffffffff
DemandedBits: Visiting:   %and.i.i.i = and i32 %0, -261 Alive Out: 0xfffffffb
DemandedBits: Visiting:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2 Alive Out: 0xfffffefb


INSTCOMBINE ITERATION #1 on _ZSt5fixedRSt8ios_base
IC: ADD:   ret %"class.std::ios_base"* %__base
IC: ADD:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
IC: ADD:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: ADD:   %and.i.i.i = and i32 %0, -261
IC: ADD:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: ADD:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: Visiting:   %and.i.i.i = and i32 %0, -261
IC: Visiting:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: Visiting:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
IC: Visiting:   ret %"class.std::ios_base"* %__base
Jump threading on function '_ZSt5fixedRSt8ios_base'
LVI Getting block end value   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 at 'entry'
PUSH:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 in entry
POP   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 in entry = notconstant<i32* null>
  Result = notconstant<i32* null>
LVI Getting block end value   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3 at 'entry'
  Result = notconstant<i32* null>
LVI Getting block end value %"class.std::ios_base"* %__base at 'entry'
PUSH: %"class.std::ios_base"* %__base in entry
POP %"class.std::ios_base"* %__base in entry = overdefined
  Result = notconstant<%"class.std::ios_base"* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
mark block live: entry
mark live:   ret %"class.std::ios_base"* %__base
post-dom root child is a return: entry
work live:   ret %"class.std::ios_base"* %__base
work live:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
mark live:   %or.i.i.i = or i32 %and.i.i.i, 4
mark live:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
work live:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
work live:   %or.i.i.i = or i32 %and.i.i.i, 4
mark live:   %and.i.i.i = and i32 %0, -261
work live:   %and.i.i.i = and i32 %0, -261
mark live:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
work live:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
final dead terminator blocks: 
Trying to eliminate MemoryDefs killed by 1 = MemoryDef(liveOnEntry) (  store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13)
  trying to get dominating access
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZSt5fixedRSt8ios_base
IC: ADD:   ret %"class.std::ios_base"* %__base
IC: ADD:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
IC: ADD:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: ADD:   %and.i.i.i = and i32 %0, -261
IC: ADD:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: ADD:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %_M_flags.i = getelementptr inbounds %"class.std::ios_base", %"class.std::ios_base"* %__base, i64 0, i32 3
IC: Visiting:   %0 = load i32, i32* %_M_flags.i, align 8, !tbaa !2
IC: Visiting:   %and.i.i.i = and i32 %0, -261
IC: Visiting:   %or.i.i.i = or i32 %and.i.i.i, 4
IC: Visiting:   store i32 %or.i.i.i, i32* %_M_flags.i, align 8, !tbaa !13
IC: Visiting:   ret %"class.std::ios_base"* %__base
Inliner visiting SCC: _ZSt16__throw_bad_castv: 0 call sites.
Inliner visiting SCC: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_: 0 call sites.
SROA function: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
EarlyCSE CVP: Add conditional value for 'tobool.not' as i1 true in if.then
EarlyCSE CVP: Add conditional value for 'tobool.not' as i1 false in if.end
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_'
LVI Getting value %"class.std::ctype"* %__f at ''
  Result = overdefined
LVI Getting block end value %"class.std::ctype"* %__f at 'entry'
PUSH: %"class.std::ctype"* %__f in entry
POP %"class.std::ctype"* %__f in entry = overdefined
  Result = overdefined
LVI Getting block end value %"class.std::ctype"* %__f at 'if.end'
PUSH: %"class.std::ctype"* %__f in if.end
POP %"class.std::ctype"* %__f in if.end = notconstant<%"class.std::ctype"* null>
  Result = notconstant<%"class.std::ctype"* null>


INSTCOMBINE ITERATION #1 on _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   ret %"class.std::ctype"* %__f
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.end
IC: ADD:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.end
IC: Visiting:   ret %"class.std::ctype"* %__f
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
		Looking for trivial roots
Found a new trivial root: %if.then
Last visited node: %entry
Found a new trivial root: %if.end
Last visited node: %if.end
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.then
3: %entry
4: %if.end
Found roots: %if.then %if.end 
---- Branch Probability Info : _ZSt13__check_facetISt5ctypeIcEERKT_PS3_ ----

Computing probabilities for if.then
Computing probabilities for if.end
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge entry -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%

block-frequency: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
=========================================================
reverse-post-order-traversal
 - 0: entry
 - 1: if.end
 - 2: if.then
loop-detection
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2048, succ = if.then
  => [ local  ] weight = 2147481600, succ = if.end
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to if.end
  => assign 0000100000000000 (0000000000000000) to if.then
 - node: if.end
  => mass:  ffffefffffffffff
 - node: if.then
  => mass:  0000100000000000
float-to-int: min = 0.0000009536743164, max = 1.0, factor = 8388608.0
 - entry: float = 1.0, scaled = 8388608.0, int = 8388607
 - if.end: float = 0.9999990463, scaled = 8388600.0, int = 8388599
 - if.then: float = 0.0000009536743164, scaled = 8.0, int = 8
block-frequency-info: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
 - entry: float = 1.0, int = 8388607
 - if.then: float = 0.00000095367, int = 8
 - if.end: float = 1.0, int = 8388599

Marked as tail call candidate:   call void @_ZSt16__throw_bad_castv() #15
Calculated Rank[__f] = 3


INSTCOMBINE ITERATION #1 on _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   ret %"class.std::ctype"* %__f
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.end
IC: ADD:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.end
IC: Visiting:   ret %"class.std::ctype"* %__f
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
SROA function: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
Instruction Merger
GVN iteration: 0
SCCP on function '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_'
Marking Block Executable: entry
markOverdefined: %"class.std::ctype"* %__f

Popped off OI-WL: %"class.std::ctype"* %__f
markOverdefined:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null

Popped off OI-WL:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
Marking Block Executable: if.then
Marking Block Executable: if.end

Popped off BBWL: 
if.end:                                           ; preds = %entry
  ret %"class.std::ctype"* %__f


Popped off BBWL: 
if.then:                                          ; preds = %entry
  tail call void @_ZSt16__throw_bad_castv() #15
  unreachable


Popped off BBWL: 
entry:
  %tobool.not = icmp eq %"class.std::ctype"* %__f, null
  br i1 %tobool.not, label %if.then, label %if.end

RESOLVING UNDEFs
DemandedBits: Root:   br i1 %tobool.not, label %if.then, label %if.end
DemandedBits: Root:   tail call void @_ZSt16__throw_bad_castv() #15
DemandedBits: Root:   unreachable
DemandedBits: Root:   ret %"class.std::ctype"* %__f
DemandedBits: Visiting:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null Alive Out: 0x1


INSTCOMBINE ITERATION #1 on _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   ret %"class.std::ctype"* %__f
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.end
IC: ADD:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.end
IC: Visiting:   ret %"class.std::ctype"* %__f
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
Jump threading on function '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_'
LVI Getting value %"class.std::ctype"* %__f at ''
  Result = overdefined
LVI Getting block end value %"class.std::ctype"* %__f at 'entry'
PUSH: %"class.std::ctype"* %__f in entry
POP %"class.std::ctype"* %__f in entry = overdefined
  Result = overdefined
LVI Getting block end value %"class.std::ctype"* %__f at 'if.end'
PUSH: %"class.std::ctype"* %__f in if.end
POP %"class.std::ctype"* %__f in if.end = notconstant<%"class.std::ctype"* null>
  Result = notconstant<%"class.std::ctype"* null>
		Looking for trivial roots
Found a new trivial root: %if.then
Last visited node: %entry
Found a new trivial root: %if.end
Last visited node: %if.end
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.then
3: %entry
4: %if.end
Found roots: %if.then %if.end 
mark live:   tail call void @_ZSt16__throw_bad_castv() #15
mark block live: if.then
mark live:   unreachable
mark live:   ret %"class.std::ctype"* %__f
mark block live: if.end
mark live:   br i1 %tobool.not, label %if.then, label %if.end
mark block live: entry
post-dom root child is a return: if.end
work live:   br i1 %tobool.not, label %if.then, label %if.end
mark live:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
work live:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
work live:   ret %"class.std::ctype"* %__f
work live:   unreachable
work live:   tail call void @_ZSt16__throw_bad_castv() #15
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZSt13__check_facetISt5ctypeIcEERKT_PS3_
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   ret %"class.std::ctype"* %__f
IC: ADD:   br i1 %tobool.not, label %if.then, label %if.end
IC: ADD:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   %tobool.not = icmp eq %"class.std::ctype"* %__f, null
IC: Visiting:   br i1 %tobool.not, label %if.then, label %if.end
IC: Visiting:   ret %"class.std::ctype"* %__f
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_'<<0x7fffc1badeb0>>  #uses=2
  CS<0x7fffc1c46bb0> calls function '_ZSt16__throw_bad_castv'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNKSt5ctypeIcE13_M_widen_initEv: 0 call sites.
Inliner visiting SCC: _ZNKSt5ctypeIcE5widenEc: 1 call sites.
SROA function: _ZNKSt5ctypeIcE5widenEc
EarlyCSE CVP: Add conditional value for 'tobool.not' as i1 true in if.end
EarlyCSE CVP: Add conditional value for 'tobool.not' as i1 false in if.then
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNKSt5ctypeIcE5widenEc'
LVI Getting value   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 at ''
  Result = overdefined
LVI Getting block end value   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
LVI Getting block end value   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8 at 'entry'
PUSH:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8 in entry
POP   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8 in entry = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 at 'entry'
  Result = overdefined
LVI Getting block end value   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)*** at 'if.end'
PUSH:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)*** in if.end
POP   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)*** in if.end = notconstant<i8 (%"class.std::ctype"*, i8)*** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)*** null>
LVI Getting block end value   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6 at 'if.end'
PUSH:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6 in if.end
POP   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6 in if.end = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 from 'if.then' to 'return'
PUSH:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 in if.then
 compute BB 'if.then' - unknown inst def found.
POP   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 in if.then = overdefined
  Result = overdefined
LVI Getting edge value   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) from 'if.end' to 'return'
PUSH:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) in if.end
 compute BB 'if.end' - unknown inst def found.
POP   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) in if.end = overdefined
  Result = overdefined
LVI Getting block end value   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] at 'return'
PUSH:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] in return
 compute BB 'return' - overdefined because of pred (local).
POP   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] in return = overdefined
  Result = overdefined
LVI Getting block end value   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom at 'if.then'
PUSH:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom in if.then
POP   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom in if.then = notconstant<i8* null>
  Result = notconstant<i8* null>


INSTCOMBINE ITERATION #1 on _ZNKSt5ctypeIcE5widenEc
IC: ADD:   br label %return
IC: ADD:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: ADD:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: ADD:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: ADD:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: ADD:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: ADD:   ret i8 %retval.0
IC: ADD:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: ADD:   br label %return
IC: ADD:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: ADD:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: ADD:   %idxprom = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not, label %if.end, label %if.then
IC: ADD:   %tobool.not = icmp eq i8 %0, 0
IC: ADD:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: ADD:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: Visiting:   %tobool.not = icmp eq i8 %0, 0
IC: Visiting:   br i1 %tobool.not, label %if.end, label %if.then
IC: Visiting:   %idxprom = zext i8 %__c to i64
IC: Visiting:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: Visiting:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: Visiting:   br label %return
IC: Visiting:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: Visiting:   ret i8 %retval.0
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: Visiting:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: Visiting:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: Visiting:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: Visiting:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: Visiting:   br label %return
		Looking for trivial roots
Found a new trivial root: %return
Last visited node: %if.end
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %return
3: %if.then
4: %entry
5: %if.end
Found roots: %return 
---- Branch Probability Info : _ZNKSt5ctypeIcE5widenEc ----

Computing probabilities for return
Computing probabilities for if.end
Computing probabilities for if.then
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge entry -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%

block-frequency: _ZNKSt5ctypeIcE5widenEc
========================================
reverse-post-order-traversal
 - 0: entry
 - 1: if.then
 - 2: if.end
 - 3: return
loop-detection
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 805306368, succ = if.end
  => [ local  ] weight = 1342177280, succ = if.then
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to if.then
  => assign 6000000000000000 (0000000000000000) to if.end
 - node: if.then
  => [ local  ] weight = 2147483648, succ = return
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to return
 - node: if.end
  => [ local  ] weight = 2147483648, succ = return
  => mass:  6000000000000000
  => assign 6000000000000000 (0000000000000000) to return
 - node: return
  => mass:  ffffffffffffffff
float-to-int: min = 0.375, max = 1.0, factor = 21.33333333
 - entry: float = 1.0, scaled = 21.33333333, int = 21
 - if.then: float = 0.625, scaled = 13.33333333, int = 13
 - if.end: float = 0.375, scaled = 8.0, int = 8
 - return: float = 1.0, scaled = 21.33333333, int = 21
block-frequency-info: _ZNKSt5ctypeIcE5widenEc
 - entry: float = 1.0, int = 21
 - if.then: float = 0.625, int = 13
 - if.end: float = 0.375, int = 8
 - return: float = 1.0, int = 21

Marked as tail call candidate:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
Marked as tail call candidate:   %call = call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
Calculated Rank[this] = 3
Calculated Rank[__c] = 4


INSTCOMBINE ITERATION #1 on _ZNKSt5ctypeIcE5widenEc
IC: ADD:   br label %return
IC: ADD:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: ADD:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: ADD:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: ADD:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: ADD:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: ADD:   ret i8 %retval.0
IC: ADD:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: ADD:   br label %return
IC: ADD:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: ADD:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: ADD:   %idxprom = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not, label %if.end, label %if.then
IC: ADD:   %tobool.not = icmp eq i8 %0, 0
IC: ADD:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: ADD:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: Visiting:   %tobool.not = icmp eq i8 %0, 0
IC: Visiting:   br i1 %tobool.not, label %if.end, label %if.then
IC: Visiting:   %idxprom = zext i8 %__c to i64
IC: Visiting:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: Visiting:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: Visiting:   br label %return
IC: Visiting:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: Visiting:   ret i8 %retval.0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: Visiting:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: Visiting:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: Visiting:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: Visiting:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: Visiting:   br label %return
SROA function: _ZNKSt5ctypeIcE5widenEc
Instruction Merger
GVN iteration: 0
GVN: load i8 %0 has unknown dependence
GVN: non-local load i8 %1 has unknown dependencies
GVN: load i8 (%"class.std::ctype"*, i8)** %vtable is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
GVN: load i8 (%"class.std::ctype"*, i8)* %3 is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
SCCP on function '_ZNKSt5ctypeIcE5widenEc'
Marking Block Executable: entry
markOverdefined: %"class.std::ctype"* %this
markOverdefined: i8 %__c

Popped off OI-WL: i8 %__c

Popped off OI-WL: %"class.std::ctype"* %this
markOverdefined:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8

Popped off OI-WL:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
Merged overdefined into   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
markOverdefined:   %tobool.not = icmp eq i8 %0, 0

Popped off OI-WL:   %tobool.not = icmp eq i8 %0, 0
Marking Block Executable: if.end
Marking Block Executable: if.then

Popped off BBWL: 
if.then:                                          ; preds = %entry
  %idxprom = zext i8 %__c to i64
  %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
  br label %return

markOverdefined:   %idxprom = zext i8 %__c to i64
markOverdefined:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
Merged overdefined into   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 : overdefined
Marking Block Executable: return

Popped off BBWL: 
return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
  ret i8 %retval.0

Merged overdefined into   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] : overdefined

Popped off BBWL: 
if.end:                                           ; preds = %entry
  tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
  %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
  %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
  %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
  %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
  %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
  br label %return

markOverdefined:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
Merged overdefined into   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9 : overdefined
markOverdefined:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
Merged overdefined into   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8 : overdefined
Merged overdefined into   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) : overdefined
Marking Edge Executable: if.end -> return

Popped off BBWL: 
entry:
  %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
  %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then


Popped off OI-WL:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)

Popped off OI-WL:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8

Popped off OI-WL:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6

Popped off OI-WL:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9

Popped off OI-WL:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***

Popped off OI-WL:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]

Popped off OI-WL:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8

Popped off OI-WL:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom

Popped off OI-WL:   %idxprom = zext i8 %__c to i64
RESOLVING UNDEFs
DemandedBits: Root:   br i1 %tobool.not, label %if.end, label %if.then
DemandedBits: Root:   br label %return
DemandedBits: Root:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
DemandedBits: Root:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
DemandedBits: Root:   br label %return
DemandedBits: Root:   ret i8 %retval.0
DemandedBits: Visiting:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] Alive Out: 0xff
DemandedBits: Visiting:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 Alive Out: 0xff
DemandedBits: Visiting:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
DemandedBits: Visiting:   %idxprom = zext i8 %__c to i64 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) Alive Out: 0xff
DemandedBits: Visiting:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
DemandedBits: Visiting:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
DemandedBits: Visiting:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
DemandedBits: Visiting:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
DemandedBits: Visiting:   %tobool.not = icmp eq i8 %0, 0 Alive Out: 0x1
DemandedBits: Visiting:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 Alive Out: 0xff
DemandedBits: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8


INSTCOMBINE ITERATION #1 on _ZNKSt5ctypeIcE5widenEc
IC: ADD:   br label %return
IC: ADD:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: ADD:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: ADD:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: ADD:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: ADD:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: ADD:   ret i8 %retval.0
IC: ADD:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: ADD:   br label %return
IC: ADD:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: ADD:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: ADD:   %idxprom = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not, label %if.end, label %if.then
IC: ADD:   %tobool.not = icmp eq i8 %0, 0
IC: ADD:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: ADD:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: Visiting:   %tobool.not = icmp eq i8 %0, 0
IC: Visiting:   br i1 %tobool.not, label %if.end, label %if.then
IC: Visiting:   %idxprom = zext i8 %__c to i64
IC: Visiting:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: Visiting:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: Visiting:   br label %return
IC: Visiting:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: Visiting:   ret i8 %retval.0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: Visiting:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: Visiting:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: Visiting:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: Visiting:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: Visiting:   br label %return
Jump threading on function '_ZNKSt5ctypeIcE5widenEc'
LVI Getting value   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 at ''
  Result = overdefined
LVI Getting block end value   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
LVI Getting block end value   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8 at 'entry'
PUSH:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8 in entry
POP   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8 in entry = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2 at 'entry'
  Result = overdefined
LVI Getting block end value   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)*** at 'if.end'
PUSH:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)*** in if.end
POP   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)*** in if.end = notconstant<i8 (%"class.std::ctype"*, i8)*** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)*** null>
LVI Getting block end value   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6 at 'if.end'
PUSH:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6 in if.end
POP   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6 in if.end = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 from 'if.then' to 'return'
PUSH:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 in if.then
 compute BB 'if.then' - unknown inst def found.
POP   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8 in if.then = overdefined
  Result = overdefined
LVI Getting edge value   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) from 'if.end' to 'return'
PUSH:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) in if.end
 compute BB 'if.end' - unknown inst def found.
POP   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c) in if.end = overdefined
  Result = overdefined
LVI Getting block end value   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] at 'return'
PUSH:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] in return
 compute BB 'return' - overdefined because of pred (local).
POP   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ] in return = overdefined
  Result = overdefined
LVI Getting block end value   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom at 'if.then'
PUSH:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom in if.then
POP   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom in if.then = notconstant<i8* null>
  Result = notconstant<i8* null>
		Looking for trivial roots
Found a new trivial root: %return
Last visited node: %if.end
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %return
3: %if.then
4: %entry
5: %if.end
Found roots: %return 
mark live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
mark block live: if.end
mark live:   br label %return
mark live:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
mark live:   ret i8 %retval.0
mark block live: return
post-dom root child is a return: return
work live:   ret i8 %retval.0
mark live:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
work live:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
mark live:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
mark block live: if.then
mark live:   br label %return
work live:   br label %return
work live:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
mark live:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
work live:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
mark live:   %idxprom = zext i8 %__c to i64
work live:   %idxprom = zext i8 %__c to i64
work live:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
mark live:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
work live:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
mark live:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
work live:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
mark live:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
work live:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
mark live:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
work live:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
work live:   br label %return
work live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
new live blocks:
	if.end
	return
	if.then
dead terminator blocks:
	entry
live control in: entry
mark live:   br i1 %tobool.not, label %if.end, label %if.then
work live:   br i1 %tobool.not, label %if.end, label %if.then
mark live:   %tobool.not = icmp eq i8 %0, 0
work live:   %tobool.not = icmp eq i8 %0, 0
mark live:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
work live:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
mark live:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
work live:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNKSt5ctypeIcE5widenEc
IC: ADD:   br label %return
IC: ADD:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: ADD:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: ADD:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: ADD:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: ADD:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: ADD:   ret i8 %retval.0
IC: ADD:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: ADD:   br label %return
IC: ADD:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: ADD:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: ADD:   %idxprom = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not, label %if.end, label %if.then
IC: ADD:   %tobool.not = icmp eq i8 %0, 0
IC: ADD:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: ADD:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %_M_widen_ok = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 8
IC: Visiting:   %0 = load i8, i8* %_M_widen_ok, align 8, !tbaa !2
IC: Visiting:   %tobool.not = icmp eq i8 %0, 0
IC: Visiting:   br i1 %tobool.not, label %if.end, label %if.then
IC: Visiting:   %idxprom = zext i8 %__c to i64
IC: Visiting:   %arrayidx = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %this, i64 0, i32 9, i64 %idxprom
IC: Visiting:   %1 = load i8, i8* %arrayidx, align 1, !tbaa !8
IC: Visiting:   br label %return
IC: Visiting:   %retval.0 = phi i8 [ %1, %if.then ], [ %call, %if.end ]
IC: Visiting:   ret i8 %retval.0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %this)
IC: Visiting:   %2 = bitcast %"class.std::ctype"* %this to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %2, align 8, !tbaa !9
IC: Visiting:   %vfn = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable, i64 6
IC: Visiting:   %3 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn, align 8
IC: Visiting:   %call = tail call signext i8 %3(%"class.std::ctype"* nonnull dereferenceable(570) %this, i8 signext %__c)
IC: Visiting:   br label %return
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNKSt5ctypeIcE5widenEc'<<0x7fffc1bacd50>>  #uses=2
  CS<0x7fffc1c8df40> calls function '_ZNKSt5ctypeIcE13_M_widen_initEv'
  CS<0x7fffc0c6b740> calls external node

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc: 2 call sites.
      Analyzing call of _ZSt13__check_facetISt5ctypeIcEERKT_PS3_... (caller:_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 2
      NumInstructions: 5
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 5
      Threshold: 325
    Inlining (cost=5, threshold=325), Call:   %call = call nonnull align 8 dereferenceable(570) %"class.std::ctype"* @_ZSt13__check_facetISt5ctypeIcEERKT_PS3_(%"class.std::ctype"* %0)
      Analyzing call of _ZNKSt5ctypeIcE5widenEc... (caller:_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 8
      NumInstructions: 17
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 45
      Threshold: 225
    Inlining (cost=45, threshold=225), Call:   %call2 = call signext i8 @_ZNKSt5ctypeIcE5widenEc(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc'<<0x7fffc1c8cba0>>  #uses=2
  CS<0x7fffc0cfaae0> calls function '_ZSt16__throw_bad_castv'
  CS<0x7fffc1d73a50> calls external node
  CS<0x7fffc14f2410> calls function '_ZNKSt5ctypeIcE13_M_widen_initEv'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
EarlyCSE CVP: Add conditional value for 'tobool.not.i' as i1 true in if.then.i
EarlyCSE CVP: Add conditional value for 'tobool.not.i' as i1 false in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
EarlyCSE CVP: Add conditional value for 'tobool.not.i3' as i1 true in if.end.i
EarlyCSE CVP: Add conditional value for 'tobool.not.i3' as i1 false in if.then.i4
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc'
LVI Getting value   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 at ''
  Result = overdefined
LVI Getting block end value   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
LVI Getting value   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 at ''
  Result = overdefined
LVI Getting block end value   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit' - unknown inst def found.
POP   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = overdefined
  Result = overdefined
LVI Getting block end value   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5 at 'entry'
PUSH:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5 in entry
POP   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5 in entry = notconstant<%"class.std::ctype"** null>
  Result = notconstant<%"class.std::ctype"** null>
LVI Getting block end value   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 at 'entry'
  Result = overdefined
LVI Getting block end value   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
POP   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
  Result = overdefined
LVI Getting block end value   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)*** at 'if.end.i'
PUSH:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)*** in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)*** in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6 at 'if.end.i'
PUSH:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6 in if.end.i
POP   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6 in if.end.i = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 from 'if.then.i4' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 in if.then.i4
 compute BB 'if.then.i4' - unknown inst def found.
POP   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 in if.then.i4 = overdefined
  Result = overdefined
LVI Getting edge value   %call.i = call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) from 'if.end.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %call.i = call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %call.i = call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] at '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] in _ZNKSt5ctypeIcE5widenEc.exit
 compute BB '_ZNKSt5ctypeIcE5widenEc.exit' - overdefined because of pred (local).
POP   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] in _ZNKSt5ctypeIcE5widenEc.exit = overdefined
  Result = overdefined
LVI Getting block end value   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i at 'if.then.i4'
PUSH:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i in if.then.i4
POP   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i in if.then.i4 = notconstant<i8* null>
  Result = notconstant<i8* null>


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i = call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: ADD:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: ADD:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: ADD:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: ADD:   ret i8 %retval.0.i
IC: ADD:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: ADD:   %idxprom.i = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: ADD:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: ADD:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: ADD:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: ADD:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: Visiting:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: Visiting:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: Visiting:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: Visiting:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: Visiting:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: Visiting:   %idxprom.i = zext i8 %__c to i64
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: Visiting:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: Visiting:   ret i8 %retval.0.i
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: Visiting:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: Visiting:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i = call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
		Looking for trivial roots
Found a new trivial root: %if.then.i
Last visited node: %entry
Found a new trivial root: %_ZNKSt5ctypeIcE5widenEc.exit
Last visited node: %if.then.i4
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.then.i
3: %entry
4: %_ZNKSt5ctypeIcE5widenEc.exit
5: %if.end.i
6: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
7: %if.then.i4
Found roots: %if.then.i %_ZNKSt5ctypeIcE5widenEc.exit 
---- Branch Probability Info : _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc ----

Computing probabilities for if.then.i
Computing probabilities for _ZNKSt5ctypeIcE5widenEc.exit
Computing probabilities for if.end.i
Computing probabilities for if.then.i4
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge entry -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%

block-frequency: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
==============================================================
reverse-post-order-traversal
 - 0: entry
 - 1: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - 2: if.then.i4
 - 3: if.end.i
 - 4: _ZNKSt5ctypeIcE5widenEc.exit
 - 5: if.then.i
loop-detection
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2048, succ = if.then.i
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => assign 0000100000000000 (0000000000000000) to if.then.i
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => [ local  ] weight = 805306368, succ = if.end.i
  => [ local  ] weight = 1342177280, succ = if.then.i4
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to if.then.i4
  => assign 5ffffa0000000000 (0000000000000000) to if.end.i
 - node: if.then.i4
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: if.end.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  ffffefffffffffff
 - node: if.then.i
  => mass:  0000100000000000
float-to-int: min = 0.0000009536743164, max = 1.0, factor = 8388608.0
 - entry: float = 1.0, scaled = 8388608.0, int = 8388607
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 0.9999990463, scaled = 8388600.0, int = 8388599
 - if.then.i4: float = 0.624999404, scaled = 5242875.0, int = 5242874
 - if.end.i: float = 0.3749996424, scaled = 3145725.0, int = 3145724
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 0.9999990463, scaled = 8388600.0, int = 8388599
 - if.then.i: float = 0.0000009536743164, scaled = 8.0, int = 8
block-frequency-info: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
 - entry: float = 1.0, int = 8388607
 - if.then.i: float = 0.00000095367, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 1.0, int = 8388599
 - if.then.i4: float = 0.625, int = 5242874
 - if.end.i: float = 0.375, int = 3145724
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 1.0, int = 8388599

Marked as tail call candidate:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
Marked as tail call candidate:   %call.i = call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
Marked as tail call candidate:   call void @_ZSt16__throw_bad_castv() #15
Calculated Rank[this] = 3
Calculated Rank[__c] = 4


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: ADD:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: ADD:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: ADD:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: ADD:   ret i8 %retval.0.i
IC: ADD:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: ADD:   %idxprom.i = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: ADD:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: ADD:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: ADD:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: ADD:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: Visiting:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: Visiting:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: Visiting:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: Visiting:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: Visiting:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: Visiting:   %idxprom.i = zext i8 %__c to i64
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: Visiting:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: Visiting:   ret i8 %retval.0.i
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: Visiting:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: Visiting:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
SROA function: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
Instruction Merger
GVN iteration: 0
GVN: load %"class.std::ctype"* %0 has unknown dependence
GVN: non-local load i8 %1 has unknown dependencies
GVN: non-local load i8 %2 has unknown dependencies
GVN: load i8 (%"class.std::ctype"*, i8)** %vtable.i is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
GVN: load i8 (%"class.std::ctype"*, i8)* %4 is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
SCCP on function '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ios"* %this
markOverdefined: i8 %__c

Popped off OI-WL: i8 %__c

Popped off OI-WL: %"class.std::basic_ios"* %this
markOverdefined:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5

Popped off OI-WL:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
Merged overdefined into   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
markOverdefined:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null

Popped off OI-WL:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
Marking Block Executable: if.then.i
Marking Block Executable: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit

Popped off BBWL: 
_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:    ; preds = %entry
  %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
  %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
  %tobool.not.i3 = icmp eq i8 %1, 0
  br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4

markOverdefined:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
Merged overdefined into   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 : overdefined
markOverdefined:   %tobool.not.i3 = icmp eq i8 %1, 0
Marking Block Executable: if.end.i
Marking Block Executable: if.then.i4

Popped off BBWL: 
if.then.i4:                                       ; preds = %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  %idxprom.i = zext i8 %__c to i64
  %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
  %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
  br label %_ZNKSt5ctypeIcE5widenEc.exit

markOverdefined:   %idxprom.i = zext i8 %__c to i64
markOverdefined:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
Merged overdefined into   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 : overdefined
Marking Block Executable: _ZNKSt5ctypeIcE5widenEc.exit

Popped off BBWL: 
_ZNKSt5ctypeIcE5widenEc.exit:                     ; preds = %if.then.i4, %if.end.i
  %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
  ret i8 %retval.0.i

Merged overdefined into   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] : overdefined

Popped off BBWL: 
if.end.i:                                         ; preds = %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
  %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
  %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
  %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
  %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
  %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
  br label %_ZNKSt5ctypeIcE5widenEc.exit

markOverdefined:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
Merged overdefined into   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11 : overdefined
markOverdefined:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
Merged overdefined into   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8 : overdefined
Merged overdefined into   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) : overdefined
Marking Edge Executable: if.end.i -> _ZNKSt5ctypeIcE5widenEc.exit

Popped off BBWL: 
if.then.i:                                        ; preds = %entry
  tail call void @_ZSt16__throw_bad_castv() #15
  unreachable


Popped off BBWL: 
entry:
  %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
  %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
  %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
  br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit


Popped off OI-WL:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)

Popped off OI-WL:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8

Popped off OI-WL:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6

Popped off OI-WL:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11

Popped off OI-WL:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***

Popped off OI-WL:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]

Popped off OI-WL:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10

Popped off OI-WL:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i

Popped off OI-WL:   %idxprom.i = zext i8 %__c to i64

Popped off OI-WL:   %tobool.not.i3 = icmp eq i8 %1, 0

Popped off OI-WL:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8

Popped off OI-WL:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
RESOLVING UNDEFs
DemandedBits: Root:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
DemandedBits: Root:   tail call void @_ZSt16__throw_bad_castv() #15
DemandedBits: Root:   unreachable
DemandedBits: Root:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
DemandedBits: Root:   br label %_ZNKSt5ctypeIcE5widenEc.exit
DemandedBits: Root:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
DemandedBits: Root:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
DemandedBits: Root:   br label %_ZNKSt5ctypeIcE5widenEc.exit
DemandedBits: Root:   ret i8 %retval.0.i
DemandedBits: Visiting:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] Alive Out: 0xff
DemandedBits: Visiting:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 Alive Out: 0xff
DemandedBits: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
DemandedBits: Visiting:   %idxprom.i = zext i8 %__c to i64 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) Alive Out: 0xff
DemandedBits: Visiting:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
DemandedBits: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
DemandedBits: Visiting:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
DemandedBits: Visiting:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
DemandedBits: Visiting:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
DemandedBits: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
DemandedBits: Visiting:   %tobool.not.i3 = icmp eq i8 %1, 0 Alive Out: 0x1
DemandedBits: Visiting:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 Alive Out: 0xff
DemandedBits: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
DemandedBits: Visiting:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null Alive Out: 0x1


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: ADD:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: ADD:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: ADD:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: ADD:   ret i8 %retval.0.i
IC: ADD:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: ADD:   %idxprom.i = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: ADD:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: ADD:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: ADD:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: ADD:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: Visiting:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: Visiting:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: Visiting:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: Visiting:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: Visiting:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: Visiting:   %idxprom.i = zext i8 %__c to i64
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: Visiting:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: Visiting:   ret i8 %retval.0.i
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: Visiting:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: Visiting:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
Jump threading on function '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc'
LVI Getting value   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 at ''
  Result = overdefined
LVI Getting block end value   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 at 'entry'
PUSH:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 in entry = overdefined
  Result = overdefined
LVI Getting value   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 at ''
  Result = overdefined
LVI Getting block end value   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit' - unknown inst def found.
POP   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = overdefined
  Result = overdefined
LVI Getting block end value   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5 at 'entry'
PUSH:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5 in entry
POP   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5 in entry = notconstant<%"class.std::ctype"** null>
  Result = notconstant<%"class.std::ctype"** null>
LVI Getting block end value   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2 at 'entry'
  Result = overdefined
LVI Getting block end value   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
PUSH:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
POP   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
  Result = overdefined
LVI Getting block end value   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)*** at 'if.end.i'
PUSH:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)*** in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)*** in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6 at 'if.end.i'
PUSH:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6 in if.end.i
POP   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6 in if.end.i = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 from 'if.then.i4' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 in if.then.i4
 compute BB 'if.then.i4' - unknown inst def found.
POP   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10 in if.then.i4 = overdefined
  Result = overdefined
LVI Getting edge value   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) from 'if.end.i' to '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) in if.end.i
 compute BB 'if.end.i' - unknown inst def found.
POP   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c) in if.end.i = overdefined
  Result = overdefined
LVI Getting block end value   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] at '_ZNKSt5ctypeIcE5widenEc.exit'
PUSH:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] in _ZNKSt5ctypeIcE5widenEc.exit
 compute BB '_ZNKSt5ctypeIcE5widenEc.exit' - overdefined because of pred (local).
POP   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ] in _ZNKSt5ctypeIcE5widenEc.exit = overdefined
  Result = overdefined
LVI Getting block end value   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i at 'if.then.i4'
PUSH:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i in if.then.i4
POP   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i in if.then.i4 = notconstant<i8* null>
  Result = notconstant<i8* null>
		Looking for trivial roots
Found a new trivial root: %if.then.i
Last visited node: %entry
Found a new trivial root: %_ZNKSt5ctypeIcE5widenEc.exit
Last visited node: %if.then.i4
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.then.i
3: %entry
4: %_ZNKSt5ctypeIcE5widenEc.exit
5: %if.end.i
6: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
7: %if.then.i4
Found roots: %if.then.i %_ZNKSt5ctypeIcE5widenEc.exit 
mark live:   tail call void @_ZSt16__throw_bad_castv() #15
mark block live: if.then.i
mark live:   unreachable
mark live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
mark block live: if.end.i
mark live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
mark live:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
mark live:   ret i8 %retval.0.i
mark block live: _ZNKSt5ctypeIcE5widenEc.exit
mark live:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
mark block live: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
mark block live: entry
post-dom root child is a return: _ZNKSt5ctypeIcE5widenEc.exit
work live:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
mark live:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
work live:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
mark live:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
work live:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
mark live:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
work live:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
work live:   ret i8 %retval.0.i
mark live:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
work live:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
mark live:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
mark block live: if.then.i4
mark live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
work live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
work live:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
mark live:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
work live:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
mark live:   %idxprom.i = zext i8 %__c to i64
work live:   %idxprom.i = zext i8 %__c to i64
work live:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
mark live:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
work live:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
mark live:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
work live:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
mark live:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
work live:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
mark live:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
work live:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
work live:   br label %_ZNKSt5ctypeIcE5widenEc.exit
work live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
work live:   unreachable
work live:   tail call void @_ZSt16__throw_bad_castv() #15
new live blocks:
	if.then.i
	if.end.i
	_ZNKSt5ctypeIcE5widenEc.exit
	_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
	entry
	if.then.i4
dead terminator blocks:
	_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
live control in: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
mark live:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
work live:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
mark live:   %tobool.not.i3 = icmp eq i8 %1, 0
work live:   %tobool.not.i3 = icmp eq i8 %1, 0
mark live:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
work live:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
mark live:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
work live:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: ADD:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: ADD:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: ADD:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: ADD:   ret i8 %retval.0.i
IC: ADD:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: ADD:   %idxprom.i = zext i8 %__c to i64
IC: ADD:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: ADD:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: ADD:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: ADD:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: ADD:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %_M_ctype = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %this, i64 0, i32 5
IC: Visiting:   %0 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype, align 8, !tbaa !2
IC: Visiting:   %tobool.not.i = icmp eq %"class.std::ctype"* %0, null
IC: Visiting:   br i1 %tobool.not.i, label %if.then.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 8
IC: Visiting:   %1 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !8
IC: Visiting:   %tobool.not.i3 = icmp eq i8 %1, 0
IC: Visiting:   br i1 %tobool.not.i3, label %if.end.i, label %if.then.i4
IC: Visiting:   %idxprom.i = zext i8 %__c to i64
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %0, i64 0, i32 9, i64 %idxprom.i
IC: Visiting:   %2 = load i8, i8* %arrayidx.i, align 1, !tbaa !10
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %2, %if.then.i4 ], [ %call.i, %if.end.i ]
IC: Visiting:   ret i8 %retval.0.i
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %0)
IC: Visiting:   %3 = bitcast %"class.std::ctype"* %0 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %3, align 8, !tbaa !11
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i, i64 6
IC: Visiting:   %4 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i = tail call signext i8 %4(%"class.std::ctype"* nonnull dereferenceable(570) %0, i8 signext %__c)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc'<<0x7fffc1c8cba0>>  #uses=2
  CS<0x7fffc0cfaae0> calls function '_ZSt16__throw_bad_castv'
  CS<0x7fffc1d73a50> calls external node
  CS<0x7fffc14f2410> calls function '_ZNKSt5ctypeIcE13_M_widen_initEv'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZNSo3putEc: 0 call sites.
Inliner visiting SCC: _ZNSo5flushEv: 0 call sites.
Inliner visiting SCC: _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_: 0 call sites.
SROA function: _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'
LVI Getting block end value   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) at 'entry'
PUSH:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) in entry
POP   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) in entry = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>


INSTCOMBINE ITERATION #1 on _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ ----

Computing probabilities for entry

block-frequency: _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
============================================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   %call = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
Calculated Rank[__os] = 3


INSTCOMBINE ITERATION #1 on _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
SROA function: _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
Instruction Merger
GVN iteration: 0
SCCP on function '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os

Popped off OI-WL: %"class.std::basic_ostream"* %__os
Merged overdefined into   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) : overdefined

Popped off OI-WL:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)

Popped off BBWL: 
entry:
  %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
  ret %"class.std::basic_ostream"* %call

RESOLVING UNDEFs
DemandedBits: Root:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
DemandedBits: Root:   ret %"class.std::basic_ostream"* %call
DemandedBits: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)


INSTCOMBINE ITERATION #1 on _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
Jump threading on function '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'
LVI Getting block end value   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) at 'entry'
PUSH:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) in entry
POP   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os) in entry = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
mark block live: entry
mark live:   ret %"class.std::basic_ostream"* %call
post-dom root child is a return: entry
work live:   ret %"class.std::basic_ostream"* %call
work live:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   ret %"class.std::basic_ostream"* %call
IC: ADD:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   %call = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os)
IC: Visiting:   ret %"class.std::basic_ostream"* %call
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'<<0x7fffc1c91f40>>  #uses=2
  CS<0x7fffc1c8c790> calls function '_ZNSo5flushEv'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_: 2 call sites.
      Analyzing call of _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc... (caller:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
      NumConstantArgs: 1
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 11
      NumInstructions: 23
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 85
      Threshold: 225
    Inlining (cost=85, threshold=225), Call:   %call = call signext i8 @_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc(%"class.std::basic_ios"* nonnull dereferenceable(264) %3, i8 signext 10)
      Analyzing call of _ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_... (caller:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 1
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 2
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: 0
      Threshold: 487
    Inlining (cost=0, threshold=487), Call:   %call2 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call1)
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'<<0x7fffc1c8d260>>  #uses=1
  CS<0x7fffc14f1940> calls function '_ZNKSt5ctypeIcE13_M_widen_initEv'
  CS<0x7fffc1c8cf40> calls function '_ZNSo3putEc'
  CS<0x7fffc1c6bab0> calls function '_ZNSo5flushEv'
  CS<0x7fffc1d73850> calls function '_ZSt16__throw_bad_castv'
  CS<0x7fffc0fca110> calls external node

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
EarlyCSE CVP: Add conditional value for 'tobool.not.i.i' as i1 true in if.then.i.i
EarlyCSE CVP: Add conditional value for 'tobool.not.i.i' as i1 false in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
EarlyCSE CVP: Add conditional value for 'tobool.not.i3.i' as i1 true in if.end.i.i
EarlyCSE CVP: Add conditional value for 'tobool.not.i3.i' as i1 false in if.then.i4.i
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'
LVI Getting value   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !5 at ''
  Result = overdefined
LVI Getting block end value   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !5 at 'entry'
PUSH:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !5 in entry
 compute BB 'entry' - unknown inst def found.
POP   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !5 in entry = overdefined
  Result = overdefined
LVI Getting value   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 at ''
  Result = overdefined
LVI Getting block end value   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i'
PUSH:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i' - unknown inst def found.
POP   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i = overdefined
  Result = overdefined
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting block end value   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 5 at 'entry'
PUSH:   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 5 in entry
POP   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 5 in entry = notconstant<%"class.std::ctype"** null>
  Result = notconstant<%"class.std::ctype"** null>
LVI Getting block end value   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !5 at 'entry'
  Result = overdefined
LVI Getting block end value   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i'
PUSH:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
POP   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i'
  Result = overdefined
LVI Getting block end value   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)*** at 'if.end.i.i'
PUSH:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)*** in if.end.i.i
 compute BB 'if.end.i.i' - unknown inst def found.
POP   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)*** in if.end.i.i = overdefined
  Result = overdefined
LVI Getting block end value   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6 at 'if.end.i.i'
PUSH:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6 in if.end.i.i
POP   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6 in if.end.i.i = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 from 'if.then.i4.i' to '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit'
PUSH:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 in if.then.i4.i
 compute BB 'if.then.i4.i' - unknown inst def found.
POP   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 in if.then.i4.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) from 'if.end.i.i' to '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit'
PUSH:   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) in if.end.i.i
 compute BB 'if.end.i.i' - unknown inst def found.
POP   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) in if.end.i.i = overdefined
  Result = overdefined
LVI Getting block end value   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1) at '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit'
PUSH:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1) in _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
POP   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1) in _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>
LVI Getting block end value   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10 at 'if.then.i4.i'
PUSH:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10 in if.then.i4.i
POP   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10 in if.then.i4.i = notconstant<i8* null>
  Result = notconstant<i8* null>


INSTCOMBINE ITERATION #1 on _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: ADD:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: ADD:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: ADD:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: ADD:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: ADD:   ret %"class.std::basic_ostream"* %call.i
IC: ADD:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: ADD:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: ADD:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: ADD:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: ADD:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: ADD:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: ADD:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: ADD:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %_M_ctype.i, align 8, !tbaa !5
IC: ADD:   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 5
IC: ADD:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 5
IC: ADD DEFERRED:   %4 = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: Old =   %4 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 5
    New =   <badref> = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %4 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ERASE   %5 = getelementptr inbounds %"class.std::basic_ios", %"class.std::basic_ios"* %3, i64 0, i32 5
IC: ADD DEFERRED:   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ERASE   %3 = bitcast i8* %add.ptr to %"class.std::basic_ios"*
IC: ADD DEFERRED:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: Visiting:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: Visiting:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: Visiting:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: Visiting:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: Visiting:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: Visiting:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: Visiting:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: Visiting:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: Visiting:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: Visiting:   ret %"class.std::basic_ostream"* %call.i
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: Visiting:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: Visiting:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: Visiting:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: Visiting:   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable


INSTCOMBINE ITERATION #2 on _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   unreachable
IC: ADD:   call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: ADD:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: ADD:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: ADD:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: ADD:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: ADD:   ret %"class.std::basic_ostream"* %call.i
IC: ADD:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: ADD:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: ADD:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: ADD:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: ADD:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: ADD:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: ADD:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: ADD:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: ADD:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: Visiting:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: Visiting:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: Visiting:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: Visiting:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: Visiting:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: Visiting:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: Visiting:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: Visiting:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: Visiting:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: Visiting:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: Visiting:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: Visiting:   ret %"class.std::basic_ostream"* %call.i
IC: Visiting:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: Visiting:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: Visiting:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: Visiting:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: Visiting:   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
		Looking for trivial roots
Found a new trivial root: %if.then.i.i
Last visited node: %entry
Found a new trivial root: %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
Last visited node: %if.then.i4.i
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.then.i.i
3: %entry
4: %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
5: %if.end.i.i
6: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
7: %if.then.i4.i
Found roots: %if.then.i.i %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit 
---- Branch Probability Info : _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ ----

Computing probabilities for if.then.i.i
Computing probabilities for _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
Computing probabilities for if.end.i.i
Computing probabilities for if.then.i4.i
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge entry -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%

block-frequency: _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
===========================================================================
reverse-post-order-traversal
 - 0: entry
 - 1: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
 - 2: if.then.i4.i
 - 3: if.end.i.i
 - 4: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
 - 5: if.then.i.i
loop-detection
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2048, succ = if.then.i.i
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
  => assign 0000100000000000 (0000000000000000) to if.then.i.i
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
  => [ local  ] weight = 805306368, succ = if.end.i.i
  => [ local  ] weight = 1342177280, succ = if.then.i4.i
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to if.then.i4.i
  => assign 5ffffa0000000000 (0000000000000000) to if.end.i.i
 - node: if.then.i4.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
 - node: if.end.i.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
 - node: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
  => mass:  ffffefffffffffff
 - node: if.then.i.i
  => mass:  0000100000000000
float-to-int: min = 0.0000009536743164, max = 1.0, factor = 8388608.0
 - entry: float = 1.0, scaled = 8388608.0, int = 8388607
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i: float = 0.9999990463, scaled = 8388600.0, int = 8388599
 - if.then.i4.i: float = 0.624999404, scaled = 5242875.0, int = 5242874
 - if.end.i.i: float = 0.3749996424, scaled = 3145725.0, int = 3145724
 - _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit: float = 0.9999990463, scaled = 8388600.0, int = 8388599
 - if.then.i.i: float = 0.0000009536743164, scaled = 8.0, int = 8
block-frequency-info: _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
 - entry: float = 1.0, int = 8388607
 - if.then.i.i: float = 0.00000095367, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i: float = 1.0, int = 8388599
 - if.then.i4.i: float = 0.625, int = 5242874
 - if.end.i.i: float = 0.375, int = 3145724
 - _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit: float = 1.0, int = 8388599

Marked as tail call candidate:   %call1 = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
Marked as tail call candidate:   %call.i = call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
Marked as tail call candidate:   call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
Marked as tail call candidate:   %call.i.i = call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
Marked as tail call candidate:   call void @_ZSt16__throw_bad_castv() #15
Calculated Rank[__os] = 3


INSTCOMBINE ITERATION #1 on _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: ADD:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: ADD:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: ADD:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: ADD:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: ADD:   ret %"class.std::basic_ostream"* %call.i
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: ADD:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: ADD:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: ADD:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: ADD:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: ADD:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: ADD:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: ADD:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: ADD:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: Visiting:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: Visiting:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: Visiting:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: Visiting:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: Visiting:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: Visiting:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: Visiting:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: Visiting:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: Visiting:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: Visiting:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: Visiting:   ret %"class.std::basic_ostream"* %call.i
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: Visiting:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: Visiting:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: Visiting:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: Visiting:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
SROA function: _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
Instruction Merger
GVN iteration: 0
GVN: load i8* %vtable has unknown dependence
GVN: load i64 %vbase.offset has unknown dependence
GVN: load %"class.std::ctype"* %4 has unknown dependence
GVN: non-local load i8 %5 has unknown dependencies
GVN: non-local load i8 %6 has unknown dependencies
GVN: load i8 (%"class.std::ctype"*, i8)** %vtable.i.i is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
GVN: load i8 (%"class.std::ctype"*, i8)* %8 is clobbered by   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
SCCP on function '_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'
Marking Block Executable: entry
markOverdefined: %"class.std::basic_ostream"* %__os

Popped off OI-WL: %"class.std::basic_ostream"* %__os
markOverdefined:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
markOverdefined:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**

Popped off OI-WL:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
Merged overdefined into   %vtable = load i8*, i8** %0, align 8, !tbaa !2 : overdefined

Popped off OI-WL:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
markOverdefined:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24

Popped off OI-WL:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
markOverdefined:   %1 = bitcast i8* %vbase.offset.ptr to i64*

Popped off OI-WL:   %1 = bitcast i8* %vbase.offset.ptr to i64*
Merged overdefined into   %vbase.offset = load i64, i64* %1, align 8 : overdefined

Popped off OI-WL:   %vbase.offset = load i64, i64* %1, align 8
markOverdefined:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset

Popped off OI-WL:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
markOverdefined:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240

Popped off OI-WL:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
markOverdefined:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**

Popped off OI-WL:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
Merged overdefined into   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5 : overdefined

Popped off OI-WL:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
markOverdefined:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null

Popped off OI-WL:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
Marking Block Executable: if.then.i.i
Marking Block Executable: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i

Popped off OI-WL:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*

Popped off BBWL: 
_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i:  ; preds = %entry
  %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
  %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
  %tobool.not.i3.i = icmp eq i8 %5, 0
  br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i

markOverdefined:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
Merged overdefined into   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 : overdefined
markOverdefined:   %tobool.not.i3.i = icmp eq i8 %5, 0
Marking Block Executable: if.end.i.i
Marking Block Executable: if.then.i4.i

Popped off BBWL: 
if.then.i4.i:                                     ; preds = %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
  %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
  %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
  br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit

markOverdefined:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
Merged overdefined into   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 : overdefined
Marking Block Executable: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit

Popped off BBWL: 
_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit: ; preds = %if.then.i4.i, %if.end.i.i
  %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
  %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
  %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
  ret %"class.std::basic_ostream"* %call.i

Merged overdefined into   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ] : overdefined
Merged overdefined into   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i) : overdefined
Merged overdefined into   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1) : overdefined

Popped off BBWL: 
if.end.i.i:                                       ; preds = %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
  tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
  %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
  %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
  %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
  %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
  %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
  br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit

markOverdefined:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
Merged overdefined into   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2 : overdefined
markOverdefined:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
Merged overdefined into   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8 : overdefined
Merged overdefined into   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) : overdefined
Marking Edge Executable: if.end.i.i -> _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit

Popped off BBWL: 
if.then.i.i:                                      ; preds = %entry
  tail call void @_ZSt16__throw_bad_castv() #15
  unreachable


Popped off BBWL: 
entry:
  %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
  %vtable = load i8*, i8** %0, align 8, !tbaa !2
  %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
  %1 = bitcast i8* %vbase.offset.ptr to i64*
  %vbase.offset = load i64, i64* %1, align 8
  %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
  %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
  %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
  %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
  %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
  br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i


Popped off OI-WL:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)

Popped off OI-WL:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8

Popped off OI-WL:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6

Popped off OI-WL:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2

Popped off OI-WL:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***

Popped off OI-WL:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)

Popped off OI-WL:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)

Popped off OI-WL:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]

Popped off OI-WL:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12

Popped off OI-WL:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10

Popped off OI-WL:   %tobool.not.i3.i = icmp eq i8 %5, 0

Popped off OI-WL:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10

Popped off OI-WL:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
RESOLVING UNDEFs
DemandedBits: Root:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
DemandedBits: Root:   tail call void @_ZSt16__throw_bad_castv() #15
DemandedBits: Root:   unreachable
DemandedBits: Root:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
DemandedBits: Root:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
DemandedBits: Root:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
DemandedBits: Root:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
DemandedBits: Root:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
DemandedBits: Root:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
DemandedBits: Root:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
DemandedBits: Root:   ret %"class.std::basic_ostream"* %call.i
DemandedBits: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
DemandedBits: Visiting:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
DemandedBits: Visiting:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ] Alive Out: 0xff
DemandedBits: Visiting:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 Alive Out: 0xff
DemandedBits: Visiting:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
DemandedBits: Visiting:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) Alive Out: 0xff
DemandedBits: Visiting:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
DemandedBits: Visiting:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
DemandedBits: Visiting:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
DemandedBits: Visiting:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
DemandedBits: Visiting:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
DemandedBits: Visiting:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
DemandedBits: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
DemandedBits: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
DemandedBits: Visiting:   %vbase.offset = load i64, i64* %1, align 8 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
DemandedBits: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
DemandedBits: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
DemandedBits: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
DemandedBits: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
DemandedBits: Visiting:   %tobool.not.i3.i = icmp eq i8 %5, 0 Alive Out: 0x1
DemandedBits: Visiting:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 Alive Out: 0xff
DemandedBits: Visiting:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
DemandedBits: Visiting:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null Alive Out: 0x1


INSTCOMBINE ITERATION #1 on _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: ADD:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: ADD:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: ADD:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: ADD:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: ADD:   ret %"class.std::basic_ostream"* %call.i
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: ADD:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: ADD:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: ADD:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: ADD:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: ADD:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: ADD:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: ADD:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: ADD:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: Visiting:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: Visiting:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: Visiting:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: Visiting:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: Visiting:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: Visiting:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: Visiting:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: Visiting:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: Visiting:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: Visiting:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: Visiting:   ret %"class.std::basic_ostream"* %call.i
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: Visiting:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: Visiting:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: Visiting:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: Visiting:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
Jump threading on function '_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'
LVI Getting value   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5 at ''
  Result = overdefined
LVI Getting block end value   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5 at 'entry'
PUSH:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5 in entry
 compute BB 'entry' - unknown inst def found.
POP   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5 in entry = overdefined
  Result = overdefined
LVI Getting value   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 at ''
  Result = overdefined
LVI Getting block end value   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i'
PUSH:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
 compute BB '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i' - unknown inst def found.
POP   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i = overdefined
  Result = overdefined
LVI Getting block end value   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** at 'entry'
PUSH:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry
POP   %0 = bitcast %"class.std::basic_ostream"* %__os to i8** in entry = notconstant<i8** null>
  Result = notconstant<i8** null>
LVI Getting block end value   %1 = bitcast i8* %vbase.offset.ptr to i64* at 'entry'
PUSH:   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry
 compute BB 'entry' - unknown inst def found.
POP   %1 = bitcast i8* %vbase.offset.ptr to i64* in entry = overdefined
  Result = overdefined
LVI Getting block end value   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"** at 'entry'
PUSH:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"** in entry
POP   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"** in entry = notconstant<%"class.std::ctype"** null>
  Result = notconstant<%"class.std::ctype"** null>
LVI Getting block end value   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5 at 'entry'
  Result = overdefined
LVI Getting block end value   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i'
PUSH:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
POP   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8 in _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i = notconstant<i8* null>
  Result = notconstant<i8* null>
LVI Getting block end value   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10 at '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i'
  Result = overdefined
LVI Getting block end value   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)*** at 'if.end.i.i'
PUSH:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)*** in if.end.i.i
 compute BB 'if.end.i.i' - unknown inst def found.
POP   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)*** in if.end.i.i = overdefined
  Result = overdefined
LVI Getting block end value   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6 at 'if.end.i.i'
PUSH:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6 in if.end.i.i
POP   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6 in if.end.i.i = notconstant<i8 (%"class.std::ctype"*, i8)** null>
  Result = notconstant<i8 (%"class.std::ctype"*, i8)** null>
LVI Getting edge value   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 from 'if.then.i4.i' to '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit'
PUSH:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 in if.then.i4.i
 compute BB 'if.then.i4.i' - unknown inst def found.
POP   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12 in if.then.i4.i = overdefined
  Result = overdefined
LVI Getting edge value   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) from 'if.end.i.i' to '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit'
PUSH:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) in if.end.i.i
 compute BB 'if.end.i.i' - unknown inst def found.
POP   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10) in if.end.i.i = overdefined
  Result = overdefined
LVI Getting block end value   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1) at '_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit'
PUSH:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1) in _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
POP   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1) in _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit = notconstant<%"class.std::basic_ostream"* null>
  Result = notconstant<%"class.std::basic_ostream"* null>
LVI Getting block end value   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10 at 'if.then.i4.i'
PUSH:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10 in if.then.i4.i
POP   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10 in if.then.i4.i = notconstant<i8* null>
  Result = notconstant<i8* null>
		Looking for trivial roots
Found a new trivial root: %if.then.i.i
Last visited node: %entry
Found a new trivial root: %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
Last visited node: %if.then.i4.i
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.then.i.i
3: %entry
4: %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
5: %if.end.i.i
6: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
7: %if.then.i4.i
Found roots: %if.then.i.i %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit 
mark live:   tail call void @_ZSt16__throw_bad_castv() #15
mark block live: if.then.i.i
mark live:   unreachable
mark live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
mark block live: if.end.i.i
mark live:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
mark live:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
mark live:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
mark block live: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
mark live:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
mark live:   ret %"class.std::basic_ostream"* %call.i
mark live:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
mark block live: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
mark block live: entry
post-dom root child is a return: _ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
work live:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
mark live:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
work live:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
mark live:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
work live:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
mark live:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
work live:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
mark live:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
work live:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
mark live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
work live:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
mark live:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
mark live:   %vbase.offset = load i64, i64* %1, align 8
work live:   %vbase.offset = load i64, i64* %1, align 8
mark live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
work live:   %1 = bitcast i8* %vbase.offset.ptr to i64*
mark live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
work live:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
mark live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
work live:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
mark live:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
work live:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
work live:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
work live:   ret %"class.std::basic_ostream"* %call.i
work live:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
work live:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
mark live:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
work live:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
mark live:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
mark block live: if.then.i4.i
mark live:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
work live:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
work live:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
mark live:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
work live:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
work live:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
mark live:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
work live:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
mark live:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
work live:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
mark live:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
work live:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
mark live:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
work live:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
work live:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
work live:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
work live:   unreachable
work live:   tail call void @_ZSt16__throw_bad_castv() #15
new live blocks:
	if.then.i.i
	if.end.i.i
	_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
	_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
	entry
	if.then.i4.i
dead terminator blocks:
	_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
live control in: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
mark live:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
work live:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
mark live:   %tobool.not.i3.i = icmp eq i8 %5, 0
work live:   %tobool.not.i3.i = icmp eq i8 %5, 0
mark live:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
work live:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
mark live:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
work live:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #15
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: ADD:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: ADD:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: ADD:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: ADD:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: ADD:   ret %"class.std::basic_ostream"* %call.i
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: ADD:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: ADD:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: ADD:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: ADD:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: ADD:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: ADD:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: ADD:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: ADD:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: ADD:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: ADD:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: ADD:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: ADD:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: ADD:   %vbase.offset = load i64, i64* %1, align 8
IC: ADD:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: ADD:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: ADD:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: ADD:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %0 = bitcast %"class.std::basic_ostream"* %__os to i8**
IC: Visiting:   %vtable = load i8*, i8** %0, align 8, !tbaa !2
IC: Visiting:   %vbase.offset.ptr = getelementptr i8, i8* %vtable, i64 -24
IC: Visiting:   %1 = bitcast i8* %vbase.offset.ptr to i64*
IC: Visiting:   %vbase.offset = load i64, i64* %1, align 8
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %__os to i8*
IC: Visiting:   %add.ptr = getelementptr inbounds i8, i8* %2, i64 %vbase.offset
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %add.ptr, i64 240
IC: Visiting:   %3 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %4 = load %"class.std::ctype"*, %"class.std::ctype"** %3, align 8, !tbaa !5
IC: Visiting:   %tobool.not.i.i = icmp eq %"class.std::ctype"* %4, null
IC: Visiting:   br i1 %tobool.not.i.i, label %if.then.i.i, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit.i
IC: Visiting:   %_M_widen_ok.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 8
IC: Visiting:   %5 = load i8, i8* %_M_widen_ok.i.i, align 8, !tbaa !10
IC: Visiting:   %tobool.not.i3.i = icmp eq i8 %5, 0
IC: Visiting:   br i1 %tobool.not.i3.i, label %if.end.i.i, label %if.then.i4.i
IC: Visiting:   %arrayidx.i.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %4, i64 0, i32 9, i64 10
IC: Visiting:   %6 = load i8, i8* %arrayidx.i.i, align 1, !tbaa !12
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   %retval.0.i.i = phi i8 [ %6, %if.then.i4.i ], [ %call.i.i, %if.end.i.i ]
IC: Visiting:   %call1 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %__os, i8 signext %retval.0.i.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1)
IC: Visiting:   ret %"class.std::basic_ostream"* %call.i
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %4)
IC: Visiting:   %7 = bitcast %"class.std::ctype"* %4 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i.i = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %7, align 8, !tbaa !2
IC: Visiting:   %vfn.i.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i.i, i64 6
IC: Visiting:   %8 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i.i, align 8
IC: Visiting:   %call.i.i = tail call signext i8 %8(%"class.std::ctype"* nonnull dereferenceable(570) %4, i8 signext 10)
IC: Visiting:   br label %_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #15
IC: Visiting:   unreachable
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_'<<0x7fffc1c8d260>>  #uses=1
  CS<0x7fffc14f1940> calls function '_ZNKSt5ctypeIcE13_M_widen_initEv'
  CS<0x7fffc1c8cf40> calls function '_ZNSo3putEc'
  CS<0x7fffc1c6bab0> calls function '_ZNSo5flushEv'
  CS<0x7fffc1d73850> calls function '_ZSt16__throw_bad_castv'
  CS<0x7fffc0fca110> calls external node

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: __cxx_global_var_init: 0 call sites.
SROA function: __cxx_global_var_init
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '__cxx_global_var_init'


INSTCOMBINE ITERATION #1 on __cxx_global_var_init
IC: ADD:   ret void
IC: ADD:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : __cxx_global_var_init ----

Computing probabilities for entry

block-frequency: __cxx_global_var_init
======================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: __cxx_global_var_init
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
Marked as tail call candidate:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15


INSTCOMBINE ITERATION #1 on __cxx_global_var_init
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
SROA function: __cxx_global_var_init
Instruction Merger
GVN iteration: 0
SCCP on function '__cxx_global_var_init'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
  ret void

Merged overdefined into   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15 : overdefined

Popped off OI-WL:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
RESOLVING UNDEFs
DemandedBits: Root:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
DemandedBits: Root:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
DemandedBits: Root:   ret void
DemandedBits: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15 Alive Out: 0x0


INSTCOMBINE ITERATION #1 on __cxx_global_var_init
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
Jump threading on function '__cxx_global_var_init'
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
mark block live: entry
mark live:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
mark live:   ret void
post-dom root child is a return: entry
work live:   ret void
work live:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
work live:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on __cxx_global_var_init
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '__cxx_global_var_init'<<0x7fffc1c88d70>>  #uses=1
  CS<0x7fffc1701aa0> calls function '_ZNSt8ios_base4InitC1Ev'
  CS<0x7fffc166d8b0> calls function '__cxa_atexit'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: _GLOBAL__sub_I_Simpson.cpp: 1 call sites.
      Analyzing call of __cxx_global_var_init... (caller:_GLOBAL__sub_I_Simpson.cpp)
      NumConstantArgs: 0
      NumConstantOffsetPtrArgs: 0
      NumAllocaArgs: 0
      NumConstantPtrCmps: 0
      NumConstantPtrDiffs: 0
      NumInstructionsSimplified: 1
      NumInstructions: 3
      SROACostSavings: 0
      SROACostSavingsLost: 0
      LoadEliminationCost: 0
      ContainsNoDuplicateCall: 0
      Cost: -14950
      Threshold: 337
    Inlining (cost=-14950, threshold=337), Call:   call fastcc void @__cxx_global_var_init()
    -> Deleting dead function: __cxx_global_var_init
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_GLOBAL__sub_I_Simpson.cpp'<<0x7fffc1c87760>>  #uses=1
  CS<0x7fffc14f1850> calls function '__cxa_atexit'
  CS<0x7fffc1d475d0> calls function '_ZNSt8ios_base4InitC1Ev'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
SROA function: _GLOBAL__sub_I_Simpson.cpp
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
Jump threading on function '_GLOBAL__sub_I_Simpson.cpp'


INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _GLOBAL__sub_I_Simpson.cpp ----

Computing probabilities for entry

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - entry: float = 1.0, int = 8

Marked as tail call candidate:   call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
Marked as tail call candidate:   %0 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15


INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
SROA function: _GLOBAL__sub_I_Simpson.cpp
Instruction Merger
GVN iteration: 0
SCCP on function '_GLOBAL__sub_I_Simpson.cpp'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
  ret void

Merged overdefined into   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15 : overdefined

Popped off OI-WL:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
RESOLVING UNDEFs
DemandedBits: Root:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
DemandedBits: Root:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
DemandedBits: Root:   ret void
DemandedBits: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15 Alive Out: 0x0


INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
Jump threading on function '_GLOBAL__sub_I_Simpson.cpp'
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
mark block live: entry
mark live:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
mark live:   ret void
post-dom root child is a return: entry
work live:   ret void
work live:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
work live:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
final dead terminator blocks: 
Trying to eliminate MemoryDefs at the end of the function


INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #15
IC: Visiting:   ret void
CGSCCPASSMGR: Pass Dirtied SCC: Function Pass Manager
CGSCCPASSMGR: Refreshing SCC with 1 nodes:
Call graph node for function: '_GLOBAL__sub_I_Simpson.cpp'<<0x7fffc1c87760>>  #uses=1
  CS<0x7fffc14f1850> calls function '__cxa_atexit'
  CS<0x7fffc1d475d0> calls function '_ZNSt8ios_base4InitC1Ev'

CGSCCPASSMGR: SCC Refresh didn't change call graph.
Inliner visiting SCC: INDIRECTNODE: 0 call sites.
GLOBAL DEAD: declare dso_local void @_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate(%"class.std::basic_ios"* nonnull dereferenceable(264), i32) local_unnamed_addr #2

GLOBAL DEAD: ; Function Attrs: argmemonly nofree nounwind readonly willreturn
declare dso_local i64 @strlen(i8* nocapture) local_unnamed_addr #7

Optimizing Global Constructor: ; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_Simpson.cpp() #8 section ".text.startup" {
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
  ret void
}

Trying to evaluate BB: 
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
  ret void

Evaluating Instruction:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
Can not constant fold function call.
Optimizing Global Constructor: ; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_Simpson.cpp() #8 section ".text.startup" {
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
  ret void
}

Trying to evaluate BB: 
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
  ret void

Evaluating Instruction:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
Can not constant fold function call.
Optimizing Global Constructor: ; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_Simpson.cpp() #8 section ".text.startup" {
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
  ret void
}

F2I: Looking at function _Z7simpsonPFddEddi
LoopSimplify: Creating pre-header for.body.preheader
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %entry
4: %for.end.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.end 
---- Branch Probability Info : _Z7simpsonPFddEddi ----

Computing probabilities for for.end
Computing probabilities for for.end.loopexit
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.preheader
Computing probabilities for entry

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.body
 - 3: for.end.loopexit
 - 4: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = for.body.preheader
  => [ local  ] weight = 1073741824, succ = for.end
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.preheader
  => assign 8000000000000000 (0000000000000000) to for.end
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit
 - node: for.end.loopexit
  => [ local  ] weight = 2147483648, succ = for.end
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - for.body: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - for.body.preheader: float = 0.5, scaled = 8.0, int = 8
 - for.body: float = 16.0, scaled = 256.0, int = 255
 - for.end.loopexit: float = 0.5, scaled = 8.0, int = 8
 - for.end: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - entry: float = 1.0, int = 16
 - for.body.preheader: float = 0.5, int = 8
 - for.body: float = 16.0, int = 255
 - for.end.loopexit: float = 0.5, int = 8
 - for.end: float = 1.0, int = 16


LV: Checking a loop in "_Z7simpsonPFddEddi" from Simpson.cpp
LV: Loop hints: force=? width=0 unroll=0
LV: Found a loop: for.body
LV: Found an induction variable.
LV: Found an induction variable.
Found an FAdd reduction PHI.  %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
Found an FAdd reduction PHI.  %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
LV: Found FP op with unsafe algebra.
LV: Found FP op with unsafe algebra.
LV: Not vectorizing: Found a non-intrinsic callsite   %call6 = tail call double %f(double %add5)
LV: Interleaving disabled by the pass manager
LV: Can't vectorize the instructions or CFG
LV: Not vectorizing: Cannot prove legality.
LAA: Found a loop in _Z7simpsonPFddEddi: for.body

In "_Z7simpsonPFddEddi" checking Loop at depth 1 containing: %for.body<header><latch><exiting>



INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7.lcssa, 2.000000e+00
IC: ADD:   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD:   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: ADD:   br label %for.body
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   br label %for.body
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %add7.lcssa = phi double [ %add7, %for.body ]
IC: Replacing   %add7.lcssa = phi double [ %add7, %for.body ]
    with   %add7 = fadd double %sum_even.049, %call6
IC: Mod =   %add7.lcssa = phi double [ %add7, %for.body ]
    New =   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ERASE   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ADD DEFERRED:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: Replacing   %add12.lcssa = phi double [ %add12, %for.body ]
    with   %add12 = fadd double %sum_odd.050, %call11
IC: Mod =   %add12.lcssa = phi double [ %add12, %for.body ]
    New =   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ERASE   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD DEFERRED:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end


INSTCOMBINE ITERATION #2 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7, 2.000000e+00
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: ADD:   br label %for.body
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   br label %for.body
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end
Looking to fold for.body.preheader into for.body
Killing Trivial BB: 

for.body.preheader:                               ; preds = %entry
  br label %for.body
SLP: Analyzing blocks in _Z7simpsonPFddEddi.
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add19 = fadd double %sum_even.0.lcssa, %add17.
SLP: Need to extract:  %add19 = fadd double %sum_even.0.lcssa, %add17 from lane 0 from   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ].
SLP: Checking user:  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00.
SLP: Need to extract:  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00 from lane 1 from   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ].
SLP: Calculating cost for tree of size 3.
SLP: Adding cost 0 for bundle that starts with   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ].
SLP: Current total cost = 0
SLP: Adding cost 1 for bundle that starts with double 0.000000e+00.
SLP: Current total cost = 1
SLP: Adding cost 1 for bundle that starts with   %phi.bo = fmul double %add7, 2.000000e+00.
SLP: Current total cost = 2
SLP: #LV: 0, Looking at   %phi.bo = fmul double %add7, 2.000000e+00
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 3.
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
SLP:  initialize schedule region to   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
SLP:  extend schedule region start to   %add19 = fadd double %sum_even.0.lcssa, %add17
SLP: try schedule bundle [  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00;  %add19 = fadd double %sum_even.0.lcssa, %add17] in block for.end
SLP:       update deps of [  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00;  %add19 = fadd double %sum_even.0.lcssa, %add17]
SLP:       update deps of /   %add19 = fadd double %sum_even.0.lcssa, %add17
SLP:     gets ready on update:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add21 = fadd double %mul20, %add19.
SLP: Need to extract:  %add21 = fadd double %mul20, %add19 from lane 0 from   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00.
SLP: Checking user:  %add21 = fadd double %mul20, %add19.
SLP: Need to extract:  %add21 = fadd double %mul20, %add19 from lane 1 from   %add19 = fadd double %sum_even.0.lcssa, %add17.
SLP: Checking user:  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00.
SLP: 	Internal user will be removed:  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00.
SLP: Checking user:  %add19 = fadd double %sum_even.0.lcssa, %add17.
SLP: 	Internal user will be removed:  %add19 = fadd double %sum_even.0.lcssa, %add17.
SLP: Calculating cost for tree of size 5.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
    %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
Operand 1:
  double 4.000000e+00
    %add17 = fadd double %call15, %call16
Scalars: 
    %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
    %add19 = fadd double %sum_even.0.lcssa, %add17
State: Vectorize
MainOp:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
AltOp:   %add19 = fadd double %sum_even.0.lcssa, %add17
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 5
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 1
SLP: Adding cost 1 for bundle that starts with   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00.
SLP: Current total cost = 1
SLP: Adding cost 0 for bundle that starts with   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ].
SLP: Current total cost = 1
SLP: Adding cost 1 for bundle that starts with   %call = tail call double %f(double %add2).
SLP: Current total cost = 2
SLP: Adding cost 1 for bundle that starts with   %add12 = fadd double %sum_odd.050, %call11.
SLP: Current total cost = 3
SLP: Adding cost 1 for bundle that starts with double 4.000000e+00.
SLP: Current total cost = 4
SLP: #LV: 1 sum_odd.0.lcssa, Looking at   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
SLP: #LV: 0, Looking at   %add12 = fadd double %sum_odd.050, %call11
SLP: #LV: 0, Looking at   %call = tail call double %f(double %add2)
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 5.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
SLP:  initialize schedule region to   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
SLP:  extend schedule region start to   %add17 = fadd double %call15, %call16
SLP: try schedule bundle [  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00;  %add17 = fadd double %call15, %call16] in block for.end
SLP:       update deps of [  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00;  %add17 = fadd double %call15, %call16]
SLP:       update deps of /   %add17 = fadd double %call15, %call16
SLP:       update deps of   %add19 = fadd double %sum_even.0.lcssa, %add17
SLP:     gets ready on update:   %add19 = fadd double %sum_even.0.lcssa, %add17
SLP:   schedule   %add19 = fadd double %sum_even.0.lcssa, %add17
SLP:    gets ready (def): [  %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00;  %add17 = fadd double %call15, %call16]
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add21 = fadd double %mul20, %add19.
SLP: Need to extract:  %add21 = fadd double %mul20, %add19 from lane 0 from   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00.
SLP: Checking user:  %add19 = fadd double %sum_even.0.lcssa, %add17.
SLP: Need to extract:  %add19 = fadd double %sum_even.0.lcssa, %add17 from lane 1 from   %add17 = fadd double %call15, %call16.
SLP: Calculating cost for tree of size 3.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
    %call15 = tail call double %f(double %a)
Operand 1:
  double 4.000000e+00
    %call16 = tail call double %f(double %b)
Scalars: 
    %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
    %add17 = fadd double %call15, %call16
State: Vectorize
MainOp:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
AltOp:   %add17 = fadd double %call15, %call16
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 5
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 1
SLP: Adding cost 1 for bundle that starts with   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00.
SLP: Current total cost = 1
SLP: Adding cost 1 for bundle that starts with   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ].
SLP: Current total cost = 2
SLP: Adding cost 1 for bundle that starts with double 4.000000e+00.
SLP: Current total cost = 3
SLP: #LV: 0, Looking at   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 4.
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %call15 = tail call double %f(double %a)
SLP:  initialize schedule region to   %call15 = tail call double %f(double %a)
SLP:  extend schedule region end to   %call16 = tail call double %f(double %b)
SLP: try schedule bundle [  %call15 = tail call double %f(double %a);  %call16 = tail call double %f(double %b)] in block for.end
SLP:       update deps of [  %call15 = tail call double %f(double %a);  %call16 = tail call double %f(double %b)]
SLP:       update deps of /   %call16 = tail call double %f(double %b)
SLP:  cancel scheduling of [  %call15 = tail call double %f(double %a);  %call16 = tail call double %f(double %b)]
SLP: We are not able to schedule this bundle!
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP:  bundle:   %add12 = fadd double %sum_odd.050, %call11
SLP:  initialize schedule region to   %add12 = fadd double %sum_odd.050, %call11
SLP:  extend schedule region start to   %add7 = fadd double %sum_even.049, %call6
SLP: try schedule bundle [  %add12 = fadd double %sum_odd.050, %call11;  %add7 = fadd double %sum_even.049, %call6] in block for.body
SLP:       update deps of [  %add12 = fadd double %sum_odd.050, %call11;  %add7 = fadd double %sum_even.049, %call6]
SLP:       update deps of /   %add7 = fadd double %sum_even.049, %call6
SLP:     gets ready on update:   %add12 = fadd double %sum_odd.050, %call11
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP: 	Checking bundle:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ].
SLP: Perfect diamond merge at   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ].
SLP:  bundle:   %call11 = tail call double %f(double %add10)
SLP:  extend schedule region start to   %call6 = tail call double %f(double %add5)
SLP: try schedule bundle [  %call11 = tail call double %f(double %add10);  %call6 = tail call double %f(double %add5)] in block for.body
SLP:       update deps of [  %call11 = tail call double %f(double %add10);  %call6 = tail call double %f(double %add5)]
SLP:       update deps of /   %call6 = tail call double %f(double %add5)
SLP:   schedule [  %add12 = fadd double %sum_odd.050, %call11;  %add7 = fadd double %sum_even.049, %call6]
SLP:  cancel scheduling of [  %call11 = tail call double %f(double %add10);  %call6 = tail call double %f(double %add5)]
SLP: We are not able to schedule this bundle!
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add12 = fadd double %sum_odd.050, %call11.
SLP: 	Internal user will be removed:  %add12 = fadd double %sum_odd.050, %call11.
SLP: Checking user:  %add7 = fadd double %sum_even.049, %call6.
SLP: 	Internal user will be removed:  %add7 = fadd double %sum_even.049, %call6.
SLP: Checking user:  %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ].
SLP: Need to extract:  %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ] from lane 0 from   %add12 = fadd double %sum_odd.050, %call11.
SLP: Checking user:  %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ].
SLP: 	Internal user will be removed:  %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ].
SLP: Checking user:  %phi.bo = fmul double %add7, 2.000000e+00.
SLP: Need to extract:  %phi.bo = fmul double %add7, 2.000000e+00 from lane 1 from   %add7 = fadd double %sum_even.049, %call6.
SLP: Checking user:  %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ].
SLP: 	Internal user will be removed:  %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ].
SLP: Calculating cost for tree of size 4.
SLP: Adding cost 0 for bundle that starts with   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ].
SLP: Current total cost = 0
SLP: Calculated costs for Tree:
1.
Operand 0:
    %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
    %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
Operand 1:
    %call11 = tail call double %f(double %add10)
    %call6 = tail call double %f(double %add5)
Scalars: 
    %add12 = fadd double %sum_odd.050, %call11
    %add7 = fadd double %sum_even.049, %call6
State: Vectorize
MainOp:   %add12 = fadd double %sum_odd.050, %call11
AltOp:   %add12 = fadd double %sum_odd.050, %call11
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -2
SLP: Adding cost -2 for bundle that starts with   %add12 = fadd double %sum_odd.050, %call11.
SLP: Current total cost = -2
SLP: Adding cost 1 for bundle that starts with   %call11 = tail call double %f(double %add10).
SLP: Current total cost = -1
SLP: Adding cost 1 for bundle that starts with   %call = tail call double %f(double %add2).
SLP: Current total cost = 0
SLP: #LV: 1 sum_odd.050, Looking at   %call11 = tail call double %f(double %add10)
SLP: #LV: 1 sum_odd.050, Looking at   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
SLP: #LV: 1 add12, Looking at   %call = tail call double %f(double %add2)
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 1.
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP:  bundle:   %add14 = add nuw nsw i32 %odd.052, 2
SLP:  initialize schedule region to   %add14 = add nuw nsw i32 %odd.052, 2
SLP:  extend schedule region start to   %add13 = add nuw nsw i32 %even.051, 2
SLP: try schedule bundle [  %add14 = add nuw nsw i32 %odd.052, 2;  %add13 = add nuw nsw i32 %even.051, 2] in block for.body
SLP:       update deps of [  %add14 = add nuw nsw i32 %odd.052, 2;  %add13 = add nuw nsw i32 %even.051, 2]
SLP:       update deps of /   %add13 = add nuw nsw i32 %even.051, 2
SLP:     gets ready on update:   %add14 = add nuw nsw i32 %odd.052, 2
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP: 	Checking bundle:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ].
SLP: Perfect diamond merge at   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ].
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %conv8 = sitofp i32 %odd.052 to double.
SLP: Need to extract:  %conv8 = sitofp i32 %odd.052 to double from lane 0 from   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ].
SLP: Checking user:  %add14 = add nuw nsw i32 %odd.052, 2.
SLP: 	Internal user will be removed:  %add14 = add nuw nsw i32 %odd.052, 2.
SLP: Checking user:  %add13 = add nuw nsw i32 %even.051, 2.
SLP: 	Internal user will be removed:  %add13 = add nuw nsw i32 %even.051, 2.
SLP: Checking user:  %conv3 = sitofp i32 %even.051 to double.
SLP: Need to extract:  %conv3 = sitofp i32 %even.051 to double from lane 1 from   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ].
SLP: Checking user:  %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ].
SLP: 	Internal user will be removed:  %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ].
SLP: Checking user:  %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ].
SLP: 	Internal user will be removed:  %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ].
SLP: Checking user:  %cmp = icmp slt i32 %add13, %mul.
SLP: Need to extract:  %cmp = icmp slt i32 %add13, %mul from lane 1 from   %add13 = add nuw nsw i32 %even.051, 2.
SLP: Calculating cost for tree of size 4.
SLP: Adding cost 0 for bundle that starts with   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ].
SLP: Current total cost = 0
SLP: Calculated costs for Tree:
1.
Operand 0:
    %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
    %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
Operand 1:
  i32 2
  i32 2
Scalars: 
    %add14 = add nuw nsw i32 %odd.052, 2
    %add13 = add nuw nsw i32 %even.051, 2
State: Vectorize
MainOp:   %add14 = add nuw nsw i32 %odd.052, 2
AltOp:   %add14 = add nuw nsw i32 %odd.052, 2
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Adding cost -1 for bundle that starts with   %add14 = add nuw nsw i32 %odd.052, 2.
SLP: Current total cost = -1
SLP: Adding cost 0 for bundle that starts with i32 2.
SLP: Current total cost = -1
SLP: Adding cost 0 for bundle that starts with i32 3.
SLP: Current total cost = -1
SLP: #LV: 1 odd.052, Looking at   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
SLP: Spill Cost = 0.
SLP: Extract Cost = 5.
SLP: Total Cost = 4.
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize a list of length = 2.


INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7, 2.000000e+00
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %entry ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %entry ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %entry ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %entry ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end
LoopSimplify: Creating pre-header for.body.preheader
Loop Unroll: F[_Z7simpsonPFddEddi] Loop %for.body
  Loop Size = 16
  will not try to unroll loop with runtime trip count -unroll-runtime not given


INSTCOMBINE ITERATION #1 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7.lcssa, 2.000000e+00
IC: ADD:   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD:   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: ADD:   br label %for.body
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   br label %for.body
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %add7.lcssa = phi double [ %add7, %for.body ]
IC: Replacing   %add7.lcssa = phi double [ %add7, %for.body ]
    with   %add7 = fadd double %sum_even.049, %call6
IC: Mod =   %add7.lcssa = phi double [ %add7, %for.body ]
    New =   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ERASE   %add7.lcssa = phi double [ %add7, %for.body ]
IC: ADD DEFERRED:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12.lcssa, %for.end.loopexit ]
IC: Replacing   %add12.lcssa = phi double [ %add12, %for.body ]
    with   %add12 = fadd double %sum_odd.050, %call11
IC: Mod =   %add12.lcssa = phi double [ %add12, %for.body ]
    New =   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ERASE   %add12.lcssa = phi double [ %add12, %for.body ]
IC: ADD DEFERRED:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end


INSTCOMBINE ITERATION #2 on _Z7simpsonPFddEddi
IC: ADD:   br label %for.end
IC: ADD:   %phi.bo = fmul double %add7, 2.000000e+00
IC: ADD:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: ADD:   %cmp = icmp slt i32 %add13, %mul
IC: ADD:   %add14 = add nuw nsw i32 %odd.052, 2
IC: ADD:   %add13 = add nuw nsw i32 %even.051, 2
IC: ADD:   %add12 = fadd double %sum_odd.050, %call11
IC: ADD:   %call11 = tail call double %f(double %add10)
IC: ADD:   %add10 = fadd double %mul9, %a
IC: ADD:   %mul9 = fmul double %div1, %conv8
IC: ADD:   %conv8 = sitofp i32 %odd.052 to double
IC: ADD:   %add7 = fadd double %sum_even.049, %call6
IC: ADD:   %call6 = tail call double %f(double %add5)
IC: ADD:   %add5 = fadd double %mul4, %a
IC: ADD:   %mul4 = fmul double %div1, %conv3
IC: ADD:   %conv3 = sitofp i32 %even.051 to double
IC: ADD:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: ADD:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: ADD:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: ADD:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: ADD:   br label %for.body
IC: ADD:   ret double %div23
IC: ADD:   %div23 = fdiv double %mul22, 3.000000e+00
IC: ADD:   %mul22 = fmul double %div1, %add21
IC: ADD:   %add21 = fadd double %mul20, %add19
IC: ADD:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: ADD:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: ADD:   %add17 = fadd double %call15, %call16
IC: ADD:   %call16 = tail call double %f(double %b)
IC: ADD:   %call15 = tail call double %f(double %a)
IC: ADD:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: ADD:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: ADD:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: ADD:   %cmp48 = icmp sgt i32 %n, 2
IC: ADD:   %call = tail call double %f(double %add2)
IC: ADD:   %add2 = fadd double %div1, %a
IC: ADD:   %div1 = fdiv double %sub, %conv
IC: ADD:   %conv = sitofp i32 %mul to double
IC: ADD:   %sub = fsub double %b, %a
IC: ADD:   %mul = shl nsw i32 %div, 1
IC: ADD:   %div = sdiv i32 %add, 2
IC: ADD:   %add = add nsw i32 %n, 1
IC: Visiting:   %add = add nsw i32 %n, 1
IC: Visiting:   %div = sdiv i32 %add, 2
IC: Visiting:   %mul = shl nsw i32 %div, 1
IC: Visiting:   %sub = fsub double %b, %a
IC: Visiting:   %conv = sitofp i32 %mul to double
IC: Visiting:   %div1 = fdiv double %sub, %conv
IC: Visiting:   %add2 = fadd double %div1, %a
IC: Visiting:   %call = tail call double %f(double %add2)
IC: Visiting:   %cmp48 = icmp sgt i32 %n, 2
IC: Visiting:   br i1 %cmp48, label %for.body.preheader, label %for.end
IC: Visiting:   %sum_even.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %phi.bo, %for.end.loopexit ]
IC: Visiting:   %sum_odd.0.lcssa = phi double [ %call, %entry ], [ %add12, %for.end.loopexit ]
IC: Visiting:   %call15 = tail call double %f(double %a)
IC: Visiting:   %call16 = tail call double %f(double %b)
IC: Visiting:   %add17 = fadd double %call15, %call16
IC: Visiting:   %add19 = fadd double %sum_even.0.lcssa, %add17
IC: Visiting:   %mul20 = fmul double %sum_odd.0.lcssa, 4.000000e+00
IC: Visiting:   %add21 = fadd double %mul20, %add19
IC: Visiting:   %mul22 = fmul double %div1, %add21
IC: Visiting:   %div23 = fdiv double %mul22, 3.000000e+00
IC: Visiting:   ret double %div23
IC: Visiting:   br label %for.body
IC: Visiting:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
IC: Visiting:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
IC: Visiting:   %sum_odd.050 = phi double [ %add12, %for.body ], [ %call, %for.body.preheader ]
IC: Visiting:   %sum_even.049 = phi double [ %add7, %for.body ], [ 0.000000e+00, %for.body.preheader ]
IC: Visiting:   %conv3 = sitofp i32 %even.051 to double
IC: Visiting:   %mul4 = fmul double %div1, %conv3
IC: Visiting:   %add5 = fadd double %mul4, %a
IC: Visiting:   %call6 = tail call double %f(double %add5)
IC: Visiting:   %add7 = fadd double %sum_even.049, %call6
IC: Visiting:   %conv8 = sitofp i32 %odd.052 to double
IC: Visiting:   %mul9 = fmul double %div1, %conv8
IC: Visiting:   %add10 = fadd double %mul9, %a
IC: Visiting:   %call11 = tail call double %f(double %add10)
IC: Visiting:   %add12 = fadd double %sum_odd.050, %call11
IC: Visiting:   %add13 = add nuw nsw i32 %even.051, 2
IC: Visiting:   %add14 = add nuw nsw i32 %odd.052, 2
IC: Visiting:   %cmp = icmp slt i32 %add13, %mul
IC: Visiting:   br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !2
IC: Visiting:   %phi.bo = fmul double %add7, 2.000000e+00
IC: Visiting:   br label %for.end
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.
F2I: Looking at function _Z4funcd
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _Z4funcd ----

Computing probabilities for entry

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - entry: float = 1.0, int = 8



INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call.i
IC: ADD:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #9
IC: Visiting:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #9
IC: Visiting:   ret double %call.i
SLP: Analyzing blocks in _Z4funcd.


INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call.i
IC: ADD:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #9
IC: Visiting:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #9
IC: Visiting:   ret double %call.i


INSTCOMBINE ITERATION #1 on _Z4funcd
IC: ADD:   ret double %call.i
IC: ADD:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #9
IC: Visiting:   %call.i = tail call double @pow(double %x, double 4.000000e+00) #9
IC: Visiting:   ret double %call.i
F2I: Looking at function main
LoopSimplify: Creating pre-header for.body.i.preheader
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %if.then.i
Found a new trivial root: %if.then.i64
Last visited node: %if.then.i64
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %_ZNKSt5ctypeIcE5widenEc.exit
4: %if.end.i
5: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
6: %_Z7simpsonPFddEddi.exit
7: %for.end.loopexit.i
8: %for.body.i
9: %for.body.i.preheader
10: %for.body
11: %entry
12: %if.then.i
13: %if.then.i64
Found roots: %for.cond.cleanup %if.then.i64 
---- Branch Probability Info : main ----

BPI: SCC 2: if.then.i _ZNKSt5ctypeIcE5widenEc.exit if.end.i _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit _Z7simpsonPFddEddi.exit for.end.loopexit.i for.body.i for.body.i.preheader for.body
Computing probabilities for if.then.i64
Computing probabilities for for.cond.cleanup
Computing probabilities for _ZNKSt5ctypeIcE5widenEc.exit
eraseBlock _ZNKSt5ctypeIcE5widenEc.exit
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.end.i
Computing probabilities for if.then.i
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for _Z7simpsonPFddEddi.exit
eraseBlock _Z7simpsonPFddEddi.exit
set edge _Z7simpsonPFddEddi.exit -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge _Z7simpsonPFddEddi.exit -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%
Computing probabilities for for.end.loopexit.i
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body.i -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.i.preheader
Computing probabilities for for.body
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.body.i.preheader
 - 3: for.body.i
 - 4: for.end.loopexit.i
 - 5: _Z7simpsonPFddEddi.exit
 - 6: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - 7: if.then.i
 - 8: if.end.i
 - 9: _ZNKSt5ctypeIcE5widenEc.exit
 - 10: for.cond.cleanup
 - 11: if.then.i64
loop-detection
 - loop = for.body
 - loop = for.body.i
 - loop = for.body: member = for.body.i.preheader
 - loop = for.body: member = for.end.loopexit.i
 - loop = for.body: member = _Z7simpsonPFddEddi.exit
 - loop = for.body: member = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - loop = for.body: member = if.then.i
 - loop = for.body: member = if.end.i
 - loop = for.body: member = _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit.i
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit.i
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-loop: for.body*
 - node: for.body
  => [ local  ] weight = 1073741824, succ = for.body.i.preheader
  => [ local  ] weight = 1073741824, succ = _Z7simpsonPFddEddi.exit
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.i.preheader
  => assign 8000000000000000 (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: for.body.i.preheader
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit.i
 - node: for.end.loopexit.i
  => [ local  ] weight = 2147483648, succ = _Z7simpsonPFddEddi.exit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: _Z7simpsonPFddEddi.exit
  => [  exit  ] weight = 2048, succ = if.then.i64
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => assign 0000100000000000 (0000000000000000) [exit] to if.then.i64
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => [ local  ] weight = 805306368, succ = if.end.i
  => [ local  ] weight = 1342177280, succ = if.then.i
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to if.then.i
  => assign 5ffffa0000000000 (0000000000000000) to if.end.i
 - node: if.then.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: if.end.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: _ZNKSt5ctypeIcE5widenEc.exit
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to for.body
  => assign 07ffff8000000000 (0000000000000000) [exit] to for.cond.cleanup
compute-loop-scale: for.body*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: for.body*
 - node: for.body
 - node: for.body.i.preheader
 - node: for.body.i
 - node: for.end.loopexit.i
 - node: _Z7simpsonPFddEddi.exit
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - node: if.then.i
 - node: if.end.i
 - node: _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 17592186044416, succ = if.then.i64
  => [ local  ] weight = 576460202547609600, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to for.cond.cleanup
  => assign 0001fffc00000000 (0000000000000000) to if.then.i64
 - node: for.cond.cleanup
  => mass:  fffe0003ffffffff
 - node: if.then.i64
  => mass:  0001fffc00000000
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - for.body: 1.0 => 31.99905398
 - for.body.i.preheader: 0.5 => 15.99952699
 - for.body.i: 32.0 => 1023.969727
 - for.end.loopexit.i: 0.5 => 15.99952699
 - _Z7simpsonPFddEddi.exit: 1.0 => 31.99905398
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: 0.9999990463 => 31.99902347
 - if.then.i: 0.624999404 => 19.99938967
 - if.end.i: 0.3749996424 => 11.9996338
 - _ZNKSt5ctypeIcE5widenEc.exit: 0.9999990463 => 31.99902347
unwrap-loop-package: for.body.i*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - for.body.i: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - entry: float = 1.0, scaled = 262152.0002, int = 262152
 - for.body: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - for.body.i.preheader: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - for.body.i: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - for.end.loopexit.i: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - if.then.i: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - if.end.i: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - for.cond.cleanup: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - if.then.i64: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 262152
 - for.cond.cleanup: float = 0.99997, int = 262144
 - for.body: float = 31.999, int = 8388616
 - for.body.i.preheader: float = 16.0, int = 4194308
 - for.body.i: float = 511.98, int = 134217856
 - for.end.loopexit.i: float = 16.0, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.999, int = 8388616
 - if.then.i64: float = 0.000030517, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.999, int = 8388608
 - if.then.i: float = 19.999, int = 5242880
 - if.end.i: float = 12.0, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.999, int = 8388608


LV: Checking a loop in "main" from Simpson.cpp
LV: Loop hints: force=? width=0 unroll=0
LV: Found a loop: for.body.i
LV: Found an induction variable.
LV: Found an induction variable.
Found an FAdd reduction PHI.  %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
Found an FAdd reduction PHI.  %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
LV: Found FP op with unsafe algebra.
LV: Found FP op with unsafe algebra.
LV: Not vectorizing: Found a non-intrinsic callsite   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
LV: Interleaving disabled by the pass manager
LV: Can't vectorize the instructions or CFG
LV: Not vectorizing: Cannot prove legality.
LAA: Found a loop in main: for.body.i

In "main" checking Loop at depth 2 containing: %for.body.i<header><latch><exiting>



INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i.lcssa, 2.000000e+00
IC: ADD:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: ADD:   br label %for.body.i
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #10
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #10
IC: Visiting:   unreachable
IC: Visiting:   br label %for.body.i
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: Replacing   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    with   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Mod =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    New =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ERASE   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD DEFERRED:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Replacing   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    with   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Mod =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    New =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ERASE   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD DEFERRED:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit


INSTCOMBINE ITERATION #2 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: ADD:   br label %for.body.i
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #10
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #10
IC: Visiting:   unreachable
IC: Visiting:   br label %for.body.i
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit
Looking to fold for.body.i.preheader into for.body.i
Killing Trivial BB: 

for.body.i.preheader:                             ; preds = %for.body
  br label %for.body.i
SLP: Analyzing blocks in main.
SLP: Trying to vectorize starting at PHIs (1)
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Found stores for 2 underlying objects.
SLP: Analyzing a store chain of length 3.
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00.
SLP: Need to extract:  %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00 from lane 0 from   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ].
SLP: Checking user:  %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00.
SLP: Need to extract:  %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00 from lane 1 from   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ].
SLP: Calculating cost for tree of size 3.
SLP: Adding cost 0 for bundle that starts with   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ].
SLP: Current total cost = 0
SLP: Adding cost 1 for bundle that starts with double 0.000000e+00.
SLP: Current total cost = 1
SLP: Adding cost 1 for bundle that starts with   %phi.bo.i = fmul double %add7.i, 2.000000e+00.
SLP: Current total cost = 2
SLP: #LV: 0, Looking at   %phi.bo.i = fmul double %add7.i, 2.000000e+00
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 3.
SLP: Trying to vectorize a list of length = 2.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP:  bundle:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
SLP:  initialize schedule region to   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
SLP:  extend schedule region end to   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
SLP: try schedule bundle [  %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00;  %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00] in block _Z7simpsonPFddEddi.exit
SLP:       update deps of [  %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00;  %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00]
SLP:       update deps of /   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
SLP:     gets ready on update:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
SLP: We are able to schedule this bundle.
SLP: added a ShuffleVector op.
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add21.i = fadd double %add19.i, %mul20.i.
SLP: Need to extract:  %add21.i = fadd double %add19.i, %mul20.i from lane 0 from   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00.
SLP: Checking user:  %add21.i = fadd double %add19.i, %mul20.i.
SLP: Need to extract:  %add21.i = fadd double %add19.i, %mul20.i from lane 1 from   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00.
SLP: Checking user:  %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00.
SLP: 	Internal user will be removed:  %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00.
SLP: Checking user:  %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00.
SLP: 	Internal user will be removed:  %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00.
SLP: Calculating cost for tree of size 5.
SLP: Calculated costs for Tree:
0.
Operand 0:
    %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
    %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
Operand 1:
  double 1.000000e+00
  double 4.000000e+00
Scalars: 
    %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
    %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
State: Vectorize
MainOp:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
AltOp:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 5
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = 1
SLP: Adding cost 1 for bundle that starts with   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00.
SLP: Current total cost = 1
SLP: Adding cost 0 for bundle that starts with   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ].
SLP: Current total cost = 1
SLP: Adding cost 1 for bundle that starts with double 0.000000e+00.
SLP: Current total cost = 2
SLP: Adding cost 1 for bundle that starts with   %phi.bo.i = fmul double %add7.i, 2.000000e+00.
SLP: Current total cost = 3
SLP: Adding cost 0 for bundle that starts with double 1.000000e+00.
SLP: Current total cost = 3
SLP: #LV: 1 sum_even.0.lcssa.i, Looking at   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
SLP: #LV: 0, Looking at   %phi.bo.i = fmul double %add7.i, 2.000000e+00
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 4.
SLP: Found GEPs for 5 underlying objects.
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP:  bundle:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
SLP:  initialize schedule region to   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
SLP:  extend schedule region start to   %add7.i = fadd double %sum_even.049.i, %call.i.i46
SLP: try schedule bundle [  %add12.i = fadd double %sum_odd.050.i, %call.i.i41;  %add7.i = fadd double %sum_even.049.i, %call.i.i46] in block for.body.i
SLP:       update deps of [  %add12.i = fadd double %sum_odd.050.i, %call.i.i41;  %add7.i = fadd double %sum_even.049.i, %call.i.i46]
SLP:       update deps of /   %add7.i = fadd double %sum_even.049.i, %call.i.i46
SLP:     gets ready on update:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP: 	Checking bundle:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ].
SLP: Perfect diamond merge at   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ].
SLP:  bundle:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
SLP:  extend schedule region start to   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
SLP: try schedule bundle [  %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9;  %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9] in block for.body.i
SLP:       update deps of [  %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9;  %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9]
SLP:       update deps of /   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
SLP:   schedule [  %add12.i = fadd double %sum_odd.050.i, %call.i.i41;  %add7.i = fadd double %sum_even.049.i, %call.i.i46]
SLP:  cancel scheduling of [  %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9;  %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9]
SLP: We are not able to schedule this bundle!
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add12.i = fadd double %sum_odd.050.i, %call.i.i41.
SLP: 	Internal user will be removed:  %add12.i = fadd double %sum_odd.050.i, %call.i.i41.
SLP: Checking user:  %add7.i = fadd double %sum_even.049.i, %call.i.i46.
SLP: 	Internal user will be removed:  %add7.i = fadd double %sum_even.049.i, %call.i.i46.
SLP: Checking user:  %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ].
SLP: Need to extract:  %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ] from lane 0 from   %add12.i = fadd double %sum_odd.050.i, %call.i.i41.
SLP: Checking user:  %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ].
SLP: 	Internal user will be removed:  %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ].
SLP: Checking user:  %phi.bo.i = fmul double %add7.i, 2.000000e+00.
SLP: Need to extract:  %phi.bo.i = fmul double %add7.i, 2.000000e+00 from lane 1 from   %add7.i = fadd double %sum_even.049.i, %call.i.i46.
SLP: Checking user:  %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ].
SLP: 	Internal user will be removed:  %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ].
SLP: Calculating cost for tree of size 4.
SLP: Adding cost 0 for bundle that starts with   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ].
SLP: Current total cost = 0
SLP: Calculated costs for Tree:
1.
Operand 0:
    %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
    %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
Operand 1:
    %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
    %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
Scalars: 
    %add12.i = fadd double %sum_odd.050.i, %call.i.i41
    %add7.i = fadd double %sum_even.049.i, %call.i.i46
State: Vectorize
MainOp:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
AltOp:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 2
SLP:     ScalarCost = 4
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -2
SLP: Adding cost -2 for bundle that starts with   %add12.i = fadd double %sum_odd.050.i, %call.i.i41.
SLP: Current total cost = -2
SLP: Adding cost 1 for bundle that starts with   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9.
SLP: Current total cost = -1
SLP: Adding cost 1 for bundle that starts with   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9.
SLP: Current total cost = 0
SLP: #LV: 1 sum_odd.050.i, Looking at   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
SLP: #LV: 1 sum_odd.050.i, Looking at   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
SLP: #LV: 1 add12.i, Looking at   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
SLP: Spill Cost = 0.
SLP: Extract Cost = 1.
SLP: Total Cost = 1.
SLP: Trying to vectorize starting at PHIs (2)
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: We are able to schedule this bundle.
SLP: added a vector of PHINodes.
SLP:  bundle:   %add14.i = add nuw nsw i32 %odd.052.i, 2
SLP:  initialize schedule region to   %add14.i = add nuw nsw i32 %odd.052.i, 2
SLP:  extend schedule region start to   %add13.i = add nuw nsw i32 %even.051.i, 2
SLP: try schedule bundle [  %add14.i = add nuw nsw i32 %odd.052.i, 2;  %add13.i = add nuw nsw i32 %even.051.i, 2] in block for.body.i
SLP:       update deps of [  %add14.i = add nuw nsw i32 %odd.052.i, 2;  %add13.i = add nuw nsw i32 %even.051.i, 2]
SLP:       update deps of /   %add13.i = add nuw nsw i32 %even.051.i, 2
SLP:     gets ready on update:   %add14.i = add nuw nsw i32 %odd.052.i, 2
SLP: We are able to schedule this bundle.
SLP: added a vector of un/bin op.
SLP: 	Checking bundle:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ].
SLP: Perfect diamond merge at   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ].
SLP: Gathering due to C,S,B,O. 
SLP: Gathering due to C,S,B,O. 
SLP: Checking user:  %add14.i = add nuw nsw i32 %odd.052.i, 2.
SLP: 	Internal user will be removed:  %add14.i = add nuw nsw i32 %odd.052.i, 2.
SLP: Checking user:  %conv8.i = sitofp i32 %odd.052.i to double.
SLP: Need to extract:  %conv8.i = sitofp i32 %odd.052.i to double from lane 0 from   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ].
SLP: Checking user:  %add13.i = add nuw nsw i32 %even.051.i, 2.
SLP: 	Internal user will be removed:  %add13.i = add nuw nsw i32 %even.051.i, 2.
SLP: Checking user:  %conv3.i = sitofp i32 %even.051.i to double.
SLP: Need to extract:  %conv3.i = sitofp i32 %even.051.i to double from lane 1 from   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ].
SLP: Checking user:  %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ].
SLP: 	Internal user will be removed:  %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ].
SLP: Checking user:  %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ].
SLP: 	Internal user will be removed:  %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ].
SLP: Checking user:  %cmp.i = icmp slt i32 %add13.i, %mul.i.
SLP: Need to extract:  %cmp.i = icmp slt i32 %add13.i, %mul.i from lane 1 from   %add13.i = add nuw nsw i32 %even.051.i, 2.
SLP: Calculating cost for tree of size 4.
SLP: Adding cost 0 for bundle that starts with   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ].
SLP: Current total cost = 0
SLP: Calculated costs for Tree:
1.
Operand 0:
    %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
    %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
Operand 1:
  i32 2
  i32 2
Scalars: 
    %add14.i = add nuw nsw i32 %odd.052.i, 2
    %add13.i = add nuw nsw i32 %even.051.i, 2
State: Vectorize
MainOp:   %add14.i = add nuw nsw i32 %odd.052.i, 2
AltOp:   %add14.i = add nuw nsw i32 %odd.052.i, 2
VectorizedValue: NULL
ReuseShuffleIndices: Empty
ReorderIndices: 
UserTreeIndices: {User:0 EdgeIdx:0}, 
SLP: Costs:
SLP:     ReuseShuffleCost = 0
SLP:     VectorCost = 1
SLP:     ScalarCost = 2
SLP:     ReuseShuffleCost + VecCost - ScalarCost = -1
SLP: Adding cost -1 for bundle that starts with   %add14.i = add nuw nsw i32 %odd.052.i, 2.
SLP: Current total cost = -1
SLP: Adding cost 0 for bundle that starts with i32 2.
SLP: Current total cost = -1
SLP: Adding cost 0 for bundle that starts with i32 3.
SLP: Current total cost = -1
SLP: #LV: 1 odd.052.i, Looking at   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
SLP: Spill Cost = 0.
SLP: Extract Cost = 5.
SLP: Total Cost = 4.
SLP: Trying to vectorize a list of length = 2.
SLP: Analyzing 2 operations 
SLP: Gathering due to C,S,B,O. 
SLP: Check whether the tree with height 1 is fully vectorizable .
SLP: Trying to vectorize starting at PHIs (1)
SLP: Trying to vectorize a list of length = 2.


INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #10
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #10
IC: Visiting:   unreachable
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit
LoopSimplify: Creating pre-header for.body.i.preheader
Loop Unroll: F[main] Loop %for.body.i
  Loop Size = 14
  runtime unrolling with count: 2
  Exiting Block = for.body.i
Trying runtime unrolling on Loop: 
Loop at depth 2 containing: %for.body.i<header><latch><exiting>
Using epilog remainder.
High cost for expanding trip count scev!
Won't unroll; remainder loop could not be generated when assuming runtime trip count
Loop Unroll: F[main] Loop %for.body
  Loop Size = 93
  will not try to unroll partially because -unroll-allow-partial not given


INSTCOMBINE ITERATION #1 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i.lcssa, 2.000000e+00
IC: ADD:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: ADD:   br label %for.body.i
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #10
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #10
IC: Visiting:   unreachable
IC: Visiting:   br label %for.body.i
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: Replacing   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    with   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Mod =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
    New =   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ERASE   %add7.i.lcssa = phi double [ %add7.i, %for.body.i ]
IC: ADD DEFERRED:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i.lcssa, %for.end.loopexit.i ]
IC: Replacing   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    with   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Mod =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
    New =   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ERASE   %add12.i.lcssa = phi double [ %add12.i, %for.body.i ]
IC: ADD DEFERRED:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit


INSTCOMBINE ITERATION #2 on main
IC: ADD:   br label %_Z7simpsonPFddEddi.exit
IC: ADD:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: ADD:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: ADD:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: ADD:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: ADD:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: ADD:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: ADD:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: ADD:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: ADD:   %mul9.i = fmul double %div1.i, %conv8.i
IC: ADD:   %conv8.i = sitofp i32 %odd.052.i to double
IC: ADD:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: ADD:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: ADD:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: ADD:   %mul4.i = fmul double %div1.i, %conv3.i
IC: ADD:   %conv3.i = sitofp i32 %even.051.i to double
IC: ADD:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: ADD:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: ADD:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: ADD:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: ADD:   br label %for.body.i
IC: ADD:   unreachable
IC: ADD:   tail call void @_ZSt16__throw_bad_castv() #10
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: ADD:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: ADD:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: ADD:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: ADD:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: ADD:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: ADD:   ret i32 0
IC: ADD:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: ADD:   %cmp = icmp ult i32 %mul, 65537
IC: ADD:   %mul = shl nsw i32 %n.066, 1
IC: ADD:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: ADD:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: ADD:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: ADD:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: ADD:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: ADD:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: ADD:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: ADD:   %tobool.not.i = icmp eq i8 %16, 0
IC: ADD:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: ADD:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: ADD:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: ADD:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: ADD:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: ADD:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: ADD:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: ADD:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: ADD:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: ADD:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: ADD:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: ADD:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: ADD:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: ADD:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: ADD:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: ADD:   store i64 20, i64* %10, align 8, !tbaa !7
IC: ADD:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: ADD:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: ADD:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: ADD:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: ADD:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: ADD:   store i64 16, i64* %8, align 8, !tbaa !18
IC: ADD:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: ADD:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: ADD:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: ADD:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: ADD:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: ADD:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: ADD:   %or.i = or i32 %and.i, 4
IC: ADD:   %and.i = and i32 %6, -261
IC: ADD:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: ADD:   %5 = bitcast i8* %_M_flags.i to i32*
IC: ADD:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: ADD:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: ADD:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: ADD:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: ADD:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: ADD:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: ADD:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: ADD:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: ADD:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: ADD:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: ADD:   store i64 6, i64* %1, align 8, !tbaa !7
IC: ADD:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: ADD:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: ADD:   %vbase.offset.i = load i64, i64* %0, align 8
IC: ADD:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: ADD:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: ADD:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: ADD:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: ADD:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: ADD:   %mul22.i = fmul double %div1.i, %add21.i
IC: ADD:   %add21.i = fadd double %add19.i, %mul20.i
IC: ADD:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: ADD:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: ADD:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: ADD:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: ADD:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: ADD:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: ADD:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: ADD:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: ADD:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: ADD:   %conv.i = sitofp i32 %mul.i to double
IC: ADD:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: ADD:   %div.i = sdiv i32 %add.i, 2
IC: ADD:   %add.i = or i32 %n.066, 1
IC: ADD:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: ADD:   br label %for.body
IC: Visiting:   br label %for.body
IC: Visiting:   %n.066 = phi i32 [ 2, %entry ], [ %mul, %_ZNKSt5ctypeIcE5widenEc.exit ]
IC: Visiting:   %add.i = or i32 %n.066, 1
IC: Visiting:   %div.i = sdiv i32 %add.i, 2
IC: Visiting:   %mul.i = shl nuw nsw i32 %div.i, 1
IC: Visiting:   %conv.i = sitofp i32 %mul.i to double
IC: Visiting:   %div1.i = fdiv double 1.000000e+00, %conv.i
IC: Visiting:   %add2.i = fadd double %div1.i, 0.000000e+00
IC: Visiting:   %call.i.i47 = tail call double @pow(double %add2.i, double 4.000000e+00) #9
IC: Visiting:   %cmp48.i = icmp sgt i32 %n.066, 2
IC: Visiting:   br i1 %cmp48.i, label %for.body.i.preheader, label %_Z7simpsonPFddEddi.exit
IC: Visiting:   %sum_even.0.lcssa.i = phi double [ 0.000000e+00, %for.body ], [ %phi.bo.i, %for.end.loopexit.i ]
IC: Visiting:   %sum_odd.0.lcssa.i = phi double [ %call.i.i47, %for.body ], [ %add12.i, %for.end.loopexit.i ]
IC: Visiting:   %add19.i = fadd double %sum_even.0.lcssa.i, 1.000000e+00
IC: Visiting:   %mul20.i = fmul double %sum_odd.0.lcssa.i, 4.000000e+00
IC: Visiting:   %add21.i = fadd double %add19.i, %mul20.i
IC: Visiting:   %mul22.i = fmul double %div1.i, %add21.i
IC: Visiting:   %div23.i = fdiv double %mul22.i, 3.000000e+00
IC: Visiting:   %call1.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) @_ZSt4cout, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i64 2)
IC: Visiting:   %vtable.i = load i8*, i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**), align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i = getelementptr i8, i8* %vtable.i, i64 -24
IC: Visiting:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
IC: Visiting:   %vbase.offset.i = load i64, i64* %0, align 8
IC: Visiting:   %_M_width.i.i = getelementptr inbounds i8, i8* bitcast (i64* getelementptr inbounds (%"class.std::basic_ostream", %"class.std::basic_ostream"* @_ZSt4cout, i64 0, i32 1, i32 0, i32 1) to i8*), i64 %vbase.offset.i
IC: Visiting:   %1 = bitcast i8* %_M_width.i.i to i64*
IC: Visiting:   store i64 6, i64* %1, align 8, !tbaa !7
IC: Visiting:   %call5 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSolsEi(%"class.std::basic_ostream"* nonnull dereferenceable(8) @_ZSt4cout, i32 %n.066)
IC: Visiting:   %call1.i30 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(%"class.std::basic_ostream"* nonnull align 8 dereferenceable(8) %call5, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0), i64 4)
IC: Visiting:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
IC: Visiting:   %vtable.i31 = load i8*, i8** %2, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i32 = getelementptr i8, i8* %vtable.i31, i64 -24
IC: Visiting:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
IC: Visiting:   %vbase.offset.i33 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i34 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 2
IC: Visiting:   %4 = bitcast i64* %add.ptr.i34 to i8*
IC: Visiting:   %_M_flags.i = getelementptr inbounds i8, i8* %4, i64 %vbase.offset.i33
IC: Visiting:   %5 = bitcast i8* %_M_flags.i to i32*
IC: Visiting:   %6 = load i32, i32* %5, align 4, !tbaa !17
IC: Visiting:   %and.i = and i32 %6, -261
IC: Visiting:   %or.i = or i32 %and.i, 4
IC: Visiting:   store i32 %or.i, i32* %5, align 4, !tbaa !17
IC: Visiting:   %vbase.offset.i44 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i45 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1
IC: Visiting:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
IC: Visiting:   %_M_precision.i.i = getelementptr inbounds i8, i8* %7, i64 %vbase.offset.i44
IC: Visiting:   %8 = bitcast i8* %_M_precision.i.i to i64*
IC: Visiting:   store i64 16, i64* %8, align 8, !tbaa !18
IC: Visiting:   %vbase.offset.i50 = load i64, i64* %3, align 8
IC: Visiting:   %add.ptr.i51 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call5, i64 0, i32 1, i32 0, i32 1
IC: Visiting:   %9 = bitcast i64* %add.ptr.i51 to i8*
IC: Visiting:   %_M_width.i.i52 = getelementptr inbounds i8, i8* %9, i64 %vbase.offset.i50
IC: Visiting:   %10 = bitcast i8* %_M_width.i.i52 to i64*
IC: Visiting:   store i64 20, i64* %10, align 8, !tbaa !7
IC: Visiting:   %call.i59 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo9_M_insertIdEERSoT_(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call5, double %div23.i)
IC: Visiting:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
IC: Visiting:   %vtable.i53 = load i8*, i8** %11, align 8, !tbaa !4
IC: Visiting:   %vbase.offset.ptr.i54 = getelementptr i8, i8* %vtable.i53, i64 -24
IC: Visiting:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
IC: Visiting:   %vbase.offset.i55 = load i64, i64* %12, align 8
IC: Visiting:   %add.ptr.i56 = getelementptr inbounds %"class.std::basic_ostream", %"class.std::basic_ostream"* %call.i59, i64 0, i32 1, i32 4
IC: Visiting:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
IC: Visiting:   %_M_ctype.i = getelementptr inbounds i8, i8* %13, i64 %vbase.offset.i55
IC: Visiting:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
IC: Visiting:   %15 = load %"class.std::ctype"*, %"class.std::ctype"** %14, align 8, !tbaa !19
IC: Visiting:   %tobool.not.i63 = icmp eq %"class.std::ctype"* %15, null
IC: Visiting:   br i1 %tobool.not.i63, label %if.then.i64, label %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
IC: Visiting:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
IC: Visiting:   %16 = load i8, i8* %_M_widen_ok.i, align 8, !tbaa !22
IC: Visiting:   %tobool.not.i = icmp eq i8 %16, 0
IC: Visiting:   br i1 %tobool.not.i, label %if.end.i, label %if.then.i
IC: Visiting:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
IC: Visiting:   %17 = load i8, i8* %arrayidx.i, align 1, !tbaa !24
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   %retval.0.i = phi i8 [ %17, %if.then.i ], [ %call.i62, %if.end.i ]
IC: Visiting:   %call1.i58 = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo3putEc(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call.i59, i8 signext %retval.0.i)
IC: Visiting:   %call.i = tail call nonnull align 8 dereferenceable(8) %"class.std::basic_ostream"* @_ZNSo5flushEv(%"class.std::basic_ostream"* nonnull dereferenceable(8) %call1.i58)
IC: Visiting:   %mul = shl nsw i32 %n.066, 1
IC: Visiting:   %cmp = icmp ult i32 %mul, 65537
IC: Visiting:   br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !25
IC: Visiting:   ret i32 0
IC: Visiting:   tail call void @_ZNKSt5ctypeIcE13_M_widen_initEv(%"class.std::ctype"* nonnull dereferenceable(570) %15)
IC: Visiting:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
IC: Visiting:   %vtable.i61 = load i8 (%"class.std::ctype"*, i8)**, i8 (%"class.std::ctype"*, i8)*** %18, align 8, !tbaa !4
IC: Visiting:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
IC: Visiting:   %19 = load i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vfn.i, align 8
IC: Visiting:   %call.i62 = tail call signext i8 %19(%"class.std::ctype"* nonnull dereferenceable(570) %15, i8 signext 10)
IC: Visiting:   br label %_ZNKSt5ctypeIcE5widenEc.exit
IC: Visiting:   tail call void @_ZSt16__throw_bad_castv() #10
IC: Visiting:   unreachable
IC: Visiting:   br label %for.body.i
IC: Visiting:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
IC: Visiting:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
IC: Visiting:   %sum_odd.050.i = phi double [ %add12.i, %for.body.i ], [ %call.i.i47, %for.body.i.preheader ]
IC: Visiting:   %sum_even.049.i = phi double [ %add7.i, %for.body.i ], [ 0.000000e+00, %for.body.i.preheader ]
IC: Visiting:   %conv3.i = sitofp i32 %even.051.i to double
IC: Visiting:   %mul4.i = fmul double %div1.i, %conv3.i
IC: Visiting:   %add5.i = fadd double %mul4.i, 0.000000e+00
IC: Visiting:   %call.i.i46 = tail call double @pow(double %add5.i, double 4.000000e+00) #9
IC: Visiting:   %add7.i = fadd double %sum_even.049.i, %call.i.i46
IC: Visiting:   %conv8.i = sitofp i32 %odd.052.i to double
IC: Visiting:   %mul9.i = fmul double %div1.i, %conv8.i
IC: Visiting:   %add10.i = fadd double %mul9.i, 0.000000e+00
IC: Visiting:   %call.i.i41 = tail call double @pow(double %add10.i, double 4.000000e+00) #9
IC: Visiting:   %add12.i = fadd double %sum_odd.050.i, %call.i.i41
IC: Visiting:   %add13.i = add nuw nsw i32 %even.051.i, 2
IC: Visiting:   %add14.i = add nuw nsw i32 %odd.052.i, 2
IC: Visiting:   %cmp.i = icmp slt i32 %add13.i, %mul.i
IC: Visiting:   br i1 %cmp.i, label %for.body.i, label %for.end.loopexit.i, !llvm.loop !2
IC: Visiting:   %phi.bo.i = fmul double %add7.i, 2.000000e+00
IC: Visiting:   br label %_Z7simpsonPFddEddi.exit
Perform LICM on Loop with header at block for.body.i
LICM: Using MemorySSA.
Perform LICM on Loop with header at block for.body
LICM: Using MemorySSA.
LICM sinking instruction:   %arrayidx.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 9, i64 10
LICM sinking instruction:   %vfn.i = getelementptr inbounds i8 (%"class.std::ctype"*, i8)*, i8 (%"class.std::ctype"*, i8)** %vtable.i61, i64 6
LICM sinking instruction:   %18 = bitcast %"class.std::ctype"* %15 to i8 (%"class.std::ctype"*, i8)***
LICM sinking instruction:   %_M_widen_ok.i = getelementptr inbounds %"class.std::ctype", %"class.std::ctype"* %15, i64 0, i32 8
LICM sinking instruction:   %14 = bitcast i8* %_M_ctype.i to %"class.std::ctype"**
LICM sinking instruction:   %13 = bitcast %"class.std::basic_streambuf"** %add.ptr.i56 to i8*
LICM sinking instruction:   %12 = bitcast i8* %vbase.offset.ptr.i54 to i64*
LICM sinking instruction:   %11 = bitcast %"class.std::basic_ostream"* %call.i59 to i8**
LICM sinking instruction:   %10 = bitcast i8* %_M_width.i.i52 to i64*
LICM sinking instruction:   %9 = bitcast i64* %add.ptr.i51 to i8*
LICM sinking instruction:   %8 = bitcast i8* %_M_precision.i.i to i64*
LICM sinking instruction:   %7 = bitcast %"class.std::basic_ios"* %add.ptr.i45 to i8*
LICM sinking instruction:   %5 = bitcast i8* %_M_flags.i to i32*
LICM sinking instruction:   %4 = bitcast i64* %add.ptr.i34 to i8*
LICM sinking instruction:   %3 = bitcast i8* %vbase.offset.ptr.i32 to i64*
LICM sinking instruction:   %2 = bitcast %"class.std::basic_ostream"* %call5 to i8**
LICM sinking instruction:   %1 = bitcast i8* %_M_width.i.i to i64*
LICM sinking instruction:   %0 = bitcast i8* %vbase.offset.ptr.i to i64*
F2I: Looking at function _GLOBAL__sub_I_Simpson.cpp
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _GLOBAL__sub_I_Simpson.cpp ----

Computing probabilities for entry

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - entry: float = 1.0, int = 8



INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
IC: Visiting:   ret void
SLP: Analyzing blocks in _GLOBAL__sub_I_Simpson.cpp.


INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
IC: Visiting:   ret void


INSTCOMBINE ITERATION #1 on _GLOBAL__sub_I_Simpson.cpp
IC: ADD:   ret void
IC: ADD:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
IC: ADD:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
IC: Visiting:   %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
IC: Visiting:   ret void
Optimizing Global Constructor: ; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_Simpson.cpp() #8 section ".text.startup" {
entry:
  tail call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* nonnull dereferenceable(1) @_ZStL8__ioinit)
  %0 = tail call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i64 0, i32 0), i8* nonnull @__dso_handle) #9
  ret void
}

Cmap[[3 x i8] c"n=\00"] = .str
Cmap[[5 x i8] c"  s=\00"] = .str.1
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %entry
4: %for.end.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.end 
---- Branch Probability Info : _Z7simpsonPFddEddi ----

Computing probabilities for for.end
Computing probabilities for for.end.loopexit
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.preheader
Computing probabilities for entry

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.body
 - 3: for.end.loopexit
 - 4: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = for.body.preheader
  => [ local  ] weight = 1073741824, succ = for.end
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.preheader
  => assign 8000000000000000 (0000000000000000) to for.end
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit
 - node: for.end.loopexit
  => [ local  ] weight = 2147483648, succ = for.end
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - for.body: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - for.body.preheader: float = 0.5, scaled = 8.0, int = 8
 - for.body: float = 16.0, scaled = 256.0, int = 255
 - for.end.loopexit: float = 0.5, scaled = 8.0, int = 8
 - for.end: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - entry: float = 1.0, int = 16
 - for.body.preheader: float = 0.5, int = 8
 - for.body: float = 16.0, int = 255
 - for.end.loopexit: float = 0.5, int = 8
 - for.end: float = 1.0, int = 16


block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.body
 - 3: for.end.loopexit
 - 4: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = for.body.preheader
  => [ local  ] weight = 1073741824, succ = for.end
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.preheader
  => assign 8000000000000000 (0000000000000000) to for.end
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit
 - node: for.end.loopexit
  => [ local  ] weight = 2147483648, succ = for.end
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - for.body: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - for.body.preheader: float = 0.5, scaled = 8.0, int = 8
 - for.body: float = 16.0, scaled = 256.0, int = 255
 - for.end.loopexit: float = 0.5, scaled = 8.0, int = 8
 - for.end: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - entry: float = 1.0, int = 16
 - for.body.preheader: float = 0.5, int = 8
 - for.body: float = 16.0, int = 255
 - for.end.loopexit: float = 0.5, int = 8
 - for.end: float = 1.0, int = 16

Looking to fold for.body.preheader into for.body
Killing Trivial BB: 

for.body.preheader:                               ; preds = %entry
  br label %for.body
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _Z4funcd ----

Computing probabilities for entry

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - entry: float = 1.0, int = 8


block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - entry: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %if.then.i
Found a new trivial root: %if.then.i64
Last visited node: %if.then.i64
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %_ZNKSt5ctypeIcE5widenEc.exit
4: %if.end.i
5: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
6: %_Z7simpsonPFddEddi.exit
7: %for.end.loopexit.i
8: %for.body.i
9: %for.body.i.preheader
10: %for.body
11: %entry
12: %if.then.i
13: %if.then.i64
Found roots: %for.cond.cleanup %if.then.i64 
---- Branch Probability Info : main ----

BPI: SCC 2: if.then.i _ZNKSt5ctypeIcE5widenEc.exit if.end.i _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit _Z7simpsonPFddEddi.exit for.end.loopexit.i for.body.i for.body.i.preheader for.body
Computing probabilities for if.then.i64
Computing probabilities for for.cond.cleanup
Computing probabilities for _ZNKSt5ctypeIcE5widenEc.exit
eraseBlock _ZNKSt5ctypeIcE5widenEc.exit
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.end.i
Computing probabilities for if.then.i
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for _Z7simpsonPFddEddi.exit
eraseBlock _Z7simpsonPFddEddi.exit
set edge _Z7simpsonPFddEddi.exit -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge _Z7simpsonPFddEddi.exit -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%
Computing probabilities for for.end.loopexit.i
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body.i -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.i.preheader
Computing probabilities for for.body
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.body.i.preheader
 - 3: for.body.i
 - 4: for.end.loopexit.i
 - 5: _Z7simpsonPFddEddi.exit
 - 6: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - 7: if.then.i
 - 8: if.end.i
 - 9: _ZNKSt5ctypeIcE5widenEc.exit
 - 10: for.cond.cleanup
 - 11: if.then.i64
loop-detection
 - loop = for.body
 - loop = for.body.i
 - loop = for.body: member = for.body.i.preheader
 - loop = for.body: member = for.end.loopexit.i
 - loop = for.body: member = _Z7simpsonPFddEddi.exit
 - loop = for.body: member = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - loop = for.body: member = if.then.i
 - loop = for.body: member = if.end.i
 - loop = for.body: member = _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit.i
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit.i
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-loop: for.body*
 - node: for.body
  => [ local  ] weight = 1073741824, succ = for.body.i.preheader
  => [ local  ] weight = 1073741824, succ = _Z7simpsonPFddEddi.exit
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.i.preheader
  => assign 8000000000000000 (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: for.body.i.preheader
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit.i
 - node: for.end.loopexit.i
  => [ local  ] weight = 2147483648, succ = _Z7simpsonPFddEddi.exit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: _Z7simpsonPFddEddi.exit
  => [  exit  ] weight = 2048, succ = if.then.i64
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => assign 0000100000000000 (0000000000000000) [exit] to if.then.i64
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => [ local  ] weight = 805306368, succ = if.end.i
  => [ local  ] weight = 1342177280, succ = if.then.i
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to if.then.i
  => assign 5ffffa0000000000 (0000000000000000) to if.end.i
 - node: if.then.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: if.end.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: _ZNKSt5ctypeIcE5widenEc.exit
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to for.body
  => assign 07ffff8000000000 (0000000000000000) [exit] to for.cond.cleanup
compute-loop-scale: for.body*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: for.body*
 - node: for.body
 - node: for.body.i.preheader
 - node: for.body.i
 - node: for.end.loopexit.i
 - node: _Z7simpsonPFddEddi.exit
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - node: if.then.i
 - node: if.end.i
 - node: _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 17592186044416, succ = if.then.i64
  => [ local  ] weight = 576460202547609600, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to for.cond.cleanup
  => assign 0001fffc00000000 (0000000000000000) to if.then.i64
 - node: for.cond.cleanup
  => mass:  fffe0003ffffffff
 - node: if.then.i64
  => mass:  0001fffc00000000
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - for.body: 1.0 => 31.99905398
 - for.body.i.preheader: 0.5 => 15.99952699
 - for.body.i: 32.0 => 1023.969727
 - for.end.loopexit.i: 0.5 => 15.99952699
 - _Z7simpsonPFddEddi.exit: 1.0 => 31.99905398
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: 0.9999990463 => 31.99902347
 - if.then.i: 0.624999404 => 19.99938967
 - if.end.i: 0.3749996424 => 11.9996338
 - _ZNKSt5ctypeIcE5widenEc.exit: 0.9999990463 => 31.99902347
unwrap-loop-package: for.body.i*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - for.body.i: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - entry: float = 1.0, scaled = 262152.0002, int = 262152
 - for.body: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - for.body.i.preheader: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - for.body.i: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - for.end.loopexit.i: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - if.then.i: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - if.end.i: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - for.cond.cleanup: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - if.then.i64: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 262152
 - for.cond.cleanup: float = 0.99997, int = 262144
 - for.body: float = 31.999, int = 8388616
 - for.body.i.preheader: float = 16.0, int = 4194308
 - for.body.i: float = 511.98, int = 134217856
 - for.end.loopexit.i: float = 16.0, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.999, int = 8388616
 - if.then.i64: float = 0.000030517, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.999, int = 8388608
 - if.then.i: float = 19.999, int = 5242880
 - if.end.i: float = 12.0, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.999, int = 8388608


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.body.i.preheader
 - 3: for.body.i
 - 4: for.end.loopexit.i
 - 5: _Z7simpsonPFddEddi.exit
 - 6: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - 7: if.then.i
 - 8: if.end.i
 - 9: _ZNKSt5ctypeIcE5widenEc.exit
 - 10: for.cond.cleanup
 - 11: if.then.i64
loop-detection
 - loop = for.body
 - loop = for.body.i
 - loop = for.body: member = for.body.i.preheader
 - loop = for.body: member = for.end.loopexit.i
 - loop = for.body: member = _Z7simpsonPFddEddi.exit
 - loop = for.body: member = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - loop = for.body: member = if.then.i
 - loop = for.body: member = if.end.i
 - loop = for.body: member = _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit.i
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit.i
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-loop: for.body*
 - node: for.body
  => [ local  ] weight = 1073741824, succ = for.body.i.preheader
  => [ local  ] weight = 1073741824, succ = _Z7simpsonPFddEddi.exit
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.i.preheader
  => assign 8000000000000000 (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: for.body.i.preheader
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit.i
 - node: for.end.loopexit.i
  => [ local  ] weight = 2147483648, succ = _Z7simpsonPFddEddi.exit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: _Z7simpsonPFddEddi.exit
  => [  exit  ] weight = 2048, succ = if.then.i64
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => assign 0000100000000000 (0000000000000000) [exit] to if.then.i64
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => [ local  ] weight = 805306368, succ = if.end.i
  => [ local  ] weight = 1342177280, succ = if.then.i
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to if.then.i
  => assign 5ffffa0000000000 (0000000000000000) to if.end.i
 - node: if.then.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: if.end.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: _ZNKSt5ctypeIcE5widenEc.exit
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to for.body
  => assign 07ffff8000000000 (0000000000000000) [exit] to for.cond.cleanup
compute-loop-scale: for.body*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: for.body*
 - node: for.body
 - node: for.body.i.preheader
 - node: for.body.i
 - node: for.end.loopexit.i
 - node: _Z7simpsonPFddEddi.exit
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - node: if.then.i
 - node: if.end.i
 - node: _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 17592186044416, succ = if.then.i64
  => [ local  ] weight = 576460202547609600, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to for.cond.cleanup
  => assign 0001fffc00000000 (0000000000000000) to if.then.i64
 - node: for.cond.cleanup
  => mass:  fffe0003ffffffff
 - node: if.then.i64
  => mass:  0001fffc00000000
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - for.body: 1.0 => 31.99905398
 - for.body.i.preheader: 0.5 => 15.99952699
 - for.body.i: 32.0 => 1023.969727
 - for.end.loopexit.i: 0.5 => 15.99952699
 - _Z7simpsonPFddEddi.exit: 1.0 => 31.99905398
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: 0.9999990463 => 31.99902347
 - if.then.i: 0.624999404 => 19.99938967
 - if.end.i: 0.3749996424 => 11.9996338
 - _ZNKSt5ctypeIcE5widenEc.exit: 0.9999990463 => 31.99902347
unwrap-loop-package: for.body.i*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - for.body.i: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - entry: float = 1.0, scaled = 262152.0002, int = 262152
 - for.body: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - for.body.i.preheader: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - for.body.i: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - for.end.loopexit.i: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - if.then.i: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - if.end.i: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - for.cond.cleanup: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - if.then.i64: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 262152
 - for.cond.cleanup: float = 0.99997, int = 262144
 - for.body: float = 31.999, int = 8388616
 - for.body.i.preheader: float = 16.0, int = 4194308
 - for.body.i: float = 511.98, int = 134217856
 - for.end.loopexit.i: float = 16.0, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.999, int = 8388616
 - if.then.i64: float = 0.000030517, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.999, int = 8388608
 - if.then.i: float = 19.999, int = 5242880
 - if.end.i: float = 12.0, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.999, int = 8388608

Looking to fold for.body.i.preheader into for.body.i
Killing Trivial BB: 

for.body.i.preheader:                             ; preds = %for.body
  br label %for.body.i
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _GLOBAL__sub_I_Simpson.cpp ----

Computing probabilities for entry

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - entry: float = 1.0, int = 8


block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - entry: float = 1.0, int = 8

LoopSimplify: Creating pre-header for.body.preheader
canonfr: PHI:   %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]
canonfr: PHI:   %even.051 = phi i32 [ %add13, %for.body ], [ 2, %for.body.preheader ]
FOUND USER:   %conv8 = sitofp i32 %odd.052 to double
   OF SCEV: {3,+,2}<nuw><nsw><%for.body>
FOUND USER:   %cmp = icmp slt i32 %add13, %mul
   OF SCEV: {4,+,2}<nuw><nsw><%for.body>
FOUND USER:   %conv3 = sitofp i32 %even.051 to double
   OF SCEV: {2,+,2}<nuw><nsw><%for.body>

LSR on loop %for.body:
  Change loop exiting icmp to use postinc iv:   %cmp = icmp slt i32 %add13, %mul
Collecting IV Chains.
IV Chain#0 Head: (  %conv3 = sitofp i32 %even.051 to double) IV={2,+,2}<nuw><nsw><%for.body>
IV Chain#0  Inc: (  %cmp = icmp slt i32 %add13, %mul) IV+2
IV Chain#0  Inc: (  %odd.052 = phi i32 [ %add14, %for.body ], [ 3, %for.body.preheader ]) IV+1
Chain:   %conv3 = sitofp i32 %even.051 to double Cost: 0
LSR is examining the following fixup sites:
  UserInst=%cmp, OperandValToReplace=%add13, PostIncLoop=%for.body
  UserInst=%conv3, OperandValToReplace=%even.051
LSR found 1 uses:
LSR is examining the following uses:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body>)
Generating cross-use offsets for {0,+,2}<%for.body>: 0 2
Skipping cross-use reuse for {0,+,2}<%for.body>
Skipping cross-use reuse for {2,+,2}<nuw><nsw><%for.body>

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body>)
    reg({0,+,2}<%for.body>) + imm(2)
Filtering for use LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
  Filtering out formula reg({0,+,2}<%for.body>) + imm(2)
    in favor of formula reg({2,+,2}<nuw><nsw><%for.body>)

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body>)
New best at 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost.
Regs:
- {2,+,2}<nuw><nsw><%for.body>


The chosen solution requires 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body>)
MergeICmpsLegacyPass: _Z7simpsonPFddEddi
processPhi()
skip: non-constant value not from cmp or not from last block.
processPhi()
skip: non-constant value not from cmp or not from last block.
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %entry
4: %for.end.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.end 
---- Branch Probability Info : _Z7simpsonPFddEddi ----

Computing probabilities for for.end
Computing probabilities for for.end.loopexit
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.preheader
Computing probabilities for entry

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.body
 - 3: for.end.loopexit
 - 4: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = for.body.preheader
  => [ local  ] weight = 1073741824, succ = for.end
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.preheader
  => assign 8000000000000000 (0000000000000000) to for.end
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit
 - node: for.end.loopexit
  => [ local  ] weight = 2147483648, succ = for.end
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - for.body: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - for.body.preheader: float = 0.5, scaled = 8.0, int = 8
 - for.body: float = 16.0, scaled = 256.0, int = 255
 - for.end.loopexit: float = 0.5, scaled = 8.0, int = 8
 - for.end: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - entry: float = 1.0, int = 16
 - for.body.preheader: float = 0.5, int = 8
 - for.body: float = 16.0, int = 255
 - for.end.loopexit: float = 0.5, int = 8
 - for.end: float = 1.0, int = 16

********** Begin Constant Hoisting **********
********** Function: _Z7simpsonPFddEddi
********** End Constant Hoisting **********
*** Interleaved Access Pass: _Z7simpsonPFddEddi
---- Branch Probability Info : _Z7simpsonPFddEddi ----

		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %entry
4: %for.end.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.end 
Computing probabilities for for.end
Computing probabilities for for.end.loopexit
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.preheader
Computing probabilities for entry

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.body
 - 3: for.end.loopexit
 - 4: for.end
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = for.body.preheader
  => [ local  ] weight = 1073741824, succ = for.end
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.preheader
  => assign 8000000000000000 (0000000000000000) to for.end
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit
 - node: for.end.loopexit
  => [ local  ] weight = 2147483648, succ = for.end
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end
 - node: for.end
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - for.body: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - for.body.preheader: float = 0.5, scaled = 8.0, int = 8
 - for.body: float = 16.0, scaled = 256.0, int = 255
 - for.end.loopexit: float = 0.5, scaled = 8.0, int = 8
 - for.end: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - entry: float = 1.0, int = 16
 - for.body.preheader: float = 0.5, int = 8
 - for.body: float = 16.0, int = 255
 - for.end.loopexit: float = 0.5, int = 8
 - for.end: float = 1.0, int = 16

MergeICmpsLegacyPass: _Z4funcd
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _Z4funcd ----

Computing probabilities for entry

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - entry: float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: _Z4funcd
********** End Constant Hoisting **********
*** Interleaved Access Pass: _Z4funcd
---- Branch Probability Info : _Z4funcd ----

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
Computing probabilities for entry

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - entry: float = 1.0, int = 8

LoopSimplify: Creating pre-header for.body.i.preheader
canonfr: PHI:   %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]
canonfr: PHI:   %even.051.i = phi i32 [ %add13.i, %for.body.i ], [ 2, %for.body.i.preheader ]
FOUND USER:   %conv8.i = sitofp i32 %odd.052.i to double
   OF SCEV: {3,+,2}<nuw><nsw><%for.body.i>
FOUND USER:   %cmp.i = icmp slt i32 %add13.i, %mul.i
   OF SCEV: {4,+,2}<nuw><nsw><%for.body.i>
FOUND USER:   %conv3.i = sitofp i32 %even.051.i to double
   OF SCEV: {2,+,2}<nuw><nsw><%for.body.i>

LSR on loop %for.body.i:
  Change loop exiting icmp to use postinc iv:   %cmp.i = icmp slt i32 %add13.i, %mul.i
Collecting IV Chains.
IV Chain#0 Head: (  %conv3.i = sitofp i32 %even.051.i to double) IV={2,+,2}<nuw><nsw><%for.body.i>
IV Chain#0  Inc: (  %cmp.i = icmp slt i32 %add13.i, %mul.i) IV+2
IV Chain#0  Inc: (  %odd.052.i = phi i32 [ %add14.i, %for.body.i ], [ 3, %for.body.i.preheader ]) IV+1
Chain:   %conv3.i = sitofp i32 %even.051.i to double Cost: 0
LSR is examining the following fixup sites:
  UserInst=%cmp.i, OperandValToReplace=%add13.i, PostIncLoop=%for.body.i
  UserInst=%conv3.i, OperandValToReplace=%even.051.i
LSR found 1 uses:
LSR is examining the following uses:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body.i>)
Generating cross-use offsets for {0,+,2}<%for.body.i>: 0 2
Skipping cross-use reuse for {0,+,2}<%for.body.i>
Skipping cross-use reuse for {2,+,2}<nuw><nsw><%for.body.i>

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body.i>)
    reg({0,+,2}<%for.body.i>) + imm(2)
Filtering for use LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
  Filtering out formula reg({0,+,2}<%for.body.i>) + imm(2)
    in favor of formula reg({2,+,2}<nuw><nsw><%for.body.i>)

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body.i>)
New best at 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost.
Regs:
- {2,+,2}<nuw><nsw><%for.body.i>


The chosen solution requires 1 instruction 1 reg, with addrec cost 1, plus 1 setup cost:
  LSR Use: Kind=Basic, Offsets={0,0}, widest fixup type: i32
    reg({2,+,2}<nuw><nsw><%for.body.i>)
LV: PHI is not a poly recurrence.
MergeICmpsLegacyPass: main
processPhi()
skip: non-constant value not from cmp or not from last block.
processPhi()
skip: non-constant value not from cmp or not from last block.
processPhi()
skip: non-constant value not from cmp or not from last block.
processPhi()
skip: non-constant value not from cmp or not from last block.
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %if.then.i
Found a new trivial root: %if.then.i64
Last visited node: %if.then.i64
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %_ZNKSt5ctypeIcE5widenEc.exit
4: %if.end.i
5: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
6: %_Z7simpsonPFddEddi.exit
7: %for.end.loopexit.i
8: %for.body.i
9: %for.body.i.preheader
10: %for.body
11: %entry
12: %if.then.i
13: %if.then.i64
Found roots: %for.cond.cleanup %if.then.i64 
---- Branch Probability Info : main ----

BPI: SCC 2: if.then.i _ZNKSt5ctypeIcE5widenEc.exit if.end.i _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit _Z7simpsonPFddEddi.exit for.end.loopexit.i for.body.i for.body.i.preheader for.body
Computing probabilities for if.then.i64
Computing probabilities for for.cond.cleanup
Computing probabilities for _ZNKSt5ctypeIcE5widenEc.exit
eraseBlock _ZNKSt5ctypeIcE5widenEc.exit
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.end.i
Computing probabilities for if.then.i
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for _Z7simpsonPFddEddi.exit
eraseBlock _Z7simpsonPFddEddi.exit
set edge _Z7simpsonPFddEddi.exit -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge _Z7simpsonPFddEddi.exit -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%
Computing probabilities for for.end.loopexit.i
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body.i -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.i.preheader
Computing probabilities for for.body
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.body.i.preheader
 - 3: for.body.i
 - 4: for.end.loopexit.i
 - 5: _Z7simpsonPFddEddi.exit
 - 6: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - 7: if.then.i
 - 8: if.end.i
 - 9: _ZNKSt5ctypeIcE5widenEc.exit
 - 10: for.cond.cleanup
 - 11: if.then.i64
loop-detection
 - loop = for.body
 - loop = for.body.i
 - loop = for.body: member = for.body.i.preheader
 - loop = for.body: member = for.end.loopexit.i
 - loop = for.body: member = _Z7simpsonPFddEddi.exit
 - loop = for.body: member = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - loop = for.body: member = if.then.i
 - loop = for.body: member = if.end.i
 - loop = for.body: member = _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit.i
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit.i
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-loop: for.body*
 - node: for.body
  => [ local  ] weight = 1073741824, succ = for.body.i.preheader
  => [ local  ] weight = 1073741824, succ = _Z7simpsonPFddEddi.exit
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.i.preheader
  => assign 8000000000000000 (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: for.body.i.preheader
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit.i
 - node: for.end.loopexit.i
  => [ local  ] weight = 2147483648, succ = _Z7simpsonPFddEddi.exit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: _Z7simpsonPFddEddi.exit
  => [  exit  ] weight = 2048, succ = if.then.i64
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => assign 0000100000000000 (0000000000000000) [exit] to if.then.i64
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => [ local  ] weight = 805306368, succ = if.end.i
  => [ local  ] weight = 1342177280, succ = if.then.i
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to if.then.i
  => assign 5ffffa0000000000 (0000000000000000) to if.end.i
 - node: if.then.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: if.end.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: _ZNKSt5ctypeIcE5widenEc.exit
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to for.body
  => assign 07ffff8000000000 (0000000000000000) [exit] to for.cond.cleanup
compute-loop-scale: for.body*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: for.body*
 - node: for.body
 - node: for.body.i.preheader
 - node: for.body.i
 - node: for.end.loopexit.i
 - node: _Z7simpsonPFddEddi.exit
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - node: if.then.i
 - node: if.end.i
 - node: _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 17592186044416, succ = if.then.i64
  => [ local  ] weight = 576460202547609600, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to for.cond.cleanup
  => assign 0001fffc00000000 (0000000000000000) to if.then.i64
 - node: for.cond.cleanup
  => mass:  fffe0003ffffffff
 - node: if.then.i64
  => mass:  0001fffc00000000
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - for.body: 1.0 => 31.99905398
 - for.body.i.preheader: 0.5 => 15.99952699
 - for.body.i: 32.0 => 1023.969727
 - for.end.loopexit.i: 0.5 => 15.99952699
 - _Z7simpsonPFddEddi.exit: 1.0 => 31.99905398
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: 0.9999990463 => 31.99902347
 - if.then.i: 0.624999404 => 19.99938967
 - if.end.i: 0.3749996424 => 11.9996338
 - _ZNKSt5ctypeIcE5widenEc.exit: 0.9999990463 => 31.99902347
unwrap-loop-package: for.body.i*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - for.body.i: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - entry: float = 1.0, scaled = 262152.0002, int = 262152
 - for.body: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - for.body.i.preheader: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - for.body.i: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - for.end.loopexit.i: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - if.then.i: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - if.end.i: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - for.cond.cleanup: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - if.then.i64: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 262152
 - for.cond.cleanup: float = 0.99997, int = 262144
 - for.body: float = 31.999, int = 8388616
 - for.body.i.preheader: float = 16.0, int = 4194308
 - for.body.i: float = 511.98, int = 134217856
 - for.end.loopexit.i: float = 16.0, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.999, int = 8388616
 - if.then.i64: float = 0.000030517, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.999, int = 8388608
 - if.then.i: float = 19.999, int = 5242880
 - if.end.i: float = 12.0, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.999, int = 8388608

********** Begin Constant Hoisting **********
********** Function: main
********** End Constant Hoisting **********
*** Interleaved Access Pass: main
---- Branch Probability Info : main ----

BPI: SCC 2: if.then.i _ZNKSt5ctypeIcE5widenEc.exit if.end.i _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit _Z7simpsonPFddEddi.exit for.end.loopexit.i for.body.i for.body.i.preheader for.body
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %if.then.i
Found a new trivial root: %if.then.i64
Last visited node: %if.then.i64
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %_ZNKSt5ctypeIcE5widenEc.exit
4: %if.end.i
5: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
6: %_Z7simpsonPFddEddi.exit
7: %for.end.loopexit.i
8: %for.body.i
9: %for.body.i.preheader
10: %for.body
11: %entry
12: %if.then.i
13: %if.then.i64
Found roots: %for.cond.cleanup %if.then.i64 
Computing probabilities for if.then.i64
Computing probabilities for for.cond.cleanup
Computing probabilities for _ZNKSt5ctypeIcE5widenEc.exit
eraseBlock _ZNKSt5ctypeIcE5widenEc.exit
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.end.i
Computing probabilities for if.then.i
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for _Z7simpsonPFddEddi.exit
eraseBlock _Z7simpsonPFddEddi.exit
set edge _Z7simpsonPFddEddi.exit -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge _Z7simpsonPFddEddi.exit -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%
Computing probabilities for for.end.loopexit.i
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body.i -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.i.preheader
Computing probabilities for for.body
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body
 - 2: for.body.i.preheader
 - 3: for.body.i
 - 4: for.end.loopexit.i
 - 5: _Z7simpsonPFddEddi.exit
 - 6: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - 7: if.then.i
 - 8: if.end.i
 - 9: _ZNKSt5ctypeIcE5widenEc.exit
 - 10: for.cond.cleanup
 - 11: if.then.i64
loop-detection
 - loop = for.body
 - loop = for.body.i
 - loop = for.body: member = for.body.i.preheader
 - loop = for.body: member = for.end.loopexit.i
 - loop = for.body: member = _Z7simpsonPFddEddi.exit
 - loop = for.body: member = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - loop = for.body: member = if.then.i
 - loop = for.body: member = if.end.i
 - loop = for.body: member = _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-loop: for.body.i*
 - node: for.body.i
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.end.loopexit.i
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body.i
  => assign 0800000000000000 (0000000000000000) [exit] to for.end.loopexit.i
compute-loop-scale: for.body.i*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body.i*
 - node: for.body.i
compute-mass-in-loop: for.body*
 - node: for.body
  => [ local  ] weight = 1073741824, succ = for.body.i.preheader
  => [ local  ] weight = 1073741824, succ = _Z7simpsonPFddEddi.exit
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to for.body.i.preheader
  => assign 8000000000000000 (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: for.body.i.preheader
  => [ local  ] weight = 2147483648, succ = for.body.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.body.i
 - node: for.body.i
  => [ local  ] weight = 576460752303423488, succ = for.end.loopexit.i
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to for.end.loopexit.i
 - node: for.end.loopexit.i
  => [ local  ] weight = 2147483648, succ = _Z7simpsonPFddEddi.exit
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to _Z7simpsonPFddEddi.exit
 - node: _Z7simpsonPFddEddi.exit
  => [  exit  ] weight = 2048, succ = if.then.i64
  => [ local  ] weight = 2147481600, succ = _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => assign 0000100000000000 (0000000000000000) [exit] to if.then.i64
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
  => [ local  ] weight = 805306368, succ = if.end.i
  => [ local  ] weight = 1342177280, succ = if.then.i
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to if.then.i
  => assign 5ffffa0000000000 (0000000000000000) to if.end.i
 - node: if.then.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: if.end.i
  => [ local  ] weight = 2147483648, succ = _ZNKSt5ctypeIcE5widenEc.exit
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to _ZNKSt5ctypeIcE5widenEc.exit
 - node: _ZNKSt5ctypeIcE5widenEc.exit
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to for.body
  => assign 07ffff8000000000 (0000000000000000) [exit] to for.cond.cleanup
compute-loop-scale: for.body*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: for.body*
 - node: for.body
 - node: for.body.i.preheader
 - node: for.body.i
 - node: for.end.loopexit.i
 - node: _Z7simpsonPFddEddi.exit
 - node: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
 - node: if.then.i
 - node: if.end.i
 - node: _ZNKSt5ctypeIcE5widenEc.exit
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 17592186044416, succ = if.then.i64
  => [ local  ] weight = 576460202547609600, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to for.cond.cleanup
  => assign 0001fffc00000000 (0000000000000000) to if.then.i64
 - node: for.cond.cleanup
  => mass:  fffe0003ffffffff
 - node: if.then.i64
  => mass:  0001fffc00000000
unwrap-loop-package: for.body*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - for.body: 1.0 => 31.99905398
 - for.body.i.preheader: 0.5 => 15.99952699
 - for.body.i: 32.0 => 1023.969727
 - for.end.loopexit.i: 0.5 => 15.99952699
 - _Z7simpsonPFddEddi.exit: 1.0 => 31.99905398
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: 0.9999990463 => 31.99902347
 - if.then.i: 0.624999404 => 19.99938967
 - if.end.i: 0.3749996424 => 11.9996338
 - _ZNKSt5ctypeIcE5widenEc.exit: 0.9999990463 => 31.99902347
unwrap-loop-package: for.body.i*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - for.body.i: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - entry: float = 1.0, scaled = 262152.0002, int = 262152
 - for.body: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - for.body.i.preheader: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - for.body.i: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - for.end.loopexit.i: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - if.then.i: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - if.end.i: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - for.cond.cleanup: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - if.then.i64: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 262152
 - for.cond.cleanup: float = 0.99997, int = 262144
 - for.body: float = 31.999, int = 8388616
 - for.body.i.preheader: float = 16.0, int = 4194308
 - for.body.i: float = 511.98, int = 134217856
 - for.end.loopexit.i: float = 16.0, int = 4194308
 - _Z7simpsonPFddEddi.exit: float = 31.999, int = 8388616
 - if.then.i64: float = 0.000030517, int = 8
 - _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit: float = 31.999, int = 8388608
 - if.then.i: float = 19.999, int = 5242880
 - if.end.i: float = 12.0, int = 3145728
 - _ZNKSt5ctypeIcE5widenEc.exit: float = 31.999, int = 8388608

CGP: Found      local addrmode: [inbounds GV:@_ZSt4cout]
CGP: Found      local addrmode: [-24 + Base:%vtable.i]
CGP: Found      local addrmode: [inbounds GV:@_ZSt4cout + 16 + Base:%vbase.offset.i]
CGP: Found      local addrmode: [inbounds Base:%call5]
CGP: Found      local addrmode: [-24 + Base:%vtable.i31]
CGP: Found      local addrmode: [inbounds 24 + Base:%call5 + 1*%vbase.offset.i33]
CGP: Found      local addrmode: [inbounds 24 + Base:%call5 + 1*%vbase.offset.i33]
CGP: Found      local addrmode: [-24 + Base:%vtable.i31]
CGP: Found      local addrmode: [inbounds 8 + Base:%call5 + 1*%vbase.offset.i44]
CGP: Found      local addrmode: [-24 + Base:%vtable.i31]
CGP: Found      local addrmode: [inbounds 16 + Base:%call5 + 1*%vbase.offset.i50]
CGP: Found      local addrmode: [inbounds Base:%call.i59]
CGP: Found      local addrmode: [-24 + Base:%vtable.i53]
CGP: Found      local addrmode: [inbounds 240 + Base:%call.i59 + 1*%vbase.offset.i55]
CGP: Found      local addrmode: [inbounds 56 + Base:%15]
CGP: Found      local addrmode: [inbounds 67 + Base:%15]
CGP: Found      local addrmode: [inbounds Base:%15]
CGP: Found      local addrmode: [inbounds 48 + Base:%vtable.i61]
MergeICmpsLegacyPass: _GLOBAL__sub_I_Simpson.cpp
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _GLOBAL__sub_I_Simpson.cpp ----

Computing probabilities for entry

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - entry: float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
********** End Constant Hoisting **********
*** Interleaved Access Pass: _GLOBAL__sub_I_Simpson.cpp
---- Branch Probability Info : _GLOBAL__sub_I_Simpson.cpp ----

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
Computing probabilities for entry

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - entry: float = 1.0, int = 8

[SafeStack] Function: _Z7simpsonPFddEddi
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %for.end
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.end
3: %entry
4: %for.end.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.end 
---- Branch Probability Info : _Z7simpsonPFddEddi ----

Computing probabilities for for.end
Computing probabilities for for.end.loopexit
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.preheader
Computing probabilities for entry



=== _Z7simpsonPFddEddi
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Creating new node: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Creating new node: t6: f64,ch = CopyFromReg t0, Register:f64 %16
Creating new node: t8: i32,ch = CopyFromReg t0, Register:i32 %17
Creating constant: t9: i32 = Constant<1>
Creating new node: t10: i32 = add nsw t8, Constant:i32<1>
Creating constant: t11: i32 = Constant<2>
Creating new node: t12: i32 = sdiv t10, Constant:i32<2>
Creating constant: t13: i8 = Constant<1>
Creating new node: t14: i32 = shl nsw t12, Constant:i8<1>
Creating new node: t16: ch = CopyToReg t0, Register:i32 %0, t14
Creating new node: t17: f64 = fsub t6, t4
Creating new node: t18: f64 = sint_to_fp t14
Creating new node: t19: f64 = fdiv t17, t18
Creating new node: t21: ch = CopyToReg t0, Register:f64 %1, t19
Creating new node: t22: f64 = fadd t19, t4
Creating constant: t23: i64 = TargetConstant<0>
Creating new node: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
Creating new node: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
Creating new node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Creating new node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Creating new node: t32: ch = CopyToReg t0, Register:f64 %2, t30
Creating new node: t34: i1 = setcc t8, Constant:i32<2>, setgt:ch
Creating fp constant: t35: f64 = ConstantFP<0.000000e+00>
Creating new node: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
Creating constant: t38: i1 = Constant<-1>
Creating new node: t39: i1 = xor t34, Constant:i1<-1>
Creating new node: t41: ch = TokenFactor t16, t21, t32, t37, t30:1
Creating new node: t42: ch = brcond t41, t39, BasicBlock:ch<for.end 0x7fffc1da7528>
Creating new node: t44: ch = br t42, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>
Initial selection DAG: %bb.0 '_Z7simpsonPFddEddi:entry'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
  t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: i32,ch = CopyFromReg t0, Register:i32 %17
      t10: i32 = add nsw t8, Constant:i32<1>
    t12: i32 = sdiv t10, Constant:i32<2>
  t14: i32 = shl nsw t12, Constant:i8<1>
      t6: f64,ch = CopyFromReg t0, Register:f64 %16
    t17: f64 = fsub t6, t4
    t18: f64 = sint_to_fp t14
  t19: f64 = fdiv t17, t18
    t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t22: f64 = fadd t19, t4
  t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
    t2: i64,ch = CopyFromReg t0, Register:i64 %14
  t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
        t16: ch = CopyToReg t0, Register:i32 %0, t14
        t21: ch = CopyToReg t0, Register:f64 %1, t19
        t32: ch = CopyToReg t0, Register:f64 %2, t30
        t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
      t41: ch = TokenFactor t16, t21, t32, t37, t30:1
        t34: i1 = setcc t8, Constant:i32<2>, setgt:ch
      t39: i1 = xor t34, Constant:i1<-1>
    t42: ch = brcond t41, t39, BasicBlock:ch<for.end 0x7fffc1da7528>
  t44: ch = br t42, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>



Combining: t44: ch = br t42, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>

Combining: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>

Combining: t42: ch = brcond t41, t39, BasicBlock:ch<for.end 0x7fffc1da7528>
Creating new node: t46: i1 = setcc t8, Constant:i32<2>, setle:ch
Creating new node: t47: ch = brcond t41, t46, BasicBlock:ch<for.end 0x7fffc1da7528>
 ... into: t47: ch = brcond t41, t46, BasicBlock:ch<for.end 0x7fffc1da7528>

Combining: t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>

Combining: t47: ch = brcond t41, t46, BasicBlock:ch<for.end 0x7fffc1da7528>

Combining: t46: i1 = setcc t8, Constant:i32<2>, setle:ch
Creating constant: t48: i32 = Constant<3>
Creating new node: t50: i1 = setcc t8, Constant:i32<3>, setlt:ch
 ... into: t50: i1 = setcc t8, Constant:i32<3>, setlt:ch

Combining: t47: ch = brcond t41, t50, BasicBlock:ch<for.end 0x7fffc1da7528>

Combining: t50: i1 = setcc t8, Constant:i32<3>, setlt:ch

Combining: t49: ch = setlt

Combining: t48: i32 = Constant<3>

Combining: t41: ch = TokenFactor t16, t21, t32, t37, t30:1

Combining: t40: ch = BasicBlock<for.end 0x7fffc1da7528>

Combining: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>

Combining: t36: f64 = Register %18

Combining: t35: f64 = ConstantFP<0.000000e+00>

Combining: t32: ch = CopyToReg t0, Register:f64 %2, t30

Combining: t31: f64 = Register %2

Combining: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Combining: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Combining: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1

Combining: t27: Untyped = RegisterMask

Combining: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22

Combining: t25: f64 = Register $xmm0

Combining: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t23: i64 = TargetConstant<0>

Combining: t22: f64 = fadd t19, t4

Combining: t21: ch = CopyToReg t0, Register:f64 %1, t19

Combining: t20: f64 = Register %1

Combining: t19: f64 = fdiv t17, t18

Combining: t18: f64 = sint_to_fp t14

Combining: t17: f64 = fsub t6, t4

Combining: t16: ch = CopyToReg t0, Register:i32 %0, t14

Combining: t15: i32 = Register %0

Combining: t14: i32 = shl nsw t12, Constant:i8<1>

Combining: t13: i8 = Constant<1>

Combining: t12: i32 = sdiv t10, Constant:i32<2>
Creating constant: t51: i64 = Constant<32>
Creating constant: t52: i64 = Constant<1>
Creating constant: t53: i64 = Constant<31>
Creating new node: t54: i32 = sra t10, Constant:i64<31>
Creating new node: t55: i32 = srl t54, Constant:i64<31>
Creating new node: t56: i32 = add t10, t55
Creating new node: t57: i32 = sra t56, Constant:i64<1>
Creating constant: t58: i32 = Constant<-1>
Creating constant: t60: i8 = Constant<0>
Creating constant: t61: i32 = Constant<0>
Creating new node: t62: i32 = sub Constant:i32<0>, t57
 ... into: t57: i32 = sra t56, Constant:i64<1>

Combining: t14: i32 = shl nsw t57, Constant:i8<1>

Replacing.2 t54: i32 = sra t10, Constant:i64<31>

With: t10: i32 = add nsw t8, Constant:i32<1>


Combining: t14: i32 = shl nsw t57, Constant:i8<1>
Creating new node: t63: i32 = srl t56, Constant:i64<1>

Replacing.2 t57: i32 = sra t56, Constant:i64<1>

With: t63: i32 = srl t56, Constant:i64<1>


Combining: t63: i32 = srl t56, Constant:i64<1>

Combining: t52: i64 = Constant<1>

Combining: t14: i32 = shl nsw t63, Constant:i8<1>
Creating constant: t64: i8 = Constant<0>
Creating constant: t65: i32 = Constant<-2>
Creating new node: t66: i32 = and t56, Constant:i32<-2>
 ... into: t66: i32 = and t56, Constant:i32<-2>

Combining: t18: f64 = sint_to_fp t66

Combining: t16: ch = CopyToReg t0, Register:i32 %0, t66

Combining: t66: i32 = and t56, Constant:i32<-2>

Combining: t65: i32 = Constant<-2>

Combining: t56: i32 = add t10, t55

Combining: t55: i32 = srl t10, Constant:i64<31>

Combining: t53: i64 = Constant<31>

Combining: t10: i32 = add nsw t8, Constant:i32<1>

Combining: t9: i32 = Constant<1>

Combining: t8: i32,ch = CopyFromReg t0, Register:i32 %17

Combining: t7: i32 = Register %17

Combining: t6: f64,ch = CopyFromReg t0, Register:f64 %16

Combining: t5: f64 = Register %16

Combining: t4: f64,ch = CopyFromReg t0, Register:f64 %15

Combining: t3: f64 = Register %15

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %14

Combining: t1: i64 = Register %14

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 '_Z7simpsonPFddEddi:entry'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
  t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: i32,ch = CopyFromReg t0, Register:i32 %17
  t10: i32 = add nsw t8, Constant:i32<1>
      t6: f64,ch = CopyFromReg t0, Register:f64 %16
    t17: f64 = fsub t6, t4
    t18: f64 = sint_to_fp t66
  t19: f64 = fdiv t17, t18
    t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t22: f64 = fadd t19, t4
  t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
    t2: i64,ch = CopyFromReg t0, Register:i64 %14
  t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
      t55: i32 = srl t10, Constant:i64<31>
    t56: i32 = add t10, t55
  t66: i32 = and t56, Constant:i32<-2>
        t16: ch = CopyToReg t0, Register:i32 %0, t66
        t21: ch = CopyToReg t0, Register:f64 %1, t19
        t32: ch = CopyToReg t0, Register:f64 %2, t30
        t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
      t41: ch = TokenFactor t16, t21, t32, t37, t30:1
      t50: i1 = setcc t8, Constant:i32<3>, setlt:ch
    t47: ch = brcond t41, t50, BasicBlock:ch<for.end 0x7fffc1da7528>
  t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>


Legalizing node: t65: i32 = Constant<-2>
Analyzing result type: i32
Legal result type
Legally typed node: t65: i32 = Constant<-2>

Legalizing node: t53: i64 = Constant<31>
Analyzing result type: i64
Legal result type
Legally typed node: t53: i64 = Constant<31>

Legalizing node: t49: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t49: ch = setlt

Legalizing node: t48: i32 = Constant<3>
Analyzing result type: i32
Legal result type
Legally typed node: t48: i32 = Constant<3>

Legalizing node: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>
Analyzing result type: ch
Legal result type
Legally typed node: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>

Legalizing node: t40: ch = BasicBlock<for.end 0x7fffc1da7528>
Analyzing result type: ch
Legal result type
Legally typed node: t40: ch = BasicBlock<for.end 0x7fffc1da7528>

Legalizing node: t36: f64 = Register %18
Ignoring node results
Legally typed node: t36: f64 = Register %18

Legalizing node: t35: f64 = ConstantFP<0.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t35: f64 = ConstantFP<0.000000e+00>

Legalizing node: t31: f64 = Register %2
Ignoring node results
Legally typed node: t31: f64 = Register %2

Legalizing node: t27: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t27: Untyped = RegisterMask

Legalizing node: t25: f64 = Register $xmm0
Ignoring node results
Legally typed node: t25: f64 = Register $xmm0

Legalizing node: t23: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t23: i64 = TargetConstant<0>

Legalizing node: t20: f64 = Register %1
Ignoring node results
Legally typed node: t20: f64 = Register %1

Legalizing node: t15: i32 = Register %0
Ignoring node results
Legally typed node: t15: i32 = Register %0

Legalizing node: t9: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t9: i32 = Constant<1>

Legalizing node: t7: i32 = Register %17
Ignoring node results
Legally typed node: t7: i32 = Register %17

Legalizing node: t5: f64 = Register %16
Ignoring node results
Legally typed node: t5: f64 = Register %16

Legalizing node: t3: f64 = Register %15
Ignoring node results
Legally typed node: t3: f64 = Register %15

Legalizing node: t1: i64 = Register %14
Ignoring node results
Legally typed node: t1: i64 = Register %14

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing node: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: f64,ch = CopyFromReg t0, Register:f64 %15

Legalizing node: t6: f64,ch = CopyFromReg t0, Register:f64 %16
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: f64,ch = CopyFromReg t0, Register:f64 %16

Legalizing node: t17: f64 = fsub t6, t4
Analyzing result type: f64
Legal result type
Analyzing operand: t6: f64,ch = CopyFromReg t0, Register:f64 %16
Legal operand
Analyzing operand: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Legal operand
Legally typed node: t17: f64 = fsub t6, t4

Legalizing node: t8: i32,ch = CopyFromReg t0, Register:i32 %17
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t8: i32,ch = CopyFromReg t0, Register:i32 %17

Legalizing node: t10: i32 = add nsw t8, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t8: i32,ch = CopyFromReg t0, Register:i32 %17
Legal operand
Analyzing operand: t9: i32 = Constant<1>
Legal operand
Legally typed node: t10: i32 = add nsw t8, Constant:i32<1>

Legalizing node: t55: i32 = srl t10, Constant:i64<31>
Analyzing result type: i32
Legal result type
Analyzing operand: t10: i32 = add nsw t8, Constant:i32<1>
Legal operand
Analyzing operand: t53: i64 = Constant<31>
Legal operand
Legally typed node: t55: i32 = srl t10, Constant:i64<31>

Legalizing node: t56: i32 = add t10, t55
Analyzing result type: i32
Legal result type
Analyzing operand: t10: i32 = add nsw t8, Constant:i32<1>
Legal operand
Analyzing operand: t55: i32 = srl t10, Constant:i64<31>
Legal operand
Legally typed node: t56: i32 = add t10, t55

Legalizing node: t66: i32 = and t56, Constant:i32<-2>
Analyzing result type: i32
Legal result type
Analyzing operand: t56: i32 = add t10, t55
Legal operand
Analyzing operand: t65: i32 = Constant<-2>
Legal operand
Legally typed node: t66: i32 = and t56, Constant:i32<-2>

Legalizing node: t18: f64 = sint_to_fp t66
Analyzing result type: f64
Legal result type
Analyzing operand: t66: i32 = and t56, Constant:i32<-2>
Legal operand
Legally typed node: t18: f64 = sint_to_fp t66

Legalizing node: t19: f64 = fdiv t17, t18
Analyzing result type: f64
Legal result type
Analyzing operand: t17: f64 = fsub t6, t4
Legal operand
Analyzing operand: t18: f64 = sint_to_fp t66
Legal operand
Legally typed node: t19: f64 = fdiv t17, t18

Legalizing node: t21: ch = CopyToReg t0, Register:f64 %1, t19
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t19: f64 = fdiv t17, t18
Legal operand
Legally typed node: t21: ch = CopyToReg t0, Register:f64 %1, t19

Legalizing node: t22: f64 = fadd t19, t4
Analyzing result type: f64
Legal result type
Analyzing operand: t19: f64 = fdiv t17, t18
Legal operand
Analyzing operand: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Legal operand
Legally typed node: t22: f64 = fadd t19, t4

Legalizing node: t16: ch = CopyToReg t0, Register:i32 %0, t66
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t66: i32 = and t56, Constant:i32<-2>
Legal operand
Legally typed node: t16: ch = CopyToReg t0, Register:i32 %0, t66

Legalizing node: t50: i1 = setcc t8, Constant:i32<3>, setlt:ch
Analyzing result type: i1
Promote integer result: t50: i1 = setcc t8, Constant:i32<3>, setlt:ch

Creating new node: t67: i8 = setcc t8, Constant:i32<3>, setlt:ch
Legalizing node: t67: i8 = setcc t8, Constant:i32<3>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t8: i32,ch = CopyFromReg t0, Register:i32 %17
Legal operand
Analyzing operand: t48: i32 = Constant<3>
Legal operand
Analyzing operand: t49: ch = setlt
Legal operand
Legally typed node: t67: i8 = setcc t8, Constant:i32<3>, setlt:ch

Legalizing node: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t22: f64 = fadd t19, t4
Legal operand
Legally typed node: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22

Legalizing node: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Legal operand
Analyzing operand: t27: Untyped = RegisterMask
Legal operand
Analyzing operand: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
Legal operand
Legally typed node: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1

Legalizing node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
Legal operand
Analyzing operand: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
Legal operand
Legally typed node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Legalizing node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Legal operand
Analyzing operand: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Legal operand
Legally typed node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Legalizing node: t32: ch = CopyToReg t0, Register:f64 %2, t30
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal operand
Legally typed node: t32: ch = CopyToReg t0, Register:f64 %2, t30

Legalizing node: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t35: f64 = ConstantFP<0.000000e+00>
Legal operand
Legally typed node: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>

Legalizing node: t41: ch = TokenFactor t16, t21, t32, t37, t30:1
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = CopyToReg t0, Register:i32 %0, t66
Legal operand
Analyzing operand: t21: ch = CopyToReg t0, Register:f64 %1, t19
Legal operand
Analyzing operand: t32: ch = CopyToReg t0, Register:f64 %2, t30
Legal operand
Analyzing operand: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
Legal operand
Analyzing operand: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal operand
Legally typed node: t41: ch = TokenFactor t16, t21, t32, t37, t30:1

Legalizing node: t47: ch = brcond t41, t50, BasicBlock:ch<for.end 0x7fffc1da7528>
Analyzing result type: ch
Legal result type
Analyzing operand: t41: ch = TokenFactor t16, t21, t32, t37, t30:1
Legal operand
Analyzing operand: t50: i1 = setcc t8, Constant:i32<3>, setlt:ch
Promote integer operand: t47: ch = brcond t41, t50, BasicBlock:ch<for.end 0x7fffc1da7528>

Creating new node: t68: i8 = zero_extend t50
Legalizing node: t68: i8 = zero_extend t50
Analyzing result type: i8
Legal result type
Analyzing operand: t50: i1 = setcc t8, Constant:i32<3>, setlt:ch
Promote integer operand: t68: i8 = zero_extend t50

Creating constant: t69: i8 = Constant<1>
Creating new node: t70: i8 = and t67, Constant:i8<1>
Replacing: t68: i8 = zero_extend t50
     with: t70: i8 = and t67, Constant:i8<1>
Legalizing node: t69: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t69: i8 = Constant<1>

Legalizing node: t70: i8 = and t67, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t67: i8 = setcc t8, Constant:i32<3>, setlt:ch
Legal operand
Analyzing operand: t69: i8 = Constant<1>
Legal operand
Legally typed node: t70: i8 = and t67, Constant:i8<1>

Legalizing node: t47: ch = brcond t41, t70, BasicBlock:ch<for.end 0x7fffc1da7528>
Analyzing result type: ch
Legal result type
Analyzing operand: t41: ch = TokenFactor t16, t21, t32, t37, t30:1
Legal operand
Analyzing operand: t70: i8 = and t67, Constant:i8<1>
Legal operand
Analyzing operand: t40: ch = BasicBlock<for.end 0x7fffc1da7528>
Legal operand
Legally typed node: t47: ch = brcond t41, t70, BasicBlock:ch<for.end 0x7fffc1da7528>

Legalizing node: t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>
Analyzing result type: ch
Legal result type
Analyzing operand: t47: ch = brcond t41, t70, BasicBlock:ch<for.end 0x7fffc1da7528>
Legal operand
Analyzing operand: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>
Legal operand
Legally typed node: t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>

Legalizing node: t65535: ch = handlenode t44
Analyzing result type: ch
Legal result type
Analyzing operand: t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>
Legal operand
Legally typed node: t65535: ch = handlenode t44

Type-legalized selection DAG: %bb.0 '_Z7simpsonPFddEddi:entry'
SelectionDAG has 47 nodes:
  t0: ch = EntryToken
  t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: i32,ch = CopyFromReg t0, Register:i32 %17
  t10: i32 = add nsw t8, Constant:i32<1>
      t6: f64,ch = CopyFromReg t0, Register:f64 %16
    t17: f64 = fsub t6, t4
    t18: f64 = sint_to_fp t66
  t19: f64 = fdiv t17, t18
    t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t22: f64 = fadd t19, t4
  t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
    t2: i64,ch = CopyFromReg t0, Register:i64 %14
  t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
      t55: i32 = srl t10, Constant:i64<31>
    t56: i32 = add t10, t55
  t66: i32 = and t56, Constant:i32<-2>
        t16: ch = CopyToReg t0, Register:i32 %0, t66
        t21: ch = CopyToReg t0, Register:f64 %1, t19
        t32: ch = CopyToReg t0, Register:f64 %2, t30
        t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
      t41: ch = TokenFactor t16, t21, t32, t37, t30:1
        t67: i8 = setcc t8, Constant:i32<3>, setlt:ch
      t70: i8 = and t67, Constant:i8<1>
    t47: ch = brcond t41, t70, BasicBlock:ch<for.end 0x7fffc1da7528>
  t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>



Combining: t70: i8 = and t67, Constant:i8<1>

Replacing.2 t70: i8 = and t67, Constant:i8<1>

With: t67: i8 = setcc t8, Constant:i32<3>, setlt:ch


Combining: t67: i8 = setcc t8, Constant:i32<3>, setlt:ch

Combining: t66: i32 = and t56, Constant:i32<-2>

Combining: t65: i32 = Constant<-2>

Combining: t56: i32 = add t10, t55

Combining: t55: i32 = srl t10, Constant:i64<31>

Combining: t53: i64 = Constant<31>

Combining: t49: ch = setlt

Combining: t48: i32 = Constant<3>

Combining: t47: ch = brcond t41, t67, BasicBlock:ch<for.end 0x7fffc1da7528>

Combining: t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>

Combining: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>

Combining: t41: ch = TokenFactor t16, t21, t32, t37, t30:1

Combining: t40: ch = BasicBlock<for.end 0x7fffc1da7528>

Combining: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>

Combining: t36: f64 = Register %18

Combining: t35: f64 = ConstantFP<0.000000e+00>

Combining: t32: ch = CopyToReg t0, Register:f64 %2, t30

Combining: t31: f64 = Register %2

Combining: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Combining: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Combining: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1

Combining: t27: Untyped = RegisterMask

Combining: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22

Combining: t25: f64 = Register $xmm0

Combining: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t23: i64 = TargetConstant<0>

Combining: t22: f64 = fadd t19, t4

Combining: t21: ch = CopyToReg t0, Register:f64 %1, t19

Combining: t20: f64 = Register %1

Combining: t19: f64 = fdiv t17, t18

Combining: t18: f64 = sint_to_fp t66

Combining: t17: f64 = fsub t6, t4

Combining: t16: ch = CopyToReg t0, Register:i32 %0, t66

Combining: t15: i32 = Register %0

Combining: t10: i32 = add nsw t8, Constant:i32<1>

Combining: t9: i32 = Constant<1>

Combining: t8: i32,ch = CopyFromReg t0, Register:i32 %17

Combining: t7: i32 = Register %17

Combining: t6: f64,ch = CopyFromReg t0, Register:f64 %16

Combining: t5: f64 = Register %16

Combining: t4: f64,ch = CopyFromReg t0, Register:f64 %15

Combining: t3: f64 = Register %15

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %14

Combining: t1: i64 = Register %14

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.0 '_Z7simpsonPFddEddi:entry'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
  t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: i32,ch = CopyFromReg t0, Register:i32 %17
  t10: i32 = add nsw t8, Constant:i32<1>
      t6: f64,ch = CopyFromReg t0, Register:f64 %16
    t17: f64 = fsub t6, t4
    t18: f64 = sint_to_fp t66
  t19: f64 = fdiv t17, t18
    t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t22: f64 = fadd t19, t4
  t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
    t2: i64,ch = CopyFromReg t0, Register:i64 %14
  t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
      t55: i32 = srl t10, Constant:i64<31>
    t56: i32 = add t10, t55
  t66: i32 = and t56, Constant:i32<-2>
        t16: ch = CopyToReg t0, Register:i32 %0, t66
        t21: ch = CopyToReg t0, Register:f64 %1, t19
        t32: ch = CopyToReg t0, Register:f64 %2, t30
        t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
      t41: ch = TokenFactor t16, t21, t32, t37, t30:1
      t67: i8 = setcc t8, Constant:i32<3>, setlt:ch
    t47: ch = brcond t41, t67, BasicBlock:ch<for.end 0x7fffc1da7528>
  t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>



Legalizing: t44: ch = br t47, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>
Legal node: nothing to do

Legalizing: t47: ch = brcond t41, t67, BasicBlock:ch<for.end 0x7fffc1da7528>
Trying custom legalization
Creating new node: t71: i32,i32 = X86ISD::SUB t8, Constant:i32<3>
Creating constant: t72: i8 = TargetConstant<12>
Creating new node: t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1
Successfully custom legalized node
 ... replacing: t47: ch = brcond t41, t67, BasicBlock:ch<for.end 0x7fffc1da7528>
     with:      t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1

Legalizing: t41: ch = TokenFactor t16, t21, t32, t37, t30:1
Legal node: nothing to do

Legalizing: t32: ch = CopyToReg t0, Register:f64 %2, t30
Legal node: nothing to do

Legalizing: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal node: nothing to do

Legalizing: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Legalizing: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
Legal node: nothing to do

Legalizing: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
Legal node: nothing to do

Legalizing: t21: ch = CopyToReg t0, Register:f64 %1, t19
Legal node: nothing to do

Legalizing: t22: f64 = fadd t19, t4
Trying custom legalization

Legalizing: t19: f64 = fdiv t17, t18
Legal node: nothing to do

Legalizing: t18: f64 = sint_to_fp t66
Trying custom legalization

Legalizing: t16: ch = CopyToReg t0, Register:i32 %0, t66
Legal node: nothing to do

Legalizing: t66: i32 = and t56, Constant:i32<-2>
Legal node: nothing to do

Legalizing: t56: i32 = add t10, t55
Legal node: nothing to do

Legalizing: t55: i32 = srl t10, Constant:i64<31>
Creating constant: t74: i8 = Constant<31>
Legal node: nothing to do

Legalizing: t10: i32 = add nsw t8, Constant:i32<1>
Legal node: nothing to do

Legalizing: t17: f64 = fsub t6, t4
Trying custom legalization

Legalizing: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Legalizing: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t8: i32,ch = CopyFromReg t0, Register:i32 %17
Legal node: nothing to do

Legalizing: t6: f64,ch = CopyFromReg t0, Register:f64 %16
Legal node: nothing to do

Legalizing: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Legalizing: t65: i32 = Constant<-2>
Legal node: nothing to do

Legalizing: t48: i32 = Constant<3>
Legal node: nothing to do

Legalizing: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>
Legal node: nothing to do

Legalizing: t40: ch = BasicBlock<for.end 0x7fffc1da7528>
Legal node: nothing to do

Legalizing: t36: f64 = Register %18

Legalizing: t35: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Legalizing: t31: f64 = Register %2

Legalizing: t27: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t25: f64 = Register $xmm0

Legalizing: t23: i64 = TargetConstant<0>

Legalizing: t20: f64 = Register %1

Legalizing: t15: i32 = Register %0

Legalizing: t9: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t7: i32 = Register %17

Legalizing: t5: f64 = Register %16

Legalizing: t3: f64 = Register %15

Legalizing: t1: i64 = Register %14

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t74: i8 = Constant<31>
Legal node: nothing to do

Legalizing: t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1
Legal node: nothing to do

Legalizing: t72: i8 = TargetConstant<12>

Legalizing: t71: i32,i32 = X86ISD::SUB t8, Constant:i32<3>
Legal node: nothing to do
Legalized selection DAG: %bb.0 '_Z7simpsonPFddEddi:entry'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
  t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: i32,ch = CopyFromReg t0, Register:i32 %17
  t10: i32 = add nsw t8, Constant:i32<1>
      t55: i32 = srl t10, Constant:i8<31>
    t56: i32 = add t10, t55
  t66: i32 = and t56, Constant:i32<-2>
      t6: f64,ch = CopyFromReg t0, Register:f64 %16
    t17: f64 = fsub t6, t4
    t18: f64 = sint_to_fp t66
  t19: f64 = fdiv t17, t18
    t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t22: f64 = fadd t19, t4
  t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
    t2: i64,ch = CopyFromReg t0, Register:i64 %14
  t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
        t16: ch = CopyToReg t0, Register:i32 %0, t66
        t21: ch = CopyToReg t0, Register:f64 %1, t19
        t32: ch = CopyToReg t0, Register:f64 %2, t30
        t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
      t41: ch = TokenFactor t16, t21, t32, t37, t30:1
      t71: i32,i32 = X86ISD::SUB t8, Constant:i32<3>
    t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1
  t44: ch = br t73, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>



Legalizing: t74: i8 = Constant<31>
Legal node: nothing to do

Combining: t74: i8 = Constant<31>

Legalizing: t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1
Legal node: nothing to do

Combining: t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1

Legalizing: t72: i8 = TargetConstant<12>

Combining: t72: i8 = TargetConstant<12>

Legalizing: t71: i32,i32 = X86ISD::SUB t8, Constant:i32<3>
Legal node: nothing to do

Combining: t71: i32,i32 = X86ISD::SUB t8, Constant:i32<3>

Legalizing: t44: ch = br t73, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>
Legal node: nothing to do

Combining: t44: ch = br t73, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>

Legalizing: t41: ch = TokenFactor t16, t21, t32, t37, t30:1
Legal node: nothing to do

Combining: t41: ch = TokenFactor t16, t21, t32, t37, t30:1

Legalizing: t32: ch = CopyToReg t0, Register:f64 %2, t30
Legal node: nothing to do

Combining: t32: ch = CopyToReg t0, Register:f64 %2, t30

Legalizing: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal node: nothing to do

Combining: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Legalizing: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Combining: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Legalizing: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
Legal node: nothing to do

Combining: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1

Legalizing: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
Legal node: nothing to do

Combining: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22

Legalizing: t21: ch = CopyToReg t0, Register:f64 %1, t19
Legal node: nothing to do

Combining: t21: ch = CopyToReg t0, Register:f64 %1, t19

Legalizing: t22: f64 = fadd t19, t4
Trying custom legalization

Combining: t22: f64 = fadd t19, t4

Legalizing: t19: f64 = fdiv t17, t18
Legal node: nothing to do

Combining: t19: f64 = fdiv t17, t18

Legalizing: t18: f64 = sint_to_fp t66
Trying custom legalization

Combining: t18: f64 = sint_to_fp t66

Legalizing: t16: ch = CopyToReg t0, Register:i32 %0, t66
Legal node: nothing to do

Combining: t16: ch = CopyToReg t0, Register:i32 %0, t66

Legalizing: t66: i32 = and t56, Constant:i32<-2>
Legal node: nothing to do

Combining: t66: i32 = and t56, Constant:i32<-2>

Legalizing: t56: i32 = add t10, t55
Legal node: nothing to do

Combining: t56: i32 = add t10, t55

Legalizing: t55: i32 = srl t10, Constant:i8<31>
Legal node: nothing to do

Combining: t55: i32 = srl t10, Constant:i8<31>

Legalizing: t10: i32 = add nsw t8, Constant:i32<1>
Legal node: nothing to do

Combining: t10: i32 = add nsw t8, Constant:i32<1>

Legalizing: t17: f64 = fsub t6, t4
Trying custom legalization

Combining: t17: f64 = fsub t6, t4

Legalizing: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Combining: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>

Legalizing: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t8: i32,ch = CopyFromReg t0, Register:i32 %17
Legal node: nothing to do

Combining: t8: i32,ch = CopyFromReg t0, Register:i32 %17

Legalizing: t6: f64,ch = CopyFromReg t0, Register:f64 %16
Legal node: nothing to do

Combining: t6: f64,ch = CopyFromReg t0, Register:f64 %16

Legalizing: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Legal node: nothing to do

Combining: t4: f64,ch = CopyFromReg t0, Register:f64 %15

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing: t65: i32 = Constant<-2>
Legal node: nothing to do

Combining: t65: i32 = Constant<-2>

Legalizing: t48: i32 = Constant<3>
Legal node: nothing to do

Combining: t48: i32 = Constant<3>

Legalizing: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>
Legal node: nothing to do

Combining: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>

Legalizing: t40: ch = BasicBlock<for.end 0x7fffc1da7528>
Legal node: nothing to do

Combining: t40: ch = BasicBlock<for.end 0x7fffc1da7528>

Legalizing: t36: f64 = Register %18

Combining: t36: f64 = Register %18

Legalizing: t35: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Combining: t35: f64 = ConstantFP<0.000000e+00>

Legalizing: t31: f64 = Register %2

Combining: t31: f64 = Register %2

Legalizing: t27: Untyped = RegisterMask
Legal node: nothing to do

Combining: t27: Untyped = RegisterMask

Legalizing: t25: f64 = Register $xmm0

Combining: t25: f64 = Register $xmm0

Legalizing: t23: i64 = TargetConstant<0>

Combining: t23: i64 = TargetConstant<0>

Legalizing: t20: f64 = Register %1

Combining: t20: f64 = Register %1

Legalizing: t15: i32 = Register %0

Combining: t15: i32 = Register %0

Legalizing: t9: i32 = Constant<1>
Legal node: nothing to do

Combining: t9: i32 = Constant<1>

Legalizing: t7: i32 = Register %17

Combining: t7: i32 = Register %17

Legalizing: t5: f64 = Register %16

Combining: t5: f64 = Register %16

Legalizing: t3: f64 = Register %15

Combining: t3: f64 = Register %15

Legalizing: t1: i64 = Register %14

Combining: t1: i64 = Register %14

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 '_Z7simpsonPFddEddi:entry'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
  t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: i32,ch = CopyFromReg t0, Register:i32 %17
  t10: i32 = add nsw t8, Constant:i32<1>
      t55: i32 = srl t10, Constant:i8<31>
    t56: i32 = add t10, t55
  t66: i32 = and t56, Constant:i32<-2>
      t6: f64,ch = CopyFromReg t0, Register:f64 %16
    t17: f64 = fsub t6, t4
    t18: f64 = sint_to_fp t66
  t19: f64 = fdiv t17, t18
    t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t22: f64 = fadd t19, t4
  t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22
    t2: i64,ch = CopyFromReg t0, Register:i64 %14
  t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
        t16: ch = CopyToReg t0, Register:i32 %0, t66
        t21: ch = CopyToReg t0, Register:f64 %1, t19
        t32: ch = CopyToReg t0, Register:f64 %2, t30
        t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>
      t41: ch = TokenFactor t16, t21, t32, t37, t30:1
      t71: i32,i32 = X86ISD::SUB t8, Constant:i32<3>
    t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1
  t44: ch = br t73, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t44: ch = br t73, BasicBlock:ch<for.body.preheader 0x7fffc1da7100>
ISEL: Starting pattern match
  Morphed node: t44: ch = JMP_1 BasicBlock:ch<for.body.preheader 0x7fffc1da7100>, t73
ISEL: Match complete!

ISEL: Starting selection on root node: t73: ch = X86ISD::BRCOND t41, BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t71:1
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t76: ch,glue = CopyToReg t41, Register:i32 $eflags, t71:1
  Morphed node: t73: ch = JCC_1 BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t76, t76:1
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch = TokenFactor t16, t21, t32, t37, t30:1

ISEL: Starting selection on root node: t32: ch = CopyToReg t0, Register:f64 %2, t30

ISEL: Starting selection on root node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

ISEL: Starting selection on root node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1
ISEL: Match complete!

ISEL: Starting selection on root node: t28: ch,glue = X86ISD::CALL t26, t2, Register:f64 $xmm0, RegisterMask:Untyped, t26:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  Match failed at index 91386
  Continuing at 91455
  Match failed at index 91456
  Continuing at 91467
  Match failed at index 91468
  Continuing at 91492
  Morphed node: t28: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t26, t26:1
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch,glue = CopyToReg t24, Register:f64 $xmm0, t22

ISEL: Starting selection on root node: t21: ch = CopyToReg t0, Register:f64 %1, t19

ISEL: Starting selection on root node: t22: f64 = fadd t19, t4
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t22: f64 = ADDSDrr nofpexcept t19, t4
ISEL: Match complete!

ISEL: Starting selection on root node: t19: f64 = fdiv t17, t18
ISEL: Starting pattern match
  Initial Opcode index to 157809
  Match failed at index 157814
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  Match failed at index 158417
  Continuing at 158553
  TypeSwitch[f64] from 158555 to 158607
  Skipped scope entry (due to false predicate) at index 158609, continuing at 158620
  Skipped scope entry (due to false predicate) at index 158621, continuing at 158631
  Morphed node: t19: f64 = DIVSDrr nofpexcept t17, t18
ISEL: Match complete!

ISEL: Starting selection on root node: t18: f64 = sint_to_fp t66
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t18: f64 = CVTSI2SDrr t66
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch = CopyToReg t0, Register:i32 %0, t66

ISEL: Starting selection on root node: t66: i32 = and t56, Constant:i32<-2>
ISEL: Starting pattern match
  Initial Opcode index to 44172
  Match failed at index 44176
  Continuing at 44491
  Match failed at index 44494
  Continuing at 44597
  OpcodeSwitch from 44600 to 44804
  Skipped scope entry (due to false predicate) at index 44807, continuing at 44854
  Skipped scope entry (due to false predicate) at index 44855, continuing at 44911
  Match failed at index 44805
  Continuing at 44913
  Match failed at index 44917
  Continuing at 45047
  Match failed at index 45050
  Continuing at 45183
  Match failed at index 45184
  Continuing at 45256
  Match failed at index 45257
  Continuing at 45292
  Match failed at index 45295
  Continuing at 45407
  OpcodeSwitch from 45409 to 45413
  Skipped scope entry (due to false predicate) at index 45416, continuing at 45456
  Skipped scope entry (due to false predicate) at index 45457, continuing at 45488
  Match failed at index 45414
  Continuing at 45525
  Match failed at index 45528
  Continuing at 45635
  Match failed at index 45637
  Continuing at 45745
  Match failed at index 45746
  Continuing at 45771
  Match failed at index 45772
  Continuing at 45829
  Match failed at index 45830
  Continuing at 45872
  Match failed at index 45873
  Continuing at 45913
  Match failed at index 45914
  Continuing at 45953
  Skipped scope entry (due to false predicate) at index 45963, continuing at 45984
  Skipped scope entry (due to false predicate) at index 45985, continuing at 46030
  Skipped scope entry (due to false predicate) at index 46031, continuing at 46076
  Skipped scope entry (due to false predicate) at index 46077, continuing at 46098
  Match failed at index 46102
  Continuing at 46115
Creating constant: t77: i32 = TargetConstant<-2>
  Morphed node: t66: i32,i32 = AND32ri8 t56, TargetConstant:i32<-2>
ISEL: Match complete!

ISEL: Starting selection on root node: t56: i32 = add t10, t55
ISEL: Starting pattern match
  Initial Opcode index to 97341
  Match failed at index 97345
  Continuing at 97448
  Match failed at index 97450
  Continuing at 97557
  TypeSwitch[i32] from 97559 to 97562
  Skipped scope entry (due to false predicate) at index 97564, continuing at 97580
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg t8: i32,ch = CopyFromReg t0, Register:i32 %17
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg t8: i32,ch = CopyFromReg t0, Register:i32 %17
 Scale 1
IndexReg nul
 Disp 1
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t79: i8 = TargetConstant<1>
Creating constant: t80: i32 = TargetConstant<1>
Creating new machine node: t82: i64 = IMPLICIT_DEF
Creating constant: t83: i32 = TargetConstant<6>
Creating new machine node: t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>
Creating new machine node: t85: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t55, TargetConstant:i32<6>
  Morphed node: t56: i32 = LEA64_32r t84, TargetConstant:i8<1>, t85, TargetConstant:i32<1>, Register:i16 $noreg
ISEL: Match complete!

ISEL: Starting selection on root node: t55: i32 = srl t10, Constant:i8<31>
ISEL: Starting pattern match
  Initial Opcode index to 42373
  Match failed at index 42377
  Continuing at 42633
  Match failed at index 42640
  Continuing at 42783
  Match failed at index 42784
  Continuing at 42830
  Match failed at index 42831
  Continuing at 42866
  TypeSwitch[i32] from 42878 to 42907
Creating constant: t86: i8 = TargetConstant<31>
  Morphed node: t55: i32,i32 = SHR32ri t10, TargetConstant:i8<31>
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i32 = add nsw t8, Constant:i32<1>
ISEL: Starting pattern match
  Initial Opcode index to 97341
  Match failed at index 97345
  Continuing at 97448
  Match failed at index 97450
  Continuing at 97557
  TypeSwitch[i32] from 97559 to 97562
  Skipped scope entry (due to false predicate) at index 97564, continuing at 97580
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg t8: i32,ch = CopyFromReg t0, Register:i32 %17
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 97583
  Continuing at 97597
  Continuing at 97615
  Match failed at index 97618
  Continuing at 97639
  Match failed at index 97641
  Continuing at 97663
  TypeSwitch[i32] from 97670 to 97697
  Match failed at index 97697
  Continuing at 97720
  Match failed at index 97721
  Continuing at 97782
  Match failed at index 97783
  Continuing at 97857
  Match failed at index 97858
  Continuing at 97887
  Match failed at index 97901
  Continuing at 97914
  Morphed node: t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t71: i32,i32 = X86ISD::SUB t8, Constant:i32<3>
ISEL: Starting pattern match
  Initial Opcode index to 89092
  Match failed at index 89099
  Continuing at 89202
  Match failed at index 89203
  Continuing at 89249
  Match failed at index 89250
  Continuing at 89313
  Continuing at 89314
  Match failed at index 89315
  Continuing at 89360
  Match failed at index 89379
  Continuing at 89392
  Match failed at index 89398
  Continuing at 89411
Creating constant: t87: i32 = TargetConstant<3>
  Morphed node: t71: i32,i32 = SUB32ri8 t8, TargetConstant:i32<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t17: f64 = fsub t6, t4
ISEL: Starting pattern match
  Initial Opcode index to 150506
  Match failed at index 150511
  Continuing at 150803
  Match failed at index 150806
  Continuing at 151107
  Match failed at index 151114
  Continuing at 151250
  TypeSwitch[f64] from 151252 to 151304
  Skipped scope entry (due to false predicate) at index 151306, continuing at 151317
  Skipped scope entry (due to false predicate) at index 151318, continuing at 151328
  Morphed node: t17: f64 = SUBSDrr nofpexcept t6, t4
ISEL: Match complete!

ISEL: Starting selection on root node: t37: ch = CopyToReg t0, Register:f64 %18, ConstantFP:f64<0.000000e+00>

ISEL: Starting selection on root node: t24: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t88: i32 = TargetConstant<0>
  Morphed node: t24: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i32,ch = CopyFromReg t0, Register:i32 %17

ISEL: Starting selection on root node: t6: f64,ch = CopyFromReg t0, Register:f64 %16

ISEL: Starting selection on root node: t4: f64,ch = CopyFromReg t0, Register:f64 %15

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %14

ISEL: Starting selection on root node: t72: i8 = TargetConstant<12>

ISEL: Starting selection on root node: t43: ch = BasicBlock<for.body.preheader 0x7fffc1da7100>

ISEL: Starting selection on root node: t40: ch = BasicBlock<for.end 0x7fffc1da7528>

ISEL: Starting selection on root node: t36: f64 = Register %18

ISEL: Starting selection on root node: t35: f64 = ConstantFP<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 195000
  TypeSwitch[f64] from 195000 to 195094
  Match failed at index 195098
  Continuing at 195107
  Match failed at index 195108
  Continuing at 195119
  Morphed node: t35: f64 = FsFLD0SD
ISEL: Match complete!

ISEL: Starting selection on root node: t31: f64 = Register %2

ISEL: Starting selection on root node: t27: Untyped = RegisterMask

ISEL: Starting selection on root node: t25: f64 = Register $xmm0

ISEL: Starting selection on root node: t23: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t20: f64 = Register %1

ISEL: Starting selection on root node: t15: i32 = Register %0

ISEL: Starting selection on root node: t7: i32 = Register %17

ISEL: Starting selection on root node: t5: f64 = Register %16

ISEL: Starting selection on root node: t3: f64 = Register %15

ISEL: Starting selection on root node: t1: i64 = Register %14

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 '_Z7simpsonPFddEddi:entry'
SelectionDAG has 55 nodes:
  t0: ch = EntryToken
  t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: i32,ch = CopyFromReg t0, Register:i32 %17
      t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>
          t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>
        t55: i32,i32 = SHR32ri t10, TargetConstant:i8<31>
      t85: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t55, TargetConstant:i32<6>
    t56: i32 = LEA64_32r t84, TargetConstant:i8<1>, t85, TargetConstant:i32<1>, Register:i16 $noreg
  t66: i32,i32 = AND32ri8 t56, TargetConstant:i32<-2>
      t6: f64,ch = CopyFromReg t0, Register:f64 %16
    t17: f64 = SUBSDrr nofpexcept t6, t4
    t18: f64 = CVTSI2SDrr t66
  t19: f64 = DIVSDrr nofpexcept t17, t18
    t24: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t22: f64 = ADDSDrr nofpexcept t19, t4
  t26: ch,glue = CopyToReg t24:1, Register:f64 $xmm0, t22
    t2: i64,ch = CopyFromReg t0, Register:i64 %14
  t28: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t26, t26:1
  t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1
  t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2
      t16: ch = CopyToReg t0, Register:i32 %0, t66
      t21: ch = CopyToReg t0, Register:f64 %1, t19
      t32: ch = CopyToReg t0, Register:f64 %2, t30
      t37: ch = CopyToReg t0, Register:f64 %18, FsFLD0SD:f64
    t41: ch = TokenFactor t16, t21, t32, t37, t30:1
    t71: i32,i32 = SUB32ri8 t8, TargetConstant:i32<3>
  t76: ch,glue = CopyToReg t41, Register:i32 $eflags, t71:1
  t78: i32 = Register $noreg
    t73: ch = JCC_1 BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t76, t76:1
  t44: ch = JMP_1 BasicBlock:ch<for.body.preheader 0x7fffc1da7100>, t73


********** List Scheduling %bb.0 'entry' **********
SU(0): t44: ch = JMP_1 BasicBlock:ch<for.body.preheader 0x7fffc1da7100>, t73

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t73: ch = JCC_1 BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t76, t76:1

    t76: ch,glue = CopyToReg t41, Register:i32 $eflags, t71:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t71: i32,i32 = SUB32ri8 t8, TargetConstant:i32<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t8: i32,ch = CopyFromReg t0, Register:i32 %17

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(2): Data Latency=1
    SU(14): Data Latency=1
    SU(16): Data Latency=1
SU(4): t41: ch = TokenFactor t16, t21, t32, t37, t30:1

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 11
  Height             : 1
  Predecessors:
    SU(25): Ord  Latency=1 Barrier
    SU(24): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(21): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t26: ch,glue = CopyToReg t24:1, Register:f64 $xmm0, t22

    t28: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t26, t26:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 3
  Predecessors:
    SU(20): Data Latency=1
    SU(19): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(23): Data Latency=1
SU(6): t22: f64 = ADDSDrr nofpexcept t19, t4

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(6): Data Latency=1
    SU(17): Data Latency=1
SU(8): t19: f64 = DIVSDrr nofpexcept t17, t18

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 5
  Predecessors:
    SU(17): Data Latency=1
    SU(9): Data Latency=1
  Successors:
    SU(6): Data Latency=1
    SU(24): Data Latency=1
SU(9): t18: f64 = CVTSI2SDrr t66

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 6
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(8): Data Latency=1
SU(10): t66: i32,i32 = AND32ri8 t56, TargetConstant:i32<-2>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 7
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(9): Data Latency=1
    SU(25): Data Latency=1
SU(11): t56: i32 = LEA64_32r t84, TargetConstant:i8<1>, t85, TargetConstant:i32<1>, Register:i16 $noreg

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 8
  Predecessors:
    SU(16): Data Latency=1
    SU(12): Data Latency=1
  Successors:
    SU(10): Data Latency=1
SU(12): t85: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t55, TargetConstant:i32<6>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 9
  Predecessors:
    SU(15): Data Latency=1
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
SU(13): t55: i32,i32 = SHR32ri t10, TargetConstant:i8<31>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 10
  Predecessors:
    SU(14): Data Latency=1
  Successors:
    SU(12): Data Latency=1
SU(14): t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 11
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(13): Data Latency=1
SU(15): t82: i64 = IMPLICIT_DEF

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(12): Data Latency=1
    SU(16): Data Latency=1
SU(16): t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(15): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(11): Data Latency=1
SU(17): t17: f64 = SUBSDrr nofpexcept t6, t4

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(18): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(8): Data Latency=1
SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(17): Data Latency=1
SU(19): t24: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(21): t37: ch = CopyToReg t0, Register:f64 %18, FsFLD0SD:f64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(22): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(22): t35: f64 = FsFLD0SD

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(21): Data Latency=1
SU(23): t32: ch = CopyToReg t0, Register:f64 %2, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t44: ch = JMP_1 BasicBlock:ch<for.body.preheader 0x7fffc1da7100>, t73


*** Scheduling [0]: SU(0): t44: ch = JMP_1 BasicBlock:ch<for.body.preheader 0x7fffc1da7100>, t73


Examining Available:
Height 1: SU(1): t73: ch = JCC_1 BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t76, t76:1

    t76: ch,glue = CopyToReg t41, Register:i32 $eflags, t71:1


*** Scheduling [1]: SU(1): t73: ch = JCC_1 BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t76, t76:1

    t76: ch,glue = CopyToReg t41, Register:i32 $eflags, t71:1


Examining Available:
Height 1: SU(4): t41: ch = TokenFactor t16, t21, t32, t37, t30:1

Height 2: SU(2): t71: i32,i32 = SUB32ri8 t8, TargetConstant:i32<3>


*** Scheduling [2]: SU(4): t41: ch = TokenFactor t16, t21, t32, t37, t30:1


Examining Available:
  SU (2)  defines a physreg SU(21)  has no physreg
Height 2: SU(2): t71: i32,i32 = SUB32ri8 t8, TargetConstant:i32<3>

Height 3: SU(21): t37: ch = CopyToReg t0, Register:f64 %18, FsFLD0SD:f64

Height 3: SU(23): t32: ch = CopyToReg t0, Register:f64 %2, t30

Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

  SU (2)  defines a physreg SU(21)  has no physreg

*** Scheduling [3]: SU(2): t71: i32,i32 = SUB32ri8 t8, TargetConstant:i32<3>


Examining Available:
Height 3: SU(21): t37: ch = CopyToReg t0, Register:f64 %18, FsFLD0SD:f64

Height 3: SU(23): t32: ch = CopyToReg t0, Register:f64 %2, t30

Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66


*** Scheduling [4]: SU(21): t37: ch = CopyToReg t0, Register:f64 %18, FsFLD0SD:f64


Examining Available:
Height 5: SU(22): t35: f64 = FsFLD0SD

Height 3: SU(23): t32: ch = CopyToReg t0, Register:f64 %2, t30

Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66


*** Scheduling [5]: SU(22): t35: f64 = FsFLD0SD


Examining Available:
Height 3: SU(23): t32: ch = CopyToReg t0, Register:f64 %2, t30

Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66


*** Scheduling [6]: SU(23): t32: ch = CopyToReg t0, Register:f64 %2, t30


Examining Available:
Height 7: SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t26: ch,glue = CopyToReg t24:1, Register:f64 $xmm0, t22

    t28: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t26, t26:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1

Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66


*** Scheduling [7]: SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t26: ch,glue = CopyToReg t24:1, Register:f64 $xmm0, t22

    t28: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t26, t26:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1


Examining Available:
Height 8: SU(19): t24: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 8: SU(6): t22: f64 = ADDSDrr nofpexcept t19, t4

Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [8]: SU(19): t24: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


Examining Available:
Height 8: SU(6): t22: f64 = ADDSDrr nofpexcept t19, t4

Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [9]: SU(6): t22: f64 = ADDSDrr nofpexcept t19, t4


Examining Available:
Height 3: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [10]: SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19


Examining Available:
Height 11: SU(8): t19: f64 = DIVSDrr nofpexcept t17, t18

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [11]: SU(8): t19: f64 = DIVSDrr nofpexcept t17, t18


Examining Available:
Height 12: SU(9): t18: f64 = CVTSI2SDrr t66

Height 12: SU(17): t17: f64 = SUBSDrr nofpexcept t6, t4

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [12]: SU(9): t18: f64 = CVTSI2SDrr t66


Examining Available:
Height 12: SU(17): t17: f64 = SUBSDrr nofpexcept t6, t4

Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [13]: SU(17): t17: f64 = SUBSDrr nofpexcept t6, t4


Examining Available:
Height 3: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [14]: SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66


Examining Available:
Height 15: SU(10): t66: i32,i32 = AND32ri8 t56, TargetConstant:i32<-2>

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [15]: SU(10): t66: i32,i32 = AND32ri8 t56, TargetConstant:i32<-2>


Examining Available:
Height 16: SU(11): t56: i32 = LEA64_32r t84, TargetConstant:i8<1>, t85, TargetConstant:i32<1>, Register:i16 $noreg

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [16]: SU(11): t56: i32 = LEA64_32r t84, TargetConstant:i8<1>, t85, TargetConstant:i32<1>, Register:i16 $noreg


Examining Available:
  Comparing latency of SU (16) depth 1 vs SU (12) depth 3
Height 17: SU(12): t85: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t55, TargetConstant:i32<6>

Height 17: SU(16): t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14

  Comparing latency of SU (16) depth 1 vs SU (12) depth 3

*** Scheduling [17]: SU(12): t85: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t55, TargetConstant:i32<6>


Examining Available:
Height 18: SU(13): t55: i32,i32 = SHR32ri t10, TargetConstant:i8<31>

Height 17: SU(16): t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [18]: SU(13): t55: i32,i32 = SHR32ri t10, TargetConstant:i8<31>


Examining Available:
Height 17: SU(16): t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>

Height 19: SU(14): t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [19]: SU(16): t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>


Examining Available:
Height 20: SU(15): t82: i64 = IMPLICIT_DEF

Height 19: SU(14): t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [20]: SU(15): t82: i64 = IMPLICIT_DEF


Examining Available:
Height 19: SU(14): t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [21]: SU(14): t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>


Examining Available:
Height 22: SU(3): t8: i32,ch = CopyFromReg t0, Register:i32 %17

Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [22]: SU(3): t8: i32,ch = CopyFromReg t0, Register:i32 %17


Examining Available:
Height 14: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [23]: SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16


Examining Available:
Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [24]: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15


Examining Available:
Height 8: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14


*** Scheduling [25]: SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14

*** Final schedule ***
SU(20): t2: i64,ch = CopyFromReg t0, Register:i64 %14

SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

SU(18): t6: f64,ch = CopyFromReg t0, Register:f64 %16

SU(3): t8: i32,ch = CopyFromReg t0, Register:i32 %17

SU(14): t10: i32,i32 = ADD32ri8 nsw t8, TargetConstant:i32<1>

SU(15): t82: i64 = IMPLICIT_DEF

SU(16): t84: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t8, TargetConstant:i32<6>

SU(13): t55: i32,i32 = SHR32ri t10, TargetConstant:i8<31>

SU(12): t85: i64 = INSERT_SUBREG IMPLICIT_DEF:i64, t55, TargetConstant:i32<6>

SU(11): t56: i32 = LEA64_32r t84, TargetConstant:i8<1>, t85, TargetConstant:i32<1>, Register:i16 $noreg

SU(10): t66: i32,i32 = AND32ri8 t56, TargetConstant:i32<-2>

SU(25): t16: ch = CopyToReg t0, Register:i32 %0, t66

SU(17): t17: f64 = SUBSDrr nofpexcept t6, t4

SU(9): t18: f64 = CVTSI2SDrr t66

SU(8): t19: f64 = DIVSDrr nofpexcept t17, t18

SU(24): t21: ch = CopyToReg t0, Register:f64 %1, t19

SU(6): t22: f64 = ADDSDrr nofpexcept t19, t4

SU(19): t24: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t26: ch,glue = CopyToReg t24:1, Register:f64 $xmm0, t22

    t28: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t26, t26:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1

SU(23): t32: ch = CopyToReg t0, Register:f64 %2, t30

SU(22): t35: f64 = FsFLD0SD

SU(21): t37: ch = CopyToReg t0, Register:f64 %18, FsFLD0SD:f64

SU(2): t71: i32,i32 = SUB32ri8 t8, TargetConstant:i32<3>

SU(4): t41: ch = TokenFactor t16, t21, t32, t37, t30:1

SU(1): t73: ch = JCC_1 BasicBlock:ch<for.end 0x7fffc1da7528>, TargetConstant:i8<12>, t76, t76:1

    t76: ch,glue = CopyToReg t41, Register:i32 $eflags, t71:1

SU(0): t44: ch = JMP_1 BasicBlock:ch<for.body.preheader 0x7fffc1da7100>, t73


Total amount of phi nodes to update: 2
Node 0 : (0x7fffc1da7600, 2147483666)
Node 1 : (0x7fffc1da7668, 2147483650)
Creating fp constant: t1: f64 = ConstantFP<3.000000e+00>
Creating new node: t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>
Creating constant: t4: i32 = Constant<2>
Creating new node: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
Creating fp constant: t7: f64 = ConstantFP<0.000000e+00>
Creating new node: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
Creating new node: t10: ch = TokenFactor t3, t6, t9
Initial selection DAG: %bb.1 '_Z7simpsonPFddEddi:for.body.preheader'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>
    t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9



Combining: t10: ch = TokenFactor t3, t6, t9

Combining: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>

Combining: t8: f64 = Register %33

Combining: t7: f64 = ConstantFP<0.000000e+00>

Combining: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>

Combining: t5: i32 = Register %32

Combining: t4: i32 = Constant<2>

Combining: t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>

Combining: t2: f64 = Register %31

Combining: t1: f64 = ConstantFP<3.000000e+00>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 '_Z7simpsonPFddEddi:for.body.preheader'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>
    t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9


Legalizing node: t8: f64 = Register %33
Ignoring node results
Legally typed node: t8: f64 = Register %33

Legalizing node: t7: f64 = ConstantFP<0.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t7: f64 = ConstantFP<0.000000e+00>

Legalizing node: t5: i32 = Register %32
Ignoring node results
Legally typed node: t5: i32 = Register %32

Legalizing node: t4: i32 = Constant<2>
Analyzing result type: i32
Legal result type
Legally typed node: t4: i32 = Constant<2>

Legalizing node: t2: f64 = Register %31
Ignoring node results
Legally typed node: t2: f64 = Register %31

Legalizing node: t1: f64 = ConstantFP<3.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t1: f64 = ConstantFP<3.000000e+00>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: f64 = ConstantFP<3.000000e+00>
Legal operand
Legally typed node: t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>

Legalizing node: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t4: i32 = Constant<2>
Legal operand
Legally typed node: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>

Legalizing node: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: f64 = ConstantFP<0.000000e+00>
Legal operand
Legally typed node: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>

Legalizing node: t10: ch = TokenFactor t3, t6, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>
Legal operand
Analyzing operand: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
Legal operand
Analyzing operand: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
Legal operand
Legally typed node: t10: ch = TokenFactor t3, t6, t9

Legalizing node: t65535: ch = handlenode t10
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = TokenFactor t3, t6, t9
Legal operand
Legally typed node: t65535: ch = handlenode t10

Type-legalized selection DAG: %bb.1 '_Z7simpsonPFddEddi:for.body.preheader'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>
    t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9



Legalizing: t10: ch = TokenFactor t3, t6, t9
Legal node: nothing to do

Legalizing: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Legalizing: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
Legal node: nothing to do

Legalizing: t3: ch = CopyToReg t0, Register:f64 %31, ConstantFP:f64<3.000000e+00>
Legal node: nothing to do

Legalizing: t8: f64 = Register %33

Legalizing: t7: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Legalizing: t5: i32 = Register %32

Legalizing: t4: i32 = Constant<2>
Legal node: nothing to do

Legalizing: t2: f64 = Register %31

Legalizing: t1: f64 = ConstantFP<3.000000e+00>
Trying to expand node
Creating new constant pool: t11: i64 = ConstantPool<double 3.000000e+00> 0
Creating new node: t12: i64 = undef
Creating new node: t13: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t1: f64 = ConstantFP<3.000000e+00>
     with:      t13: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t13: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t12: i64 = undef
Legal node: nothing to do

Legalizing: t11: i64 = ConstantPool<double 3.000000e+00> 0
Trying custom legalization
Creating new constant pool: t14: i64 = TargetConstantPool<double 3.000000e+00> 0
Creating new node: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Successfully custom legalized node
 ... replacing: t11: i64 = ConstantPool<double 3.000000e+00> 0
     with:      t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Legalizing: t14: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.1 '_Z7simpsonPFddEddi:for.body.preheader'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
        t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
    t3: ch = CopyToReg t0, Register:f64 %31, t13
    t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9



Legalizing: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t14: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t14: i64 = TargetConstantPool<double 3.000000e+00> 0

Legalizing: t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
Legalizing non-extending load operation

Combining: t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64

Legalizing: t12: i64 = undef
Legal node: nothing to do

Combining: t12: i64 = undef

Legalizing: t10: ch = TokenFactor t3, t6, t9
Legal node: nothing to do

Combining: t10: ch = TokenFactor t3, t6, t9

Legalizing: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Combining: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>

Legalizing: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
Legal node: nothing to do

Combining: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>

Legalizing: t3: ch = CopyToReg t0, Register:f64 %31, t13
Legal node: nothing to do

Combining: t3: ch = CopyToReg t0, Register:f64 %31, t13

Legalizing: t8: f64 = Register %33

Combining: t8: f64 = Register %33

Legalizing: t7: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Combining: t7: f64 = ConstantFP<0.000000e+00>

Legalizing: t5: i32 = Register %32

Combining: t5: i32 = Register %32

Legalizing: t4: i32 = Constant<2>
Legal node: nothing to do

Combining: t4: i32 = Constant<2>

Legalizing: t2: f64 = Register %31

Combining: t2: f64 = Register %31

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 '_Z7simpsonPFddEddi:for.body.preheader'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
        t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
    t3: ch = CopyToReg t0, Register:f64 %31, t13
    t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9


===== Instruction selection begins: %bb.1 'for.body.preheader'

ISEL: Starting selection on root node: t10: ch = TokenFactor t3, t6, t9

ISEL: Starting selection on root node: t3: ch = CopyToReg t0, Register:f64 %31, t13

ISEL: Starting selection on root node: t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t17: i8 = TargetConstant<1>
Creating new constant pool: t19: i32 = TargetConstantPool<double 3.000000e+00> 0
  Morphed node: t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = CopyToReg t0, Register:f64 %33, ConstantFP:f64<0.000000e+00>

ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:i32 %32, Constant:i32<2>

ISEL: Starting selection on root node: t8: f64 = Register %33

ISEL: Starting selection on root node: t7: f64 = ConstantFP<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 195000
  TypeSwitch[f64] from 195000 to 195094
  Match failed at index 195098
  Continuing at 195107
  Match failed at index 195108
  Continuing at 195119
  Morphed node: t7: f64 = FsFLD0SD
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i32 = Register %32

ISEL: Starting selection on root node: t4: i32 = Constant<2>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i32] from 124159 to 124162
  Match failed at index 124166
  Continuing at 124177
Creating constant: t21: i32 = TargetConstant<2>
  Morphed node: t4: i32 = MOV32ri TargetConstant:i32<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t2: f64 = Register %31

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 '_Z7simpsonPFddEddi:for.body.preheader'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
      t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
    t3: ch = CopyToReg t0, Register:f64 %31, t13
      t4: i32 = MOV32ri TargetConstant:i32<2>
    t6: ch = CopyToReg t0, Register:i32 %32, t4
    t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64
  t10: ch = TokenFactor t3, t6, t9


********** List Scheduling %bb.1 'for.body.preheader' **********
SU(0): t10: ch = TokenFactor t3, t6, t9

  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t7: f64 = FsFLD0SD

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t6: ch = CopyToReg t0, Register:i32 %32, t4

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(3): Data Latency=1
SU(5): t3: ch = CopyToReg t0, Register:f64 %31, t13

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t10: ch = TokenFactor t3, t6, t9


*** Scheduling [0]: SU(0): t10: ch = TokenFactor t3, t6, t9


Examining Available:
Height 1: SU(5): t3: ch = CopyToReg t0, Register:f64 %31, t13

Height 1: SU(3): t6: ch = CopyToReg t0, Register:i32 %32, t4

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64


*** Scheduling [1]: SU(5): t3: ch = CopyToReg t0, Register:f64 %31, t13


Examining Available:
Height 2: SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

Height 1: SU(3): t6: ch = CopyToReg t0, Register:i32 %32, t4

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64


*** Scheduling [2]: SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 1: SU(3): t6: ch = CopyToReg t0, Register:i32 %32, t4

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64


*** Scheduling [3]: SU(3): t6: ch = CopyToReg t0, Register:i32 %32, t4


Examining Available:
Height 4: SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64


*** Scheduling [4]: SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>


Examining Available:
Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64


*** Scheduling [5]: SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64


Examining Available:
Height 6: SU(2): t7: f64 = FsFLD0SD


*** Scheduling [6]: SU(2): t7: f64 = FsFLD0SD

*** Final schedule ***
SU(2): t7: f64 = FsFLD0SD

SU(1): t9: ch = CopyToReg t0, Register:f64 %33, FsFLD0SD:f64

SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>

SU(3): t6: ch = CopyToReg t0, Register:i32 %32, t4

SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

SU(5): t3: ch = CopyToReg t0, Register:f64 %31, t13

SU(0): t10: ch = TokenFactor t3, t6, t9


Total amount of phi nodes to update: 4
Node 0 : (0x7fffc1da72b0, 2147483679)
Node 1 : (0x7fffc1da7318, 2147483680)
Node 2 : (0x7fffc1da7380, 2147483650)
Node 3 : (0x7fffc1da73e8, 2147483681)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Creating new node: t3: f64 = sint_to_fp t2
Creating new node: t5: f64,ch = CopyFromReg t0, Register:f64 %1
Creating new node: t6: f64 = fmul t5, t3
Creating new node: t8: f64,ch = CopyFromReg t0, Register:f64 %15
Creating new node: t9: f64 = fadd t6, t8
Creating new node: t11: i64,ch = CopyFromReg t0, Register:i64 %14
Creating constant: t12: i64 = TargetConstant<0>
Creating new node: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
Creating new node: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
Creating new node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Creating new node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Creating new node: t21: f64,ch = CopyFromReg t0, Register:f64 %6
Creating new node: t22: f64 = fadd t21, t19
Creating new node: t24: ch = CopyToReg t0, Register:f64 %7, t22
Creating new node: t26: f64,ch = CopyFromReg t0, Register:f64 %3
Creating new node: t27: f64 = fmul t5, t26
Creating new node: t28: f64 = fadd t27, t8
Creating new node: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
Creating new node: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
Creating new node: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
Creating new node: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
Creating new node: t35: f64,ch = CopyFromReg t0, Register:f64 %5
Creating new node: t36: f64 = fadd t35, t33
Creating new node: t38: ch = CopyToReg t0, Register:f64 %8, t36
Creating constant: t39: i32 = Constant<2>
Creating new node: t40: i32 = add nuw nsw t2, Constant:i32<2>
Creating new node: t42: ch = CopyToReg t0, Register:i32 %9, t40
Creating fp constant: t43: f64 = ConstantFP<2.000000e+00>
Creating new node: t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
Creating new node: t46: ch = CopyToReg t0, Register:f64 %10, t44
Creating new node: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Creating new node: t50: i1 = setcc t40, t48, setlt:ch
Creating new node: t52: ch = TokenFactor t24, t38, t42, t46, t33:1
Creating new node: t53: ch = brcond t52, t50, BasicBlock:ch<for.body 0x7fffc1da71d8>
Creating new node: t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>
Initial selection DAG: %bb.2 '_Z7simpsonPFddEddi:for.body'
SelectionDAG has 56 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %4
  t5: f64,ch = CopyFromReg t0, Register:f64 %1
  t8: f64,ch = CopyFromReg t0, Register:f64 %15
  t11: i64,ch = CopyFromReg t0, Register:i64 %14
    t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t9: f64 = fadd t6, t8
  t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
  t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
  t26: f64,ch = CopyFromReg t0, Register:f64 %3
    t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t27: f64 = fmul t5, t26
    t28: f64 = fadd t27, t8
  t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
  t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
  t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
  t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
  t40: i32 = add nuw nsw t2, Constant:i32<2>
            t21: f64,ch = CopyFromReg t0, Register:f64 %6
          t22: f64 = fadd t21, t19
        t24: ch = CopyToReg t0, Register:f64 %7, t22
            t35: f64,ch = CopyFromReg t0, Register:f64 %5
          t36: f64 = fadd t35, t33
        t38: ch = CopyToReg t0, Register:f64 %8, t36
        t42: ch = CopyToReg t0, Register:i32 %9, t40
          t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
        t46: ch = CopyToReg t0, Register:f64 %10, t44
      t52: ch = TokenFactor t24, t38, t42, t46, t33:1
        t48: i32,ch = CopyFromReg t0, Register:i32 %0
      t50: i1 = setcc t40, t48, setlt:ch
    t53: ch = brcond t52, t50, BasicBlock:ch<for.body 0x7fffc1da71d8>
  t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>



Combining: t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>

Combining: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>

Combining: t53: ch = brcond t52, t50, BasicBlock:ch<for.body 0x7fffc1da71d8>

Combining: t52: ch = TokenFactor t24, t38, t42, t46, t33:1

Combining: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>

Combining: t50: i1 = setcc t40, t48, setlt:ch

Combining: t49: ch = setlt

Combining: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t47: i32 = Register %0

Combining: t46: ch = CopyToReg t0, Register:f64 %10, t44

Combining: t45: f64 = Register %10

Combining: t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
Creating fp constant: t56: f64 = ConstantFP<-2.000000e+00>

Combining: t43: f64 = ConstantFP<2.000000e+00>

Combining: t42: ch = CopyToReg t0, Register:i32 %9, t40

Combining: t41: i32 = Register %9

Combining: t40: i32 = add nuw nsw t2, Constant:i32<2>

Combining: t39: i32 = Constant<2>

Combining: t38: ch = CopyToReg t0, Register:f64 %8, t36

Combining: t37: f64 = Register %8

Combining: t36: f64 = fadd t35, t33

Combining: t35: f64,ch = CopyFromReg t0, Register:f64 %5

Combining: t34: f64 = Register %5

Combining: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1

Combining: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1

Combining: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1

Combining: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28

Combining: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: f64 = fadd t27, t8

Combining: t27: f64 = fmul t5, t26

Combining: t26: f64,ch = CopyFromReg t0, Register:f64 %3

Combining: t25: f64 = Register %3

Combining: t24: ch = CopyToReg t0, Register:f64 %7, t22

Combining: t23: f64 = Register %7

Combining: t22: f64 = fadd t21, t19

Combining: t21: f64,ch = CopyFromReg t0, Register:f64 %6

Combining: t20: f64 = Register %6

Combining: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

Combining: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Combining: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1

Combining: t16: Untyped = RegisterMask

Combining: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9

Combining: t14: f64 = Register $xmm0

Combining: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t12: i64 = TargetConstant<0>

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %14

Combining: t10: i64 = Register %14

Combining: t9: f64 = fadd t6, t8

Combining: t8: f64,ch = CopyFromReg t0, Register:f64 %15

Combining: t7: f64 = Register %15

Combining: t6: f64 = fmul t5, t3

Combining: t5: f64,ch = CopyFromReg t0, Register:f64 %1

Combining: t4: f64 = Register %1

Combining: t3: f64 = sint_to_fp t2

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Combining: t1: i32 = Register %4

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.2 '_Z7simpsonPFddEddi:for.body'
SelectionDAG has 56 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %4
  t5: f64,ch = CopyFromReg t0, Register:f64 %1
  t8: f64,ch = CopyFromReg t0, Register:f64 %15
  t11: i64,ch = CopyFromReg t0, Register:i64 %14
    t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t9: f64 = fadd t6, t8
  t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
  t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
  t26: f64,ch = CopyFromReg t0, Register:f64 %3
    t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t27: f64 = fmul t5, t26
    t28: f64 = fadd t27, t8
  t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
  t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
  t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
  t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
  t40: i32 = add nuw nsw t2, Constant:i32<2>
            t21: f64,ch = CopyFromReg t0, Register:f64 %6
          t22: f64 = fadd t21, t19
        t24: ch = CopyToReg t0, Register:f64 %7, t22
            t35: f64,ch = CopyFromReg t0, Register:f64 %5
          t36: f64 = fadd t35, t33
        t38: ch = CopyToReg t0, Register:f64 %8, t36
        t42: ch = CopyToReg t0, Register:i32 %9, t40
          t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
        t46: ch = CopyToReg t0, Register:f64 %10, t44
      t52: ch = TokenFactor t24, t38, t42, t46, t33:1
        t48: i32,ch = CopyFromReg t0, Register:i32 %0
      t50: i1 = setcc t40, t48, setlt:ch
    t53: ch = brcond t52, t50, BasicBlock:ch<for.body 0x7fffc1da71d8>
  t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>


Legalizing node: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>

Legalizing node: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>
Analyzing result type: ch
Legal result type
Legally typed node: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>

Legalizing node: t49: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t49: ch = setlt

Legalizing node: t47: i32 = Register %0
Ignoring node results
Legally typed node: t47: i32 = Register %0

Legalizing node: t45: f64 = Register %10
Ignoring node results
Legally typed node: t45: f64 = Register %10

Legalizing node: t43: f64 = ConstantFP<2.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t43: f64 = ConstantFP<2.000000e+00>

Legalizing node: t41: i32 = Register %9
Ignoring node results
Legally typed node: t41: i32 = Register %9

Legalizing node: t39: i32 = Constant<2>
Analyzing result type: i32
Legal result type
Legally typed node: t39: i32 = Constant<2>

Legalizing node: t37: f64 = Register %8
Ignoring node results
Legally typed node: t37: f64 = Register %8

Legalizing node: t34: f64 = Register %5
Ignoring node results
Legally typed node: t34: f64 = Register %5

Legalizing node: t25: f64 = Register %3
Ignoring node results
Legally typed node: t25: f64 = Register %3

Legalizing node: t23: f64 = Register %7
Ignoring node results
Legally typed node: t23: f64 = Register %7

Legalizing node: t20: f64 = Register %6
Ignoring node results
Legally typed node: t20: f64 = Register %6

Legalizing node: t16: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t16: Untyped = RegisterMask

Legalizing node: t14: f64 = Register $xmm0
Ignoring node results
Legally typed node: t14: f64 = Register $xmm0

Legalizing node: t12: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t12: i64 = TargetConstant<0>

Legalizing node: t10: i64 = Register %14
Ignoring node results
Legally typed node: t10: i64 = Register %14

Legalizing node: t7: f64 = Register %15
Ignoring node results
Legally typed node: t7: f64 = Register %15

Legalizing node: t4: f64 = Register %1
Ignoring node results
Legally typed node: t4: f64 = Register %1

Legalizing node: t1: i32 = Register %4
Ignoring node results
Legally typed node: t1: i32 = Register %4

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Legalizing node: t3: f64 = sint_to_fp t2
Analyzing result type: f64
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Legal operand
Legally typed node: t3: f64 = sint_to_fp t2

Legalizing node: t40: i32 = add nuw nsw t2, Constant:i32<2>
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Legal operand
Analyzing operand: t39: i32 = Constant<2>
Legal operand
Legally typed node: t40: i32 = add nuw nsw t2, Constant:i32<2>

Legalizing node: t42: ch = CopyToReg t0, Register:i32 %9, t40
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t40: i32 = add nuw nsw t2, Constant:i32<2>
Legal operand
Legally typed node: t42: ch = CopyToReg t0, Register:i32 %9, t40

Legalizing node: t5: f64,ch = CopyFromReg t0, Register:f64 %1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t5: f64,ch = CopyFromReg t0, Register:f64 %1

Legalizing node: t6: f64 = fmul t5, t3
Analyzing result type: f64
Legal result type
Analyzing operand: t5: f64,ch = CopyFromReg t0, Register:f64 %1
Legal operand
Analyzing operand: t3: f64 = sint_to_fp t2
Legal operand
Legally typed node: t6: f64 = fmul t5, t3

Legalizing node: t8: f64,ch = CopyFromReg t0, Register:f64 %15
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t8: f64,ch = CopyFromReg t0, Register:f64 %15

Legalizing node: t9: f64 = fadd t6, t8
Analyzing result type: f64
Legal result type
Analyzing operand: t6: f64 = fmul t5, t3
Legal operand
Analyzing operand: t8: f64,ch = CopyFromReg t0, Register:f64 %15
Legal operand
Legally typed node: t9: f64 = fadd t6, t8

Legalizing node: t11: i64,ch = CopyFromReg t0, Register:i64 %14
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t11: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing node: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t9: f64 = fadd t6, t8
Legal operand
Legally typed node: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9

Legalizing node: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
Legal operand
Analyzing operand: t11: i64,ch = CopyFromReg t0, Register:i64 %14
Legal operand
Analyzing operand: t16: Untyped = RegisterMask
Legal operand
Analyzing operand: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
Legal operand
Legally typed node: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1

Legalizing node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
Legal operand
Analyzing operand: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
Legal operand
Legally typed node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Legalizing node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Legal operand
Analyzing operand: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Legal operand
Legally typed node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

Legalizing node: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal operand
Legally typed node: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t21: f64,ch = CopyFromReg t0, Register:f64 %6
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t21: f64,ch = CopyFromReg t0, Register:f64 %6

Legalizing node: t22: f64 = fadd t21, t19
Analyzing result type: f64
Legal result type
Analyzing operand: t21: f64,ch = CopyFromReg t0, Register:f64 %6
Legal operand
Analyzing operand: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal operand
Legally typed node: t22: f64 = fadd t21, t19

Legalizing node: t24: ch = CopyToReg t0, Register:f64 %7, t22
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t22: f64 = fadd t21, t19
Legal operand
Legally typed node: t24: ch = CopyToReg t0, Register:f64 %7, t22

Legalizing node: t26: f64,ch = CopyFromReg t0, Register:f64 %3
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t26: f64,ch = CopyFromReg t0, Register:f64 %3

Legalizing node: t27: f64 = fmul t5, t26
Analyzing result type: f64
Legal result type
Analyzing operand: t5: f64,ch = CopyFromReg t0, Register:f64 %1
Legal operand
Analyzing operand: t26: f64,ch = CopyFromReg t0, Register:f64 %3
Legal operand
Legally typed node: t27: f64 = fmul t5, t26

Legalizing node: t28: f64 = fadd t27, t8
Analyzing result type: f64
Legal result type
Analyzing operand: t27: f64 = fmul t5, t26
Legal operand
Analyzing operand: t8: f64,ch = CopyFromReg t0, Register:f64 %15
Legal operand
Legally typed node: t28: f64 = fadd t27, t8

Legalizing node: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t28: f64 = fadd t27, t8
Legal operand
Legally typed node: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28

Legalizing node: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
Legal operand
Analyzing operand: t11: i64,ch = CopyFromReg t0, Register:i64 %14
Legal operand
Analyzing operand: t16: Untyped = RegisterMask
Legal operand
Analyzing operand: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
Legal operand
Legally typed node: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1

Legalizing node: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
Legal operand
Analyzing operand: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
Legal operand
Legally typed node: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1

Legalizing node: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
Legal operand
Analyzing operand: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
Legal operand
Legally typed node: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1

Legalizing node: t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t26: f64,ch = CopyFromReg t0, Register:f64 %3
Legal operand
Analyzing operand: t43: f64 = ConstantFP<2.000000e+00>
Legal operand
Legally typed node: t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>

Legalizing node: t46: ch = CopyToReg t0, Register:f64 %10, t44
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
Legal operand
Legally typed node: t46: ch = CopyToReg t0, Register:f64 %10, t44

Legalizing node: t35: f64,ch = CopyFromReg t0, Register:f64 %5
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t35: f64,ch = CopyFromReg t0, Register:f64 %5

Legalizing node: t36: f64 = fadd t35, t33
Analyzing result type: f64
Legal result type
Analyzing operand: t35: f64,ch = CopyFromReg t0, Register:f64 %5
Legal operand
Analyzing operand: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
Legal operand
Legally typed node: t36: f64 = fadd t35, t33

Legalizing node: t38: ch = CopyToReg t0, Register:f64 %8, t36
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t36: f64 = fadd t35, t33
Legal operand
Legally typed node: t38: ch = CopyToReg t0, Register:f64 %8, t36

Legalizing node: t52: ch = TokenFactor t24, t38, t42, t46, t33:1
Analyzing result type: ch
Legal result type
Analyzing operand: t24: ch = CopyToReg t0, Register:f64 %7, t22
Legal operand
Analyzing operand: t38: ch = CopyToReg t0, Register:f64 %8, t36
Legal operand
Analyzing operand: t42: ch = CopyToReg t0, Register:i32 %9, t40
Legal operand
Analyzing operand: t46: ch = CopyToReg t0, Register:f64 %10, t44
Legal operand
Analyzing operand: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
Legal operand
Legally typed node: t52: ch = TokenFactor t24, t38, t42, t46, t33:1

Legalizing node: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t50: i1 = setcc t40, t48, setlt:ch
Analyzing result type: i1
Promote integer result: t50: i1 = setcc t40, t48, setlt:ch

Creating new node: t57: i8 = setcc t40, t48, setlt:ch
Legalizing node: t53: ch = brcond t52, t50, BasicBlock:ch<for.body 0x7fffc1da71d8>
Analyzing result type: ch
Legal result type
Analyzing operand: t52: ch = TokenFactor t24, t38, t42, t46, t33:1
Legal operand
Analyzing operand: t50: i1 = setcc t40, t48, setlt:ch
Promote integer operand: t53: ch = brcond t52, t50, BasicBlock:ch<for.body 0x7fffc1da71d8>

Creating new node: t58: i8 = zero_extend t50
Legalizing node: t58: i8 = zero_extend t50
Analyzing result type: i8
Legal result type
Analyzing operand: t50: i1 = setcc t40, t48, setlt:ch
Promote integer operand: t58: i8 = zero_extend t50

Creating constant: t59: i8 = Constant<1>
Creating new node: t60: i8 = and t57, Constant:i8<1>
Replacing: t58: i8 = zero_extend t50
     with: t60: i8 = and t57, Constant:i8<1>
Legalizing node: t59: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t59: i8 = Constant<1>

Legalizing node: t57: i8 = setcc t40, t48, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t40: i32 = add nuw nsw t2, Constant:i32<2>
Legal operand
Analyzing operand: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t49: ch = setlt
Legal operand
Legally typed node: t57: i8 = setcc t40, t48, setlt:ch

Legalizing node: t60: i8 = and t57, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t57: i8 = setcc t40, t48, setlt:ch
Legal operand
Analyzing operand: t59: i8 = Constant<1>
Legal operand
Legally typed node: t60: i8 = and t57, Constant:i8<1>

Legalizing node: t53: ch = brcond t52, t60, BasicBlock:ch<for.body 0x7fffc1da71d8>
Analyzing result type: ch
Legal result type
Analyzing operand: t52: ch = TokenFactor t24, t38, t42, t46, t33:1
Legal operand
Analyzing operand: t60: i8 = and t57, Constant:i8<1>
Legal operand
Analyzing operand: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>
Legal operand
Legally typed node: t53: ch = brcond t52, t60, BasicBlock:ch<for.body 0x7fffc1da71d8>

Legalizing node: t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>
Analyzing result type: ch
Legal result type
Analyzing operand: t53: ch = brcond t52, t60, BasicBlock:ch<for.body 0x7fffc1da71d8>
Legal operand
Analyzing operand: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>
Legal operand
Legally typed node: t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>

Legalizing node: t65535: ch = handlenode t55
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>
Legal operand
Legally typed node: t65535: ch = handlenode t55

Type-legalized selection DAG: %bb.2 '_Z7simpsonPFddEddi:for.body'
SelectionDAG has 58 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %4
  t5: f64,ch = CopyFromReg t0, Register:f64 %1
  t8: f64,ch = CopyFromReg t0, Register:f64 %15
  t11: i64,ch = CopyFromReg t0, Register:i64 %14
    t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t9: f64 = fadd t6, t8
  t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
  t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
  t26: f64,ch = CopyFromReg t0, Register:f64 %3
    t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t27: f64 = fmul t5, t26
    t28: f64 = fadd t27, t8
  t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
  t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
  t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
  t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
  t40: i32 = add nuw nsw t2, Constant:i32<2>
            t21: f64,ch = CopyFromReg t0, Register:f64 %6
          t22: f64 = fadd t21, t19
        t24: ch = CopyToReg t0, Register:f64 %7, t22
            t35: f64,ch = CopyFromReg t0, Register:f64 %5
          t36: f64 = fadd t35, t33
        t38: ch = CopyToReg t0, Register:f64 %8, t36
        t42: ch = CopyToReg t0, Register:i32 %9, t40
          t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
        t46: ch = CopyToReg t0, Register:f64 %10, t44
      t52: ch = TokenFactor t24, t38, t42, t46, t33:1
          t48: i32,ch = CopyFromReg t0, Register:i32 %0
        t57: i8 = setcc t40, t48, setlt:ch
      t60: i8 = and t57, Constant:i8<1>
    t53: ch = brcond t52, t60, BasicBlock:ch<for.body 0x7fffc1da71d8>
  t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>



Combining: t60: i8 = and t57, Constant:i8<1>

Replacing.2 t60: i8 = and t57, Constant:i8<1>

With: t57: i8 = setcc t40, t48, setlt:ch


Combining: t57: i8 = setcc t40, t48, setlt:ch

Combining: t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>

Combining: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>

Combining: t53: ch = brcond t52, t57, BasicBlock:ch<for.body 0x7fffc1da71d8>

Combining: t52: ch = TokenFactor t24, t38, t42, t46, t33:1

Combining: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>

Combining: t49: ch = setlt

Combining: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t47: i32 = Register %0

Combining: t46: ch = CopyToReg t0, Register:f64 %10, t44

Combining: t45: f64 = Register %10

Combining: t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
Creating fp constant: t61: f64 = ConstantFP<-2.000000e+00>

Combining: t43: f64 = ConstantFP<2.000000e+00>

Combining: t42: ch = CopyToReg t0, Register:i32 %9, t40

Combining: t41: i32 = Register %9

Combining: t40: i32 = add nuw nsw t2, Constant:i32<2>

Combining: t39: i32 = Constant<2>

Combining: t38: ch = CopyToReg t0, Register:f64 %8, t36

Combining: t37: f64 = Register %8

Combining: t36: f64 = fadd t35, t33

Combining: t35: f64,ch = CopyFromReg t0, Register:f64 %5

Combining: t34: f64 = Register %5

Combining: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1

Combining: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1

Combining: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1

Combining: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28

Combining: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t28: f64 = fadd t27, t8

Combining: t27: f64 = fmul t5, t26

Combining: t26: f64,ch = CopyFromReg t0, Register:f64 %3

Combining: t25: f64 = Register %3

Combining: t24: ch = CopyToReg t0, Register:f64 %7, t22

Combining: t23: f64 = Register %7

Combining: t22: f64 = fadd t21, t19

Combining: t21: f64,ch = CopyFromReg t0, Register:f64 %6

Combining: t20: f64 = Register %6

Combining: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

Combining: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Combining: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1

Combining: t16: Untyped = RegisterMask

Combining: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9

Combining: t14: f64 = Register $xmm0

Combining: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t12: i64 = TargetConstant<0>

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %14

Combining: t10: i64 = Register %14

Combining: t9: f64 = fadd t6, t8

Combining: t8: f64,ch = CopyFromReg t0, Register:f64 %15

Combining: t7: f64 = Register %15

Combining: t6: f64 = fmul t5, t3

Combining: t5: f64,ch = CopyFromReg t0, Register:f64 %1

Combining: t4: f64 = Register %1

Combining: t3: f64 = sint_to_fp t2

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Combining: t1: i32 = Register %4

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.2 '_Z7simpsonPFddEddi:for.body'
SelectionDAG has 56 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %4
  t5: f64,ch = CopyFromReg t0, Register:f64 %1
  t8: f64,ch = CopyFromReg t0, Register:f64 %15
  t11: i64,ch = CopyFromReg t0, Register:i64 %14
    t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t9: f64 = fadd t6, t8
  t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
  t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
  t26: f64,ch = CopyFromReg t0, Register:f64 %3
    t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t27: f64 = fmul t5, t26
    t28: f64 = fadd t27, t8
  t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
  t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
  t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
  t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
  t40: i32 = add nuw nsw t2, Constant:i32<2>
            t21: f64,ch = CopyFromReg t0, Register:f64 %6
          t22: f64 = fadd t21, t19
        t24: ch = CopyToReg t0, Register:f64 %7, t22
            t35: f64,ch = CopyFromReg t0, Register:f64 %5
          t36: f64 = fadd t35, t33
        t38: ch = CopyToReg t0, Register:f64 %8, t36
        t42: ch = CopyToReg t0, Register:i32 %9, t40
          t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
        t46: ch = CopyToReg t0, Register:f64 %10, t44
      t52: ch = TokenFactor t24, t38, t42, t46, t33:1
        t48: i32,ch = CopyFromReg t0, Register:i32 %0
      t57: i8 = setcc t40, t48, setlt:ch
    t53: ch = brcond t52, t57, BasicBlock:ch<for.body 0x7fffc1da71d8>
  t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>



Legalizing: t55: ch = br t53, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>
Legal node: nothing to do

Legalizing: t53: ch = brcond t52, t57, BasicBlock:ch<for.body 0x7fffc1da71d8>
Trying custom legalization
Creating new node: t62: i32,i32 = X86ISD::SUB t40, t48
Creating constant: t63: i8 = TargetConstant<12>
Creating new node: t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1
Successfully custom legalized node
 ... replacing: t53: ch = brcond t52, t57, BasicBlock:ch<for.body 0x7fffc1da71d8>
     with:      t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1

Legalizing: t52: ch = TokenFactor t24, t38, t42, t46, t33:1
Legal node: nothing to do

Legalizing: t38: ch = CopyToReg t0, Register:f64 %8, t36
Legal node: nothing to do

Legalizing: t36: f64 = fadd t35, t33
Trying custom legalization

Legalizing: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
Legal node: nothing to do

Legalizing: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1

Legalizing: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
Legal node: nothing to do

Legalizing: t24: ch = CopyToReg t0, Register:f64 %7, t22
Legal node: nothing to do

Legalizing: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
Legal node: nothing to do

Legalizing: t22: f64 = fadd t21, t19
Trying custom legalization

Legalizing: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal node: nothing to do

Legalizing: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Legalizing: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
Legal node: nothing to do

Legalizing: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
Legal node: nothing to do

Legalizing: t9: f64 = fadd t6, t8
Trying custom legalization

Legalizing: t28: f64 = fadd t27, t8
Trying custom legalization

Legalizing: t46: ch = CopyToReg t0, Register:f64 %10, t44
Legal node: nothing to do

Legalizing: t6: f64 = fmul t5, t3
Legal node: nothing to do

Legalizing: t42: ch = CopyToReg t0, Register:i32 %9, t40
Legal node: nothing to do

Legalizing: t27: f64 = fmul t5, t26
Legal node: nothing to do

Legalizing: t44: f64 = fadd t26, ConstantFP:f64<2.000000e+00>
Trying custom legalization

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Legalizing: t40: i32 = add nuw nsw t2, Constant:i32<2>
Legal node: nothing to do

Legalizing: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t35: f64,ch = CopyFromReg t0, Register:f64 %5
Legal node: nothing to do

Legalizing: t26: f64,ch = CopyFromReg t0, Register:f64 %3
Legal node: nothing to do

Legalizing: t21: f64,ch = CopyFromReg t0, Register:f64 %6
Legal node: nothing to do

Legalizing: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t11: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Legalizing: t8: f64,ch = CopyFromReg t0, Register:f64 %15
Legal node: nothing to do

Legalizing: t5: f64,ch = CopyFromReg t0, Register:f64 %1
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>
Legal node: nothing to do

Legalizing: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>
Legal node: nothing to do

Legalizing: t47: i32 = Register %0

Legalizing: t45: f64 = Register %10

Legalizing: t43: f64 = ConstantFP<2.000000e+00>
Trying to expand node
Creating new constant pool: t65: i64 = ConstantPool<double 2.000000e+00> 0
Creating new node: t66: i64 = undef
Creating new node: t67: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 2.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t43: f64 = ConstantFP<2.000000e+00>
     with:      t67: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 2.000000e+00> 0, undef:i64

Legalizing: t41: i32 = Register %9

Legalizing: t39: i32 = Constant<2>
Legal node: nothing to do

Legalizing: t37: f64 = Register %8

Legalizing: t34: f64 = Register %5

Legalizing: t25: f64 = Register %3

Legalizing: t23: f64 = Register %7

Legalizing: t20: f64 = Register %6

Legalizing: t16: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t14: f64 = Register $xmm0

Legalizing: t12: i64 = TargetConstant<0>

Legalizing: t10: i64 = Register %14

Legalizing: t7: f64 = Register %15

Legalizing: t4: f64 = Register %1

Legalizing: t1: i32 = Register %4

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t67: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 2.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t66: i64 = undef
Legal node: nothing to do

Legalizing: t65: i64 = ConstantPool<double 2.000000e+00> 0
Trying custom legalization
Creating new constant pool: t68: i64 = TargetConstantPool<double 2.000000e+00> 0
Creating new node: t69: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
Successfully custom legalized node
 ... replacing: t65: i64 = ConstantPool<double 2.000000e+00> 0
     with:      t69: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0

Legalizing: t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1
Legal node: nothing to do

Legalizing: t63: i8 = TargetConstant<12>

Legalizing: t62: i32,i32 = X86ISD::SUB t40, t48
Legal node: nothing to do

Legalizing: t69: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
Legal node: nothing to do

Legalizing: t68: i64 = TargetConstantPool<double 2.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.2 '_Z7simpsonPFddEddi:for.body'
SelectionDAG has 59 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %4
  t5: f64,ch = CopyFromReg t0, Register:f64 %1
  t8: f64,ch = CopyFromReg t0, Register:f64 %15
  t11: i64,ch = CopyFromReg t0, Register:i64 %14
  t26: f64,ch = CopyFromReg t0, Register:f64 %3
  t40: i32 = add nuw nsw t2, Constant:i32<2>
    t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t9: f64 = fadd t6, t8
  t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
  t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
    t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t27: f64 = fmul t5, t26
    t28: f64 = fadd t27, t8
  t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
  t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
  t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
  t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
            t21: f64,ch = CopyFromReg t0, Register:f64 %6
          t22: f64 = fadd t21, t19
        t24: ch = CopyToReg t0, Register:f64 %7, t22
            t35: f64,ch = CopyFromReg t0, Register:f64 %5
          t36: f64 = fadd t35, t33
        t38: ch = CopyToReg t0, Register:f64 %8, t36
        t42: ch = CopyToReg t0, Register:i32 %9, t40
              t69: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
            t67: f64,ch = load<(load 8 from constant-pool)> t0, t69, undef:i64
          t44: f64 = fadd t26, t67
        t46: ch = CopyToReg t0, Register:f64 %10, t44
      t52: ch = TokenFactor t24, t38, t42, t46, t33:1
        t48: i32,ch = CopyFromReg t0, Register:i32 %0
      t62: i32,i32 = X86ISD::SUB t40, t48
    t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1
  t55: ch = br t64, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>



Legalizing: t69: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
Legal node: nothing to do

Combining: t69: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0

Legalizing: t68: i64 = TargetConstantPool<double 2.000000e+00> 0
Legal node: nothing to do

Combining: t68: i64 = TargetConstantPool<double 2.000000e+00> 0

Legalizing: t67: f64,ch = load<(load 8 from constant-pool)> t0, t69, undef:i64
Legalizing non-extending load operation

Combining: t67: f64,ch = load<(load 8 from constant-pool)> t0, t69, undef:i64

Legalizing: t66: i64 = undef
Legal node: nothing to do

Combining: t66: i64 = undef

Legalizing: t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1
Legal node: nothing to do

Combining: t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1

Legalizing: t63: i8 = TargetConstant<12>

Combining: t63: i8 = TargetConstant<12>

Legalizing: t62: i32,i32 = X86ISD::SUB t40, t48
Legal node: nothing to do

Combining: t62: i32,i32 = X86ISD::SUB t40, t48

Legalizing: t55: ch = br t64, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>
Legal node: nothing to do

Combining: t55: ch = br t64, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>

Legalizing: t52: ch = TokenFactor t24, t38, t42, t46, t33:1
Legal node: nothing to do

Combining: t52: ch = TokenFactor t24, t38, t42, t46, t33:1

Legalizing: t38: ch = CopyToReg t0, Register:f64 %8, t36
Legal node: nothing to do

Combining: t38: ch = CopyToReg t0, Register:f64 %8, t36

Legalizing: t36: f64 = fadd t35, t33
Trying custom legalization

Combining: t36: f64 = fadd t35, t33

Legalizing: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
Legal node: nothing to do

Combining: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1

Legalizing: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1

Combining: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1

Legalizing: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
Legal node: nothing to do

Combining: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1

Legalizing: t24: ch = CopyToReg t0, Register:f64 %7, t22
Legal node: nothing to do

Combining: t24: ch = CopyToReg t0, Register:f64 %7, t22

Legalizing: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
Legal node: nothing to do

Combining: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28

Legalizing: t22: f64 = fadd t21, t19
Trying custom legalization

Combining: t22: f64 = fadd t21, t19

Legalizing: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal node: nothing to do

Combining: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

Legalizing: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Combining: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Legalizing: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
Legal node: nothing to do

Combining: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1

Legalizing: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
Legal node: nothing to do

Combining: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9

Legalizing: t9: f64 = fadd t6, t8
Trying custom legalization

Combining: t9: f64 = fadd t6, t8

Legalizing: t28: f64 = fadd t27, t8
Trying custom legalization

Combining: t28: f64 = fadd t27, t8

Legalizing: t46: ch = CopyToReg t0, Register:f64 %10, t44
Legal node: nothing to do

Combining: t46: ch = CopyToReg t0, Register:f64 %10, t44

Legalizing: t6: f64 = fmul t5, t3
Legal node: nothing to do

Combining: t6: f64 = fmul t5, t3

Legalizing: t42: ch = CopyToReg t0, Register:i32 %9, t40
Legal node: nothing to do

Combining: t42: ch = CopyToReg t0, Register:i32 %9, t40

Legalizing: t27: f64 = fmul t5, t26
Legal node: nothing to do

Combining: t27: f64 = fmul t5, t26

Legalizing: t44: f64 = fadd t26, t67
Trying custom legalization

Combining: t44: f64 = fadd t26, t67

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Combining: t3: f64 = sint_to_fp t2

Legalizing: t40: i32 = add nuw nsw t2, Constant:i32<2>
Legal node: nothing to do

Combining: t40: i32 = add nuw nsw t2, Constant:i32<2>

Legalizing: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t35: f64,ch = CopyFromReg t0, Register:f64 %5
Legal node: nothing to do

Combining: t35: f64,ch = CopyFromReg t0, Register:f64 %5

Legalizing: t26: f64,ch = CopyFromReg t0, Register:f64 %3
Legal node: nothing to do

Combining: t26: f64,ch = CopyFromReg t0, Register:f64 %3

Legalizing: t21: f64,ch = CopyFromReg t0, Register:f64 %6
Legal node: nothing to do

Combining: t21: f64,ch = CopyFromReg t0, Register:f64 %6

Legalizing: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t11: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Combining: t11: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing: t8: f64,ch = CopyFromReg t0, Register:f64 %15
Legal node: nothing to do

Combining: t8: f64,ch = CopyFromReg t0, Register:f64 %15

Legalizing: t5: f64,ch = CopyFromReg t0, Register:f64 %1
Legal node: nothing to do

Combining: t5: f64,ch = CopyFromReg t0, Register:f64 %1

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Legalizing: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>

Legalizing: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>
Legal node: nothing to do

Combining: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>

Legalizing: t47: i32 = Register %0

Combining: t47: i32 = Register %0

Legalizing: t45: f64 = Register %10

Combining: t45: f64 = Register %10

Legalizing: t41: i32 = Register %9

Combining: t41: i32 = Register %9

Legalizing: t39: i32 = Constant<2>
Legal node: nothing to do

Combining: t39: i32 = Constant<2>

Legalizing: t37: f64 = Register %8

Combining: t37: f64 = Register %8

Legalizing: t34: f64 = Register %5

Combining: t34: f64 = Register %5

Legalizing: t25: f64 = Register %3

Combining: t25: f64 = Register %3

Legalizing: t23: f64 = Register %7

Combining: t23: f64 = Register %7

Legalizing: t20: f64 = Register %6

Combining: t20: f64 = Register %6

Legalizing: t16: Untyped = RegisterMask
Legal node: nothing to do

Combining: t16: Untyped = RegisterMask

Legalizing: t14: f64 = Register $xmm0

Combining: t14: f64 = Register $xmm0

Legalizing: t12: i64 = TargetConstant<0>

Combining: t12: i64 = TargetConstant<0>

Legalizing: t10: i64 = Register %14

Combining: t10: i64 = Register %14

Legalizing: t7: f64 = Register %15

Combining: t7: f64 = Register %15

Legalizing: t4: f64 = Register %1

Combining: t4: f64 = Register %1

Legalizing: t1: i32 = Register %4

Combining: t1: i32 = Register %4

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.2 '_Z7simpsonPFddEddi:for.body'
SelectionDAG has 59 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %4
  t5: f64,ch = CopyFromReg t0, Register:f64 %1
  t8: f64,ch = CopyFromReg t0, Register:f64 %15
  t11: i64,ch = CopyFromReg t0, Register:i64 %14
  t26: f64,ch = CopyFromReg t0, Register:f64 %3
  t40: i32 = add nuw nsw t2, Constant:i32<2>
    t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t9: f64 = fadd t6, t8
  t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9
  t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
    t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t27: f64 = fmul t5, t26
    t28: f64 = fadd t27, t8
  t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28
  t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
  t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
  t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1
            t21: f64,ch = CopyFromReg t0, Register:f64 %6
          t22: f64 = fadd t21, t19
        t24: ch = CopyToReg t0, Register:f64 %7, t22
            t35: f64,ch = CopyFromReg t0, Register:f64 %5
          t36: f64 = fadd t35, t33
        t38: ch = CopyToReg t0, Register:f64 %8, t36
        t42: ch = CopyToReg t0, Register:i32 %9, t40
              t69: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
            t67: f64,ch = load<(load 8 from constant-pool)> t0, t69, undef:i64
          t44: f64 = fadd t26, t67
        t46: ch = CopyToReg t0, Register:f64 %10, t44
      t52: ch = TokenFactor t24, t38, t42, t46, t33:1
        t48: i32,ch = CopyFromReg t0, Register:i32 %0
      t62: i32,i32 = X86ISD::SUB t40, t48
    t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1
  t55: ch = br t64, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>


===== Instruction selection begins: %bb.2 'for.body'

ISEL: Starting selection on root node: t55: ch = br t64, BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t55: ch = JMP_1 BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch = X86ISD::BRCOND t52, BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t62:1
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t71: ch,glue = CopyToReg t52, Register:i32 $eflags, t62:1
  Morphed node: t64: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t71, t71:1
ISEL: Match complete!

ISEL: Starting selection on root node: t52: ch = TokenFactor t24, t38, t42, t46, t33:1

ISEL: Starting selection on root node: t38: ch = CopyToReg t0, Register:f64 %8, t36

ISEL: Starting selection on root node: t36: f64 = fadd t35, t33
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t36: f64 = ADDSDrr nofpexcept t35, t33
ISEL: Match complete!

ISEL: Starting selection on root node: t33: f64,ch,glue = CopyFromReg t32, Register:f64 $xmm0, t32:1

ISEL: Starting selection on root node: t32: ch,glue = callseq_end t31, TargetConstant:i64<0>, TargetConstant:i64<0>, t31:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t32: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t31, t31:1
ISEL: Match complete!

ISEL: Starting selection on root node: t31: ch,glue = X86ISD::CALL t30, t11, Register:f64 $xmm0, RegisterMask:Untyped, t30:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  Match failed at index 91386
  Continuing at 91455
  Match failed at index 91456
  Continuing at 91467
  Match failed at index 91468
  Continuing at 91492
  Morphed node: t31: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t30, t30:1
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch = CopyToReg t0, Register:f64 %7, t22

ISEL: Starting selection on root node: t30: ch,glue = CopyToReg t29, Register:f64 $xmm0, t28

ISEL: Starting selection on root node: t22: f64 = fadd t21, t19
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t22: f64 = ADDSDrr nofpexcept t21, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch,glue = callseq_start t19:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t72: i32 = TargetConstant<0>
  Morphed node: t29: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t19:1
ISEL: Match complete!

ISEL: Starting selection on root node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

ISEL: Starting selection on root node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch,glue = X86ISD::CALL t15, t11, Register:f64 $xmm0, RegisterMask:Untyped, t15:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  Match failed at index 91386
  Continuing at 91455
  Match failed at index 91456
  Continuing at 91467
  Match failed at index 91468
  Continuing at 91492
  Morphed node: t17: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t15, t15:1
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = CopyToReg t13, Register:f64 $xmm0, t9

ISEL: Starting selection on root node: t46: ch = CopyToReg t0, Register:f64 %10, t44

ISEL: Starting selection on root node: t9: f64 = fadd t6, t8
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t9: f64 = ADDSDrr nofpexcept t6, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t44: f64 = fadd t26, t67
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  OpcodeSwitch from 144649 to 144654
  TypeSwitch[f64] from 144665 to 144689
  Match failed at index 144689
  Continuing at 144709
  Match failed at index 144710
  Continuing at 144783
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  TypeSwitch[f64] from 145261 to 145325
  Skipped scope entry (due to false predicate) at index 145327, continuing at 145345
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t74: i8 = TargetConstant<1>
Creating new constant pool: t76: i32 = TargetConstantPool<double 2.000000e+00> 0
  Morphed node: t44: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t26, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t28: f64 = fadd t27, t8
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t28: f64 = ADDSDrr nofpexcept t27, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t6: f64 = fmul t5, t3
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t6: f64 = MULSDrr nofpexcept t5, t3
ISEL: Match complete!

ISEL: Starting selection on root node: t42: ch = CopyToReg t0, Register:i32 %9, t40

ISEL: Starting selection on root node: t62: i32,i32 = X86ISD::SUB t40, t48
ISEL: Starting pattern match
  Initial Opcode index to 89092
  Match failed at index 89099
  Continuing at 89202
  Match failed at index 89203
  Continuing at 89249
  Match failed at index 89250
  Continuing at 89313
  Continuing at 89314
  Match failed at index 89315
  Continuing at 89360
  Skipped scope entry (due to false predicate) at index 89371, continuing at 89501
  Match failed at index 89505
  Continuing at 89519
  Match failed at index 89520
  Continuing at 89539
  Match failed at index 89543
  Continuing at 89557
  Match failed at index 89558
  Continuing at 89577
  Match failed at index 89583
  Continuing at 89595
  Match failed at index 89596
  Continuing at 89615
  Match failed at index 89616
  Continuing at 89635
  Continuing at 89636
  Match failed at index 89637
  Continuing at 89648
  Match failed at index 89649
  Continuing at 89660
  Morphed node: t62: i32,i32 = SUB32rr t40, t48
ISEL: Match complete!

ISEL: Starting selection on root node: t27: f64 = fmul t5, t26
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t27: f64 = MULSDrr nofpexcept t5, t26
ISEL: Match complete!

ISEL: Starting selection on root node: t3: f64 = sint_to_fp t2
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t3: f64 = CVTSI2SDrr t2
ISEL: Match complete!

ISEL: Starting selection on root node: t40: i32 = add nuw nsw t2, Constant:i32<2>
ISEL: Starting pattern match
  Initial Opcode index to 97341
  Match failed at index 97345
  Continuing at 97448
  Match failed at index 97450
  Continuing at 97557
  TypeSwitch[i32] from 97559 to 97562
  Skipped scope entry (due to false predicate) at index 97564, continuing at 97580
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg t2: i32,ch = CopyFromReg t0, Register:i32 %4
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 97583
  Continuing at 97597
  Continuing at 97615
  Match failed at index 97618
  Continuing at 97639
  Match failed at index 97641
  Continuing at 97663
  Skipped scope entry (due to false predicate) at index 97668, continuing at 97720
  Skipped scope entry (due to false predicate) at index 97721, continuing at 97782
  Skipped scope entry (due to false predicate) at index 97783, continuing at 97857
  Skipped scope entry (due to false predicate) at index 97858, continuing at 97887
  Match failed at index 97901
  Continuing at 97914
Creating constant: t79: i32 = TargetConstant<2>
  Morphed node: t40: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t48: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t35: f64,ch = CopyFromReg t0, Register:f64 %5

ISEL: Starting selection on root node: t26: f64,ch = CopyFromReg t0, Register:f64 %3

ISEL: Starting selection on root node: t21: f64,ch = CopyFromReg t0, Register:f64 %6

ISEL: Starting selection on root node: t13: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i64,ch = CopyFromReg t0, Register:i64 %14

ISEL: Starting selection on root node: t8: f64,ch = CopyFromReg t0, Register:f64 %15

ISEL: Starting selection on root node: t5: f64,ch = CopyFromReg t0, Register:f64 %1

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %4

ISEL: Starting selection on root node: t63: i8 = TargetConstant<12>

ISEL: Starting selection on root node: t54: ch = BasicBlock<for.end.loopexit 0x7fffc1da7450>

ISEL: Starting selection on root node: t51: ch = BasicBlock<for.body 0x7fffc1da71d8>

ISEL: Starting selection on root node: t47: i32 = Register %0

ISEL: Starting selection on root node: t45: f64 = Register %10

ISEL: Starting selection on root node: t41: i32 = Register %9

ISEL: Starting selection on root node: t37: f64 = Register %8

ISEL: Starting selection on root node: t34: f64 = Register %5

ISEL: Starting selection on root node: t25: f64 = Register %3

ISEL: Starting selection on root node: t23: f64 = Register %7

ISEL: Starting selection on root node: t20: f64 = Register %6

ISEL: Starting selection on root node: t16: Untyped = RegisterMask

ISEL: Starting selection on root node: t14: f64 = Register $xmm0

ISEL: Starting selection on root node: t12: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t10: i64 = Register %14

ISEL: Starting selection on root node: t7: f64 = Register %15

ISEL: Starting selection on root node: t4: f64 = Register %1

ISEL: Starting selection on root node: t1: i32 = Register %4

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 '_Z7simpsonPFddEddi:for.body'
SelectionDAG has 64 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %4
  t5: f64,ch = CopyFromReg t0, Register:f64 %1
  t8: f64,ch = CopyFromReg t0, Register:f64 %15
  t11: i64,ch = CopyFromReg t0, Register:i64 %14
  t26: f64,ch = CopyFromReg t0, Register:f64 %3
  t40: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>
    t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
        t3: f64 = CVTSI2SDrr t2
      t6: f64 = MULSDrr nofpexcept t5, t3
    t9: f64 = ADDSDrr nofpexcept t6, t8
  t15: ch,glue = CopyToReg t13:1, Register:f64 $xmm0, t9
  t17: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t15, t15:1
  t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1
  t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2
    t29: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t19:1
      t27: f64 = MULSDrr nofpexcept t5, t26
    t28: f64 = ADDSDrr nofpexcept t27, t8
  t30: ch,glue = CopyToReg t29:1, Register:f64 $xmm0, t28
  t31: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t30, t30:1
  t32: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t31, t31:1
  t33: f64,ch,glue = CopyFromReg t32:1, Register:f64 $xmm0, t32:2
          t21: f64,ch = CopyFromReg t0, Register:f64 %6
        t22: f64 = ADDSDrr nofpexcept t21, t19
      t24: ch = CopyToReg t0, Register:f64 %7, t22
          t35: f64,ch = CopyFromReg t0, Register:f64 %5
        t36: f64 = ADDSDrr nofpexcept t35, t33
      t38: ch = CopyToReg t0, Register:f64 %8, t36
      t42: ch = CopyToReg t0, Register:i32 %9, t40
        t44: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t26, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0
      t46: ch = CopyToReg t0, Register:f64 %10, t44
    t52: ch = TokenFactor t24, t38, t42, t46, t33:1
      t48: i32,ch = CopyFromReg t0, Register:i32 %0
    t62: i32,i32 = SUB32rr t40, t48
  t71: ch,glue = CopyToReg t52, Register:i32 $eflags, t62:1
  t78: i32 = Register $noreg
    t64: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t71, t71:1
  t55: ch = JMP_1 BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>, t64


********** List Scheduling %bb.2 'for.body' **********
SU(0): t55: ch = JMP_1 BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>, t64

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t64: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t71, t71:1

    t71: ch,glue = CopyToReg t52, Register:i32 $eflags, t62:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(6): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t62: i32,i32 = SUB32rr t40, t48

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t48: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(4): t40: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(22): Data Latency=1
SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %4

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(4): Data Latency=1
    SU(17): Data Latency=1
SU(6): t52: ch = TokenFactor t24, t38, t42, t46, t33:1

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(26): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(7): t33: f64,ch,glue = CopyFromReg t32:1, Register:f64 $xmm0, t32:2

    t30: ch,glue = CopyToReg t29:1, Register:f64 $xmm0, t28

    t31: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t30, t30:1

    t32: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t31, t31:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(19): Data Latency=1
    SU(13): Ord  Latency=1 Barrier
    SU(8): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(24): Data Latency=1
SU(8): t28: f64 = ADDSDrr nofpexcept t27, t8

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(10): Data Latency=1
    SU(9): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(9): t8: f64,ch = CopyFromReg t0, Register:f64 %15

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(8): Data Latency=1
    SU(15): Data Latency=1
SU(10): t27: f64 = MULSDrr nofpexcept t5, t26

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(12): Data Latency=1
    SU(11): Data Latency=1
  Successors:
    SU(8): Data Latency=1
SU(11): t26: f64,ch = CopyFromReg t0, Register:f64 %3

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(10): Data Latency=1
    SU(21): Data Latency=1
SU(12): t5: f64,ch = CopyFromReg t0, Register:f64 %1

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 9
  Successors:
    SU(10): Data Latency=1
    SU(16): Data Latency=1
SU(13): t29: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t19:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t15: ch,glue = CopyToReg t13:1, Register:f64 $xmm0, t9

    t17: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t15, t15:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(19): Data Latency=1
    SU(18): Ord  Latency=1 Barrier
    SU(15): Data Latency=1
  Successors:
    SU(13): Ord  Latency=1 Barrier
    SU(27): Data Latency=1
SU(15): t9: f64 = ADDSDrr nofpexcept t6, t8

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(16): Data Latency=1
    SU(9): Data Latency=1
  Successors:
    SU(14): Data Latency=1
SU(16): t6: f64 = MULSDrr nofpexcept t5, t3

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(12): Data Latency=1
    SU(17): Data Latency=1
  Successors:
    SU(15): Data Latency=1
SU(17): t3: f64 = CVTSI2SDrr t2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(16): Data Latency=1
SU(18): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(14): Ord  Latency=1 Barrier
SU(19): t11: i64,ch = CopyFromReg t0, Register:i64 %14

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(7): Data Latency=1
    SU(14): Data Latency=1
SU(20): t46: ch = CopyToReg t0, Register:f64 %10, t44

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(21): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(21): t44: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t26, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(20): Data Latency=1
SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(24): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(24): t36: f64 = ADDSDrr nofpexcept t35, t33

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(25): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(23): Data Latency=1
SU(25): t35: f64,ch = CopyFromReg t0, Register:f64 %5

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(24): Data Latency=1
SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(27): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(27): t22: f64 = ADDSDrr nofpexcept t21, t19

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(28): Data Latency=1
    SU(14): Data Latency=1
  Successors:
    SU(26): Data Latency=1
SU(28): t21: f64,ch = CopyFromReg t0, Register:f64 %6

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(27): Data Latency=1
VRegCycle: SU(21)

Examining Available:
Height 0: SU(0): t55: ch = JMP_1 BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>, t64


*** Scheduling [0]: SU(0): t55: ch = JMP_1 BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>, t64


Examining Available:
Height 1: SU(1): t64: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t71, t71:1

    t71: ch,glue = CopyToReg t52, Register:i32 $eflags, t62:1


*** Scheduling [1]: SU(1): t64: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t71, t71:1

    t71: ch,glue = CopyToReg t52, Register:i32 $eflags, t62:1


Examining Available:
Height 1: SU(6): t52: ch = TokenFactor t24, t38, t42, t46, t33:1

Height 2: SU(2): t62: i32,i32 = SUB32rr t40, t48


*** Scheduling [2]: SU(6): t52: ch = TokenFactor t24, t38, t42, t46, t33:1


Examining Available:
Height 2: SU(2): t62: i32,i32 = SUB32rr t40, t48

Height 3: SU(20): t46: ch = CopyToReg t0, Register:f64 %10, t44

Height 3: SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40

Height 3: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [3]: SU(2): t62: i32,i32 = SUB32rr t40, t48


Examining Available:
Height 4: SU(3): t48: i32,ch = CopyFromReg t0, Register:i32 %0

Height 3: SU(20): t46: ch = CopyToReg t0, Register:f64 %10, t44

Height 3: SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40

Height 3: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [4]: SU(3): t48: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 3: SU(20): t46: ch = CopyToReg t0, Register:f64 %10, t44

Height 3: SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40

Height 3: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [5]: SU(20): t46: ch = CopyToReg t0, Register:f64 %10, t44


Examining Available:
Height 6: SU(21): t44: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t26, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0

Height 3: SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40

Height 3: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [6]: SU(21): t44: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t26, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 3: SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40

Height 3: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [7]: SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40


Examining Available:
Height 8: SU(4): t40: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>

Height 3: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [8]: SU(4): t40: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>


Examining Available:
Height 3: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [9]: SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36


Examining Available:
Height 10: SU(24): t36: f64 = ADDSDrr nofpexcept t35, t33

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [10]: SU(24): t36: f64 = ADDSDrr nofpexcept t35, t33


Examining Available:
Height 11: SU(25): t35: f64,ch = CopyFromReg t0, Register:f64 %5

Height 11: SU(7): t33: f64,ch,glue = CopyFromReg t32:1, Register:f64 $xmm0, t32:2

    t30: ch,glue = CopyToReg t29:1, Register:f64 $xmm0, t28

    t31: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t30, t30:1

    t32: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t31, t31:1

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [11]: SU(25): t35: f64,ch = CopyFromReg t0, Register:f64 %5


Examining Available:
Height 11: SU(7): t33: f64,ch,glue = CopyFromReg t32:1, Register:f64 $xmm0, t32:2

    t30: ch,glue = CopyToReg t29:1, Register:f64 $xmm0, t28

    t31: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t30, t30:1

    t32: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t31, t31:1

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [12]: SU(7): t33: f64,ch,glue = CopyFromReg t32:1, Register:f64 $xmm0, t32:2

    t30: ch,glue = CopyToReg t29:1, Register:f64 $xmm0, t28

    t31: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t30, t30:1

    t32: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t31, t31:1


Examining Available:
Height 13: SU(13): t29: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t19:1

Height 13: SU(8): t28: f64 = ADDSDrr nofpexcept t27, t8

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [13]: SU(13): t29: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t19:1


Examining Available:
Height 13: SU(8): t28: f64 = ADDSDrr nofpexcept t27, t8

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [14]: SU(8): t28: f64 = ADDSDrr nofpexcept t27, t8


Examining Available:
Height 15: SU(10): t27: f64 = MULSDrr nofpexcept t5, t26

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [15]: SU(10): t27: f64 = MULSDrr nofpexcept t5, t26


Examining Available:
Height 16: SU(11): t26: f64,ch = CopyFromReg t0, Register:f64 %3

Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [16]: SU(11): t26: f64,ch = CopyFromReg t0, Register:f64 %3


Examining Available:
Height 3: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


*** Scheduling [17]: SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22


Examining Available:
Height 18: SU(27): t22: f64 = ADDSDrr nofpexcept t21, t19


*** Scheduling [18]: SU(27): t22: f64 = ADDSDrr nofpexcept t21, t19


Examining Available:
Height 19: SU(28): t21: f64,ch = CopyFromReg t0, Register:f64 %6

Height 19: SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t15: ch,glue = CopyToReg t13:1, Register:f64 $xmm0, t9

    t17: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t15, t15:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1


*** Scheduling [19]: SU(28): t21: f64,ch = CopyFromReg t0, Register:f64 %6


Examining Available:
Height 19: SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t15: ch,glue = CopyToReg t13:1, Register:f64 $xmm0, t9

    t17: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t15, t15:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1


*** Scheduling [20]: SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t15: ch,glue = CopyToReg t13:1, Register:f64 $xmm0, t9

    t17: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t15, t15:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1


Examining Available:
Height 21: SU(19): t11: i64,ch = CopyFromReg t0, Register:i64 %14

Height 21: SU(18): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 21: SU(15): t9: f64 = ADDSDrr nofpexcept t6, t8


*** Scheduling [21]: SU(19): t11: i64,ch = CopyFromReg t0, Register:i64 %14


Examining Available:
Height 21: SU(18): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 21: SU(15): t9: f64 = ADDSDrr nofpexcept t6, t8


*** Scheduling [22]: SU(18): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


Examining Available:
Height 21: SU(15): t9: f64 = ADDSDrr nofpexcept t6, t8


*** Scheduling [23]: SU(15): t9: f64 = ADDSDrr nofpexcept t6, t8


Examining Available:
Height 24: SU(9): t8: f64,ch = CopyFromReg t0, Register:f64 %15

Height 24: SU(16): t6: f64 = MULSDrr nofpexcept t5, t3


*** Scheduling [24]: SU(9): t8: f64,ch = CopyFromReg t0, Register:f64 %15


Examining Available:
Height 24: SU(16): t6: f64 = MULSDrr nofpexcept t5, t3


*** Scheduling [25]: SU(16): t6: f64 = MULSDrr nofpexcept t5, t3


Examining Available:
Height 26: SU(12): t5: f64,ch = CopyFromReg t0, Register:f64 %1

Height 26: SU(17): t3: f64 = CVTSI2SDrr t2


*** Scheduling [26]: SU(12): t5: f64,ch = CopyFromReg t0, Register:f64 %1


Examining Available:
Height 26: SU(17): t3: f64 = CVTSI2SDrr t2


*** Scheduling [27]: SU(17): t3: f64 = CVTSI2SDrr t2


Examining Available:
Height 28: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %4


*** Scheduling [28]: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %4

*** Final schedule ***
SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %4

SU(17): t3: f64 = CVTSI2SDrr t2

SU(12): t5: f64,ch = CopyFromReg t0, Register:f64 %1

SU(16): t6: f64 = MULSDrr nofpexcept t5, t3

SU(9): t8: f64,ch = CopyFromReg t0, Register:f64 %15

SU(15): t9: f64 = ADDSDrr nofpexcept t6, t8

SU(18): t13: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(19): t11: i64,ch = CopyFromReg t0, Register:i64 %14

SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t15: ch,glue = CopyToReg t13:1, Register:f64 $xmm0, t9

    t17: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t15, t15:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1

SU(28): t21: f64,ch = CopyFromReg t0, Register:f64 %6

SU(27): t22: f64 = ADDSDrr nofpexcept t21, t19

SU(26): t24: ch = CopyToReg t0, Register:f64 %7, t22

SU(11): t26: f64,ch = CopyFromReg t0, Register:f64 %3

SU(10): t27: f64 = MULSDrr nofpexcept t5, t26

SU(8): t28: f64 = ADDSDrr nofpexcept t27, t8

SU(13): t29: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t19:1

SU(7): t33: f64,ch,glue = CopyFromReg t32:1, Register:f64 $xmm0, t32:2

    t30: ch,glue = CopyToReg t29:1, Register:f64 $xmm0, t28

    t31: ch,glue = CALL64r t11, Register:f64 $xmm0, RegisterMask:Untyped, t30, t30:1

    t32: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t31, t31:1

SU(25): t35: f64,ch = CopyFromReg t0, Register:f64 %5

SU(24): t36: f64 = ADDSDrr nofpexcept t35, t33

SU(23): t38: ch = CopyToReg t0, Register:f64 %8, t36

SU(4): t40: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>

SU(22): t42: ch = CopyToReg t0, Register:i32 %9, t40

SU(21): t44: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t26, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0

SU(20): t46: ch = CopyToReg t0, Register:f64 %10, t44

SU(3): t48: i32,ch = CopyFromReg t0, Register:i32 %0

SU(2): t62: i32,i32 = SUB32rr t40, t48

SU(6): t52: ch = TokenFactor t24, t38, t42, t46, t33:1

SU(1): t64: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1da71d8>, TargetConstant:i8<12>, t71, t71:1

    t71: ch,glue = CopyToReg t52, Register:i32 $eflags, t62:1

SU(0): t55: ch = JMP_1 BasicBlock:ch<for.end.loopexit 0x7fffc1da7450>, t64


Total amount of phi nodes to update: 4
Node 0 : (0x7fffc1da72b0, 2147483658)
Node 1 : (0x7fffc1da7318, 2147483657)
Node 2 : (0x7fffc1da7380, 2147483656)
Node 3 : (0x7fffc1da73e8, 2147483655)
Creating new node: t2: f64,ch = CopyFromReg t0, Register:f64 %7
Creating fp constant: t3: f64 = ConstantFP<2.000000e+00>
Creating new node: t4: f64 = fmul t2, ConstantFP:f64<2.000000e+00>
Creating new node: t6: ch = CopyToReg t0, Register:f64 %11, t4
Initial selection DAG: %bb.3 '_Z7simpsonPFddEddi:for.end.loopexit'
SelectionDAG has 7 nodes:
  t0: ch = EntryToken
      t2: f64,ch = CopyFromReg t0, Register:f64 %7
    t4: f64 = fmul t2, ConstantFP:f64<2.000000e+00>
  t6: ch = CopyToReg t0, Register:f64 %11, t4



Combining: t6: ch = CopyToReg t0, Register:f64 %11, t4

Combining: t5: f64 = Register %11

Combining: t4: f64 = fmul t2, ConstantFP:f64<2.000000e+00>
Creating new node: t7: f64 = fadd t2, t2
 ... into: t7: f64 = fadd t2, t2

Combining: t6: ch = CopyToReg t0, Register:f64 %11, t7

Combining: t7: f64 = fadd t2, t2

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %7

Combining: t1: f64 = Register %7

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.3 '_Z7simpsonPFddEddi:for.end.loopexit'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %7
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %11, t7


Legalizing node: t5: f64 = Register %11
Ignoring node results
Legally typed node: t5: f64 = Register %11

Legalizing node: t1: f64 = Register %7
Ignoring node results
Legally typed node: t1: f64 = Register %7

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: f64,ch = CopyFromReg t0, Register:f64 %7
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: f64,ch = CopyFromReg t0, Register:f64 %7

Legalizing node: t7: f64 = fadd t2, t2
Analyzing result type: f64
Legal result type
Analyzing operand: t2: f64,ch = CopyFromReg t0, Register:f64 %7
Legal operand
Analyzing operand: t2: f64,ch = CopyFromReg t0, Register:f64 %7
Legal operand
Legally typed node: t7: f64 = fadd t2, t2

Legalizing node: t6: ch = CopyToReg t0, Register:f64 %11, t7
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: f64 = fadd t2, t2
Legal operand
Legally typed node: t6: ch = CopyToReg t0, Register:f64 %11, t7

Legalizing node: t65535: ch = handlenode t6
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = CopyToReg t0, Register:f64 %11, t7
Legal operand
Legally typed node: t65535: ch = handlenode t6

Type-legalized selection DAG: %bb.3 '_Z7simpsonPFddEddi:for.end.loopexit'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %7
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %11, t7



Legalizing: t6: ch = CopyToReg t0, Register:f64 %11, t7
Legal node: nothing to do

Legalizing: t7: f64 = fadd t2, t2
Trying custom legalization

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %7
Legal node: nothing to do

Legalizing: t5: f64 = Register %11

Legalizing: t1: f64 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.3 '_Z7simpsonPFddEddi:for.end.loopexit'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %7
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %11, t7



Legalizing: t6: ch = CopyToReg t0, Register:f64 %11, t7
Legal node: nothing to do

Combining: t6: ch = CopyToReg t0, Register:f64 %11, t7

Legalizing: t7: f64 = fadd t2, t2
Trying custom legalization

Combining: t7: f64 = fadd t2, t2

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %7
Legal node: nothing to do

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %7

Legalizing: t5: f64 = Register %11

Combining: t5: f64 = Register %11

Legalizing: t1: f64 = Register %7

Combining: t1: f64 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.3 '_Z7simpsonPFddEddi:for.end.loopexit'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %7
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %11, t7


===== Instruction selection begins: %bb.3 'for.end.loopexit'

ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:f64 %11, t7

ISEL: Starting selection on root node: t7: f64 = fadd t2, t2
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t7: f64 = ADDSDrr nofpexcept t2, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t2: f64,ch = CopyFromReg t0, Register:f64 %7

ISEL: Starting selection on root node: t5: f64 = Register %11

ISEL: Starting selection on root node: t1: f64 = Register %7

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.3 '_Z7simpsonPFddEddi:for.end.loopexit'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %7
    t7: f64 = ADDSDrr nofpexcept t2, t2
  t6: ch = CopyToReg t0, Register:f64 %11, t7


********** List Scheduling %bb.3 'for.end.loopexit' **********
SU(0): t6: ch = CopyToReg t0, Register:f64 %11, t7

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %7

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t6: ch = CopyToReg t0, Register:f64 %11, t7


*** Scheduling [0]: SU(0): t6: ch = CopyToReg t0, Register:f64 %11, t7


Examining Available:
Height 1: SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2


*** Scheduling [1]: SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2


Examining Available:
Height 2: SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %7


*** Scheduling [2]: SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %7

*** Final schedule ***
SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %7

SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2

SU(0): t6: ch = CopyToReg t0, Register:f64 %11, t7


Total amount of phi nodes to update: 2
Node 0 : (0x7fffc1da7600, 2147483659)
Node 1 : (0x7fffc1da7668, 2147483656)
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Creating new node: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Creating constant: t5: i64 = TargetConstant<0>
Creating new node: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
Creating new node: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
Creating new node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Creating new node: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
Creating new node: t14: f64,ch = CopyFromReg t0, Register:f64 %16
Creating new node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
Creating new node: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
Creating new node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Creating new node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Creating new node: t20: f64 = fadd t12, t19
Creating new node: t22: f64,ch = CopyFromReg t0, Register:f64 %12
Creating new node: t23: f64 = fadd t22, t20
Creating new node: t25: f64,ch = CopyFromReg t0, Register:f64 %13
Creating fp constant: t26: f64 = ConstantFP<4.000000e+00>
Creating new node: t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
Creating new node: t28: f64 = fadd t27, t23
Creating new node: t30: f64,ch = CopyFromReg t0, Register:f64 %1
Creating new node: t31: f64 = fmul t30, t28
Creating fp constant: t32: f64 = ConstantFP<3.000000e+00>
Creating new node: t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
Creating constant: t34: i32 = TargetConstant<0>
Creating new node: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
Creating new node: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1
Initial selection DAG: %bb.4 '_Z7simpsonPFddEddi:for.end'
SelectionDAG has 37 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %14
    t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
  t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t14: f64,ch = CopyFromReg t0, Register:f64 %16
  t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
  t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
        t30: f64,ch = CopyFromReg t0, Register:f64 %1
            t25: f64,ch = CopyFromReg t0, Register:f64 %13
          t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
            t22: f64,ch = CopyFromReg t0, Register:f64 %12
            t20: f64 = fadd t12, t19
          t23: f64 = fadd t22, t20
        t28: f64 = fadd t27, t23
      t31: f64 = fmul t30, t28
    t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
  t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
  t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1



Combining: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1

Combining: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33

Combining: t34: i32 = TargetConstant<0>

Combining: t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
Creating fp constant: t37: f64 = ConstantFP<-3.000000e+00>

Combining: t32: f64 = ConstantFP<3.000000e+00>

Combining: t31: f64 = fmul t30, t28

Combining: t30: f64,ch = CopyFromReg t0, Register:f64 %1

Combining: t29: f64 = Register %1

Combining: t28: f64 = fadd t27, t23
Creating fp constant: t38: f64 = ConstantFP<-4.000000e+00>
Creating new node: t39: f64 = fmul t25, ConstantFP:f64<-4.000000e+00>

Combining: t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
Creating fp constant: t40: f64 = ConstantFP<-4.000000e+00>

Combining: t26: f64 = ConstantFP<4.000000e+00>

Combining: t25: f64,ch = CopyFromReg t0, Register:f64 %13

Combining: t24: f64 = Register %13

Combining: t23: f64 = fadd t22, t20

Combining: t22: f64,ch = CopyFromReg t0, Register:f64 %12

Combining: t21: f64 = Register %12

Combining: t20: f64 = fadd t12, t19

Combining: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

Combining: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Combining: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1

Combining: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14

Combining: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t14: f64,ch = CopyFromReg t0, Register:f64 %16

Combining: t13: f64 = Register %16

Combining: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1

Combining: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Combining: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1

Combining: t9: Untyped = RegisterMask

Combining: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4

Combining: t7: f64 = Register $xmm0

Combining: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t5: i64 = TargetConstant<0>

Combining: t4: f64,ch = CopyFromReg t0, Register:f64 %15

Combining: t3: f64 = Register %15

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %14

Combining: t1: i64 = Register %14

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.4 '_Z7simpsonPFddEddi:for.end'
SelectionDAG has 37 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %14
    t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
  t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t14: f64,ch = CopyFromReg t0, Register:f64 %16
  t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
  t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
        t30: f64,ch = CopyFromReg t0, Register:f64 %1
            t25: f64,ch = CopyFromReg t0, Register:f64 %13
          t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
            t22: f64,ch = CopyFromReg t0, Register:f64 %12
            t20: f64 = fadd t12, t19
          t23: f64 = fadd t22, t20
        t28: f64 = fadd t27, t23
      t31: f64 = fmul t30, t28
    t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
  t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
  t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1


Legalizing node: t34: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t34: i32 = TargetConstant<0>

Legalizing node: t32: f64 = ConstantFP<3.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t32: f64 = ConstantFP<3.000000e+00>

Legalizing node: t29: f64 = Register %1
Ignoring node results
Legally typed node: t29: f64 = Register %1

Legalizing node: t26: f64 = ConstantFP<4.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t26: f64 = ConstantFP<4.000000e+00>

Legalizing node: t24: f64 = Register %13
Ignoring node results
Legally typed node: t24: f64 = Register %13

Legalizing node: t21: f64 = Register %12
Ignoring node results
Legally typed node: t21: f64 = Register %12

Legalizing node: t13: f64 = Register %16
Ignoring node results
Legally typed node: t13: f64 = Register %16

Legalizing node: t9: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t9: Untyped = RegisterMask

Legalizing node: t7: f64 = Register $xmm0
Ignoring node results
Legally typed node: t7: f64 = Register $xmm0

Legalizing node: t5: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t5: i64 = TargetConstant<0>

Legalizing node: t3: f64 = Register %15
Ignoring node results
Legally typed node: t3: f64 = Register %15

Legalizing node: t1: i64 = Register %14
Ignoring node results
Legally typed node: t1: i64 = Register %14

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing node: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: f64,ch = CopyFromReg t0, Register:f64 %15

Legalizing node: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Legal operand
Legally typed node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4

Legalizing node: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Legal operand
Analyzing operand: t9: Untyped = RegisterMask
Legal operand
Analyzing operand: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
Legal operand
Legally typed node: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1

Legalizing node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
Legal operand
Analyzing operand: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
Legal operand
Legally typed node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Legalizing node: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Legal operand
Analyzing operand: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Legal operand
Legally typed node: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1

Legalizing node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
Legal operand
Legally typed node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t14: f64,ch = CopyFromReg t0, Register:f64 %16
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t14: f64,ch = CopyFromReg t0, Register:f64 %16

Legalizing node: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t14: f64,ch = CopyFromReg t0, Register:f64 %16
Legal operand
Legally typed node: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14

Legalizing node: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Legal operand
Analyzing operand: t9: Untyped = RegisterMask
Legal operand
Analyzing operand: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
Legal operand
Legally typed node: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1

Legalizing node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
Legal operand
Analyzing operand: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
Legal operand
Legally typed node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Legalizing node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Legal operand
Analyzing operand: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
Legal operand
Legally typed node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

Legalizing node: t20: f64 = fadd t12, t19
Analyzing result type: f64
Legal result type
Analyzing operand: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
Legal operand
Analyzing operand: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal operand
Legally typed node: t20: f64 = fadd t12, t19

Legalizing node: t22: f64,ch = CopyFromReg t0, Register:f64 %12
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t22: f64,ch = CopyFromReg t0, Register:f64 %12

Legalizing node: t23: f64 = fadd t22, t20
Analyzing result type: f64
Legal result type
Analyzing operand: t22: f64,ch = CopyFromReg t0, Register:f64 %12
Legal operand
Analyzing operand: t20: f64 = fadd t12, t19
Legal operand
Legally typed node: t23: f64 = fadd t22, t20

Legalizing node: t25: f64,ch = CopyFromReg t0, Register:f64 %13
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t25: f64,ch = CopyFromReg t0, Register:f64 %13

Legalizing node: t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t25: f64,ch = CopyFromReg t0, Register:f64 %13
Legal operand
Analyzing operand: t26: f64 = ConstantFP<4.000000e+00>
Legal operand
Legally typed node: t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>

Legalizing node: t28: f64 = fadd t27, t23
Analyzing result type: f64
Legal result type
Analyzing operand: t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
Legal operand
Analyzing operand: t23: f64 = fadd t22, t20
Legal operand
Legally typed node: t28: f64 = fadd t27, t23

Legalizing node: t30: f64,ch = CopyFromReg t0, Register:f64 %1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t30: f64,ch = CopyFromReg t0, Register:f64 %1

Legalizing node: t31: f64 = fmul t30, t28
Analyzing result type: f64
Legal result type
Analyzing operand: t30: f64,ch = CopyFromReg t0, Register:f64 %1
Legal operand
Analyzing operand: t28: f64 = fadd t27, t23
Legal operand
Legally typed node: t31: f64 = fmul t30, t28

Legalizing node: t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t31: f64 = fmul t30, t28
Legal operand
Analyzing operand: t32: f64 = ConstantFP<3.000000e+00>
Legal operand
Legally typed node: t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>

Legalizing node: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal operand
Analyzing operand: t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
Legal operand
Legally typed node: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33

Legalizing node: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
Legal operand
Analyzing operand: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
Legal operand
Legally typed node: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1

Legalizing node: t65535: ch = handlenode t36
Analyzing result type: ch
Legal result type
Analyzing operand: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1
Legal operand
Legally typed node: t65535: ch = handlenode t36

Type-legalized selection DAG: %bb.4 '_Z7simpsonPFddEddi:for.end'
SelectionDAG has 37 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %14
    t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
  t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t14: f64,ch = CopyFromReg t0, Register:f64 %16
  t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
  t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
        t30: f64,ch = CopyFromReg t0, Register:f64 %1
            t25: f64,ch = CopyFromReg t0, Register:f64 %13
          t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
            t22: f64,ch = CopyFromReg t0, Register:f64 %12
            t20: f64 = fadd t12, t19
          t23: f64 = fadd t22, t20
        t28: f64 = fadd t27, t23
      t31: f64 = fmul t30, t28
    t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
  t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
  t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1



Legalizing: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1
Legal node: nothing to do

Legalizing: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
Legal node: nothing to do

Legalizing: t33: f64 = fdiv t31, ConstantFP:f64<3.000000e+00>
Legal node: nothing to do

Legalizing: t31: f64 = fmul t30, t28
Legal node: nothing to do

Legalizing: t28: f64 = fadd t27, t23
Trying custom legalization

Legalizing: t23: f64 = fadd t22, t20
Trying custom legalization

Legalizing: t20: f64 = fadd t12, t19
Trying custom legalization

Legalizing: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal node: nothing to do

Legalizing: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Legalizing: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
Legal node: nothing to do

Legalizing: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
Legal node: nothing to do

Legalizing: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
Legal node: nothing to do

Legalizing: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Legalizing: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
Legal node: nothing to do

Legalizing: t27: f64 = fmul t25, ConstantFP:f64<4.000000e+00>
Legal node: nothing to do

Legalizing: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
Legal node: nothing to do

Legalizing: t30: f64,ch = CopyFromReg t0, Register:f64 %1
Legal node: nothing to do

Legalizing: t25: f64,ch = CopyFromReg t0, Register:f64 %13
Legal node: nothing to do

Legalizing: t22: f64,ch = CopyFromReg t0, Register:f64 %12
Legal node: nothing to do

Legalizing: t14: f64,ch = CopyFromReg t0, Register:f64 %16
Legal node: nothing to do

Legalizing: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Legalizing: t34: i32 = TargetConstant<0>

Legalizing: t32: f64 = ConstantFP<3.000000e+00>
Trying to expand node
Creating new constant pool: t41: i64 = ConstantPool<double 3.000000e+00> 0
Creating new node: t42: i64 = undef
Creating new node: t43: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t32: f64 = ConstantFP<3.000000e+00>
     with:      t43: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64

Legalizing: t29: f64 = Register %1

Legalizing: t26: f64 = ConstantFP<4.000000e+00>
Trying to expand node
Creating new constant pool: t44: i64 = ConstantPool<double 4.000000e+00> 0
Creating new node: t45: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t26: f64 = ConstantFP<4.000000e+00>
     with:      t45: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64

Legalizing: t24: f64 = Register %13

Legalizing: t21: f64 = Register %12

Legalizing: t13: f64 = Register %16

Legalizing: t9: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t7: f64 = Register $xmm0

Legalizing: t5: i64 = TargetConstant<0>

Legalizing: t3: f64 = Register %15

Legalizing: t1: i64 = Register %14

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t45: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t44: i64 = ConstantPool<double 4.000000e+00> 0
Trying custom legalization
Creating new constant pool: t46: i64 = TargetConstantPool<double 4.000000e+00> 0
Creating new node: t47: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Successfully custom legalized node
 ... replacing: t44: i64 = ConstantPool<double 4.000000e+00> 0
     with:      t47: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t43: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t42: i64 = undef
Legal node: nothing to do

Legalizing: t41: i64 = ConstantPool<double 3.000000e+00> 0
Trying custom legalization
Creating new constant pool: t48: i64 = TargetConstantPool<double 3.000000e+00> 0
Creating new node: t49: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Successfully custom legalized node
 ... replacing: t41: i64 = ConstantPool<double 3.000000e+00> 0
     with:      t49: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t49: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Legalizing: t48: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do

Legalizing: t47: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t46: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.4 '_Z7simpsonPFddEddi:for.end'
SelectionDAG has 42 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %14
    t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
  t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t14: f64,ch = CopyFromReg t0, Register:f64 %16
  t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
  t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
        t30: f64,ch = CopyFromReg t0, Register:f64 %1
            t25: f64,ch = CopyFromReg t0, Register:f64 %13
              t47: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
            t45: f64,ch = load<(load 8 from constant-pool)> t0, t47, undef:i64
          t27: f64 = fmul t25, t45
            t22: f64,ch = CopyFromReg t0, Register:f64 %12
            t20: f64 = fadd t12, t19
          t23: f64 = fadd t22, t20
        t28: f64 = fadd t27, t23
      t31: f64 = fmul t30, t28
        t49: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t43: f64,ch = load<(load 8 from constant-pool)> t0, t49, undef:i64
    t33: f64 = fdiv t31, t43
  t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
  t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1



Legalizing: t49: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t49: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t48: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t48: i64 = TargetConstantPool<double 3.000000e+00> 0

Legalizing: t47: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t47: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t46: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t46: i64 = TargetConstantPool<double 4.000000e+00> 0

Legalizing: t45: f64,ch = load<(load 8 from constant-pool)> t0, t47, undef:i64
Legalizing non-extending load operation

Combining: t45: f64,ch = load<(load 8 from constant-pool)> t0, t47, undef:i64

Legalizing: t43: f64,ch = load<(load 8 from constant-pool)> t0, t49, undef:i64
Legalizing non-extending load operation

Combining: t43: f64,ch = load<(load 8 from constant-pool)> t0, t49, undef:i64

Legalizing: t42: i64 = undef
Legal node: nothing to do

Combining: t42: i64 = undef

Legalizing: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1
Legal node: nothing to do

Combining: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1

Legalizing: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
Legal node: nothing to do

Combining: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33

Legalizing: t33: f64 = fdiv t31, t43
Legal node: nothing to do

Combining: t33: f64 = fdiv t31, t43

Legalizing: t31: f64 = fmul t30, t28
Legal node: nothing to do

Combining: t31: f64 = fmul t30, t28

Legalizing: t28: f64 = fadd t27, t23
Trying custom legalization

Combining: t28: f64 = fadd t27, t23

Legalizing: t23: f64 = fadd t22, t20
Trying custom legalization

Combining: t23: f64 = fadd t22, t20

Legalizing: t20: f64 = fadd t12, t19
Trying custom legalization

Combining: t20: f64 = fadd t12, t19

Legalizing: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
Legal node: nothing to do

Combining: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

Legalizing: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Combining: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1

Legalizing: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
Legal node: nothing to do

Combining: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1

Legalizing: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
Legal node: nothing to do

Combining: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14

Legalizing: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
Legal node: nothing to do

Combining: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1

Legalizing: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Combining: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Legalizing: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
Legal node: nothing to do

Combining: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1

Legalizing: t27: f64 = fmul t25, t45
Legal node: nothing to do

Combining: t27: f64 = fmul t25, t45

Legalizing: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
Legal node: nothing to do

Combining: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4

Legalizing: t30: f64,ch = CopyFromReg t0, Register:f64 %1
Legal node: nothing to do

Combining: t30: f64,ch = CopyFromReg t0, Register:f64 %1

Legalizing: t25: f64,ch = CopyFromReg t0, Register:f64 %13
Legal node: nothing to do

Combining: t25: f64,ch = CopyFromReg t0, Register:f64 %13

Legalizing: t22: f64,ch = CopyFromReg t0, Register:f64 %12
Legal node: nothing to do

Combining: t22: f64,ch = CopyFromReg t0, Register:f64 %12

Legalizing: t14: f64,ch = CopyFromReg t0, Register:f64 %16
Legal node: nothing to do

Combining: t14: f64,ch = CopyFromReg t0, Register:f64 %16

Legalizing: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t4: f64,ch = CopyFromReg t0, Register:f64 %15
Legal node: nothing to do

Combining: t4: f64,ch = CopyFromReg t0, Register:f64 %15

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %14
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %14

Legalizing: t34: i32 = TargetConstant<0>

Combining: t34: i32 = TargetConstant<0>

Legalizing: t29: f64 = Register %1

Combining: t29: f64 = Register %1

Legalizing: t24: f64 = Register %13

Combining: t24: f64 = Register %13

Legalizing: t21: f64 = Register %12

Combining: t21: f64 = Register %12

Legalizing: t13: f64 = Register %16

Combining: t13: f64 = Register %16

Legalizing: t9: Untyped = RegisterMask
Legal node: nothing to do

Combining: t9: Untyped = RegisterMask

Legalizing: t7: f64 = Register $xmm0

Combining: t7: f64 = Register $xmm0

Legalizing: t5: i64 = TargetConstant<0>

Combining: t5: i64 = TargetConstant<0>

Legalizing: t3: f64 = Register %15

Combining: t3: f64 = Register %15

Legalizing: t1: i64 = Register %14

Combining: t1: i64 = Register %14

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.4 '_Z7simpsonPFddEddi:for.end'
SelectionDAG has 42 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %14
    t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4
  t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1
    t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
    t14: f64,ch = CopyFromReg t0, Register:f64 %16
  t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14
  t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
  t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
  t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1
        t30: f64,ch = CopyFromReg t0, Register:f64 %1
            t25: f64,ch = CopyFromReg t0, Register:f64 %13
              t47: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
            t45: f64,ch = load<(load 8 from constant-pool)> t0, t47, undef:i64
          t27: f64 = fmul t25, t45
            t22: f64,ch = CopyFromReg t0, Register:f64 %12
            t20: f64 = fadd t12, t19
          t23: f64 = fadd t22, t20
        t28: f64 = fadd t27, t23
      t31: f64 = fmul t30, t28
        t49: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t43: f64,ch = load<(load 8 from constant-pool)> t0, t49, undef:i64
    t33: f64 = fdiv t31, t43
  t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
  t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1


===== Instruction selection begins: %bb.4 'for.end'

ISEL: Starting selection on root node: t36: ch = X86ISD::RET_FLAG t35, TargetConstant:i32<0>, Register:f64 $xmm0, t35:1
ISEL: Starting pattern match
  Initial Opcode index to 127064
  Morphed node: t36: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t35, t35:1
ISEL: Match complete!

ISEL: Starting selection on root node: t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33

ISEL: Starting selection on root node: t33: f64 = fdiv t31, t43
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  TypeSwitch[f64] from 157830 to 157854
  Match failed at index 157854
  Continuing at 157874
  Match failed at index 157875
  Continuing at 157948
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  TypeSwitch[f64] from 158429 to 158493
  Skipped scope entry (due to false predicate) at index 158495, continuing at 158513
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t51: i8 = TargetConstant<1>
Creating new constant pool: t53: i32 = TargetConstantPool<double 3.000000e+00> 0
  Morphed node: t33: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t31, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t31: f64 = fmul t30, t28
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t31: f64 = MULSDrr nofpexcept t30, t28
ISEL: Match complete!

ISEL: Starting selection on root node: t28: f64 = fadd t27, t23
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t28: f64 = ADDSDrr nofpexcept t27, t23
ISEL: Match complete!

ISEL: Starting selection on root node: t23: f64 = fadd t22, t20
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t23: f64 = ADDSDrr nofpexcept t22, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: f64 = fadd t12, t19
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t20: f64 = ADDSDrr nofpexcept t12, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t19: f64,ch,glue = CopyFromReg t18, Register:f64 $xmm0, t18:1

ISEL: Starting selection on root node: t18: ch,glue = callseq_end t17, TargetConstant:i64<0>, TargetConstant:i64<0>, t17:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch,glue = X86ISD::CALL t16, t2, Register:f64 $xmm0, RegisterMask:Untyped, t16:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  Match failed at index 91386
  Continuing at 91455
  Match failed at index 91456
  Continuing at 91467
  Match failed at index 91468
  Continuing at 91492
  Morphed node: t17: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t16, t16:1
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch,glue = CopyToReg t15, Register:f64 $xmm0, t14

ISEL: Starting selection on root node: t15: ch,glue = callseq_start t12:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: f64,ch,glue = CopyFromReg t11, Register:f64 $xmm0, t11:1

ISEL: Starting selection on root node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1
ISEL: Match complete!

ISEL: Starting selection on root node: t27: f64 = fmul t25, t45
ISEL: Starting pattern match
  Initial Opcode index to 154194
  OpcodeSwitch from 154199 to 154204
  TypeSwitch[f64] from 154215 to 154239
  Match failed at index 154239
  Continuing at 154259
  Match failed at index 154260
  Continuing at 154333
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  TypeSwitch[f64] from 154811 to 154875
  Skipped scope entry (due to false predicate) at index 154877, continuing at 154895
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t55: i32 = TargetConstantPool<double 4.000000e+00> 0
  Morphed node: t27: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t25, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch,glue = X86ISD::CALL t8, t2, Register:f64 $xmm0, RegisterMask:Untyped, t8:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  Match failed at index 91386
  Continuing at 91455
  Match failed at index 91456
  Continuing at 91467
  Match failed at index 91468
  Continuing at 91492
  Morphed node: t10: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t8, t8:1
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm0, t4

ISEL: Starting selection on root node: t30: f64,ch = CopyFromReg t0, Register:f64 %1

ISEL: Starting selection on root node: t25: f64,ch = CopyFromReg t0, Register:f64 %13

ISEL: Starting selection on root node: t22: f64,ch = CopyFromReg t0, Register:f64 %12

ISEL: Starting selection on root node: t14: f64,ch = CopyFromReg t0, Register:f64 %16

ISEL: Starting selection on root node: t6: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: f64,ch = CopyFromReg t0, Register:f64 %15

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %14

ISEL: Starting selection on root node: t34: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t29: f64 = Register %1

ISEL: Starting selection on root node: t24: f64 = Register %13

ISEL: Starting selection on root node: t21: f64 = Register %12

ISEL: Starting selection on root node: t13: f64 = Register %16

ISEL: Starting selection on root node: t9: Untyped = RegisterMask

ISEL: Starting selection on root node: t7: f64 = Register $xmm0

ISEL: Starting selection on root node: t5: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t3: f64 = Register %15

ISEL: Starting selection on root node: t1: i64 = Register %14

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.4 '_Z7simpsonPFddEddi:for.end'
SelectionDAG has 41 nodes:
  t0: ch = EntryToken
  t2: i64,ch = CopyFromReg t0, Register:i64 %14
    t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t4: f64,ch = CopyFromReg t0, Register:f64 %15
  t8: ch,glue = CopyToReg t6:1, Register:f64 $xmm0, t4
  t10: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t8, t8:1
  t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1
  t12: f64,ch,glue = CopyFromReg t11:1, Register:f64 $xmm0, t11:2
    t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1
    t14: f64,ch = CopyFromReg t0, Register:f64 %16
  t16: ch,glue = CopyToReg t15:1, Register:f64 $xmm0, t14
  t17: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t16, t16:1
  t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1
  t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2
        t30: f64,ch = CopyFromReg t0, Register:f64 %1
            t25: f64,ch = CopyFromReg t0, Register:f64 %13
          t27: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t25, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
            t22: f64,ch = CopyFromReg t0, Register:f64 %12
            t20: f64 = ADDSDrr nofpexcept t12, t19
          t23: f64 = ADDSDrr nofpexcept t22, t20
        t28: f64 = ADDSDrr nofpexcept t27, t23
      t31: f64 = MULSDrr nofpexcept t30, t28
    t33: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t31, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
  t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33
  t36: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t35, t35:1


********** List Scheduling %bb.4 'for.end' **********
SU(0): t36: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t35, t35:1

    t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 0
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
    SU(1): Data Latency=1
SU(1): t33: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t31, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t31: f64 = MULSDrr nofpexcept t30, t28

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 2
  Predecessors:
    SU(13): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t28: f64 = ADDSDrr nofpexcept t27, t23

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 3
  Predecessors:
    SU(11): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t23: f64 = ADDSDrr nofpexcept t22, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 4
  Predecessors:
    SU(10): Data Latency=1
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(5): t20: f64 = ADDSDrr nofpexcept t12, t19

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 5
  Predecessors:
    SU(6): Data Latency=1
    SU(14): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t12: f64,ch,glue = CopyFromReg t11:1, Register:f64 $xmm0, t11:2

    t8: ch,glue = CopyToReg t6:1, Register:f64 $xmm0, t4

    t10: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t8, t8:1

    t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 8
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 9
  Successors:
    SU(6): Data Latency=1
SU(8): t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 9
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(9): t2: i64,ch = CopyFromReg t0, Register:i64 %14

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 9
  Successors:
    SU(6): Data Latency=1
    SU(14): Data Latency=1
SU(10): t22: f64,ch = CopyFromReg t0, Register:f64 %12

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(4): Data Latency=1
SU(11): t27: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t25, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(12): t25: f64,ch = CopyFromReg t0, Register:f64 %13

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(11): Data Latency=1
SU(13): t30: f64,ch = CopyFromReg t0, Register:f64 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t16: ch,glue = CopyToReg t15:1, Register:f64 $xmm0, t14

    t17: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t16, t16:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 6
  Predecessors:
    SU(9): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
    SU(15): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
    SU(5): Data Latency=1
SU(15): t14: f64,ch = CopyFromReg t0, Register:f64 %16

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(14): Data Latency=1
SU(16): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 7
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(14): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t36: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t35, t35:1

    t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33


*** Scheduling [0]: SU(0): t36: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t35, t35:1

    t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33


Examining Available:
Height 1: SU(1): t33: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t31, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [1]: SU(1): t33: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t31, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 2: SU(2): t31: f64 = MULSDrr nofpexcept t30, t28


*** Scheduling [2]: SU(2): t31: f64 = MULSDrr nofpexcept t30, t28


Examining Available:
Height 3: SU(13): t30: f64,ch = CopyFromReg t0, Register:f64 %1

Height 3: SU(3): t28: f64 = ADDSDrr nofpexcept t27, t23


*** Scheduling [3]: SU(13): t30: f64,ch = CopyFromReg t0, Register:f64 %1


Examining Available:
Height 3: SU(3): t28: f64 = ADDSDrr nofpexcept t27, t23


*** Scheduling [4]: SU(3): t28: f64 = ADDSDrr nofpexcept t27, t23


Examining Available:
Height 5: SU(11): t27: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t25, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

Height 5: SU(4): t23: f64 = ADDSDrr nofpexcept t22, t20


*** Scheduling [5]: SU(11): t27: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t25, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 6: SU(12): t25: f64,ch = CopyFromReg t0, Register:f64 %13

Height 5: SU(4): t23: f64 = ADDSDrr nofpexcept t22, t20


*** Scheduling [6]: SU(12): t25: f64,ch = CopyFromReg t0, Register:f64 %13


Examining Available:
Height 5: SU(4): t23: f64 = ADDSDrr nofpexcept t22, t20


*** Scheduling [7]: SU(4): t23: f64 = ADDSDrr nofpexcept t22, t20


Examining Available:
Height 8: SU(10): t22: f64,ch = CopyFromReg t0, Register:f64 %12

Height 8: SU(5): t20: f64 = ADDSDrr nofpexcept t12, t19


*** Scheduling [8]: SU(10): t22: f64,ch = CopyFromReg t0, Register:f64 %12


Examining Available:
Height 8: SU(5): t20: f64 = ADDSDrr nofpexcept t12, t19


*** Scheduling [9]: SU(5): t20: f64 = ADDSDrr nofpexcept t12, t19


Examining Available:
Height 10: SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t16: ch,glue = CopyToReg t15:1, Register:f64 $xmm0, t14

    t17: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t16, t16:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1


*** Scheduling [10]: SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t16: ch,glue = CopyToReg t15:1, Register:f64 $xmm0, t14

    t17: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t16, t16:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1


Examining Available:
Height 11: SU(15): t14: f64,ch = CopyFromReg t0, Register:f64 %16

Height 11: SU(16): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1


*** Scheduling [11]: SU(15): t14: f64,ch = CopyFromReg t0, Register:f64 %16


Examining Available:
Height 11: SU(16): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1


*** Scheduling [12]: SU(16): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1


Examining Available:
Height 13: SU(6): t12: f64,ch,glue = CopyFromReg t11:1, Register:f64 $xmm0, t11:2

    t8: ch,glue = CopyToReg t6:1, Register:f64 $xmm0, t4

    t10: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t8, t8:1

    t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1


*** Scheduling [13]: SU(6): t12: f64,ch,glue = CopyFromReg t11:1, Register:f64 $xmm0, t11:2

    t8: ch,glue = CopyToReg t6:1, Register:f64 $xmm0, t4

    t10: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t8, t8:1

    t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1


Examining Available:
Height 14: SU(9): t2: i64,ch = CopyFromReg t0, Register:i64 %14

Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 14: SU(8): t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [14]: SU(9): t2: i64,ch = CopyFromReg t0, Register:i64 %14


Examining Available:
Height 14: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

Height 14: SU(8): t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [15]: SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15


Examining Available:
Height 14: SU(8): t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [16]: SU(8): t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(8): t6: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(7): t4: f64,ch = CopyFromReg t0, Register:f64 %15

SU(9): t2: i64,ch = CopyFromReg t0, Register:i64 %14

SU(6): t12: f64,ch,glue = CopyFromReg t11:1, Register:f64 $xmm0, t11:2

    t8: ch,glue = CopyToReg t6:1, Register:f64 $xmm0, t4

    t10: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t8, t8:1

    t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1

SU(16): t15: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t12:1

SU(15): t14: f64,ch = CopyFromReg t0, Register:f64 %16

SU(14): t19: f64,ch,glue = CopyFromReg t18:1, Register:f64 $xmm0, t18:2

    t16: ch,glue = CopyToReg t15:1, Register:f64 $xmm0, t14

    t17: ch,glue = CALL64r t2, Register:f64 $xmm0, RegisterMask:Untyped, t16, t16:1

    t18: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t17, t17:1

SU(5): t20: f64 = ADDSDrr nofpexcept t12, t19

SU(10): t22: f64,ch = CopyFromReg t0, Register:f64 %12

SU(4): t23: f64 = ADDSDrr nofpexcept t22, t20

SU(12): t25: f64,ch = CopyFromReg t0, Register:f64 %13

SU(11): t27: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t25, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

SU(3): t28: f64 = ADDSDrr nofpexcept t27, t23

SU(13): t30: f64,ch = CopyFromReg t0, Register:f64 %1

SU(2): t31: f64 = MULSDrr nofpexcept t30, t28

SU(1): t33: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t31, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

SU(0): t36: ch = RET TargetConstant:i32<0>, Register:f64 $xmm0, t35, t35:1

    t35: ch,glue = CopyToReg t19:1, Register:f64 $xmm0, t33


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z7simpsonPFddEddi: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.4(0x40000000); %bb.1(50.00%), %bb.4(50.00%)
  liveins: $rdi, $xmm0, $xmm1, $esi
  %17:gr32 = COPY $esi
  %16:fr64 = COPY $xmm1
  %15:fr64 = COPY $xmm0
  %14:gr64 = COPY $rdi
  %19:gr32 = nsw ADD32ri8 %17:gr32(tied-def 0), 1, implicit-def dead $eflags
  %21:gr64 = IMPLICIT_DEF
  %20:gr64 = INSERT_SUBREG %21:gr64(tied-def 0), %17:gr32, %subreg.sub_32bit
  %22:gr32 = SHR32ri %19:gr32(tied-def 0), 31, implicit-def dead $eflags
  %24:gr64 = IMPLICIT_DEF
  %23:gr64_nosp = INSERT_SUBREG %24:gr64(tied-def 0), killed %22:gr32, %subreg.sub_32bit
  %25:gr32 = LEA64_32r killed %20:gr64, 1, killed %23:gr64_nosp, 1, $noreg
  %0:gr32 = AND32ri8 %25:gr32(tied-def 0), -2, implicit-def dead $eflags
  %26:fr64 = nofpexcept SUBSDrr %16:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  %27:fr64 = CVTSI2SDrr %0:gr32
  %1:fr64 = nofpexcept DIVSDrr %26:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr
  %28:fr64 = nofpexcept ADDSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %28:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:fr64 = COPY $xmm0
  %2:fr64 = COPY %29:fr64
  %18:fr64 = FsFLD0SD
  %30:gr32 = SUB32ri8 %17:gr32(tied-def 0), 3, implicit-def $eflags
  JCC_1 %bb.4, 12, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %33:fr64 = FsFLD0SD
  %32:gr32 = MOV32ri 2
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:fr64 = PHI %31:fr64, %bb.1, %10:fr64, %bb.2
  %4:gr32 = PHI %32:gr32, %bb.1, %9:gr32, %bb.2
  %5:fr64 = PHI %2:fr64, %bb.1, %8:fr64, %bb.2
  %6:fr64 = PHI %33:fr64, %bb.1, %7:fr64, %bb.2
  %34:fr64 = CVTSI2SDrr %4:gr32
  %35:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %34:fr64, implicit $mxcsr
  %36:fr64 = nofpexcept ADDSDrr %35:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %36:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:fr64 = COPY $xmm0
  %7:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  %38:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %3:fr64, implicit $mxcsr
  %39:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %39:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:fr64 = COPY $xmm0
  %8:fr64 = nofpexcept ADDSDrr %5:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  %9:gr32 = nuw nsw ADD32ri8 %4:gr32(tied-def 0), 2, implicit-def dead $eflags
  %10:fr64 = nofpexcept ADDSDrm %3:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %41:gr32 = SUB32rr %9:gr32(tied-def 0), %0:gr32, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end.loopexit:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %11:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %7:fr64, implicit $mxcsr

bb.4.for.end:
; predecessors: %bb.0, %bb.3

  %12:fr64 = PHI %18:fr64, %bb.0, %11:fr64, %bb.3
  %13:fr64 = PHI %2:fr64, %bb.0, %8:fr64, %bb.3
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %15:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %42:fr64 = COPY $xmm0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %16:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %43:fr64 = COPY $xmm0
  %44:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  %45:fr64 = nofpexcept ADDSDrr %12:fr64(tied-def 0), killed %44:fr64, implicit $mxcsr
  %46:fr64 = nofpexcept MULSDrm %13:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %47:fr64 = nofpexcept ADDSDrr %46:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
  %48:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
  %49:fr64 = nofpexcept DIVSDrm %48:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  $xmm0 = COPY %49:fr64
  RET 0, $xmm0

# End machine code for function _Z7simpsonPFddEddi.

***** Machine Function before Domain Reassignment *****
# Machine code for function _Z7simpsonPFddEddi: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.4(0x40000000); %bb.1(50.00%), %bb.4(50.00%)
  liveins: $rdi, $xmm0, $xmm1, $esi
  %17:gr32 = COPY $esi
  %16:fr64 = COPY $xmm1
  %15:fr64 = COPY $xmm0
  %14:gr64 = COPY $rdi
  %19:gr32 = nsw ADD32ri8 %17:gr32(tied-def 0), 1, implicit-def dead $eflags
  %21:gr64 = IMPLICIT_DEF
  %20:gr64 = INSERT_SUBREG %21:gr64(tied-def 0), %17:gr32, %subreg.sub_32bit
  %22:gr32 = SHR32ri %19:gr32(tied-def 0), 31, implicit-def dead $eflags
  %24:gr64 = IMPLICIT_DEF
  %23:gr64_nosp = INSERT_SUBREG %24:gr64(tied-def 0), killed %22:gr32, %subreg.sub_32bit
  %25:gr32 = LEA64_32r killed %20:gr64, 1, killed %23:gr64_nosp, 1, $noreg
  %0:gr32 = AND32ri8 %25:gr32(tied-def 0), -2, implicit-def dead $eflags
  %26:fr64 = nofpexcept SUBSDrr %16:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  %27:fr64 = CVTSI2SDrr %0:gr32
  %1:fr64 = nofpexcept DIVSDrr %26:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr
  %28:fr64 = nofpexcept ADDSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %28:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:fr64 = COPY $xmm0
  %2:fr64 = COPY %29:fr64
  %18:fr64 = FsFLD0SD
  %30:gr32 = SUB32ri8 %17:gr32(tied-def 0), 3, implicit-def $eflags
  JCC_1 %bb.4, 12, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %33:fr64 = FsFLD0SD
  %32:gr32 = MOV32ri 2
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:fr64 = PHI %31:fr64, %bb.1, %10:fr64, %bb.2
  %4:gr32 = PHI %32:gr32, %bb.1, %9:gr32, %bb.2
  %5:fr64 = PHI %2:fr64, %bb.1, %8:fr64, %bb.2
  %6:fr64 = PHI %33:fr64, %bb.1, %7:fr64, %bb.2
  %34:fr64 = CVTSI2SDrr %4:gr32
  %35:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %34:fr64, implicit $mxcsr
  %36:fr64 = nofpexcept ADDSDrr %35:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %36:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:fr64 = COPY $xmm0
  %7:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  %38:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %3:fr64, implicit $mxcsr
  %39:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %39:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:fr64 = COPY $xmm0
  %8:fr64 = nofpexcept ADDSDrr %5:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  %9:gr32 = nuw nsw ADD32ri8 %4:gr32(tied-def 0), 2, implicit-def dead $eflags
  %10:fr64 = nofpexcept ADDSDrm %3:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %41:gr32 = SUB32rr %9:gr32(tied-def 0), %0:gr32, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end.loopexit:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %11:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %7:fr64, implicit $mxcsr

bb.4.for.end:
; predecessors: %bb.0, %bb.3

  %12:fr64 = PHI %18:fr64, %bb.0, %11:fr64, %bb.3
  %13:fr64 = PHI %2:fr64, %bb.0, %8:fr64, %bb.3
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %15:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %42:fr64 = COPY $xmm0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %16:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %43:fr64 = COPY $xmm0
  %44:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  %45:fr64 = nofpexcept ADDSDrr %12:fr64(tied-def 0), killed %44:fr64, implicit $mxcsr
  %46:fr64 = nofpexcept MULSDrm %13:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %47:fr64 = nofpexcept ADDSDrr %46:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
  %48:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
  %49:fr64 = nofpexcept DIVSDrm %48:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  $xmm0 = COPY %49:fr64
  RET 0, $xmm0

# End machine code for function _Z7simpsonPFddEddi.

# Machine code for function _Z7simpsonPFddEddi: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.4(0x40000000); %bb.1(50.00%), %bb.4(50.00%)
	  liveins: $rdi, $xmm0, $xmm1, $esi
16B	  %17:gr32 = COPY $esi
32B	  %16:fr64 = COPY $xmm1
48B	  %15:fr64 = COPY $xmm0
64B	  %14:gr64 = COPY $rdi
80B	  %19:gr32 = nsw ADD32ri8 %17:gr32(tied-def 0), 1, implicit-def dead $eflags
96B	  %21:gr64 = IMPLICIT_DEF
112B	  %20:gr64 = INSERT_SUBREG %21:gr64(tied-def 0), %17:gr32, %subreg.sub_32bit
128B	  %22:gr32 = SHR32ri %19:gr32(tied-def 0), 31, implicit-def dead $eflags
144B	  %24:gr64 = IMPLICIT_DEF
160B	  %23:gr64_nosp = INSERT_SUBREG %24:gr64(tied-def 0), killed %22:gr32, %subreg.sub_32bit
176B	  %25:gr32 = LEA64_32r killed %20:gr64, 1, killed %23:gr64_nosp, 1, $noreg
192B	  %0:gr32 = AND32ri8 %25:gr32(tied-def 0), -2, implicit-def dead $eflags
208B	  %26:fr64 = nofpexcept SUBSDrr %16:fr64(tied-def 0), %15:fr64, implicit $mxcsr
224B	  %27:fr64 = CVTSI2SDrr %0:gr32
240B	  %1:fr64 = nofpexcept DIVSDrr %26:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr
256B	  %28:fr64 = nofpexcept ADDSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
272B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
288B	  $xmm0 = COPY %28:fr64
304B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
320B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
336B	  %29:fr64 = COPY $xmm0
352B	  %2:fr64 = COPY %29:fr64
368B	  %18:fr64 = FsFLD0SD
384B	  %30:gr32 = SUB32ri8 %17:gr32(tied-def 0), 3, implicit-def $eflags
400B	  JCC_1 %bb.4, 12, implicit $eflags
416B	  JMP_1 %bb.1

432B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

448B	  %33:fr64 = FsFLD0SD
464B	  %32:gr32 = MOV32ri 2
480B	  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

496B	bb.2.for.body:
	; predecessors: %bb.1, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

512B	  %3:fr64 = PHI %31:fr64, %bb.1, %10:fr64, %bb.2
528B	  %4:gr32 = PHI %32:gr32, %bb.1, %9:gr32, %bb.2
544B	  %5:fr64 = PHI %2:fr64, %bb.1, %8:fr64, %bb.2
560B	  %6:fr64 = PHI %33:fr64, %bb.1, %7:fr64, %bb.2
576B	  %34:fr64 = CVTSI2SDrr %4:gr32
592B	  %35:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %34:fr64, implicit $mxcsr
608B	  %36:fr64 = nofpexcept ADDSDrr %35:fr64(tied-def 0), %15:fr64, implicit $mxcsr
624B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
640B	  $xmm0 = COPY %36:fr64
656B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
672B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  %37:fr64 = COPY $xmm0
704B	  %7:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %37:fr64, implicit $mxcsr
720B	  %38:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %3:fr64, implicit $mxcsr
736B	  %39:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %15:fr64, implicit $mxcsr
752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
768B	  $xmm0 = COPY %39:fr64
784B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
816B	  %40:fr64 = COPY $xmm0
832B	  %8:fr64 = nofpexcept ADDSDrr %5:fr64(tied-def 0), %40:fr64, implicit $mxcsr
848B	  %9:gr32 = nuw nsw ADD32ri8 %4:gr32(tied-def 0), 2, implicit-def dead $eflags
864B	  %10:fr64 = nofpexcept ADDSDrm %3:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
880B	  %41:gr32 = SUB32rr %9:gr32(tied-def 0), %0:gr32, implicit-def $eflags
896B	  JCC_1 %bb.2, 12, implicit $eflags
912B	  JMP_1 %bb.3

928B	bb.3.for.end.loopexit:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

944B	  %11:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %7:fr64, implicit $mxcsr

960B	bb.4.for.end:
	; predecessors: %bb.0, %bb.3

976B	  %12:fr64 = PHI %18:fr64, %bb.0, %11:fr64, %bb.3
992B	  %13:fr64 = PHI %2:fr64, %bb.0, %8:fr64, %bb.3
1008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1024B	  $xmm0 = COPY %15:fr64
1040B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1056B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1072B	  %42:fr64 = COPY $xmm0
1088B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1104B	  $xmm0 = COPY %16:fr64
1120B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1136B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1152B	  %43:fr64 = COPY $xmm0
1168B	  %44:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %43:fr64, implicit $mxcsr
1184B	  %45:fr64 = nofpexcept ADDSDrr %12:fr64(tied-def 0), killed %44:fr64, implicit $mxcsr
1200B	  %46:fr64 = nofpexcept MULSDrm %13:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1216B	  %47:fr64 = nofpexcept ADDSDrr %46:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
1232B	  %48:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
1248B	  %49:fr64 = nofpexcept DIVSDrm %48:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1264B	  $xmm0 = COPY %49:fr64
1280B	  RET 0, $xmm0

# End machine code for function _Z7simpsonPFddEddi.

********** Stack Coloring **********
********** Function: _Z7simpsonPFddEddi
********** EARLY IF-CONVERSION **********
********** Function: _Z7simpsonPFddEddi
Machine InstCombiner: _Z7simpsonPFddEddi
Combining MBB entry
Combining MBB for.body.preheader
Combining MBB for.body
Combining MBB for.end.loopexit
Combining MBB for.end
********** X86 cmov Conversion : _Z7simpsonPFddEddi**********

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB2[for.body]
 - 3: BB3[for.end.loopexit]
 - 4: BB4[for.end]
loop-detection
 - loop = BB2[for.body]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB3[for.end.loopexit]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.end.loopexit]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB4[for.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[for.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB4[for.end]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.end.loopexit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[for.end.loopexit]
 - node: BB3[for.end.loopexit]
  => [ local  ] weight = 2147483648, succ = BB4[for.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.end]
 - node: BB4[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[for.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB2[for.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[for.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB2[for.body]: float = 16.0, scaled = 256.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, scaled = 8.0, int = 8
 - BB4[for.end]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - BB0[entry]: float = 1.0, int = 16
 - BB1[for.body.preheader]: float = 0.5, int = 8
 - BB2[for.body]: float = 16.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, int = 8
 - BB4[for.end]: float = 1.0, int = 16

******** Pre-regalloc Machine LICM: _Z7simpsonPFddEddi ********
Entering %bb.2
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 from %bb.2 to %bb.1
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB2[for.body]
 - 3: BB3[for.end.loopexit]
 - 4: BB4[for.end]
loop-detection
 - loop = BB2[for.body]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB3[for.end.loopexit]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.end.loopexit]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB4[for.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[for.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB4[for.end]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.end.loopexit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[for.end.loopexit]
 - node: BB3[for.end.loopexit]
  => [ local  ] weight = 2147483648, succ = BB4[for.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.end]
 - node: BB4[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[for.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB2[for.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[for.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB2[for.body]: float = 16.0, scaled = 256.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, scaled = 8.0, int = 8
 - BB4[for.end]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - BB0[entry]: float = 1.0, int = 16
 - BB1[for.body.preheader]: float = 0.5, int = 8
 - BB2[for.body]: float = 16.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, int = 8
 - BB4[for.end]: float = 1.0, int = 16

Entering: entry
Entering: for.end
Exiting: for.end
Entering: for.body.preheader
Examining: %33:fr64 = FsFLD0SD
*** Found a common subexpression: %18:fr64 = FsFLD0SD
*** Not profitable, avoid CSE!
Entering: for.body
Entering: for.end.loopexit
Exiting: for.end.loopexit
Exiting: for.body
Exiting: for.body.preheader
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.4
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.4
3: %bb.3
4: %bb.2
5: %bb.1
6: %bb.0
Found roots: %bb.4 
******** Machine Sinking ********
Sink instr %18:fr64 = FsFLD0SD
	into block bb.4.for.end:
; predecessors: %bb.0, %bb.3

  %12:fr64 = PHI %18:fr64, %bb.0, %11:fr64, %bb.3
  %13:fr64 = PHI %2:fr64, %bb.0, %8:fr64, %bb.3
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %15:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %42:fr64 = COPY $xmm0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %16:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %43:fr64 = COPY $xmm0
  %44:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  %45:fr64 = nofpexcept ADDSDrr %12:fr64(tied-def 0), killed %44:fr64, implicit $mxcsr
  %46:fr64 = nofpexcept MULSDrm %13:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %47:fr64 = nofpexcept ADDSDrr %46:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
  %48:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
  %49:fr64 = nofpexcept DIVSDrm %48:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  $xmm0 = COPY %49:fr64
  RET 0, $xmm0
Sinking along critical edge.
 *** PUNTING: Not legal or profitable to break critical edge
********** PEEPHOLE OPTIMIZER **********
********** Function: _Z7simpsonPFddEddi
Encountered load fold barrier on CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
Attempting to optimize compare: %30:gr32 = SUB32ri8 %17:gr32(tied-def 0), 3, implicit-def $eflags
Optimize recurrence chain from %5:fr64 = PHI %2:fr64, %bb.1, %8:fr64, %bb.2
	Inst: %8:fr64 = nofpexcept ADDSDrr %5:fr64(tied-def 0), %40:fr64, implicit $mxcsr
Optimize recurrence chain from %6:fr64 = PHI %33:fr64, %bb.1, %7:fr64, %bb.2
	Inst: %7:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %37:fr64, implicit $mxcsr
Encountered load fold barrier on CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
Encountered load fold barrier on CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
Attempting to optimize compare: %41:gr32 = SUB32rr %9:gr32(tied-def 0), %0:gr32, implicit-def $eflags
Encountered load fold barrier on CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
Encountered load fold barrier on CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
**** Analysing _Z7simpsonPFddEddi
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : _Z7simpsonPFddEddi **********
********** X86 EFLAGS copy lowering : _Z7simpsonPFddEddi **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: _Z7simpsonPFddEddi
%bb.0 has 2 implicit defs.
Processing %24:gr64 = IMPLICIT_DEF
Processing %21:gr64 = IMPLICIT_DEF
%2 live-out before critical edge %bb.0 -> %bb.4: %13:fr64 = PHI %2:fr64, %bb.0, %8:fr64, %bb.3
Splitting critical edge: %bb.0 -- %bb.5 -- %bb.4
Removing terminator kill: JCC_1 %bb.4, 12, implicit killed $eflags
Updating terminators on %bb.0
Restored terminator kill: JCC_1 %bb.1, 13, implicit killed $eflags
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z7simpsonPFddEddi
	%19:gr32 = nsw ADD32ri8 %17:gr32(tied-def 0), 1, implicit-def dead $eflags
2addr: CONVERTING 2-ADDR: %19:gr32 = nsw ADD32ri8 %17:gr32(tied-def 0), 1, implicit-def dead $eflags
2addr:         TO 3-ADDR: %19:gr32 = LEA64_32r killed %57:gr64, 1, $noreg, 1, $noreg
		rewrite undef:	%20:gr64 = INSERT_SUBREG undef %20:gr64(tied-def 0), %17:gr32, %subreg.sub_32bit
	%20:gr64 = INSERT_SUBREG undef %20:gr64(tied-def 0), %17:gr32, %subreg.sub_32bit
		convert to:	undef %20.sub_32bit:gr64 = COPY %17:gr32
	%22:gr32 = SHR32ri killed %19:gr32(tied-def 0), 31, implicit-def dead $eflags
		prepend:	%22:gr32 = COPY %19:gr32
		rewrite to:	%22:gr32 = SHR32ri %22:gr32(tied-def 0), 31, implicit-def dead $eflags
		rewrite undef:	%23:gr64_nosp = INSERT_SUBREG undef %23:gr64_nosp(tied-def 0), killed %22:gr32, %subreg.sub_32bit
	%23:gr64_nosp = INSERT_SUBREG undef %23:gr64_nosp(tied-def 0), killed %22:gr32, %subreg.sub_32bit
		convert to:	undef %23.sub_32bit:gr64_nosp = COPY killed %22:gr32
	%0:gr32 = AND32ri8 killed %25:gr32(tied-def 0), -2, implicit-def dead $eflags
		prepend:	%0:gr32 = COPY %25:gr32
		rewrite to:	%0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
	%26:fr64 = nofpexcept SUBSDrr %16:fr64(tied-def 0), %15:fr64, implicit $mxcsr
		prepend:	%26:fr64 = COPY %16:fr64
		rewrite to:	%26:fr64 = nofpexcept SUBSDrr %26:fr64(tied-def 0), %15:fr64, implicit $mxcsr
	%1:fr64 = nofpexcept DIVSDrr killed %26:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr
		prepend:	%1:fr64 = COPY %26:fr64
		rewrite to:	%1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr
	%28:fr64 = nofpexcept ADDSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
		prepend:	%28:fr64 = COPY %1:fr64
		rewrite to:	%28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
	%35:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %34:fr64, implicit $mxcsr
2addr: COMMUTING  : %35:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), killed %34:fr64, implicit $mxcsr
2addr: COMMUTED TO: %35:fr64 = nofpexcept MULSDrr killed %34:fr64(tied-def 0), %1:fr64, implicit $mxcsr
		prepend:	%35:fr64 = COPY %34:fr64
		rewrite to:	%35:fr64 = nofpexcept MULSDrr %35:fr64(tied-def 0), %1:fr64, implicit $mxcsr
	%36:fr64 = nofpexcept ADDSDrr killed %35:fr64(tied-def 0), %15:fr64, implicit $mxcsr
		prepend:	%36:fr64 = COPY %35:fr64
		rewrite to:	%36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
	%7:fr64 = nofpexcept ADDSDrr killed %6:fr64(tied-def 0), killed %37:fr64, implicit $mxcsr
		prepend:	%7:fr64 = COPY %6:fr64
		rewrite to:	%7:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), killed %37:fr64, implicit $mxcsr
	%38:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %3:fr64, implicit $mxcsr
		prepend:	%38:fr64 = COPY %1:fr64
		rewrite to:	%38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %3:fr64, implicit $mxcsr
	%39:fr64 = nofpexcept ADDSDrr killed %38:fr64(tied-def 0), %15:fr64, implicit $mxcsr
		prepend:	%39:fr64 = COPY %38:fr64
		rewrite to:	%39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
	%8:fr64 = nofpexcept ADDSDrr killed %5:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
		prepend:	%8:fr64 = COPY %5:fr64
		rewrite to:	%8:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
	%9:gr32 = nuw nsw ADD32ri8 killed %4:gr32(tied-def 0), 2, implicit-def dead $eflags
		prepend:	%9:gr32 = COPY %4:gr32
		rewrite to:	%9:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 2, implicit-def dead $eflags
	%10:fr64 = ADDSDrr killed %3:fr64(tied-def 0), %50:fr64, implicit $mxcsr
		prepend:	%10:fr64 = COPY %3:fr64
		rewrite to:	%10:fr64 = ADDSDrr %10:fr64(tied-def 0), %50:fr64, implicit $mxcsr
	%11:fr64 = nofpexcept ADDSDrr killed %7:fr64(tied-def 0), %7:fr64, implicit $mxcsr
		prepend:	%11:fr64 = COPY %7:fr64
		rewrite to:	%11:fr64 = nofpexcept ADDSDrr %11:fr64(tied-def 0), %11:fr64, implicit $mxcsr
	%44:fr64 = nofpexcept ADDSDrr killed %42:fr64(tied-def 0), killed %43:fr64, implicit $mxcsr
2addr: COMMUTING  : %44:fr64 = nofpexcept ADDSDrr killed %42:fr64(tied-def 0), killed %43:fr64, implicit $mxcsr
2addr: COMMUTED TO: %44:fr64 = nofpexcept ADDSDrr killed %43:fr64(tied-def 0), killed %42:fr64, implicit $mxcsr
		prepend:	%44:fr64 = COPY %43:fr64
		rewrite to:	%44:fr64 = nofpexcept ADDSDrr %44:fr64(tied-def 0), killed %42:fr64, implicit $mxcsr
	%45:fr64 = nofpexcept ADDSDrr killed %12:fr64(tied-def 0), killed %44:fr64, implicit $mxcsr
2addr: COMMUTING  : %45:fr64 = nofpexcept ADDSDrr killed %12:fr64(tied-def 0), killed %44:fr64, implicit $mxcsr
2addr: COMMUTED TO: %45:fr64 = nofpexcept ADDSDrr killed %44:fr64(tied-def 0), killed %12:fr64, implicit $mxcsr
		prepend:	%45:fr64 = COPY %44:fr64
		rewrite to:	%45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), killed %12:fr64, implicit $mxcsr
	%46:fr64 = nofpexcept MULSDrm killed %13:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		prepend:	%46:fr64 = COPY %13:fr64
		rewrite to:	%46:fr64 = nofpexcept MULSDrm %46:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	%47:fr64 = nofpexcept ADDSDrr killed %46:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
		prepend:	%47:fr64 = COPY %46:fr64
		rewrite to:	%47:fr64 = nofpexcept ADDSDrr %47:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
	%48:fr64 = nofpexcept MULSDrr killed %1:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
		prepend:	%48:fr64 = COPY %1:fr64
		rewrite to:	%48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
	%49:fr64 = nofpexcept DIVSDrm killed %48:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		prepend:	%49:fr64 = COPY %48:fr64
		rewrite to:	%49:fr64 = nofpexcept DIVSDrm %49:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
# Machine code for function _Z7simpsonPFddEddi: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.5(0x40000000); %bb.1(50.00%), %bb.5(50.00%)
	  liveins: $rdi, $xmm0, $xmm1, $esi
16B	  %17:gr32 = COPY killed $esi
32B	  %16:fr64 = COPY killed $xmm1
48B	  %15:fr64 = COPY killed $xmm0
64B	  %14:gr64 = COPY killed $rdi
80B	  undef %57.sub_32bit:gr64 = COPY %17:gr32
96B	  %19:gr32 = LEA64_32r killed %57:gr64, 1, $noreg, 1, $noreg
112B	  undef %20.sub_32bit:gr64 = COPY %17:gr32
128B	  %22:gr32 = COPY killed %19:gr32
144B	  %22:gr32 = SHR32ri %22:gr32(tied-def 0), 31, implicit-def dead $eflags
160B	  undef %23.sub_32bit:gr64_nosp = COPY killed %22:gr32
176B	  %25:gr32 = LEA64_32r killed %20:gr64, 1, killed %23:gr64_nosp, 1, $noreg
192B	  %0:gr32 = COPY killed %25:gr32
208B	  %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
224B	  %26:fr64 = COPY %16:fr64
240B	  %26:fr64 = nofpexcept SUBSDrr %26:fr64(tied-def 0), %15:fr64, implicit $mxcsr
256B	  %27:fr64 = CVTSI2SDrr %0:gr32
272B	  %1:fr64 = COPY killed %26:fr64
288B	  %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr
304B	  %28:fr64 = COPY %1:fr64
320B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  $xmm0 = COPY killed %28:fr64
368B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
384B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  %29:fr64 = COPY killed $xmm0
416B	  %2:fr64 = COPY killed %29:fr64
432B	  %18:fr64 = FsFLD0SD
448B	  CMP32ri8 killed %17:gr32, 3, implicit-def $eflags
464B	  JCC_1 %bb.1, 13, implicit killed $eflags

480B	bb.5:
	; predecessors: %bb.0
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

496B	  %55:fr64 = COPY killed %18:fr64
512B	  %56:fr64 = COPY killed %2:fr64
528B	  JMP_1 %bb.4

544B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

560B	  %33:fr64 = FsFLD0SD
576B	  %32:gr32 = MOV32ri 2
592B	  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
608B	  %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
624B	  %51:fr64 = COPY killed %31:fr64
640B	  %52:gr32 = COPY killed %32:gr32
656B	  %53:fr64 = COPY killed %2:fr64
672B	  %54:fr64 = COPY killed %33:fr64

688B	bb.2.for.body:
	; predecessors: %bb.1, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

704B	  %6:fr64 = COPY killed %54:fr64
720B	  %5:fr64 = COPY killed %53:fr64
736B	  %4:gr32 = COPY killed %52:gr32
752B	  %3:fr64 = COPY killed %51:fr64
768B	  %34:fr64 = CVTSI2SDrr %4:gr32
784B	  %35:fr64 = COPY killed %34:fr64
800B	  %35:fr64 = nofpexcept MULSDrr %35:fr64(tied-def 0), %1:fr64, implicit $mxcsr
816B	  %36:fr64 = COPY killed %35:fr64
832B	  %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $xmm0 = COPY killed %36:fr64
880B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %37:fr64 = COPY killed $xmm0
928B	  %7:fr64 = COPY killed %6:fr64
944B	  %7:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), killed %37:fr64, implicit $mxcsr
960B	  %38:fr64 = COPY %1:fr64
976B	  %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %3:fr64, implicit $mxcsr
992B	  %39:fr64 = COPY killed %38:fr64
1008B	  %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
1024B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $xmm0 = COPY killed %39:fr64
1056B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1088B	  %40:fr64 = COPY killed $xmm0
1104B	  %8:fr64 = COPY killed %5:fr64
1120B	  %8:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
1136B	  %9:gr32 = COPY killed %4:gr32
1152B	  %9:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 2, implicit-def dead $eflags
1168B	  %10:fr64 = COPY killed %3:fr64
1184B	  %10:fr64 = ADDSDrr %10:fr64(tied-def 0), %50:fr64, implicit $mxcsr
1200B	  CMP32rr %9:gr32, %0:gr32, implicit-def $eflags
1216B	  %51:fr64 = COPY killed %10:fr64
1232B	  %52:gr32 = COPY killed %9:gr32
1248B	  %53:fr64 = COPY %8:fr64
1264B	  %54:fr64 = COPY %7:fr64
1280B	  JCC_1 %bb.2, 12, implicit killed $eflags
1296B	  JMP_1 %bb.3

1312B	bb.3.for.end.loopexit:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1328B	  %11:fr64 = COPY killed %7:fr64
1344B	  %11:fr64 = nofpexcept ADDSDrr %11:fr64(tied-def 0), %11:fr64, implicit $mxcsr
1360B	  %55:fr64 = COPY killed %11:fr64
1376B	  %56:fr64 = COPY killed %8:fr64

1392B	bb.4.for.end:
	; predecessors: %bb.3, %bb.5

1408B	  %13:fr64 = COPY killed %56:fr64
1424B	  %12:fr64 = COPY killed %55:fr64
1440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  $xmm0 = COPY killed %15:fr64
1472B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1488B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1504B	  %42:fr64 = COPY killed $xmm0
1520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1536B	  $xmm0 = COPY killed %16:fr64
1552B	  CALL64r killed %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1584B	  %43:fr64 = COPY killed $xmm0
1600B	  %44:fr64 = COPY killed %43:fr64
1616B	  %44:fr64 = nofpexcept ADDSDrr %44:fr64(tied-def 0), killed %42:fr64, implicit $mxcsr
1632B	  %45:fr64 = COPY killed %44:fr64
1648B	  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), killed %12:fr64, implicit $mxcsr
1664B	  %46:fr64 = COPY killed %13:fr64
1680B	  %46:fr64 = nofpexcept MULSDrm %46:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1696B	  %47:fr64 = COPY killed %46:fr64
1712B	  %47:fr64 = nofpexcept ADDSDrr %47:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
1728B	  %48:fr64 = COPY killed %1:fr64
1744B	  %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
1760B	  %49:fr64 = COPY killed %48:fr64
1776B	  %49:fr64 = nofpexcept DIVSDrm %49:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1792B	  $xmm0 = COPY killed %49:fr64
1808B	  RET 0, killed $xmm0

# End machine code for function _Z7simpsonPFddEddi.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 DIL#0 DIH#0 HDI#0 XMM0#0 XMM1#0 SIL#0 SIH#0 HSI#0
Created 8 new intervals.
********** INTERVALS **********
DIL [0B,64r:0)  0@0B-phi
DIH [0B,64r:0)  0@0B-phi
HDI [0B,64r:0)  0@0B-phi
SIL [0B,16r:0)  0@0B-phi
SIH [0B,16r:0)  0@0B-phi
HSI [0B,16r:0)  0@0B-phi
XMM0 [0B,48r:0)[352r,368r:11)[368r,400r:10)[864r,880r:9)[880r,912r:8)[1040r,1056r:7)[1056r,1088r:6)[1456r,1472r:5)[1472r,1504r:4)[1536r,1552r:3)[1552r,1584r:2)[1792r,1808r:1)  0@0B-phi 1@1792r 2@1552r 3@1536r 4@1472r 5@1456r 6@1056r 7@1040r 8@880r 9@864r 10@368r 11@352r
XMM1 [0B,32r:0)  0@0B-phi
%0 [192r,208r:0)[208r,480B:1)[544B,1312B:1)  0@192r 1@208r weight:0.000000e+00
%1 [272r,288r:0)[288r,1728r:1)  0@272r 1@288r weight:0.000000e+00
%2 [416r,512r:0)[544B,656r:0)  0@416r weight:0.000000e+00
%3 [752r,1168r:0)  0@752r weight:0.000000e+00
%4 [736r,1136r:0)  0@736r weight:0.000000e+00
%5 [720r,1104r:0)  0@720r weight:0.000000e+00
%6 [704r,928r:0)  0@704r weight:0.000000e+00
%7 [928r,944r:0)[944r,1328r:1)  0@928r 1@944r weight:0.000000e+00
%8 [1104r,1120r:0)[1120r,1376r:1)  0@1104r 1@1120r weight:0.000000e+00
%9 [1136r,1152r:0)[1152r,1232r:1)  0@1136r 1@1152r weight:0.000000e+00
%10 [1168r,1184r:0)[1184r,1216r:1)  0@1168r 1@1184r weight:0.000000e+00
%11 [1328r,1344r:0)[1344r,1360r:1)  0@1328r 1@1344r weight:0.000000e+00
%12 [1424r,1648r:0)  0@1424r weight:0.000000e+00
%13 [1408r,1664r:0)  0@1408r weight:0.000000e+00
%14 [64r,1552r:0)  0@64r weight:0.000000e+00
%15 [48r,1456r:0)  0@48r weight:0.000000e+00
%16 [32r,1536r:0)  0@32r weight:0.000000e+00
%17 [16r,448r:0)  0@16r weight:0.000000e+00
%18 [432r,496r:0)  0@432r weight:0.000000e+00
%19 [96r,128r:0)  0@96r weight:0.000000e+00
%20 [112r,176r:0)  0@112r weight:0.000000e+00
%22 [128r,144r:0)[144r,160r:1)  0@128r 1@144r weight:0.000000e+00
%23 [160r,176r:0)  0@160r weight:0.000000e+00
%25 [176r,192r:0)  0@176r weight:0.000000e+00
%26 [224r,240r:0)[240r,272r:1)  0@224r 1@240r weight:0.000000e+00
%27 [256r,288r:0)  0@256r weight:0.000000e+00
%28 [304r,320r:0)[320r,352r:1)  0@304r 1@320r weight:0.000000e+00
%29 [400r,416r:0)  0@400r weight:0.000000e+00
%31 [592r,624r:0)  0@592r weight:0.000000e+00
%32 [576r,640r:0)  0@576r weight:0.000000e+00
%33 [560r,672r:0)  0@560r weight:0.000000e+00
%34 [768r,784r:0)  0@768r weight:0.000000e+00
%35 [784r,800r:0)[800r,816r:1)  0@784r 1@800r weight:0.000000e+00
%36 [816r,832r:0)[832r,864r:1)  0@816r 1@832r weight:0.000000e+00
%37 [912r,944r:0)  0@912r weight:0.000000e+00
%38 [960r,976r:0)[976r,992r:1)  0@960r 1@976r weight:0.000000e+00
%39 [992r,1008r:0)[1008r,1040r:1)  0@992r 1@1008r weight:0.000000e+00
%40 [1088r,1120r:0)  0@1088r weight:0.000000e+00
%42 [1504r,1616r:0)  0@1504r weight:0.000000e+00
%43 [1584r,1600r:0)  0@1584r weight:0.000000e+00
%44 [1600r,1616r:0)[1616r,1632r:1)  0@1600r 1@1616r weight:0.000000e+00
%45 [1632r,1648r:0)[1648r,1712r:1)  0@1632r 1@1648r weight:0.000000e+00
%46 [1664r,1680r:0)[1680r,1696r:1)  0@1664r 1@1680r weight:0.000000e+00
%47 [1696r,1712r:0)[1712r,1744r:1)  0@1696r 1@1712r weight:0.000000e+00
%48 [1728r,1744r:0)[1744r,1760r:1)  0@1728r 1@1744r weight:0.000000e+00
%49 [1760r,1776r:0)[1776r,1792r:1)  0@1760r 1@1776r weight:0.000000e+00
%50 [608r,1312B:0)  0@608r weight:0.000000e+00
%51 [624r,688B:0)[688B,752r:2)[1216r,1312B:1)  0@624r 1@1216r 2@688B-phi weight:0.000000e+00
%52 [640r,688B:0)[688B,736r:2)[1232r,1312B:1)  0@640r 1@1232r 2@688B-phi weight:0.000000e+00
%53 [656r,688B:0)[688B,720r:2)[1248r,1312B:1)  0@656r 1@1248r 2@688B-phi weight:0.000000e+00
%54 [672r,688B:0)[688B,704r:2)[1264r,1312B:1)  0@672r 1@1264r 2@688B-phi weight:0.000000e+00
%55 [496r,544B:0)[1360r,1392B:1)[1392B,1424r:2)  0@496r 1@1360r 2@1392B-phi weight:0.000000e+00
%56 [512r,544B:0)[1376r,1392B:1)[1392B,1408r:2)  0@512r 1@1376r 2@1392B-phi weight:0.000000e+00
%57 [80r,96r:0)  0@80r weight:0.000000e+00
RegMasks: 368r 880r 1056r 1472r 1552r
********** MACHINEINSTRS **********
# Machine code for function _Z7simpsonPFddEddi: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.5(0x40000000); %bb.1(50.00%), %bb.5(50.00%)
	  liveins: $rdi, $xmm0, $xmm1, $esi
16B	  %17:gr32 = COPY $esi
32B	  %16:fr64 = COPY $xmm1
48B	  %15:fr64 = COPY $xmm0
64B	  %14:gr64 = COPY $rdi
80B	  undef %57.sub_32bit:gr64 = COPY %17:gr32
96B	  %19:gr32 = LEA64_32r %57:gr64, 1, $noreg, 1, $noreg
112B	  undef %20.sub_32bit:gr64 = COPY %17:gr32
128B	  %22:gr32 = COPY %19:gr32
144B	  %22:gr32 = SHR32ri %22:gr32(tied-def 0), 31, implicit-def dead $eflags
160B	  undef %23.sub_32bit:gr64_nosp = COPY %22:gr32
176B	  %25:gr32 = LEA64_32r %20:gr64, 1, %23:gr64_nosp, 1, $noreg
192B	  %0:gr32 = COPY %25:gr32
208B	  %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
224B	  %26:fr64 = COPY %16:fr64
240B	  %26:fr64 = nofpexcept SUBSDrr %26:fr64(tied-def 0), %15:fr64, implicit $mxcsr
256B	  %27:fr64 = CVTSI2SDrr %0:gr32
272B	  %1:fr64 = COPY %26:fr64
288B	  %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
304B	  %28:fr64 = COPY %1:fr64
320B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  $xmm0 = COPY %28:fr64
368B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
384B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  %29:fr64 = COPY $xmm0
416B	  %2:fr64 = COPY %29:fr64
432B	  %18:fr64 = FsFLD0SD
448B	  CMP32ri8 %17:gr32, 3, implicit-def $eflags
464B	  JCC_1 %bb.1, 13, implicit killed $eflags

480B	bb.5:
	; predecessors: %bb.0
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

496B	  %55:fr64 = COPY %18:fr64
512B	  %56:fr64 = COPY %2:fr64
528B	  JMP_1 %bb.4

544B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

560B	  %33:fr64 = FsFLD0SD
576B	  %32:gr32 = MOV32ri 2
592B	  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
608B	  %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
624B	  %51:fr64 = COPY %31:fr64
640B	  %52:gr32 = COPY %32:gr32
656B	  %53:fr64 = COPY %2:fr64
672B	  %54:fr64 = COPY %33:fr64

688B	bb.2.for.body:
	; predecessors: %bb.1, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

704B	  %6:fr64 = COPY %54:fr64
720B	  %5:fr64 = COPY %53:fr64
736B	  %4:gr32 = COPY %52:gr32
752B	  %3:fr64 = COPY %51:fr64
768B	  %34:fr64 = CVTSI2SDrr %4:gr32
784B	  %35:fr64 = COPY %34:fr64
800B	  %35:fr64 = nofpexcept MULSDrr %35:fr64(tied-def 0), %1:fr64, implicit $mxcsr
816B	  %36:fr64 = COPY %35:fr64
832B	  %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $xmm0 = COPY %36:fr64
880B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %37:fr64 = COPY $xmm0
928B	  %7:fr64 = COPY %6:fr64
944B	  %7:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %37:fr64, implicit $mxcsr
960B	  %38:fr64 = COPY %1:fr64
976B	  %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %3:fr64, implicit $mxcsr
992B	  %39:fr64 = COPY %38:fr64
1008B	  %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
1024B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $xmm0 = COPY %39:fr64
1056B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1088B	  %40:fr64 = COPY $xmm0
1104B	  %8:fr64 = COPY %5:fr64
1120B	  %8:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), %40:fr64, implicit $mxcsr
1136B	  %9:gr32 = COPY %4:gr32
1152B	  %9:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 2, implicit-def dead $eflags
1168B	  %10:fr64 = COPY %3:fr64
1184B	  %10:fr64 = ADDSDrr %10:fr64(tied-def 0), %50:fr64, implicit $mxcsr
1200B	  CMP32rr %9:gr32, %0:gr32, implicit-def $eflags
1216B	  %51:fr64 = COPY %10:fr64
1232B	  %52:gr32 = COPY %9:gr32
1248B	  %53:fr64 = COPY %8:fr64
1264B	  %54:fr64 = COPY %7:fr64
1280B	  JCC_1 %bb.2, 12, implicit killed $eflags
1296B	  JMP_1 %bb.3

1312B	bb.3.for.end.loopexit:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1328B	  %11:fr64 = COPY %7:fr64
1344B	  %11:fr64 = nofpexcept ADDSDrr %11:fr64(tied-def 0), %11:fr64, implicit $mxcsr
1360B	  %55:fr64 = COPY %11:fr64
1376B	  %56:fr64 = COPY %8:fr64

1392B	bb.4.for.end:
	; predecessors: %bb.3, %bb.5

1408B	  %13:fr64 = COPY %56:fr64
1424B	  %12:fr64 = COPY %55:fr64
1440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  $xmm0 = COPY %15:fr64
1472B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1488B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1504B	  %42:fr64 = COPY $xmm0
1520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1536B	  $xmm0 = COPY %16:fr64
1552B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1584B	  %43:fr64 = COPY $xmm0
1600B	  %44:fr64 = COPY %43:fr64
1616B	  %44:fr64 = nofpexcept ADDSDrr %44:fr64(tied-def 0), %42:fr64, implicit $mxcsr
1632B	  %45:fr64 = COPY %44:fr64
1648B	  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %12:fr64, implicit $mxcsr
1664B	  %46:fr64 = COPY %13:fr64
1680B	  %46:fr64 = nofpexcept MULSDrm %46:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1696B	  %47:fr64 = COPY %46:fr64
1712B	  %47:fr64 = nofpexcept ADDSDrr %47:fr64(tied-def 0), %45:fr64, implicit $mxcsr
1728B	  %48:fr64 = COPY %1:fr64
1744B	  %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %47:fr64, implicit $mxcsr
1760B	  %49:fr64 = COPY %48:fr64
1776B	  %49:fr64 = nofpexcept DIVSDrm %49:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1792B	  $xmm0 = COPY %49:fr64
1808B	  RET 0, $xmm0

# End machine code for function _Z7simpsonPFddEddi.

********** SIMPLE REGISTER COALESCING **********
********** Function: _Z7simpsonPFddEddi
********** JOINING INTERVALS ***********
for.body:
864B	$xmm0 = COPY %36:fr64
	Considering merging %36 with $xmm0
	Can only merge into reserved registers.
912B	%37:fr64 = COPY $xmm0
	Considering merging %37 with $xmm0
	Can only merge into reserved registers.
1040B	$xmm0 = COPY %39:fr64
	Considering merging %39 with $xmm0
	Can only merge into reserved registers.
1088B	%40:fr64 = COPY $xmm0
	Considering merging %40 with $xmm0
	Can only merge into reserved registers.
1248B	%53:fr64 = COPY %8:fr64
	Considering merging to FR64 with %8 in %53
		RHS = %8 [1104r,1120r:0)[1120r,1376r:1)  0@1104r 1@1120r weight:0.000000e+00
		LHS = %53 [656r,688B:0)[688B,720r:2)[1248r,1312B:1)  0@656r 1@1248r 2@688B-phi weight:0.000000e+00
		merge %53:1@1248r into %8:1@1120r --> @1120r
		erased:	1248r	%53:fr64 = COPY %8:fr64
AllocationOrder(FR64) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
		updated: 1104B	%53:fr64 = COPY %5:fr64
		updated: 1120B	%53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %40:fr64, implicit $mxcsr
		updated: 1376B	%56:fr64 = COPY %53:fr64
	Success: %8 -> %53
	Result = %53 [656r,688B:0)[688B,720r:2)[1104r,1120r:3)[1120r,1376r:1)  0@656r 1@1120r 2@688B-phi 3@1104r weight:0.000000e+00
1264B	%54:fr64 = COPY %7:fr64
	Considering merging to FR64 with %7 in %54
		RHS = %7 [928r,944r:0)[944r,1328r:1)  0@928r 1@944r weight:0.000000e+00
		LHS = %54 [672r,688B:0)[688B,704r:2)[1264r,1312B:1)  0@672r 1@1264r 2@688B-phi weight:0.000000e+00
		merge %54:1@1264r into %7:1@944r --> @944r
		erased:	1264r	%54:fr64 = COPY %7:fr64
		updated: 928B	%54:fr64 = COPY %6:fr64
		updated: 944B	%54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
		updated: 1328B	%11:fr64 = COPY %54:fr64
	Success: %7 -> %54
	Result = %54 [672r,688B:0)[688B,704r:2)[928r,944r:3)[944r,1328r:1)  0@672r 1@944r 2@688B-phi 3@928r weight:0.000000e+00
704B	%6:fr64 = COPY %54:fr64
	Considering merging to FR64 with %6 in %54
		RHS = %6 [704r,928r:0)  0@704r weight:0.000000e+00
		LHS = %54 [672r,688B:0)[688B,704r:2)[928r,944r:3)[944r,1328r:1)  0@672r 1@944r 2@688B-phi 3@928r weight:0.000000e+00
		merge %6:0@704r into %54:2@688B --> @688B
		merge %54:3@928r into %6:0@704r --> @688B
		erased:	928r	%54:fr64 = COPY %6:fr64
		erased:	704r	%6:fr64 = COPY %54:fr64
	Success: %6 -> %54
	Result = %54 [672r,688B:0)[688B,944r:2)[944r,1328r:1)  0@672r 1@944r 2@688B-phi weight:0.000000e+00
720B	%5:fr64 = COPY %53:fr64
	Considering merging to FR64 with %5 in %53
		RHS = %5 [720r,1104r:0)  0@720r weight:0.000000e+00
		LHS = %53 [656r,688B:0)[688B,720r:2)[1104r,1120r:3)[1120r,1376r:1)  0@656r 1@1120r 2@688B-phi 3@1104r weight:0.000000e+00
		merge %5:0@720r into %53:2@688B --> @688B
		merge %53:3@1104r into %5:0@720r --> @688B
		erased:	1104r	%53:fr64 = COPY %5:fr64
		erased:	720r	%5:fr64 = COPY %53:fr64
	Success: %5 -> %53
	Result = %53 [656r,688B:0)[688B,1120r:2)[1120r,1376r:1)  0@656r 1@1120r 2@688B-phi weight:0.000000e+00
736B	%4:gr32 = COPY %52:gr32
	Considering merging to GR32 with %4 in %52
		RHS = %4 [736r,1136r:0)  0@736r weight:0.000000e+00
		LHS = %52 [640r,688B:0)[688B,736r:2)[1232r,1312B:1)  0@640r 1@1232r 2@688B-phi weight:0.000000e+00
		merge %4:0@736r into %52:2@688B --> @688B
		erased:	736r	%4:gr32 = COPY %52:gr32
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
		updated: 768B	%34:fr64 = CVTSI2SDrr %52:gr32
		updated: 1136B	%9:gr32 = COPY %52:gr32
	Success: %4 -> %52
	Result = %52 [640r,688B:0)[688B,1136r:2)[1232r,1312B:1)  0@640r 1@1232r 2@688B-phi weight:0.000000e+00
752B	%3:fr64 = COPY %51:fr64
	Considering merging to FR64 with %3 in %51
		RHS = %3 [752r,1168r:0)  0@752r weight:0.000000e+00
		LHS = %51 [624r,688B:0)[688B,752r:2)[1216r,1312B:1)  0@624r 1@1216r 2@688B-phi weight:0.000000e+00
		merge %3:0@752r into %51:2@688B --> @688B
		erased:	752r	%3:fr64 = COPY %51:fr64
		updated: 976B	%38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %51:fr64, implicit $mxcsr
		updated: 1168B	%10:fr64 = COPY %51:fr64
	Success: %3 -> %51
	Result = %51 [624r,688B:0)[688B,1168r:2)[1216r,1312B:1)  0@624r 1@1216r 2@688B-phi weight:0.000000e+00
784B	%35:fr64 = COPY %34:fr64
	Considering merging to FR64 with %34 in %35
		RHS = %34 [768r,784r:0)  0@768r weight:0.000000e+00
		LHS = %35 [784r,800r:0)[800r,816r:1)  0@784r 1@800r weight:0.000000e+00
		merge %35:0@784r into %34:0@768r --> @768r
		erased:	784r	%35:fr64 = COPY %34:fr64
		updated: 768B	%35:fr64 = CVTSI2SDrr %52:gr32
	Success: %34 -> %35
	Result = %35 [768r,800r:0)[800r,816r:1)  0@768r 1@800r weight:0.000000e+00
816B	%36:fr64 = COPY %35:fr64
	Considering merging to FR64 with %35 in %36
		RHS = %35 [768r,800r:0)[800r,816r:1)  0@768r 1@800r weight:0.000000e+00
		LHS = %36 [816r,832r:0)[832r,864r:1)  0@816r 1@832r weight:0.000000e+00
		merge %36:0@816r into %35:1@800r --> @800r
		erased:	816r	%36:fr64 = COPY %35:fr64
		updated: 768B	%36:fr64 = CVTSI2SDrr %52:gr32
		updated: 800B	%36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %1:fr64, implicit $mxcsr
	Success: %35 -> %36
	Result = %36 [768r,800r:2)[800r,832r:0)[832r,864r:1)  0@800r 1@832r 2@768r weight:0.000000e+00
960B	%38:fr64 = COPY %1:fr64
	Considering merging to FR64 with %1 in %38
		RHS = %1 [272r,288r:0)[288r,1728r:1)  0@272r 1@288r weight:0.000000e+00
		LHS = %38 [960r,976r:0)[976r,992r:1)  0@960r 1@976r weight:0.000000e+00
		merge %38:0@960r into %1:1@288r --> @288r
		interference at %38:1@976r
	Interference!
992B	%39:fr64 = COPY %38:fr64
	Considering merging to FR64 with %38 in %39
		RHS = %38 [960r,976r:0)[976r,992r:1)  0@960r 1@976r weight:0.000000e+00
		LHS = %39 [992r,1008r:0)[1008r,1040r:1)  0@992r 1@1008r weight:0.000000e+00
		merge %39:0@992r into %38:1@976r --> @976r
		erased:	992r	%39:fr64 = COPY %38:fr64
		updated: 960B	%39:fr64 = COPY %1:fr64
		updated: 976B	%39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
	Success: %38 -> %39
	Result = %39 [960r,976r:2)[976r,1008r:0)[1008r,1040r:1)  0@976r 1@1008r 2@960r weight:0.000000e+00
1136B	%9:gr32 = COPY %52:gr32
	Considering merging to GR32 with %9 in %52
		RHS = %9 [1136r,1152r:0)[1152r,1232r:1)  0@1136r 1@1152r weight:0.000000e+00
		LHS = %52 [640r,688B:0)[688B,1136r:2)[1232r,1312B:1)  0@640r 1@1232r 2@688B-phi weight:0.000000e+00
		merge %52:1@1232r into %9:1@1152r --> @1152r
		merge %9:0@1136r into %52:2@688B --> @688B
		erased:	1232r	%52:gr32 = COPY %9:gr32
		erased:	1136r	%9:gr32 = COPY %52:gr32
		updated: 1152B	%52:gr32 = nuw nsw ADD32ri8 %52:gr32(tied-def 0), 2, implicit-def dead $eflags
		updated: 1200B	CMP32rr %52:gr32, %0:gr32, implicit-def $eflags
	Success: %9 -> %52
	Result = %52 [640r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@640r 1@1152r 2@688B-phi weight:0.000000e+00
1168B	%10:fr64 = COPY %51:fr64
	Considering merging to FR64 with %10 in %51
		RHS = %10 [1168r,1184r:0)[1184r,1216r:1)  0@1168r 1@1184r weight:0.000000e+00
		LHS = %51 [624r,688B:0)[688B,1168r:2)[1216r,1312B:1)  0@624r 1@1216r 2@688B-phi weight:0.000000e+00
		merge %51:1@1216r into %10:1@1184r --> @1184r
		merge %10:0@1168r into %51:2@688B --> @688B
		erased:	1216r	%51:fr64 = COPY %10:fr64
		erased:	1168r	%10:fr64 = COPY %51:fr64
		updated: 1184B	%51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
	Success: %10 -> %51
	Result = %51 [624r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@624r 1@1184r 2@688B-phi weight:0.000000e+00
entry:
16B	%17:gr32 = COPY $esi
	Considering merging %17 with $esi
	Can only merge into reserved registers.
32B	%16:fr64 = COPY $xmm1
	Considering merging %16 with $xmm1
	Can only merge into reserved registers.
48B	%15:fr64 = COPY $xmm0
	Considering merging %15 with $xmm0
	Can only merge into reserved registers.
64B	%14:gr64 = COPY $rdi
	Considering merging %14 with $rdi
	Can only merge into reserved registers.
352B	$xmm0 = COPY %28:fr64
	Considering merging %28 with $xmm0
	Can only merge into reserved registers.
400B	%29:fr64 = COPY $xmm0
	Considering merging %29 with $xmm0
	Can only merge into reserved registers.
for.body.preheader:
656B	%53:fr64 = COPY %2:fr64
	Considering merging to FR64 with %2 in %53
		RHS = %2 [416r,512r:0)[544B,656r:0)  0@416r weight:0.000000e+00
		LHS = %53 [656r,688B:0)[688B,1120r:2)[1120r,1376r:1)  0@656r 1@1120r 2@688B-phi weight:0.000000e+00
		merge %53:0@656r into %2:0@416r --> @416r
		erased:	656r	%53:fr64 = COPY %2:fr64
		updated: 416B	%53:fr64 = COPY %29:fr64
		updated: 512B	%56:fr64 = COPY %53:fr64
	Success: %2 -> %53
	Result = %53 [416r,512r:0)[544B,688B:0)[688B,1120r:2)[1120r,1376r:1)  0@416r 1@1120r 2@688B-phi weight:0.000000e+00
for.end.loopexit:
1376B	%56:fr64 = COPY %53:fr64
	Considering merging to FR64 with %56 in %53
		RHS = %56 [512r,544B:0)[1376r,1392B:1)[1392B,1408r:2)  0@512r 1@1376r 2@1392B-phi weight:0.000000e+00
		LHS = %53 [416r,512r:0)[544B,688B:0)[688B,1120r:2)[1120r,1376r:1)  0@416r 1@1120r 2@688B-phi weight:0.000000e+00
		merge %56:0@512r into %53:0@416r --> @416r
		merge %56:1@1376r into %53:1@1120r --> @1120r
		erased:	512r	%56:fr64 = COPY %53:fr64
		erased:	1376r	%56:fr64 = COPY %53:fr64
		updated: 1408B	%13:fr64 = COPY %53:fr64
	Success: %56 -> %53
	Result = %53 [416r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1408r:3)  0@416r 1@1120r 2@688B-phi 3@1392B-phi weight:0.000000e+00
for.end:
1456B	$xmm0 = COPY %15:fr64
	Considering merging %15 with $xmm0
	Can only merge into reserved registers.
1504B	%42:fr64 = COPY $xmm0
	Considering merging %42 with $xmm0
	Can only merge into reserved registers.
1536B	$xmm0 = COPY %16:fr64
	Considering merging %16 with $xmm0
	Can only merge into reserved registers.
1584B	%43:fr64 = COPY $xmm0
	Considering merging %43 with $xmm0
	Can only merge into reserved registers.
1792B	$xmm0 = COPY %49:fr64
	Considering merging %49 with $xmm0
	Can only merge into reserved registers.
:
496B	%55:fr64 = COPY %18:fr64
	Considering merging to FR64 with %18 in %55
		RHS = %18 [432r,496r:0)  0@432r weight:0.000000e+00
		LHS = %55 [496r,544B:0)[1360r,1392B:1)[1392B,1424r:2)  0@496r 1@1360r 2@1392B-phi weight:0.000000e+00
		merge %55:0@496r into %18:0@432r --> @432r
		erased:	496r	%55:fr64 = COPY %18:fr64
		updated: 432B	%55:fr64 = FsFLD0SD
	Success: %18 -> %55
	Result = %55 [432r,544B:0)[1360r,1392B:1)[1392B,1424r:2)  0@432r 1@1360r 2@1392B-phi weight:0.000000e+00
80B	undef %57.sub_32bit:gr64 = COPY %17:gr32
	Considering merging to GR64_with_sub_8bit with %17 in %57:sub_32bit
		RHS = %17 [16r,448r:0)  0@16r weight:0.000000e+00
		LHS = %57 [80r,96r:0)  0@80r weight:0.000000e+00
		merge %57:0@80r into %17:0@16r --> @16r
		erased:	80r	undef %57.sub_32bit:gr64 = COPY %17:gr32
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
AllocationOrder(GR64_with_sub_8bit) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
		updated: 16B	undef %57.sub_32bit:gr64_with_sub_8bit = COPY $esi
		updated: 112B	undef %20.sub_32bit:gr64 = COPY %57.sub_32bit:gr64_with_sub_8bit
		updated: 448B	CMP32ri8 %57.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
	Success: %17:sub_32bit -> %57
	Result = %57 [16r,448r:0)  0@16r weight:0.000000e+00
112B	undef %20.sub_32bit:gr64 = COPY %57.sub_32bit:gr64_with_sub_8bit
	Considering merging to GR64_with_sub_8bit with %57 in %20
		RHS = %57 [16r,448r:0)  0@16r weight:0.000000e+00
		LHS = %20 [112r,176r:0)  0@112r weight:0.000000e+00
		merge %20:0@112r into %57:0@16r --> @16r
		erased:	112r	undef %20.sub_32bit:gr64 = COPY %57.sub_32bit:gr64_with_sub_8bit
		updated: 16B	undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
		updated: 96B	%19:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
		updated: 448B	CMP32ri8 %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
	Success: %57 -> %20
	Result = %20 [16r,448r:0)  0@16r weight:0.000000e+00
128B	%22:gr32 = COPY %19:gr32
	Considering merging to GR32 with %19 in %22
		RHS = %19 [96r,128r:0)  0@96r weight:0.000000e+00
		LHS = %22 [128r,144r:0)[144r,160r:1)  0@128r 1@144r weight:0.000000e+00
		merge %22:0@128r into %19:0@96r --> @96r
		erased:	128r	%22:gr32 = COPY %19:gr32
		updated: 96B	%22:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
	Success: %19 -> %22
	Result = %22 [96r,144r:0)[144r,160r:1)  0@96r 1@144r weight:0.000000e+00
160B	undef %23.sub_32bit:gr64_nosp = COPY %22:gr32
	Considering merging to GR64_NOSP with %22 in %23:sub_32bit
		RHS = %22 [96r,144r:0)[144r,160r:1)  0@96r 1@144r weight:0.000000e+00
		LHS = %23 [160r,176r:0)  0@160r weight:0.000000e+00
		merge %23:0@160r into %22:1@144r --> @144r
		erased:	160r	undef %23.sub_32bit:gr64_nosp = COPY %22:gr32
AllocationOrder(GR64_NOSP) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
		updated: 96B	undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
		updated: 144B	%23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
	Success: %22:sub_32bit -> %23
	Result = %23 [96r,144r:1)[144r,176r:0)  0@144r 1@96r weight:0.000000e+00
192B	%0:gr32 = COPY %25:gr32
	Considering merging to GR32 with %25 in %0
		RHS = %25 [176r,192r:0)  0@176r weight:0.000000e+00
		LHS = %0 [192r,208r:0)[208r,480B:1)[544B,1312B:1)  0@192r 1@208r weight:0.000000e+00
		merge %0:0@192r into %25:0@176r --> @176r
		erased:	192r	%0:gr32 = COPY %25:gr32
		updated: 176B	%0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
	Success: %25 -> %0
	Result = %0 [176r,208r:0)[208r,480B:1)[544B,1312B:1)  0@176r 1@208r weight:0.000000e+00
224B	%26:fr64 = COPY %16:fr64
	Considering merging to FR64 with %16 in %26
		RHS = %16 [32r,1536r:0)  0@32r weight:0.000000e+00
		LHS = %26 [224r,240r:0)[240r,272r:1)  0@224r 1@240r weight:0.000000e+00
		merge %26:0@224r into %16:0@32r --> @32r
		interference at %26:1@240r
	Interference!
272B	%1:fr64 = COPY %26:fr64
	Considering merging to FR64 with %26 in %1
		RHS = %26 [224r,240r:0)[240r,272r:1)  0@224r 1@240r weight:0.000000e+00
		LHS = %1 [272r,288r:0)[288r,1728r:1)  0@272r 1@288r weight:0.000000e+00
		merge %1:0@272r into %26:1@240r --> @240r
		erased:	272r	%1:fr64 = COPY %26:fr64
		updated: 224B	%1:fr64 = COPY %16:fr64
		updated: 240B	%1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
	Success: %26 -> %1
	Result = %1 [224r,240r:2)[240r,288r:0)[288r,1728r:1)  0@240r 1@288r 2@224r weight:0.000000e+00
304B	%28:fr64 = COPY %1:fr64
	Considering merging to FR64 with %28 in %1
		RHS = %28 [304r,320r:0)[320r,352r:1)  0@304r 1@320r weight:0.000000e+00
		LHS = %1 [224r,240r:2)[240r,288r:0)[288r,1728r:1)  0@240r 1@288r 2@224r weight:0.000000e+00
		merge %28:0@304r into %1:1@288r --> @288r
		interference at %28:1@320r
	Interference!
416B	%53:fr64 = COPY %29:fr64
	Considering merging to FR64 with %29 in %53
		RHS = %29 [400r,416r:0)  0@400r weight:0.000000e+00
		LHS = %53 [416r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1408r:3)  0@416r 1@1120r 2@688B-phi 3@1392B-phi weight:0.000000e+00
		merge %53:0@416r into %29:0@400r --> @400r
		erased:	416r	%53:fr64 = COPY %29:fr64
		updated: 400B	%53:fr64 = COPY $xmm0
	Success: %29 -> %53
	Result = %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1408r:3)  0@400r 1@1120r 2@688B-phi 3@1392B-phi weight:0.000000e+00
624B	%51:fr64 = COPY %31:fr64
	Considering merging to FR64 with %31 in %51
		RHS = %31 [592r,624r:0)  0@592r weight:0.000000e+00
		LHS = %51 [624r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@624r 1@1184r 2@688B-phi weight:0.000000e+00
		merge %51:0@624r into %31:0@592r --> @592r
		erased:	624r	%51:fr64 = COPY %31:fr64
		updated: 592B	%51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
	Success: %31 -> %51
	Result = %51 [592r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@592r 1@1184r 2@688B-phi weight:0.000000e+00
640B	%52:gr32 = COPY %32:gr32
	Considering merging to GR32 with %32 in %52
		RHS = %32 [576r,640r:0)  0@576r weight:0.000000e+00
		LHS = %52 [640r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@640r 1@1152r 2@688B-phi weight:0.000000e+00
		merge %52:0@640r into %32:0@576r --> @576r
		erased:	640r	%52:gr32 = COPY %32:gr32
		updated: 576B	%52:gr32 = MOV32ri 2
	Success: %32 -> %52
	Result = %52 [576r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@576r 1@1152r 2@688B-phi weight:0.000000e+00
672B	%54:fr64 = COPY %33:fr64
	Considering merging to FR64 with %33 in %54
		RHS = %33 [560r,672r:0)  0@560r weight:0.000000e+00
		LHS = %54 [672r,688B:0)[688B,944r:2)[944r,1328r:1)  0@672r 1@944r 2@688B-phi weight:0.000000e+00
		merge %54:0@672r into %33:0@560r --> @560r
		erased:	672r	%54:fr64 = COPY %33:fr64
		updated: 560B	%54:fr64 = FsFLD0SD
	Success: %33 -> %54
	Result = %54 [560r,688B:0)[688B,944r:2)[944r,1328r:1)  0@560r 1@944r 2@688B-phi weight:0.000000e+00
1328B	%11:fr64 = COPY %54:fr64
	Considering merging to FR64 with %11 in %54
		RHS = %11 [1328r,1344r:0)[1344r,1360r:1)  0@1328r 1@1344r weight:0.000000e+00
		LHS = %54 [560r,688B:0)[688B,944r:2)[944r,1328r:1)  0@560r 1@944r 2@688B-phi weight:0.000000e+00
		merge %11:0@1328r into %54:1@944r --> @944r
		erased:	1328r	%11:fr64 = COPY %54:fr64
		updated: 1344B	%54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %54:fr64, implicit $mxcsr
		updated: 1360B	%55:fr64 = COPY %54:fr64
	Success: %11 -> %54
	Result = %54 [560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1360r:3)  0@560r 1@944r 2@688B-phi 3@1344r weight:0.000000e+00
1360B	%55:fr64 = COPY %54:fr64
	Considering merging to FR64 with %55 in %54
		RHS = %55 [432r,544B:0)[1360r,1392B:1)[1392B,1424r:2)  0@432r 1@1360r 2@1392B-phi weight:0.000000e+00
		LHS = %54 [560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1360r:3)  0@560r 1@944r 2@688B-phi 3@1344r weight:0.000000e+00
		merge %55:1@1360r into %54:3@1344r --> @1344r
		erased:	1360r	%55:fr64 = COPY %54:fr64
		updated: 432B	%54:fr64 = FsFLD0SD
		updated: 1424B	%12:fr64 = COPY %54:fr64
	Success: %55 -> %54
	Result = %54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1424r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:0.000000e+00
1408B	%13:fr64 = COPY %53:fr64
	Considering merging to FR64 with %13 in %53
		RHS = %13 [1408r,1664r:0)  0@1408r weight:0.000000e+00
		LHS = %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1408r:3)  0@400r 1@1120r 2@688B-phi 3@1392B-phi weight:0.000000e+00
		merge %13:0@1408r into %53:3@1392B --> @1392B
		erased:	1408r	%13:fr64 = COPY %53:fr64
		updated: 1664B	%46:fr64 = COPY %53:fr64
	Success: %13 -> %53
	Result = %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1664r:3)  0@400r 1@1120r 2@688B-phi 3@1392B-phi weight:0.000000e+00
1424B	%12:fr64 = COPY %54:fr64
	Considering merging to FR64 with %12 in %54
		RHS = %12 [1424r,1648r:0)  0@1424r weight:0.000000e+00
		LHS = %54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1424r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:0.000000e+00
		merge %12:0@1424r into %54:5@1392B --> @1392B
		erased:	1424r	%12:fr64 = COPY %54:fr64
		updated: 1648B	%45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
	Success: %12 -> %54
	Result = %54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1648r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:0.000000e+00
1600B	%44:fr64 = COPY %43:fr64
	Considering merging to FR64 with %43 in %44
		RHS = %43 [1584r,1600r:0)  0@1584r weight:0.000000e+00
		LHS = %44 [1600r,1616r:0)[1616r,1632r:1)  0@1600r 1@1616r weight:0.000000e+00
		merge %44:0@1600r into %43:0@1584r --> @1584r
		erased:	1600r	%44:fr64 = COPY %43:fr64
		updated: 1584B	%44:fr64 = COPY $xmm0
	Success: %43 -> %44
	Result = %44 [1584r,1616r:0)[1616r,1632r:1)  0@1584r 1@1616r weight:0.000000e+00
1632B	%45:fr64 = COPY %44:fr64
	Considering merging to FR64 with %44 in %45
		RHS = %44 [1584r,1616r:0)[1616r,1632r:1)  0@1584r 1@1616r weight:0.000000e+00
		LHS = %45 [1632r,1648r:0)[1648r,1712r:1)  0@1632r 1@1648r weight:0.000000e+00
		merge %45:0@1632r into %44:1@1616r --> @1616r
		erased:	1632r	%45:fr64 = COPY %44:fr64
		updated: 1584B	%45:fr64 = COPY $xmm0
		updated: 1616B	%45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
	Success: %44 -> %45
	Result = %45 [1584r,1616r:2)[1616r,1648r:0)[1648r,1712r:1)  0@1616r 1@1648r 2@1584r weight:0.000000e+00
1664B	%46:fr64 = COPY %53:fr64
	Considering merging to FR64 with %46 in %53
		RHS = %46 [1664r,1680r:0)[1680r,1696r:1)  0@1664r 1@1680r weight:0.000000e+00
		LHS = %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1664r:3)  0@400r 1@1120r 2@688B-phi 3@1392B-phi weight:0.000000e+00
		merge %46:0@1664r into %53:3@1392B --> @1392B
		erased:	1664r	%46:fr64 = COPY %53:fr64
		updated: 1680B	%53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		updated: 1696B	%47:fr64 = COPY %53:fr64
	Success: %46 -> %53
	Result = %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1696r:4)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r weight:0.000000e+00
1696B	%47:fr64 = COPY %53:fr64
	Considering merging to FR64 with %47 in %53
		RHS = %47 [1696r,1712r:0)[1712r,1744r:1)  0@1696r 1@1712r weight:0.000000e+00
		LHS = %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1696r:4)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r weight:0.000000e+00
		merge %47:0@1696r into %53:4@1680r --> @1680r
		erased:	1696r	%47:fr64 = COPY %53:fr64
		updated: 1712B	%53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
		updated: 1744B	%48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %53:fr64, implicit $mxcsr
	Success: %47 -> %53
	Result = %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1712r:4)[1712r,1744r:5)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r 5@1712r weight:0.000000e+00
1728B	%48:fr64 = COPY %1:fr64
	Considering merging to FR64 with %48 in %1
		RHS = %48 [1728r,1744r:0)[1744r,1760r:1)  0@1728r 1@1744r weight:0.000000e+00
		LHS = %1 [224r,240r:2)[240r,288r:0)[288r,1728r:1)  0@240r 1@288r 2@224r weight:0.000000e+00
		merge %48:0@1728r into %1:1@288r --> @288r
		erased:	1728r	%48:fr64 = COPY %1:fr64
		updated: 1744B	%1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
		updated: 1760B	%49:fr64 = COPY %1:fr64
	Success: %48 -> %1
	Result = %1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1760r:3)  0@240r 1@288r 2@224r 3@1744r weight:0.000000e+00
1760B	%49:fr64 = COPY %1:fr64
	Considering merging to FR64 with %49 in %1
		RHS = %49 [1760r,1776r:0)[1776r,1792r:1)  0@1760r 1@1776r weight:0.000000e+00
		LHS = %1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1760r:3)  0@240r 1@288r 2@224r 3@1744r weight:0.000000e+00
		merge %49:0@1760r into %1:3@1744r --> @1744r
		erased:	1760r	%49:fr64 = COPY %1:fr64
		updated: 1776B	%1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
		updated: 1792B	$xmm0 = COPY %1:fr64
	Success: %49 -> %1
	Result = %1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:0.000000e+00
960B	%39:fr64 = COPY %1:fr64
	Considering merging to FR64 with %39 in %1
		RHS = %39 [960r,976r:2)[976r,1008r:0)[1008r,1040r:1)  0@976r 1@1008r 2@960r weight:0.000000e+00
		LHS = %1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:0.000000e+00
		interference at %39:0@976r
	Interference!
1456B	$xmm0 = COPY %15:fr64
	Considering merging %15 with $xmm0
	Can only merge into reserved registers.
1536B	$xmm0 = COPY %16:fr64
	Considering merging %16 with $xmm0
	Can only merge into reserved registers.
224B	%1:fr64 = COPY %16:fr64
	Considering merging to FR64 with %16 in %1
		RHS = %16 [32r,1536r:0)  0@32r weight:0.000000e+00
		LHS = %1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:0.000000e+00
		interference at %1:0@240r
	Interference!
304B	%28:fr64 = COPY %1:fr64
	Considering merging to FR64 with %28 in %1
		RHS = %28 [304r,320r:0)[320r,352r:1)  0@304r 1@320r weight:0.000000e+00
		LHS = %1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:0.000000e+00
		merge %28:0@304r into %1:1@288r --> @288r
		interference at %28:1@320r
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,64r:0)  0@0B-phi
DIH [0B,64r:0)  0@0B-phi
HDI [0B,64r:0)  0@0B-phi
SIL [0B,16r:0)  0@0B-phi
SIH [0B,16r:0)  0@0B-phi
HSI [0B,16r:0)  0@0B-phi
XMM0 [0B,48r:0)[352r,368r:11)[368r,400r:10)[864r,880r:9)[880r,912r:8)[1040r,1056r:7)[1056r,1088r:6)[1456r,1472r:5)[1472r,1504r:4)[1536r,1552r:3)[1552r,1584r:2)[1792r,1808r:1)  0@0B-phi 1@1792r 2@1552r 3@1536r 4@1472r 5@1456r 6@1056r 7@1040r 8@880r 9@864r 10@368r 11@352r
XMM1 [0B,32r:0)  0@0B-phi
%0 [176r,208r:0)[208r,480B:1)[544B,1312B:1)  0@176r 1@208r weight:0.000000e+00
%1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:0.000000e+00
%14 [64r,1552r:0)  0@64r weight:0.000000e+00
%15 [48r,1456r:0)  0@48r weight:0.000000e+00
%16 [32r,1536r:0)  0@32r weight:0.000000e+00
%20 [16r,448r:0)  0@16r weight:0.000000e+00
%23 [96r,144r:1)[144r,176r:0)  0@144r 1@96r weight:0.000000e+00
%27 [256r,288r:0)  0@256r weight:0.000000e+00
%28 [304r,320r:0)[320r,352r:1)  0@304r 1@320r weight:0.000000e+00
%36 [768r,800r:2)[800r,832r:0)[832r,864r:1)  0@800r 1@832r 2@768r weight:0.000000e+00
%37 [912r,944r:0)  0@912r weight:0.000000e+00
%39 [960r,976r:2)[976r,1008r:0)[1008r,1040r:1)  0@976r 1@1008r 2@960r weight:0.000000e+00
%40 [1088r,1120r:0)  0@1088r weight:0.000000e+00
%42 [1504r,1616r:0)  0@1504r weight:0.000000e+00
%45 [1584r,1616r:2)[1616r,1648r:0)[1648r,1712r:1)  0@1616r 1@1648r 2@1584r weight:0.000000e+00
%50 [608r,1312B:0)  0@608r weight:0.000000e+00
%51 [592r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@592r 1@1184r 2@688B-phi weight:0.000000e+00
%52 [576r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@576r 1@1152r 2@688B-phi weight:0.000000e+00
%53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1712r:4)[1712r,1744r:5)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r 5@1712r weight:0.000000e+00
%54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1648r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:0.000000e+00
RegMasks: 368r 880r 1056r 1472r 1552r
********** MACHINEINSTRS **********
# Machine code for function _Z7simpsonPFddEddi: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.5(0x40000000); %bb.1(50.00%), %bb.5(50.00%)
	  liveins: $rdi, $xmm0, $xmm1, $esi
16B	  undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
32B	  %16:fr64 = COPY $xmm1
48B	  %15:fr64 = COPY $xmm0
64B	  %14:gr64 = COPY $rdi
96B	  undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
144B	  %23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
176B	  %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
208B	  %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
224B	  %1:fr64 = COPY %16:fr64
240B	  %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
256B	  %27:fr64 = CVTSI2SDrr %0:gr32
288B	  %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
304B	  %28:fr64 = COPY %1:fr64
320B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  $xmm0 = COPY %28:fr64
368B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
384B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  %53:fr64 = COPY $xmm0
432B	  %54:fr64 = FsFLD0SD
448B	  CMP32ri8 %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
464B	  JCC_1 %bb.1, 13, implicit killed $eflags

480B	bb.5:
	; predecessors: %bb.0
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

528B	  JMP_1 %bb.4

544B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

560B	  %54:fr64 = FsFLD0SD
576B	  %52:gr32 = MOV32ri 2
592B	  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
608B	  %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

688B	bb.2.for.body:
	; predecessors: %bb.1, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

768B	  %36:fr64 = CVTSI2SDrr %52:gr32
800B	  %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %1:fr64, implicit $mxcsr
832B	  %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $xmm0 = COPY %36:fr64
880B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %37:fr64 = COPY $xmm0
944B	  %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
960B	  %39:fr64 = COPY %1:fr64
976B	  %39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
1008B	  %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
1024B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $xmm0 = COPY %39:fr64
1056B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1088B	  %40:fr64 = COPY $xmm0
1120B	  %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %40:fr64, implicit $mxcsr
1152B	  %52:gr32 = nuw nsw ADD32ri8 %52:gr32(tied-def 0), 2, implicit-def dead $eflags
1184B	  %51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
1200B	  CMP32rr %52:gr32, %0:gr32, implicit-def $eflags
1280B	  JCC_1 %bb.2, 12, implicit killed $eflags
1296B	  JMP_1 %bb.3

1312B	bb.3.for.end.loopexit:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1344B	  %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %54:fr64, implicit $mxcsr

1392B	bb.4.for.end:
	; predecessors: %bb.3, %bb.5

1440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  $xmm0 = COPY %15:fr64
1472B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1488B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1504B	  %42:fr64 = COPY $xmm0
1520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1536B	  $xmm0 = COPY %16:fr64
1552B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1584B	  %45:fr64 = COPY $xmm0
1616B	  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
1648B	  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
1680B	  %53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1712B	  %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
1744B	  %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
1776B	  %1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1792B	  $xmm0 = COPY %1:fr64
1808B	  RET 0, $xmm0

# End machine code for function _Z7simpsonPFddEddi.

Before MISched:
# Machine code for function _Z7simpsonPFddEddi: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.5(0x40000000); %bb.1(50.00%), %bb.5(50.00%)
  liveins: $rdi, $xmm0, $xmm1, $esi
  undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
  %16:fr64 = COPY $xmm1
  %15:fr64 = COPY $xmm0
  %14:gr64 = COPY $rdi
  undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
  %23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
  %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
  %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
  %1:fr64 = COPY %16:fr64
  %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  %27:fr64 = CVTSI2SDrr %0:gr32
  %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
  %28:fr64 = COPY %1:fr64
  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %28:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %53:fr64 = COPY $xmm0
  %54:fr64 = FsFLD0SD
  CMP32ri8 %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
  JCC_1 %bb.1, 13, implicit killed $eflags

bb.5:
; predecessors: %bb.0
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  JMP_1 %bb.4

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %54:fr64 = FsFLD0SD
  %52:gr32 = MOV32ri 2
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %36:fr64 = CVTSI2SDrr %52:gr32
  %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %1:fr64, implicit $mxcsr
  %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %36:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:fr64 = COPY $xmm0
  %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  %39:fr64 = COPY %1:fr64
  %39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
  %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %39:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:fr64 = COPY $xmm0
  %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  %52:gr32 = nuw nsw ADD32ri8 %52:gr32(tied-def 0), 2, implicit-def dead $eflags
  %51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
  CMP32rr %52:gr32, %0:gr32, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit killed $eflags
  JMP_1 %bb.3

bb.3.for.end.loopexit:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %54:fr64, implicit $mxcsr

bb.4.for.end:
; predecessors: %bb.3, %bb.5

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %15:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %42:fr64 = COPY $xmm0
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %16:fr64
  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %45:fr64 = COPY $xmm0
  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
  %53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
  %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
  %1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  $xmm0 = COPY %1:fr64
  RET 0, $xmm0

# End machine code for function _Z7simpsonPFddEddi.

AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
AllocationOrder(GR16) = [ $ax $cx $dx $si $di $r8w $r9w $r10w $r11w $bx $bp $r14w $r15w $r12w $r13w ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
********** MI Scheduling **********
_Z7simpsonPFddEddi:%bb.0 entry
  From: %53:fr64 = COPY $xmm0
    To: JCC_1 %bb.1, 13, implicit killed $eflags
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(2) - ExitSU /  CMP32ri8 - JCC_1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %53:fr64 = COPY $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(2): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   %54:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Successors:
    SU(2): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   CMP32ri8 %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
  # preds left       : 2
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.1, 13, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) CMP32ri8 %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(1) %54:fr64 = FsFLD0SD
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %53:fr64 = COPY $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %53:fr64 = COPY $xmm0
SU(1):   %54:fr64 = FsFLD0SD
SU(2):   CMP32ri8 %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags

********** MI Scheduling **********
_Z7simpsonPFddEddi:%bb.0 entry
  From: undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 14
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP_with_GR32_SIDI=2
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=1
FR32=4
GR64_NOREX=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=4
GR16=6
Live In: DIL DIH HDI XMM0 XMM1 SIL SIH HSI 
Live Out: %28 %15 %1 %0 %16 %20 %14 
Live Thru: 
  LiveReg: %28
  LiveReg: %15
  UpdateRegP: SU(9) %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
              to 
  UpdateRegP: SU(13) %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
              to 
  LiveReg: %1
  UpdateRegP: SU(12) %28:fr64 = COPY %1:fr64
              to FR32 -1    FR32X -1
  LiveReg: %0
  UpdateRegP: SU(10) %27:fr64 = CVTSI2SDrr %0:gr32
              to FR32 -1    FR32X -1
  LiveReg: %16
  UpdateRegP: SU(8) %1:fr64 = COPY %16:fr64
              to FR32 -1    FR32X -1
  LiveReg: %20
  UpdateRegP: SU(4) undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
              to GR16 -2
  UpdateRegP: SU(6) %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
              to 
  LiveReg: %14
Top Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP_with_GR32_SIDI=2
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=1
FR32=2
GR64_NOREX=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=2
GR16=2
Bottom Pressure:
FR32=4
FR32X=4
GR16=6
AllocationOrder(TILECFG) = [ $tmmcfg ]
AllocationOrder(BNDR) = [ $bnd0 $bnd1 $bnd2 $bnd3 ]
AllocationOrder(SEGMENT_REG) = [ ]
AllocationOrder(GR32_BPSP) = [ $ebp ] (sub-class)
AllocationOrder(GR32_BPSP) = [ $ebp ] (sub-class)
AllocationOrder(GR32_BSI) = [ $esi $ebx ] (sub-class)
AllocationOrder(GR32_BSI) = [ $esi $ebx ] (sub-class)
AllocationOrder(GR32_DIBP) = [ $edi $ebp ] (sub-class)
AllocationOrder(GR32_DIBP) = [ $edi $ebp ] (sub-class)
AllocationOrder(RFP32) = [ $fp0 $fp1 $fp2 $fp3 $fp4 $fp5 $fp6 ]
AllocationOrder(GR8_ABCD_H) = [ $ah $ch $dh $bh ] (sub-class)
AllocationOrder(GR8_ABCD_L) = [ $al $cl $dl $bl ] (sub-class)
AllocationOrder(VK1) = [ $k0 $k1 $k2 $k3 $k4 $k5 $k6 $k7 ]
AllocationOrder(VR64) = [ $mm0 $mm1 $mm2 $mm3 $mm4 $mm5 $mm6 $mm7 ]
AllocationOrder(TILE) = [ $tmm0 $tmm1 $tmm2 $tmm3 $tmm4 $tmm5 $tmm6 $tmm7 ]
AllocationOrder(GR8_NOREX) = [ $al $cl $dl $bl ]
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
AllocationOrder(GR64_NOREX_and_GR64_TCW64) = [ $rax $rcx $rdx ] (sub-class)
AllocationOrder(GR64_NOREX_and_GR64_TCW64) = [ $rax $rcx $rdx ] (sub-class)
AllocationOrder(DEBUG_REG) = [ $dr0 $dr1 $dr2 $dr3 $dr4 $dr5 $dr6 $dr7 $dr8 $dr9 $dr10 $dr11 $dr12 $dr13 $dr14 $dr15 ]
AllocationOrder(FR32) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
AllocationOrder(CONTROL_REG) = [ $cr0 $cr1 $cr2 $cr3 $cr4 $cr5 $cr6 $cr7 $cr8 $cr9 $cr10 $cr11 $cr12 $cr13 $cr14 $cr15 ]
AllocationOrder(GR64_NOREX) = [ $rax $rcx $rdx $rsi $rdi $rbx $rbp ] (sub-class)
AllocationOrder(GR64_TCW64) = [ $rax $rcx $rdx $r8 $r9 $r10 $r11 ] (sub-class)
AllocationOrder(GR64_TCW64) = [ $rax $rcx $rdx $r8 $r9 $r10 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR64_TC) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR64_TC) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r11 ] (sub-class)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
AllocationOrder(FR32X) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
AllocationOrder(LOW32_ADDR_ACCESS_RBP) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d $rbp ]
Excess PSets: 
SU(0):   undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 32
  Successors:
    SU(6): Data Latency=0 Reg=%20
    SU(4): Data Latency=0 Reg=%20
  Pressure Diff      : GR32_BSI 1    GR32_SIDI 1    GR32_DIBP_with_GR32_SIDI 1    GR8_ABCD_H_with_GR32_BSI 1    GR8_ABCD_L_with_GR32_BSI 1    GR8_NOREX 1    GR64_NOREX 1    GR8 1    GR8_with_GR32_DIBP 1    GR8_with_GR32_BSI 1    GR64_TC_with_GR64_TCW64 1    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit 1    GR8_with_GR64_NOREX 1    GR64_TC 1    GR8_with_GR64_TCW64 1    GR8_with_GR64_TC 1
  Single Issue       : false;
SU(1):   %16:fr64 = COPY $xmm1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 27
  Successors:
    SU(8): Data Latency=0 Reg=%16
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %15:fr64 = COPY $xmm0
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 27
  Successors:
    SU(13): Data Latency=0 Reg=%15
    SU(9): Data Latency=0 Reg=%15
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %14:gr64 = COPY $rdi
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Pressure Diff      : GR32_BPSP 1    GR32_SIDI 1    GR32_DIBP_with_GR32_SIDI 1    GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit 1    GR64_NOREX 1    GR8 1    GR8_with_GR32_DIBP 1    GR8_with_GR32_BSI 1    GR64_TC_with_GR64_TCW64 1    GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit 1    GR8_with_GR64_NOREX 1    GR64_TC 1    GR8_with_GR64_TCW64 1    GR8_with_GR64_TC 1    GR16 -1
  Single Issue       : false;
SU(4):   undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 32
  Predecessors:
    SU(0): Data Latency=0 Reg=%20
  Successors:
    SU(5): Data Latency=1 Reg=%23
    SU(5): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(5):   %23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 31
  Predecessors:
    SU(4): Data Latency=1 Reg=%23
    SU(4): Out  Latency=0
  Successors:
    SU(6): Data Latency=1 Reg=%23
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 30
  Predecessors:
    SU(5): Data Latency=1 Reg=%23
    SU(0): Data Latency=0 Reg=%20
  Successors:
    SU(7): Data Latency=1 Reg=%0
    SU(7): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 29
  Predecessors:
    SU(6): Data Latency=1 Reg=%0
    SU(6): Out  Latency=0
  Successors:
    SU(10): Data Latency=1 Reg=%0
  Pressure Diff      : 
  Single Issue       : false;
SU(8):   %1:fr64 = COPY %16:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 27
  Predecessors:
    SU(1): Data Latency=0 Reg=%16
  Successors:
    SU(9): Data Latency=0 Reg=%1
    SU(9): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(9):   %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 27
  Predecessors:
    SU(8): Data Latency=0 Reg=%1
    SU(8): Out  Latency=0
    SU(2): Data Latency=0 Reg=%15
  Successors:
    SU(11): Data Latency=3 Reg=%1
    SU(11): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(10):   %27:fr64 = CVTSI2SDrr %0:gr32
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 28
  Predecessors:
    SU(7): Data Latency=1 Reg=%0
  Successors:
    SU(11): Data Latency=4 Reg=%27
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(11):   %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 22
  Depth              : 8
  Height             : 24
  Predecessors:
    SU(10): Data Latency=4 Reg=%27
    SU(9): Data Latency=3 Reg=%1
    SU(9): Out  Latency=0
  Successors:
    SU(12): Data Latency=22 Reg=%1
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(12):   %28:fr64 = COPY %1:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 30
  Height             : 2
  Predecessors:
    SU(11): Data Latency=22 Reg=%1
  Successors:
    SU(13): Data Latency=0 Reg=%28
    SU(13): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(13):   %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 30
  Height             : 2
  Predecessors:
    SU(12): Data Latency=0 Reg=%28
    SU(12): Out  Latency=0
    SU(2): Data Latency=0 Reg=%15
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 32
  Height             : 0
  Predecessors:
    SU(13): Ord  Latency=2 Artificial
Critical Path(GS-RR ): 32
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 13 
  Cand SU(3) ORDER                              
  Cand SU(13) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(13) %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=6
  LiveReg: %28
  UpdateRegP: SU(13) %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(13) 30c
  BotQ.A BotLatency SU(13) 2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 12 
  Cand SU(3) ORDER                              
  Cand SU(12) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(12) %28:fr64 = COPY %1:fr64
Bottom Pressure:
FR32=3
FR32X=3
GR16=6
  Ready @2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 11 
  Cand SU(3) ORDER                              
  Cand SU(11) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(11) %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=6
  LiveReg: %1
  UpdateRegP: SU(11) %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
              to 
  LiveReg: %27
  UpdateRegP: SU(11) %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @24c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(11) 24c
BotQ.A @0c
  Retired: 2
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 24c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 10 9 
  Cand SU(3) ORDER                              
  Cand SU(10) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(10) %27:fr64 = CVTSI2SDrr %0:gr32
Bottom Pressure:
FR32=3
FR32X=3
GR16=6
  Ready @28c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(10) 28c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 28c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 9 7 
  Cand SU(3) ORDER                              
  Cand SU(9) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(9) %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
Bottom Pressure:
FR32=3
FR32X=3
GR16=6
  LiveReg: %1
  UpdateRegP: SU(9) %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @27c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 5
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 28c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 7 8 2 
  Cand SU(3) ORDER                              
  Cand SU(7) PHYS-REG                           
  Cand SU(8) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(8) %1:fr64 = COPY %16:fr64
Bottom Pressure:
FR32=2
FR32X=2
GR16=6
  Ready @27c
BotQ.A @1c
  Retired: 5
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 28c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 7 2 1 
  Cand SU(3) ORDER                              
  Cand SU(7) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(7) %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=6
  LiveReg: %0
  UpdateRegP: SU(7) %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
              to GR16 -2
  Ready @29c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(7) 29c
BotQ.A @1c
  Retired: 6
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 29c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 2 6 
  Cand SU(3) ORDER                              
  Cand SU(6) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(6) %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
Bottom Pressure:
FR32=2
FR32X=2
GR16=6
  LiveReg: %23
  UpdateRegP: SU(6) %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
              to GR16 -2
  Ready @30c
  SBPort01 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(6) 30c
BotQ.A @1c
  Retired: 7
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 30c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 2 5 
  Cand SU(3) ORDER                              
  Cand SU(5) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(5) %23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=6
  LiveReg: %23
  UpdateRegP: SU(5) %23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
              to GR16 -2
  Ready @31c
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(5) 31c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 31c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 2 4 
  Cand SU(3) ORDER                              
  Cand SU(4) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(4) undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  Ready @32c
  SBPort01 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(4) 32c
BotQ.A @2c
  Retired: 9
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 32c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 1 2 0 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %14:gr64 = COPY $rdi
Bottom Pressure:
GR32_BPSP=1
GR32_SIDI=1
GR32_DIBP_with_GR32_SIDI=1
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
FR32=2
GR64_NOREX=1
GR8=1
GR8_with_GR32_DIBP=1
GR8_with_GR32_BSI=1
GR64_TC_with_GR64_TCW64=1
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_with_GR64_NOREX=1
GR64_TC=1
GR8_with_GR64_TCW64=1
GR8_with_GR64_TC=1
FR32X=2
GR16=3
  Ready @2c
BotQ.A @2c
  Retired: 9
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 32c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 2 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %15:fr64 = COPY $xmm0
Bottom Pressure:
GR32_BPSP=1
GR32_SIDI=1
GR32_DIBP_with_GR32_SIDI=1
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
FR32=2
GR64_NOREX=1
GR8=1
GR8_with_GR32_DIBP=1
GR8_with_GR32_BSI=1
GR64_TC_with_GR64_TCW64=1
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_with_GR64_NOREX=1
GR64_TC=1
GR8_with_GR64_TCW64=1
GR8_with_GR64_TC=1
FR32X=2
GR16=3
  Ready @27c
BotQ.A @2c
  Retired: 9
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 32c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %16:fr64 = COPY $xmm1
Bottom Pressure:
GR32_BPSP=1
GR32_SIDI=1
GR32_DIBP_with_GR32_SIDI=1
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
FR32=2
GR64_NOREX=1
GR8=1
GR8_with_GR32_DIBP=1
GR8_with_GR32_BSI=1
GR64_TC_with_GR64_TCW64=1
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_with_GR64_NOREX=1
GR64_TC=1
GR8_with_GR64_TCW64=1
GR8_with_GR64_TC=1
FR32X=2
GR16=3
  Ready @27c
BotQ.A @2c
  Retired: 9
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 32c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
Bottom Pressure:
GR32_BPSP=1
GR32_BSI=1
GR32_SIDI=2
GR32_DIBP_with_GR32_SIDI=2
GR32_DIBP_with_LOW32_ADDR_ACCESS_with_sub_32bit=1
GR8_ABCD_H_with_GR32_BSI=1
GR8_ABCD_L_with_GR32_BSI=1
GR8_NOREX=1
FR32=2
GR64_NOREX=2
GR8=2
GR8_with_GR32_DIBP=2
GR8_with_GR32_BSI=2
GR64_TC_with_GR64_TCW64=2
GR8_with_LOW32_ADDR_ACCESS_with_sub_32bit=2
GR8_with_GR64_NOREX=2
GR64_TC=2
GR8_with_GR64_TCW64=2
GR8_with_GR64_TC=2
FR32X=2
GR16=2
  Ready @32c
BotQ.A @2c
  Retired: 9
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 32c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
SU(1):   %16:fr64 = COPY $xmm1
SU(2):   %15:fr64 = COPY $xmm0
SU(3):   %14:gr64 = COPY $rdi
SU(4):   undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
SU(5):   %23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
SU(6):   %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
SU(7):   %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
SU(8):   %1:fr64 = COPY %16:fr64
SU(9):   %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
SU(10):   %27:fr64 = CVTSI2SDrr %0:gr32
SU(11):   %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
SU(12):   %28:fr64 = COPY %1:fr64
SU(13):   %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr

********** MI Scheduling **********
_Z7simpsonPFddEddi:%bb.1 for.body.preheader
  From: %54:fr64 = FsFLD0SD
    To: End RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %54:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %52:gr32 = MOV32ri 2
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(2):   %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
SU(3):   %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 3 2 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 5c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %52:gr32 = MOV32ri 2
  Ready @0c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %54:fr64 = FsFLD0SD
  Ready @0c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.1 ***
SU(0):   %54:fr64 = FsFLD0SD
SU(1):   %52:gr32 = MOV32ri 2
SU(2):   %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(3):   %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

********** MI Scheduling **********
_Z7simpsonPFddEddi:%bb.2 for.body
  From: %40:fr64 = COPY $xmm0
    To: JCC_1 %bb.2, 12, implicit killed $eflags
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(4) - ExitSU /  CMP32rr - JCC_1
  Bind SU(3) - SU(4)
  Bind SU(1) - SU(4)
SU(0):   %40:fr64 = COPY $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=0 Reg=%40
  Single Issue       : false;
SU(1):   %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 2
  Predecessors:
    SU(0): Data Latency=0 Reg=%40
  Successors:
    ExitSU: Ord  Latency=2 Artificial
    SU(4): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   %52:gr32 = nuw nsw ADD32ri8 %52:gr32(tied-def 0), 2, implicit-def dead $eflags
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%52
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(3):   %51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 2
  Successors:
    ExitSU: Ord  Latency=2 Artificial
    SU(4): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   CMP32rr %52:gr32, %0:gr32, implicit-def $eflags
  # preds left       : 4
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Data Latency=1 Reg=%52
    SU(2): Out  Latency=0
    SU(3): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.2, 12, implicit killed $eflags
  # preds left       : 3
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Artificial
    SU(3): Ord  Latency=2 Artificial
    SU(1): Ord  Latency=2 Artificial
    SU(4): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 2
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) CMP32rr %52:gr32, %0:gr32, implicit-def $eflags
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A TopLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 1 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 2c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %52:gr32 = nuw nsw ADD32ri8 %52:gr32(tied-def 0), 2, implicit-def dead $eflags
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %40:fr64 = COPY $xmm0
  Ready @2c
BotQ.A @1c
  Retired: 4
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %40:fr64 = COPY $xmm0
SU(1):   %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %40:fr64, implicit $mxcsr
SU(2):   %52:gr32 = nuw nsw ADD32ri8 %52:gr32(tied-def 0), 2, implicit-def dead $eflags
SU(3):   %51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
SU(4):   CMP32rr %52:gr32, %0:gr32, implicit-def $eflags

********** MI Scheduling **********
_Z7simpsonPFddEddi:%bb.2 for.body
  From: %37:fr64 = COPY $xmm0
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %37:fr64 = COPY $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=0 Reg=%37
  Single Issue       : false;
SU(1):   %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 2
  Predecessors:
    SU(0): Data Latency=0 Reg=%37
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Single Issue       : false;
SU(2):   %39:fr64 = COPY %1:fr64
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 7
  Successors:
    SU(3): Data Latency=0 Reg=%39
    SU(3): Out  Latency=0
  Single Issue       : false;
SU(3):   %39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 7
  Predecessors:
    SU(2): Data Latency=0 Reg=%39
    SU(2): Out  Latency=0
  Successors:
    SU(4): Data Latency=5 Reg=%39
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(3): Data Latency=5 Reg=%39
    SU(3): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=2 Artificial
    SU(1): Ord  Latency=2 Artificial
Critical Path(GS-RR ): 7
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 1 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(4) 5c
  BotQ.A BotLatency SU(4) 2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
  Ready @7c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 7c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %39:fr64 = COPY %1:fr64
  Ready @7c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %37:fr64 = COPY $xmm0
  Ready @2c
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %37:fr64 = COPY $xmm0
SU(1):   %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
SU(2):   %39:fr64 = COPY %1:fr64
SU(3):   %39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
SU(4):   %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr

********** MI Scheduling **********
_Z7simpsonPFddEddi:%bb.2 for.body
  From: %36:fr64 = CVTSI2SDrr %52:gr32
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %36:fr64 = CVTSI2SDrr %52:gr32
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 11
  Successors:
    SU(1): Data Latency=4 Reg=%36
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %1:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 4
  Height             : 7
  Predecessors:
    SU(0): Data Latency=4 Reg=%36
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=5 Reg=%36
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 9
  Height             : 2
  Predecessors:
    SU(1): Data Latency=5 Reg=%36
    SU(1): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 11
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=2 Artificial
Critical Path(GS-RR ): 11
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(2) 9c
  BotQ.A BotLatency SU(2) 2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %1:fr64, implicit $mxcsr
  Ready @7c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 7c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %36:fr64 = CVTSI2SDrr %52:gr32
  Ready @11c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(0) 11c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %36:fr64 = CVTSI2SDrr %52:gr32
SU(1):   %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %1:fr64, implicit $mxcsr
SU(2):   %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr

********** MI Scheduling **********
_Z7simpsonPFddEddi:%bb.4 for.end
  From: %45:fr64 = COPY $xmm0
    To: RET 0, $xmm0
 RegionInstrs: 8
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=5
FR32X=5
Live In: XMM0 %1 %53 %54 %42 
Live Out: 
Live Thru: 
Top Pressure:
FR32=5
FR32X=5
Bottom Pressure:
FR32=1
FR32X=1
Excess PSets: 
SU(0):   %45:fr64 = COPY $xmm0
  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 37
  Successors:
    SU(1): Data Latency=0 Reg=%45
    SU(1): Out  Latency=0
    SU(7): Anti Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(1):   %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 37
  Predecessors:
    SU(0): Data Latency=0 Reg=%45
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=3 Reg=%45
    SU(2): Out  Latency=0
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(2):   %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 3
  Height             : 34
  Predecessors:
    SU(1): Data Latency=3 Reg=%45
    SU(1): Out  Latency=0
  Successors:
    SU(4): Data Latency=3 Reg=%45
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(3):   %53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 11
  Depth              : 0
  Height             : 42
  Successors:
    SU(4): Data Latency=11 Reg=%53
    SU(4): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 11
  Height             : 31
  Predecessors:
    SU(2): Data Latency=3 Reg=%45
    SU(3): Out  Latency=0
    SU(3): Data Latency=11 Reg=%53
  Successors:
    SU(5): Data Latency=3 Reg=%53
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(5):   %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 14
  Height             : 28
  Predecessors:
    SU(4): Data Latency=3 Reg=%53
  Successors:
    SU(6): Data Latency=0 Reg=%1
    SU(6): Out  Latency=0
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(6):   %1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 28
  Depth              : 14
  Height             : 28
  Predecessors:
    SU(5): Data Latency=0 Reg=%1
    SU(5): Out  Latency=0
  Successors:
    SU(7): Data Latency=28 Reg=%1
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   $xmm0 = COPY %1:fr64
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 42
  Height             : 0
  Predecessors:
    SU(6): Data Latency=28 Reg=%1
    SU(0): Anti Latency=0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   RET 0, $xmm0
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 42
  Height             : 0
  Predecessors:
    SU(7): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 42
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) $xmm0 = COPY %1:fr64
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %1
  UpdateRegP: SU(7) $xmm0 = COPY %1:fr64
              to FR32 -1    FR32X -1
  Ready @0c
  BotQ.A TopLatency SU(7) 42c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) %1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
Bottom Pressure:
FR32=1
FR32X=1
  LiveReg: %1
  UpdateRegP: SU(6) %1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @28c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort23 +1x6u
  SBPort015 +1x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(6) 28c
BotQ.A @0c
  Retired: 2
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 28c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
Bottom Pressure:
FR32=2
FR32X=2
  LiveReg: %1
  UpdateRegP: SU(5) %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
              to 
  LiveReg: %53
  UpdateRegP: SU(5) %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @28c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 28c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %53
  UpdateRegP: SU(4) %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
              to 
  LiveReg: %45
  UpdateRegP: SU(4) %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @31c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(4) 31c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 31c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
Bottom Pressure:
FR32=3
FR32X=3
  LiveReg: %53
  UpdateRegP: SU(3) %53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
              to FR32 -1    FR32X -1
  Ready @42c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort23 +1x6u
  SBPort015 +1x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(3) 42c
BotQ.A @1c
  Retired: 6
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 42c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
  LiveReg: %45
  UpdateRegP: SU(2) %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
              to 
  LiveReg: %54
  UpdateRegP: SU(2) %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @34c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 7
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 42c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
Bottom Pressure:
FR32=5
FR32X=5
  LiveReg: %45
  UpdateRegP: SU(1) %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
              to 
  LiveReg: %42
  UpdateRegP: SU(1) %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @37c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 42c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %45:fr64 = COPY $xmm0
Bottom Pressure:
FR32=5
FR32X=5
  Ready @37c
BotQ.A @2c
  Retired: 8
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 42c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %45:fr64 = COPY $xmm0
SU(1):   %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
SU(2):   %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
SU(3):   %53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
SU(4):   %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
SU(5):   %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
SU(6):   %1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
SU(7):   $xmm0 = COPY %1:fr64

********** INTERVALS **********
DIL [0B,64r:0)  0@0B-phi
DIH [0B,64r:0)  0@0B-phi
HDI [0B,64r:0)  0@0B-phi
SIL [0B,16r:0)  0@0B-phi
SIH [0B,16r:0)  0@0B-phi
HSI [0B,16r:0)  0@0B-phi
XMM0 [0B,48r:0)[352r,368r:11)[368r,400r:10)[864r,880r:9)[880r,912r:8)[1040r,1056r:7)[1056r,1088r:6)[1456r,1472r:5)[1472r,1504r:4)[1536r,1552r:3)[1552r,1584r:2)[1792r,1808r:1)  0@0B-phi 1@1792r 2@1552r 3@1536r 4@1472r 5@1456r 6@1056r 7@1040r 8@880r 9@864r 10@368r 11@352r
XMM1 [0B,32r:0)  0@0B-phi
%0 [176r,208r:0)[208r,480B:1)[544B,1312B:1)  0@176r 1@208r weight:0.000000e+00
%1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:0.000000e+00
%14 [64r,1552r:0)  0@64r weight:0.000000e+00
%15 [48r,1456r:0)  0@48r weight:0.000000e+00
%16 [32r,1536r:0)  0@32r weight:0.000000e+00
%20 [16r,448r:0)  0@16r weight:0.000000e+00
%23 [96r,144r:1)[144r,176r:0)  0@144r 1@96r weight:0.000000e+00
%27 [256r,288r:0)  0@256r weight:0.000000e+00
%28 [304r,320r:0)[320r,352r:1)  0@304r 1@320r weight:0.000000e+00
%36 [768r,800r:2)[800r,832r:0)[832r,864r:1)  0@800r 1@832r 2@768r weight:0.000000e+00
%37 [912r,944r:0)  0@912r weight:0.000000e+00
%39 [960r,976r:2)[976r,1008r:0)[1008r,1040r:1)  0@976r 1@1008r 2@960r weight:0.000000e+00
%40 [1088r,1120r:0)  0@1088r weight:0.000000e+00
%42 [1504r,1616r:0)  0@1504r weight:0.000000e+00
%45 [1584r,1616r:2)[1616r,1648r:0)[1648r,1712r:1)  0@1616r 1@1648r 2@1584r weight:0.000000e+00
%50 [608r,1312B:0)  0@608r weight:0.000000e+00
%51 [592r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@592r 1@1184r 2@688B-phi weight:0.000000e+00
%52 [576r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@576r 1@1152r 2@688B-phi weight:0.000000e+00
%53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1712r:4)[1712r,1744r:5)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r 5@1712r weight:0.000000e+00
%54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1648r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:0.000000e+00
RegMasks: 368r 880r 1056r 1472r 1552r
********** MACHINEINSTRS **********
# Machine code for function _Z7simpsonPFddEddi: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 3.000000e+00, align=8
  cp#1: 2.000000e+00, align=8
  cp#2: 4.000000e+00, align=8
Function Live Ins: $rdi in %14, $xmm0 in %15, $xmm1 in %16, $esi in %17

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.5(0x40000000); %bb.1(50.00%), %bb.5(50.00%)
	  liveins: $rdi, $xmm0, $xmm1, $esi
16B	  undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
32B	  %16:fr64 = COPY $xmm1
48B	  %15:fr64 = COPY $xmm0
64B	  %14:gr64 = COPY $rdi
96B	  undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
144B	  %23.sub_32bit:gr64_nosp = SHR32ri %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
176B	  %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, %23:gr64_nosp, 1, $noreg
208B	  %0:gr32 = AND32ri8 %0:gr32(tied-def 0), -2, implicit-def dead $eflags
224B	  %1:fr64 = COPY %16:fr64
240B	  %1:fr64 = nofpexcept SUBSDrr %1:fr64(tied-def 0), %15:fr64, implicit $mxcsr
256B	  %27:fr64 = CVTSI2SDrr %0:gr32
288B	  %1:fr64 = nofpexcept DIVSDrr %1:fr64(tied-def 0), %27:fr64, implicit $mxcsr
304B	  %28:fr64 = COPY %1:fr64
320B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %15:fr64, implicit $mxcsr
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  $xmm0 = COPY %28:fr64
368B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
384B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  %53:fr64 = COPY $xmm0
432B	  %54:fr64 = FsFLD0SD
448B	  CMP32ri8 %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
464B	  JCC_1 %bb.1, 13, implicit killed $eflags

480B	bb.5:
	; predecessors: %bb.0
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

528B	  JMP_1 %bb.4

544B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

560B	  %54:fr64 = FsFLD0SD
576B	  %52:gr32 = MOV32ri 2
592B	  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
608B	  %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)

688B	bb.2.for.body:
	; predecessors: %bb.1, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

768B	  %36:fr64 = CVTSI2SDrr %52:gr32
800B	  %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %1:fr64, implicit $mxcsr
832B	  %36:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %15:fr64, implicit $mxcsr
848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $xmm0 = COPY %36:fr64
880B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %37:fr64 = COPY $xmm0
944B	  %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
960B	  %39:fr64 = COPY %1:fr64
976B	  %39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
1008B	  %39:fr64 = nofpexcept ADDSDrr %39:fr64(tied-def 0), %15:fr64, implicit $mxcsr
1024B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $xmm0 = COPY %39:fr64
1056B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1088B	  %40:fr64 = COPY $xmm0
1120B	  %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %40:fr64, implicit $mxcsr
1152B	  %52:gr32 = nuw nsw ADD32ri8 %52:gr32(tied-def 0), 2, implicit-def dead $eflags
1184B	  %51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
1200B	  CMP32rr %52:gr32, %0:gr32, implicit-def $eflags
1280B	  JCC_1 %bb.2, 12, implicit killed $eflags
1296B	  JMP_1 %bb.3

1312B	bb.3.for.end.loopexit:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1344B	  %54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %54:fr64, implicit $mxcsr

1392B	bb.4.for.end:
	; predecessors: %bb.3, %bb.5

1440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  $xmm0 = COPY %15:fr64
1472B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1488B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1504B	  %42:fr64 = COPY $xmm0
1520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1536B	  $xmm0 = COPY %16:fr64
1552B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1584B	  %45:fr64 = COPY $xmm0
1616B	  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %42:fr64, implicit $mxcsr
1648B	  %45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
1680B	  %53:fr64 = nofpexcept MULSDrm %53:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1712B	  %53:fr64 = nofpexcept ADDSDrr %53:fr64(tied-def 0), %45:fr64, implicit $mxcsr
1744B	  %1:fr64 = nofpexcept MULSDrr %1:fr64(tied-def 0), %53:fr64, implicit $mxcsr
1776B	  %1:fr64 = nofpexcept DIVSDrm %1:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1792B	  $xmm0 = COPY %1:fr64
1808B	  RET 0, $xmm0

# End machine code for function _Z7simpsonPFddEddi.


block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB5
 - 2: BB1[for.body.preheader]
 - 3: BB2[for.body]
 - 4: BB3[for.end.loopexit]
 - 5: BB4[for.end]
loop-detection
 - loop = BB2[for.body]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB3[for.end.loopexit]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.end.loopexit]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB5
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB5
  => assign 8000000000000000 (0000000000000000) to BB1[for.body.preheader]
 - node: BB5
  => [ local  ] weight = 2147483648, succ = BB4[for.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.end]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.end.loopexit]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB3[for.end.loopexit]
 - node: BB3[for.end.loopexit]
  => [ local  ] weight = 2147483648, succ = BB4[for.end]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[for.end]
 - node: BB4[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[for.body]*: mass = 8000000000000000, scale = 32.0
  => combined-scale = 16.0
 - BB2[for.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB5: float = 0.5, scaled = 8.0, int = 8
 - BB1[for.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB2[for.body]: float = 16.0, scaled = 256.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, scaled = 8.0, int = 8
 - BB4[for.end]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - BB0[entry]: float = 1.0, int = 16
 - BB5: float = 0.5, int = 8
 - BB1[for.body.preheader]: float = 0.5, int = 8
 - BB2[for.body]: float = 16.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, int = 8
 - BB4[for.end]: float = 1.0, int = 16

********** BASIC REGISTER ALLOCATION **********
********** Function: _Z7simpsonPFddEddi
********** Compute Spill Weights **********
********** Function: _Z7simpsonPFddEddi
VirtReg:23-> 0(group: GR64_NOSP)
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
AllocationOrder(GR64_NOSP) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
0 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:40-> 1(group: FR64)
AllocationOrder(FR64) = [ $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 ]
hints: $xmm0
1 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:27-> 2(group: FR64)
2 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:37-> 3(group: FR64)
hints: $xmm0
3 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:39-> 4(group: FR64)
hints: $xmm0
4 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:36-> 5(group: FR64)
hints: $xmm0
5 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:52-> 6(group: GR32)
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d ]
6 can be allocatable among $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:51-> 7(group: FR64)
7 can be allocatable among 
VirtReg:54-> 8(group: FR64)
8 can be allocatable among 
VirtReg:53-> 9(group: FR64)
hints: $xmm0
9 can be allocatable among 
VirtReg:1-> 10(group: FR64)
hints: $xmm0
10 can be allocatable among 
VirtReg:15-> 11(group: FR64)
hints: $xmm0
11 can be allocatable among 
VirtReg:14-> 12(group: GR64)
hints: $rdi
12 can be allocatable among $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:0-> 13(group: GR32)
13 can be allocatable among $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:45-> 14(group: FR64)
hints: $xmm0
14 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:28-> 15(group: FR64)
hints: $xmm0
15 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:50-> 16(group: FR64)
16 can be allocatable among 
VirtReg:20-> 17(group: GR64_with_sub_8bit)
AllocationOrder(GR64_with_sub_8bit) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp ]
hints: $rsi
17 can be allocatable among $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:42-> 18(group: FR64)
hints: $xmm0
18 can be allocatable among 
VirtReg:16-> 19(group: FR64)
hints: $xmm0 $xmm1
19 can be allocatable among 
test!!! regcount = 20

selectOrSplit GR64_NOSP:%23 [96r,144r:1)[144r,176r:0)  0@144r 1@96r weight:INF w=INF
assigning %23 to $rax: AH [96r,144r:1)[144r,176r:0)  0@144r 1@96r AL [96r,144r:1)[144r,176r:0)  0@144r 1@96r HAX [96r,144r:1)[144r,176r:0)  0@144r 1@96r

selectOrSplit FR64:%40 [1088r,1120r:0)  0@1088r weight:INF w=INF
hints: $xmm0
assigning %40 to $xmm0: XMM0 [1088r,1120r:0)  0@1088r

selectOrSplit FR64:%27 [256r,288r:0)  0@256r weight:INF w=INF
assigning %27 to $xmm0: XMM0 [256r,288r:0)  0@256r

selectOrSplit FR64:%37 [912r,944r:0)  0@912r weight:INF w=INF
hints: $xmm0
assigning %37 to $xmm0: XMM0 [912r,944r:0)  0@912r

selectOrSplit FR64:%39 [960r,976r:2)[976r,1008r:0)[1008r,1040r:1)  0@976r 1@1008r 2@960r weight:2.012109e-01 w=2.012109e-01
hints: $xmm0
assigning %39 to $xmm0: XMM0 [960r,976r:2)[976r,1008r:0)[1008r,1040r:1)  0@976r 1@1008r 2@960r

selectOrSplit FR64:%36 [768r,800r:2)[800r,832r:0)[832r,864r:1)  0@800r 1@832r 2@768r weight:1.947203e-01 w=1.947203e-01
hints: $xmm0
assigning %36 to $xmm0: XMM0 [768r,800r:2)[800r,832r:0)[832r,864r:1)  0@800r 1@832r 2@768r

selectOrSplit GR32:%52 [576r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@576r 1@1152r 2@688B-phi weight:1.128748e-01 w=1.128748e-01
assigning %52 to $ebx: BH [576r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@576r 1@1152r 2@688B-phi BL [576r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@576r 1@1152r 2@688B-phi HBX [576r,688B:0)[688B,1152r:2)[1152r,1312B:1)  0@576r 1@1152r 2@688B-phi

selectOrSplit FR64:%51 [592r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@592r 1@1184r 2@688B-phi weight:1.002348e-01 w=1.002348e-01
51-> 36, 37, 39, 40, 
spilling: %51 [592r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@592r 1@1184r 2@688B-phi weight:1.002348e-01
Inline spilling FR64:%51 [592r,688B:0)[688B,1184r:2)[1184r,1312B:1)  0@592r 1@1184r 2@688B-phi weight:1.002348e-01
From original %51
	cannot remat for 1184e	%51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
	cannot remat for 976e	%39:fr64 = nofpexcept MULSDrr %39:fr64(tied-def 0), %51:fr64, implicit $mxcsr
	cannot remat for 1184e	%51:fr64 = ADDSDrr %51:fr64(tied-def 0), %50:fr64, implicit $mxcsr
Merged spilled regs: SS#0 [592r,1312B:0)  0@x weight:0.000000e+00
spillAroundUses %51
	rewrite: 592r	%58:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

	spill:   600r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %58:fr64 :: (store 8 into %stack.0)
	reload:   1160r	%59:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
	rewrite: 1184r	%59:fr64 = ADDSDrr %59:fr64(tied-def 0), %50:fr64, implicit $mxcsr

	spill:   1192r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %59:fr64 :: (store 8 into %stack.0)
	folded:   976r	%39:fr64 = nofpexcept MULSDrm %39:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
queuing new interval: %58 [592r,600r:0)  0@592r weight:INF
queuing new interval: %59 [1160r,1184r:1)[1184r,1192r:0)  0@1184r 1@1160r weight:INF

selectOrSplit FR64:%58 [592r,600r:0)  0@592r weight:INF w=INF
assigning %58 to $xmm0: XMM0 [592r,600r:0)  0@592r

selectOrSplit FR64:%59 [1160r,1184r:1)[1184r,1192r:0)  0@1184r 1@1160r weight:INF w=INF
assigning %59 to $xmm0: XMM0 [1160r,1184r:1)[1184r,1192r:0)  0@1184r 1@1160r

selectOrSplit FR64:%54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1648r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:6.203066e-02 w=6.203066e-02
54-> 58, 36, 37, 39, 40, 59, 
spilling: %54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1648r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:6.203066e-02
Inline spilling FR64:%54 [432r,544B:4)[560r,688B:0)[688B,944r:2)[944r,1344r:1)[1344r,1392B:3)[1392B,1648r:5)  0@560r 1@944r 2@688B-phi 3@1344r 4@432r 5@1392B-phi weight:6.203066e-02
From original %54
	cannot remat for 1344e	%54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %54:fr64, implicit $mxcsr
	cannot remat for 944e	%54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %37:fr64, implicit $mxcsr
	cannot remat for 1344e	%54:fr64 = nofpexcept ADDSDrr %54:fr64(tied-def 0), %54:fr64, implicit $mxcsr
	cannot remat for 1648e	%45:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), %54:fr64, implicit $mxcsr
Merged spilled regs: SS#1 [432r,544B:0)[560r,1648r:0)  0@x weight:0.000000e+00
spillAroundUses %54
	rewrite: 432r	%60:fr64 = FsFLD0SD

	spill:   440r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %60:fr64 :: (store 8 into %stack.1)
	reload:   1320r	%61:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
	rewrite: 1344r	%61:fr64 = nofpexcept ADDSDrr %61:fr64(tied-def 0), killed %61:fr64, implicit $mxcsr

	spill:   1352r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %61:fr64 :: (store 8 into %stack.1)
	rewrite: 560r	%62:fr64 = FsFLD0SD

	spill:   568r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %62:fr64 :: (store 8 into %stack.1)
	reload:   920r	%63:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
	rewrite: 944r	%63:fr64 = nofpexcept ADDSDrr %63:fr64(tied-def 0), %37:fr64, implicit $mxcsr

	spill:   952r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %63:fr64 :: (store 8 into %stack.1)
	folded:   1648r	%45:fr64 = nofpexcept ADDSDrm %45:fr64(tied-def 0), %stack.1, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
queuing new interval: %60 [432r,440r:0)  0@432r weight:INF
queuing new interval: %61 [1320r,1344r:1)[1344r,1352r:0)  0@1344r 1@1320r weight:INF
queuing new interval: %62 [560r,568r:0)  0@560r weight:INF
queuing new interval: %63 [920r,944r:1)[944r,952r:0)  0@944r 1@920r weight:INF

selectOrSplit FR64:%60 [432r,440r:0)  0@432r weight:INF w=INF
assigning %60 to $xmm0: XMM0 [432r,440r:0)  0@432r

selectOrSplit FR64:%61 [1320r,1344r:1)[1344r,1352r:0)  0@1344r 1@1320r weight:INF w=INF
assigning %61 to $xmm0: XMM0 [1320r,1344r:1)[1344r,1352r:0)  0@1344r 1@1320r

selectOrSplit FR64:%62 [560r,568r:0)  0@560r weight:INF w=INF
assigning %62 to $xmm0: XMM0 [560r,568r:0)  0@560r

selectOrSplit FR64:%63 [920r,944r:1)[944r,952r:0)  0@944r 1@920r weight:INF w=INF
63-> 37, 
assigning %63 to $xmm1: XMM1 [920r,944r:1)[944r,952r:0)  0@944r 1@920r

selectOrSplit FR64:%53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1712r:4)[1712r,1744r:5)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r 5@1712r weight:5.885393e-02 w=5.885393e-02
hints: $xmm0
53-> 60, 62, 58, 36, 37, 39, 40, 59, 61, 
53-> 63, 
spilling: %53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1712r:4)[1712r,1744r:5)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r 5@1712r weight:5.885393e-02
Inline spilling FR64:%53 [400r,688B:0)[688B,1120r:2)[1120r,1392B:1)[1392B,1680r:3)[1680r,1712r:4)[1712r,1744r:5)  0@400r 1@1120r 2@688B-phi 3@1392B-phi 4@1680r 5@1712r weight:5.885393e-02
From original %53
Merged spilled regs: SS#2 [400r,1744r:0)  0@x weight:0.000000e+00
spillAroundUses %53
	reload:   1688r	%64:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
	rewrite: 1712r	%64:fr64 = nofpexcept ADDSDrr %64:fr64(tied-def 0), %45:fr64, implicit $mxcsr

	spill:   1720r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %64:fr64 :: (store 8 into %stack.2)
	reload:   1656r	%65:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
	rewrite: 1680r	%65:fr64 = nofpexcept MULSDrm %65:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)

	spill:   1684r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %65:fr64 :: (store 8 into %stack.2)
	folded:   400r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.2)
	reload:   1096r	%66:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
	rewrite: 1120r	%66:fr64 = nofpexcept ADDSDrr %66:fr64(tied-def 0), %40:fr64, implicit $mxcsr

	spill:   1128r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %66:fr64 :: (store 8 into %stack.2)
	folded:   1744r	%1:fr64 = nofpexcept MULSDrm %1:fr64(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
queuing new interval: %64 [1688r,1712r:1)[1712r,1720r:0)  0@1712r 1@1688r weight:INF
queuing new interval: %65 [1656r,1680r:1)[1680r,1684r:0)  0@1680r 1@1656r weight:INF
queuing new interval: %66 [1096r,1120r:1)[1120r,1128r:0)  0@1120r 1@1096r weight:INF

selectOrSplit FR64:%64 [1688r,1712r:1)[1712r,1720r:0)  0@1712r 1@1688r weight:INF w=INF
assigning %64 to $xmm0: XMM0 [1688r,1712r:1)[1712r,1720r:0)  0@1712r 1@1688r

selectOrSplit FR64:%65 [1656r,1680r:1)[1680r,1684r:0)  0@1680r 1@1656r weight:INF w=INF
assigning %65 to $xmm0: XMM0 [1656r,1680r:1)[1680r,1684r:0)  0@1680r 1@1656r

selectOrSplit FR64:%66 [1096r,1120r:1)[1120r,1128r:0)  0@1120r 1@1096r weight:INF w=INF
66-> 40, 
assigning %66 to $xmm1: XMM1 [1096r,1120r:1)[1120r,1128r:0)  0@1120r 1@1096r

selectOrSplit FR64:%1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:2.200394e-02 w=2.200394e-02
hints: $xmm0
1-> 27, 60, 62, 58, 36, 37, 39, 40, 59, 61, 65, 64, 
1-> 63, 66, 
spilling: %1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:2.200394e-02
Inline spilling FR64:%1 [224r,240r:2)[240r,288r:0)[288r,1744r:1)[1744r,1776r:3)[1776r,1792r:4)  0@240r 1@288r 2@224r 3@1744r 4@1776r weight:2.200394e-02
From original %1
Merged spilled regs: SS#3 [224r,1792r:0)  0@x weight:0.000000e+00
spillAroundUses %1
	reload:   1724r	%67:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	rewrite: 1744r	%67:fr64 = nofpexcept MULSDrm %67:fr64(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)

	spill:   1752r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %67:fr64 :: (store 8 into %stack.3)
	reload:   1756r	%68:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	rewrite: 1776r	%68:fr64 = nofpexcept DIVSDrm %68:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)

	spill:   1784r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %68:fr64 :: (store 8 into %stack.3)
	reload:   232r	%69:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	rewrite: 240r	%69:fr64 = nofpexcept SUBSDrr %69:fr64(tied-def 0), %15:fr64, implicit $mxcsr

	spill:   248r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %69:fr64 :: (store 8 into %stack.3)
	folded:   224r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, %16:fr64 :: (store 8 into %stack.3)
	reload:   264r	%70:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	rewrite: 288r	%70:fr64 = nofpexcept DIVSDrr %70:fr64(tied-def 0), %27:fr64, implicit $mxcsr

	spill:   296r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %70:fr64 :: (store 8 into %stack.3)
	folded:   304r	%28:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	folded:   800r	%36:fr64 = nofpexcept MULSDrm %36:fr64(tied-def 0), %stack.3, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
	folded:   960r	%39:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	folded:   1792r	$xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
queuing new interval: %67 [1724r,1744r:1)[1744r,1752r:0)  0@1744r 1@1724r weight:INF
queuing new interval: %68 [1756r,1776r:1)[1776r,1784r:0)  0@1776r 1@1756r weight:INF
queuing new interval: %69 [232r,240r:1)[240r,248r:0)  0@240r 1@232r weight:INF
queuing new interval: %70 [264r,288r:1)[288r,296r:0)  0@288r 1@264r weight:INF

selectOrSplit FR64:%67 [1724r,1744r:1)[1744r,1752r:0)  0@1744r 1@1724r weight:INF w=INF
assigning %67 to $xmm0: XMM0 [1724r,1744r:1)[1744r,1752r:0)  0@1744r 1@1724r

selectOrSplit FR64:%69 [232r,240r:1)[240r,248r:0)  0@240r 1@232r weight:INF w=INF
assigning %69 to $xmm0: XMM0 [232r,240r:1)[240r,248r:0)  0@240r 1@232r

selectOrSplit FR64:%70 [264r,288r:1)[288r,296r:0)  0@288r 1@264r weight:INF w=INF
70-> 27, 
assigning %70 to $xmm1: XMM1 [264r,288r:1)[288r,296r:0)  0@288r 1@264r

selectOrSplit FR64:%68 [1756r,1776r:1)[1776r,1784r:0)  0@1776r 1@1756r weight:INF w=INF
assigning %68 to $xmm0: XMM0 [1756r,1776r:1)[1776r,1784r:0)  0@1776r 1@1756r

selectOrSplit FR64:%15 [48r,1456r:0)  0@48r weight:2.004079e-02 w=2.004079e-02
hints: $xmm0
15-> 69, 27, 60, 62, 58, 36, 37, 39, 40, 59, 61, 
15-> 70, 63, 66, 
spilling: %15 [48r,1456r:0)  0@48r weight:2.004079e-02
Inline spilling FR64:%15 [48r,1456r:0)  0@48r weight:2.004079e-02
From original %15
Merged spilled regs: SS#4 [48r,1456r:0)  0@x weight:0.000000e+00
spillAroundUses %15
	folded:   48r	MOVSDmr %stack.4, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.4)
	folded:   240r	%69:fr64 = nofpexcept SUBSDrm %69:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
	folded:   1456r	$xmm0 = MOVSDrm_alt %stack.4, 1, $noreg, 0, $noreg :: (load 8 from %stack.4)
	folded:   320r	%28:fr64 = nofpexcept ADDSDrm %28:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
	folded:   832r	%36:fr64 = nofpexcept ADDSDrm %36:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
	folded:   1008r	%39:fr64 = nofpexcept ADDSDrm %39:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)

selectOrSplit GR64:%14 [64r,1552r:0)  0@64r weight:1.919160e-02 w=1.919160e-02
hints: $rdi
14-> 23, 
14-> 23, 
14-> 23, 
14-> 52, 
14-> 52, 
14-> 52, 
assigning %14 to $r14: R14B [64r,1552r:0)  0@64r R14BH [64r,1552r:0)  0@64r R14WH [64r,1552r:0)  0@64r

selectOrSplit GR32:%0 [176r,208r:0)[208r,480B:1)[544B,1312B:1)  0@176r 1@208r weight:1.356293e-02 w=1.356293e-02
0-> 52, 
0-> 52, 
0-> 52, 
assigning %0 to $ebp: BPL [176r,208r:0)[208r,480B:1)[544B,1312B:1)  0@176r 1@208r BPH [176r,208r:0)[208r,480B:1)[544B,1312B:1)  0@176r 1@208r HBP [176r,208r:0)[208r,480B:1)[544B,1312B:1)  0@176r 1@208r

selectOrSplit FR64:%45 [1584r,1616r:2)[1616r,1648r:0)[1648r,1712r:1)  0@1616r 1@1648r 2@1584r weight:1.147727e-02 w=1.147727e-02
hints: $xmm0
45-> 65, 64, 
assigning %45 to $xmm1: XMM1 [1584r,1616r:2)[1616r,1648r:0)[1648r,1712r:1)  0@1616r 1@1648r 2@1584r

selectOrSplit FR64:%28 [304r,320r:0)[320r,352r:1)  0@304r 1@320r weight:9.017857e-03 w=9.017857e-03
hints: $xmm0
assigning %28 to $xmm0: XMM0 [304r,320r:0)[320r,352r:1)  0@304r 1@320r

selectOrSplit FR64:%50 [608r,1312B:0)  0@608r weight:7.458031e-03 w=7.458031e-03
50-> 36, 37, 39, 40, 59, 
50-> 63, 66, 
spilling: %50 [608r,1312B:0)  0@608r weight:7.458031e-03
Inline spilling FR64:%50 [608r,1312B:0)  0@608r weight:7.458031e-03
From original %50
	folded:   1184r	%59:fr64 = ADDSDrm %59:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
All defs dead: dead %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 608r	dead %50:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.

selectOrSplit GR64_with_sub_8bit:%20 [16r,448r:0)  0@16r weight:4.855769e-03 w=4.855769e-03
hints: $rsi
20-> 23, 
20-> 23, 
20-> 23, 
assigning %20 to $rbx: BH [16r,448r:0)  0@16r BL [16r,448r:0)  0@16r HBX [16r,448r:0)  0@16r

selectOrSplit FR64:%42 [1504r,1616r:0)  0@1504r weight:3.945312e-03 w=3.945312e-03
hints: $xmm0
42-> 45, 
spilling: %42 [1504r,1616r:0)  0@1504r weight:3.945312e-03
Inline spilling FR64:%42 [1504r,1616r:0)  0@1504r weight:3.945312e-03
From original %42
Merged spilled regs: SS#5 [1504r,1616r:0)  0@x weight:0.000000e+00
spillAroundUses %42
	folded:   1504r	MOVSDmr %stack.5, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.5)
	folded:   1616r	%45:fr64 = nofpexcept ADDSDrm %45:fr64(tied-def 0), %stack.5, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.5)

selectOrSplit FR64:%16 [32r,1536r:0)  0@32r weight:1.591387e-03 w=1.591387e-03
hints: $xmm0 $xmm1
16-> 69, 27, 28, 60, 62, 58, 36, 37, 39, 40, 59, 61, 
16-> 70, 63, 66, 
spilling: %16 [32r,1536r:0)  0@32r weight:1.591387e-03
Inline spilling FR64:%16 [32r,1536r:0)  0@32r weight:1.591387e-03
From original %16
Merged spilled regs: SS#6 [32r,1536r:0)  0@x weight:0.000000e+00
spillAroundUses %16
	folded:   32r	MOVSDmr %stack.6, 1, $noreg, 0, $noreg, $xmm1 :: (store 8 into %stack.6)
	folded:   1536r	$xmm0 = MOVSDrm_alt %stack.6, 1, $noreg, 0, $noreg :: (load 8 from %stack.6)
	reload:   216r	%72:fr64 = MOVSDrm_alt %stack.6, 1, $noreg, 0, $noreg :: (load 8 from %stack.6)
	rewrite: 224r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %72:fr64 :: (store 8 into %stack.3)

queuing new interval: %72 [216r,224r:0)  0@216r weight:INF

selectOrSplit FR64:%72 [216r,224r:0)  0@216r weight:INF w=INF
assigning %72 to $xmm0: XMM0 [216r,224r:0)  0@216r

For Slot0 and VN0:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot0 and VN1:
Equal spills in BB: 2 
Orders size is 1
BB2,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN4:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN3:
Equal spills in BB: 3 
Orders size is 1
BB3,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN0:
Equal spills in BB: 1 
Orders size is 1
BB1,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN1:
Equal spills in BB: 2 
Orders size is 1
BB2,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN5:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN4:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN1:
Equal spills in BB: 2 
Orders size is 1
BB2,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN3:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN4:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN2:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN1:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot4 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot5 and VN0:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot6 and VN0:
Equal spills in BB: 0 
Orders size is 1
BB0,
Finally inserted spills in BB: 
Finally removed spills in BB: 
Post alloc VirtRegMap:
********** REGISTER MAP **********
[%0 -> $ebp] GR32
[%14 -> $r14] GR64
[%20 -> $rbx] GR64_with_sub_8bit
[%23 -> $rax] GR64_NOSP
[%27 -> $xmm0] FR64
[%28 -> $xmm0] FR64
[%36 -> $xmm0] FR64
[%37 -> $xmm0] FR64
[%39 -> $xmm0] FR64
[%40 -> $xmm0] FR64
[%45 -> $xmm1] FR64
[%52 -> $ebx] GR32
[%58 -> $xmm0] FR64
[%59 -> $xmm0] FR64
[%60 -> $xmm0] FR64
[%61 -> $xmm0] FR64
[%62 -> $xmm0] FR64
[%63 -> $xmm1] FR64
[%64 -> $xmm0] FR64
[%65 -> $xmm0] FR64
[%66 -> $xmm1] FR64
[%67 -> $xmm0] FR64
[%68 -> $xmm0] FR64
[%69 -> $xmm0] FR64
[%70 -> $xmm1] FR64
[%72 -> $xmm0] FR64
[%1 -> fi#3] FR64
[%15 -> fi#4] FR64
[%16 -> fi#6] FR64
[%42 -> fi#5] FR64
[%51 -> fi#0] FR64
[%53 -> fi#2] FR64
[%54 -> fi#1] FR64


********** REWRITE VIRTUAL REGISTERS **********
********** Function: _Z7simpsonPFddEddi
********** REGISTER MAP **********
[%0 -> $ebp] GR32
[%14 -> $r14] GR64
[%20 -> $rbx] GR64_with_sub_8bit
[%23 -> $rax] GR64_NOSP
[%27 -> $xmm0] FR64
[%28 -> $xmm0] FR64
[%36 -> $xmm0] FR64
[%37 -> $xmm0] FR64
[%39 -> $xmm0] FR64
[%40 -> $xmm0] FR64
[%45 -> $xmm1] FR64
[%52 -> $ebx] GR32
[%58 -> $xmm0] FR64
[%59 -> $xmm0] FR64
[%60 -> $xmm0] FR64
[%61 -> $xmm0] FR64
[%62 -> $xmm0] FR64
[%63 -> $xmm1] FR64
[%64 -> $xmm0] FR64
[%65 -> $xmm0] FR64
[%66 -> $xmm1] FR64
[%67 -> $xmm0] FR64
[%68 -> $xmm0] FR64
[%69 -> $xmm0] FR64
[%70 -> $xmm1] FR64
[%72 -> $xmm0] FR64
[%1 -> fi#3] FR64
[%15 -> fi#4] FR64
[%16 -> fi#6] FR64
[%42 -> fi#5] FR64
[%51 -> fi#0] FR64
[%53 -> fi#2] FR64
[%54 -> fi#1] FR64

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.5(0x40000000); %bb.1(50.00%), %bb.5(50.00%)
	  liveins: $esi, $rdi, $xmm0, $xmm1
16B	  undef %20.sub_32bit:gr64_with_sub_8bit = COPY $esi
32B	  MOVSDmr %stack.6, 1, $noreg, 0, $noreg, $xmm1 :: (store 8 into %stack.6)
48B	  MOVSDmr %stack.4, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.4)
64B	  %14:gr64 = COPY $rdi
96B	  undef %23.sub_32bit:gr64_nosp = LEA64_32r %20:gr64_with_sub_8bit, 1, $noreg, 1, $noreg
144B	  %23.sub_32bit:gr64_nosp = SHR32ri killed %23.sub_32bit:gr64_nosp(tied-def 0), 31, implicit-def dead $eflags
176B	  %0:gr32 = LEA64_32r %20:gr64_with_sub_8bit, 1, killed %23:gr64_nosp, 1, $noreg
208B	  %0:gr32 = AND32ri8 killed %0:gr32(tied-def 0), -2, implicit-def dead $eflags
216B	  %72:fr64 = MOVSDrm_alt %stack.6, 1, $noreg, 0, $noreg :: (load 8 from %stack.6)
224B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %72:fr64 :: (store 8 into %stack.3)
232B	  %69:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
240B	  %69:fr64 = nofpexcept SUBSDrm killed %69:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
248B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %69:fr64 :: (store 8 into %stack.3)
256B	  %27:fr64 = CVTSI2SDrr %0:gr32
264B	  %70:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
288B	  %70:fr64 = nofpexcept DIVSDrr killed %70:fr64(tied-def 0), killed %27:fr64, implicit $mxcsr
296B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %70:fr64 :: (store 8 into %stack.3)
304B	  %28:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
320B	  %28:fr64 = nofpexcept ADDSDrm killed %28:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
336B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  $xmm0 = COPY killed %28:fr64
368B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
384B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.2)
432B	  %60:fr64 = FsFLD0SD
440B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %60:fr64 :: (store 8 into %stack.1)
448B	  CMP32ri8 killed %20.sub_32bit:gr64_with_sub_8bit, 3, implicit-def $eflags
464B	  JCC_1 %bb.1, 13, implicit killed $eflags
> renamable $ebx = COPY $esi, implicit-def $rbx
> MOVSDmr %stack.6, 1, $noreg, 0, $noreg, $xmm1 :: (store 8 into %stack.6)
> MOVSDmr %stack.4, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.4)
> renamable $r14 = COPY $rdi
> renamable $eax = LEA64_32r renamable $rbx, 1, $noreg, 1, $noreg, implicit-def $rax
> renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
> renamable $ebp = LEA64_32r renamable $rbx, 1, killed renamable $rax, 1, $noreg
> renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
> renamable $xmm0 = MOVSDrm_alt %stack.6, 1, $noreg, 0, $noreg :: (load 8 from %stack.6)
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept SUBSDrm killed renamable $xmm0(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> renamable $xmm0 = CVTSI2SDrr renamable $ebp
> renamable $xmm1 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm1 = nofpexcept DIVSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm1 :: (store 8 into %stack.3)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.2)
> renamable $xmm0 = FsFLD0SD
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
> CMP32ri8 renamable $ebx, 3, implicit-def $eflags, implicit killed $rbx
> JCC_1 %bb.1, 13, implicit killed $eflags
480B	bb.5:
	; predecessors: %bb.0
	  successors: %bb.4(0x80000000); %bb.4(100.00%)
	  liveins: $r14
528B	  JMP_1 %bb.4
> JMP_1 %bb.4
544B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)
	  liveins: $ebp, $r14
560B	  %62:fr64 = FsFLD0SD
568B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %62:fr64 :: (store 8 into %stack.1)
576B	  %52:gr32 = MOV32ri 2
592B	  %58:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
600B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %58:fr64 :: (store 8 into %stack.0)
> renamable $xmm0 = FsFLD0SD
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
> renamable $ebx = MOV32ri 2
> renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
688B	bb.2.for.body:
	; predecessors: %bb.1, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)
	  liveins: $ebp, $ebx, $r14
768B	  %36:fr64 = CVTSI2SDrr %52:gr32
800B	  %36:fr64 = nofpexcept MULSDrm killed %36:fr64(tied-def 0), %stack.3, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
832B	  %36:fr64 = nofpexcept ADDSDrm killed %36:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
848B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
864B	  $xmm0 = COPY killed %36:fr64
880B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %37:fr64 = COPY $xmm0
920B	  %63:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
944B	  %63:fr64 = nofpexcept ADDSDrr killed %63:fr64(tied-def 0), killed %37:fr64, implicit $mxcsr
952B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %63:fr64 :: (store 8 into %stack.1)
960B	  %39:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
976B	  %39:fr64 = nofpexcept MULSDrm killed %39:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
1008B	  %39:fr64 = nofpexcept ADDSDrm killed %39:fr64(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
1024B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  $xmm0 = COPY killed %39:fr64
1056B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1088B	  %40:fr64 = COPY $xmm0
1096B	  %66:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
1120B	  %66:fr64 = nofpexcept ADDSDrr killed %66:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
1128B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %66:fr64 :: (store 8 into %stack.2)
1152B	  %52:gr32 = nuw nsw ADD32ri8 killed %52:gr32(tied-def 0), 2, implicit-def dead $eflags
1160B	  %59:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
1184B	  %59:fr64 = ADDSDrm killed %59:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1192B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %59:fr64 :: (store 8 into %stack.0)
1200B	  CMP32rr %52:gr32, %0:gr32, implicit-def $eflags
1280B	  JCC_1 %bb.2, 12, implicit killed $eflags
1296B	  JMP_1 %bb.3
> renamable $xmm0 = CVTSI2SDrr renamable $ebx
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), %stack.3, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $xmm0 = COPY $xmm0
Identity copy: renamable $xmm0 = COPY $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
> renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm1 :: (store 8 into %stack.1)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), %stack.4, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $xmm0 = COPY $xmm0
Identity copy: renamable $xmm0 = COPY $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
> renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed renamable $xmm1 :: (store 8 into %stack.2)
> renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
> renamable $xmm0 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
> renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
> CMP32rr renamable $ebx, renamable $ebp, implicit-def $eflags
> JCC_1 %bb.2, 12, implicit killed $eflags
> JMP_1 %bb.3
1312B	bb.3.for.end.loopexit:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)
	  liveins: $r14
1320B	  %61:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
1344B	  %61:fr64 = nofpexcept ADDSDrr killed %61:fr64(tied-def 0), %61:fr64, implicit $mxcsr
1352B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %61:fr64 :: (store 8 into %stack.1)
> renamable $xmm0 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
> renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
1392B	bb.4.for.end:
	; predecessors: %bb.3, %bb.5
	  liveins: $r14
1440B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1456B	  $xmm0 = MOVSDrm_alt %stack.4, 1, $noreg, 0, $noreg :: (load 8 from %stack.4)
1472B	  CALL64r %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1488B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1504B	  MOVSDmr %stack.5, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.5)
1520B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1536B	  $xmm0 = MOVSDrm_alt %stack.6, 1, $noreg, 0, $noreg :: (load 8 from %stack.6)
1552B	  CALL64r killed %14:gr64, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1584B	  %45:fr64 = COPY $xmm0
1616B	  %45:fr64 = nofpexcept ADDSDrm killed %45:fr64(tied-def 0), %stack.5, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.5)
1648B	  %45:fr64 = nofpexcept ADDSDrm killed %45:fr64(tied-def 0), %stack.1, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
1656B	  %65:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
1680B	  %65:fr64 = nofpexcept MULSDrm killed %65:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1684B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %65:fr64 :: (store 8 into %stack.2)
1688B	  %64:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
1712B	  %64:fr64 = nofpexcept ADDSDrr killed %64:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
1720B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %64:fr64 :: (store 8 into %stack.2)
1724B	  %67:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
1744B	  %67:fr64 = nofpexcept MULSDrm killed %67:fr64(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
1752B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %67:fr64 :: (store 8 into %stack.3)
1756B	  %68:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
1776B	  %68:fr64 = nofpexcept DIVSDrm killed %68:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1784B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %68:fr64 :: (store 8 into %stack.3)
1792B	  $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
1808B	  RET 0, $xmm0
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = MOVSDrm_alt %stack.4, 1, $noreg, 0, $noreg :: (load 8 from %stack.4)
> CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOVSDmr %stack.5, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.5)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = MOVSDrm_alt %stack.6, 1, $noreg, 0, $noreg :: (load 8 from %stack.6)
> CALL64r killed renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $xmm1 = COPY $xmm0
> renamable $xmm1 = nofpexcept ADDSDrm killed renamable $xmm1(tied-def 0), %stack.5, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.5)
> renamable $xmm1 = nofpexcept ADDSDrm killed renamable $xmm1(tied-def 0), %stack.1, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
> renamable $xmm0 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.2)
> renamable $xmm0 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
> renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.2)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> RET 0, $xmm0
********** Stack Slot Coloring **********
********** Function: _Z7simpsonPFddEddi
Spill slot intervals:
SS#0 [592r,1312B:0)  0@x weight:4.831250e+01
SS#1 [432r,544B:0)[560r,1648r:0)  0@x weight:3.537500e+01
SS#2 [400r,1744r:0)  0@x weight:3.787500e+01
SS#3 [224r,1792r:0)  0@x weight:4.287500e+01
SS#4 [48r,1456r:0)  0@x weight:3.587500e+01
SS#5 [1504r,1616r:0)  0@x weight:2.000000e+00
SS#6 [32r,1536r:0)  0@x weight:3.000000e+00

Color spill slot intervals:
Assigning fi#0 to fi#0
Assigning fi#3 to fi#1
Assigning fi#2 to fi#2
Assigning fi#4 to fi#3
Assigning fi#1 to fi#4
Assigning fi#6 to fi#5
Assigning fi#5 to fi#0

Spill slots after coloring:
SS#0 [592r,1312B:0)  0@x weight:5.031250e+01
SS#1 [432r,544B:0)[560r,1648r:0)  0@x weight:4.287500e+01
SS#2 [400r,1744r:0)  0@x weight:3.787500e+01
SS#3 [224r,1792r:0)  0@x weight:3.587500e+01
SS#4 [48r,1456r:0)  0@x weight:3.537500e+01
SS#5 [1504r,1616r:0)  0@x weight:3.000000e+00
SS#6 [32r,1536r:0)  0@x weight:0.000000e+00

Removing unused stack object fi#6
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is a deletion candidate:   renamable $r14 = COPY $rdi
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Replacing $r14
     with $rdi
     in CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
     from renamable $r14 = COPY $rdi
MCP: After replacement: CALL64r $rdi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0

MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: BackwardCopyPropagateBlock 
MCP: ForwardCopyPropagateBlock 
MCP: BackwardCopyPropagateBlock for.body.preheader
MCP: ForwardCopyPropagateBlock for.body.preheader
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: BackwardCopyPropagateBlock for.end.loopexit
MCP: ForwardCopyPropagateBlock for.end.loopexit
MCP: BackwardCopyPropagateBlock for.end
MCP: ForwardCopyPropagateBlock for.end
MCP: Copy is a deletion candidate:   renamable $xmm1 = COPY $xmm0
MCP: Copy is used - not dead:   renamable $xmm1 = COPY $xmm0
******** Post-regalloc Machine LICM: _Z7simpsonPFddEddi ********
***** X86 Load Value Injection (LVI) Load Hardening : _Z7simpsonPFddEddi *****

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB5
 - 2: BB1[for.body.preheader]
 - 3: BB2[for.body]
 - 4: BB3[for.end.loopexit]
 - 5: BB4[for.end]
loop-detection
 - loop = BB2[for.body]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB3[for.end.loopexit]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.end.loopexit]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB5
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB5
  => assign 8000000000000000 (0000000000000000) to BB1[for.body.preheader]
 - node: BB5
  => [ local  ] weight = 2147483648, succ = BB4[for.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.end]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.end.loopexit]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB3[for.end.loopexit]
 - node: BB3[for.end.loopexit]
  => [ local  ] weight = 2147483648, succ = BB4[for.end]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[for.end]
 - node: BB4[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[for.body]*: mass = 8000000000000000, scale = 32.0
  => combined-scale = 16.0
 - BB2[for.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB5: float = 0.5, scaled = 8.0, int = 8
 - BB1[for.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB2[for.body]: float = 16.0, scaled = 256.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, scaled = 8.0, int = 8
 - BB4[for.end]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - BB0[entry]: float = 1.0, int = 16
 - BB5: float = 0.5, int = 8
 - BB1[for.body.preheader]: float = 0.5, int = 8
 - BB2[for.body]: float = 16.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, int = 8
 - BB4[for.end]: float = 1.0, int = 16

		Looking for trivial roots
Found a new trivial root: %bb.4
Last visited node: %bb.1
		Looking for non-trivial roots
Total: 6, Num: 7
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.4
3: %bb.5
4: %bb.0
5: %bb.3
6: %bb.2
7: %bb.1
Found roots: %bb.4 
**** Analysing _Z7simpsonPFddEddi
Look into: 0 entry
Use or define CSR(1) or FI(0): renamable $ebx = COPY $esi, implicit-def $rbx

No Shrink wrap candidate found
alloc FI(5) at SP[-40]
alloc FI(0) at SP[-48]
alloc FI(3) at SP[-56]
alloc FI(4) at SP[-64]
alloc FI(2) at SP[-72]
alloc FI(1) at SP[-80]

TryTailMergeBlocks: %bb.3, %bb.5
  with successor %bb.4
  which has fall-through from %bb.3
Looking for common tails of at least 3 instructions

Removing MBB: bb.1:
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $r14

TryTailMergeBlocks: %bb.4, %bb.0
  with successor %bb.5
  which has fall-through from %bb.4
Looking for common tails of at least 3 instructions
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is a deletion candidate:   renamable $r14 = COPY $rdi
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: Copy is used - not dead:   renamable $ebx = COPY $esi, implicit-def $rbx
MCP: BackwardCopyPropagateBlock for.body.preheader
MCP: ForwardCopyPropagateBlock for.body.preheader
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: BackwardCopyPropagateBlock for.end.loopexit
MCP: ForwardCopyPropagateBlock for.end.loopexit
MCP: BackwardCopyPropagateBlock for.end
MCP: ForwardCopyPropagateBlock for.end
MCP: Copy is a deletion candidate:   renamable $xmm1 = COPY $xmm0
MCP: Copy is used - not dead:   renamable $xmm1 = COPY $xmm0
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z7simpsonPFddEddi
real copy:   renamable $ebx = COPY $esi, implicit-def $rbx
replaced by: $ebx = MOV32rr $esi, implicit-def $rbx
real copy:   renamable $r14 = COPY $rdi
replaced by: $r14 = MOV64rr $rdi
real copy:   renamable $xmm1 = COPY $xmm0
replaced by: $xmm1 = MOVAPSrr $xmm0

block-frequency: _Z7simpsonPFddEddi
===================================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB2[for.body]
 - 3: BB3[for.end.loopexit]
 - 4: BB4[for.end]
loop-detection
 - loop = BB2[for.body]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB3[for.end.loopexit]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.end.loopexit]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[for.body.preheader]
  => [ local  ] weight = 1073741824, succ = BB4[for.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[for.body.preheader]
  => assign 8000000000000000 (0000000000000000) to BB4[for.end]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.end.loopexit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[for.end.loopexit]
 - node: BB3[for.end.loopexit]
  => [ local  ] weight = 2147483648, succ = BB4[for.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.end]
 - node: BB4[for.end]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[for.body]*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - BB2[for.body]: 1.0 => 16.0
float-to-int: min = 0.5, max = 16.0, factor = 16.0
 - BB0[entry]: float = 1.0, scaled = 16.0, int = 16
 - BB1[for.body.preheader]: float = 0.5, scaled = 8.0, int = 8
 - BB2[for.body]: float = 16.0, scaled = 256.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, scaled = 8.0, int = 8
 - BB4[for.end]: float = 1.0, scaled = 16.0, int = 16
block-frequency-info: _Z7simpsonPFddEddi
 - BB0[entry]: float = 1.0, int = 16
 - BB1[for.body.preheader]: float = 0.5, int = 8
 - BB2[for.body]: float = 16.0, int = 255
 - BB3[for.end.loopexit]: float = 0.5, int = 8
 - BB4[for.end]: float = 1.0, int = 16

		Looking for trivial roots
Found a new trivial root: %bb.4
Last visited node: %bb.1
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.4
3: %bb.0
4: %bb.3
5: %bb.2
6: %bb.1
Found roots: %bb.4 
Pre-computing triangle chains.
Finding best loop top for: %bb.2 ('for.body')
    final top unchanged
Finding best loop exit for: %bb.2 ('for.body')
    exiting: %bb.2 ('for.body') -> %bb.3 ('for.end.loopexit') [L:0] (0.4375)
    No other candidate exit blocks, using loop header
Selecting best successor for: %bb.2 ('for.body')
Finished forming chain for header block %bb.2 ('for.body')
          ... %bb.2 ('for.body')
Selecting best successor for: %bb.0 ('entry')
    Candidate: %bb.1 ('for.body.preheader'), probability: 0x40000000 / 0x80000000 = 50.00%
    Setting it as best candidate
    Not a candidate: %bb.4 ('for.end') -> 0x40000000 / 0x80000000 = 50.00% (prob) (non-cold CFG conflict)
    Selected: %bb.1 ('for.body.preheader')
Merging from %bb.0 ('entry') to %bb.1 ('for.body.preheader')
Selecting best successor for: %bb.1 ('for.body.preheader')
    Candidate: %bb.2 ('for.body'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.2 ('for.body')
Merging from %bb.1 ('for.body.preheader') to %bb.2 ('for.body')
Selecting best successor for: %bb.2 ('for.body')
    Candidate: %bb.3 ('for.end.loopexit'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.3 ('for.end.loopexit')
Merging from %bb.2 ('for.body') to %bb.3 ('for.end.loopexit')
Selecting best successor for: %bb.3 ('for.end.loopexit')
    Candidate: %bb.4 ('for.end'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.4 ('for.end')
Merging from %bb.3 ('for.end.loopexit') to %bb.4 ('for.end')
Selecting best successor for: %bb.4 ('for.end')
Finished forming chain for header block %bb.0 ('entry')
[MBP] Function: _Z7simpsonPFddEddi
Placing chain %bb.0 ('entry')
          ... %bb.1 ('for.body.preheader')
Updating terminators on %bb.0
          ... %bb.2 ('for.body')
Updating terminators on %bb.1
          ... %bb.3 ('for.end.loopexit')
Updating terminators on %bb.2
          ... %bb.4 ('for.end')
Updating terminators on %bb.3

TryTailMergeBlocks: %bb.3, %bb.0
  with successor %bb.4
  which has fall-through from %bb.3
Looking for common tails of at least 3 instructions
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
$eip:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
$eiz:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
$es:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
$eip:	2	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eiz:	2	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$es:	2	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eip:	4	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eiz:	4	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$es:	4	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eip:	6	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$eiz:	6	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$es:	6	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$dx:	6	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$al:	11	$ebx = MOV32rr $esi, implicit-def $rbx
$ax:	11	$ebx = MOV32rr $esi, implicit-def $rbx
$dih:	11	$ebx = MOV32rr $esi, implicit-def $rbx
$al:	11	$ebx = MOV32rr $esi, implicit-def $rbx
$ax:	11	$ebx = MOV32rr $esi, implicit-def $rbx
$dih:	11	$ebx = MOV32rr $esi, implicit-def $rbx
$k7:	14	$r14 = MOV64rr $rdi
$mm0:	14	$r14 = MOV64rr $rdi
$mm1:	14	$r14 = MOV64rr $rdi
$noreg:	15	renamable $eax = LEA64_32r renamable $rbx, 1, $noreg, 1, $noreg, implicit-def $rax
$ah:	15	renamable $eax = LEA64_32r renamable $rbx, 1, $noreg, 1, $noreg, implicit-def $rax
$dh:	15	renamable $eax = LEA64_32r renamable $rbx, 1, $noreg, 1, $noreg, implicit-def $rax
$noreg:	15	renamable $eax = LEA64_32r renamable $rbx, 1, $noreg, 1, $noreg, implicit-def $rax
$ah:	15	renamable $eax = LEA64_32r renamable $rbx, 1, $noreg, 1, $noreg, implicit-def $rax
$dh:	15	renamable $eax = LEA64_32r renamable $rbx, 1, $noreg, 1, $noreg, implicit-def $rax
$noreg:	16	renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
$ah:	16	renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
$dh:	16	renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
$dx:	16	renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
$noreg:	16	renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
$ah:	16	renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
$dh:	16	renamable $eax = SHR32ri renamable $eax(tied-def 0), 31, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
$bh:	17	renamable $ebp = LEA64_32r renamable $rbx, 1, killed renamable $rax, 1, $noreg
$bl:	17	renamable $ebp = LEA64_32r renamable $rbx, 1, killed renamable $rax, 1, $noreg
$di:	17	renamable $ebp = LEA64_32r renamable $rbx, 1, killed renamable $rax, 1, $noreg
$bh:	18	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$bl:	18	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$di:	18	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$dx:	18	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$st5:	19	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 40, $noreg :: (load 8 from %stack.5)
$st5:	21	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	22	renamable $xmm0 = nofpexcept SUBSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$st5:	24	renamable $xmm0 = CVTSI2SDrr renamable $ebp
$st6:	25	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st6:	26	renamable $xmm1 = nofpexcept DIVSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$st5:	28	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	29	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$eip:	30	CALL64r $rdi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	30	CALL64r $rdi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	30	CALL64r $rdi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	30	CALL64r $rdi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	30	CALL64r $rdi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	32	renamable $xmm0 = XORPSrr undef $xmm0(tied-def 0), undef $xmm0
$dx:	34	CMP32ri8 renamable $ebx, 3, implicit-def $eflags, implicit killed $rbx
%bb.1: all preds known
$st5:	0	renamable $xmm0 = XORPSrr undef $xmm0(tied-def 0), undef $xmm0
$al:	2	renamable $ebx = MOV32ri 2
$ax:	2	renamable $ebx = MOV32ri 2
$dih:	2	renamable $ebx = MOV32ri 2
$st5:	3	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
%bb.2: incomplete
$st5:	0	renamable $xmm0 = CVTSI2SDrr renamable $ebx
$st5:	1	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
$st5:	2	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$eip:	3	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	3	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	3	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	3	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	3	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st6:	4	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.4)
$st6:	5	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$st5:	7	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	8	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 32, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$st5:	9	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$eip:	10	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	10	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	10	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	10	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	10	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st6:	11	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.2)
$st6:	12	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$al:	14	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$ax:	14	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$dih:	14	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$dx:	14	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$st5:	15	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 32, $noreg :: (load 8 from %stack.0)
$st5:	16	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$dx:	18	CMP32rr renamable $ebx, renamable $ebp, implicit-def $eflags
%bb.2: all preds known
%bb.3: all preds known
$st5:	0	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.4)
$st5:	1	renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
%bb.4: all preds known
$st5:	0	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 24, $noreg :: (load 8 from %stack.3)
$eip:	1	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	1	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	1	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	1	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	1	CALL64r renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	3	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 40, $noreg :: (load 8 from %stack.5)
$eip:	4	CALL64r killed renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	4	CALL64r killed renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	4	CALL64r killed renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	4	CALL64r killed renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	4	CALL64r killed renamable $r14, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st6:	5	$xmm1 = MOVAPSrr $xmm0
$st6:	6	renamable $xmm1 = nofpexcept ADDSDrm killed renamable $xmm1(tied-def 0), $rsp, 1, $noreg, 32, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$st6:	7	renamable $xmm1 = nofpexcept ADDSDrm killed renamable $xmm1(tied-def 0), $rsp, 1, $noreg, 16, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
$st5:	8	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.2)
$st5:	9	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st5:	11	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.2)
$st5:	12	renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
$st5:	14	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	15	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 8, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
$st5:	17	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	18	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st5:	20	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$eip:	21	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$eiz:	21	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$es:	21	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$dx:	21	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
$al:	23	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$ax:	23	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$dih:	23	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	23	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	23	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	23	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$k7:	25	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm0:	25	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm1:	25	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	25	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	25	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	25	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$bh:	27	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$bl:	27	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$di:	27	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	27	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	27	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	27	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 40, $noreg :: (load 8 from %stack.5)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept SUBSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = CVTSI2SDrr renamable $ebp
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm1:	renamable $xmm1 = nofpexcept DIVSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = XORPDrr undef $xmm0(tied-def 0), undef $xmm0
%bb.1: all preds known
$xmm0:	renamable $xmm0 = XORPDrr undef $xmm0(tied-def 0), undef $xmm0
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
%bb.2: incomplete
$xmm0:	renamable $xmm0 = CVTSI2SDrr renamable $ebx
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.4)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 32, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.2)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 32, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
%bb.2: all preds known
$xmm0:	renamable $xmm0 = CVTSI2SDrr renamable $ebx
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.4)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 32, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.2)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 32, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
%bb.3: all preds known
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.4)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
%bb.4: all preds known
$xmm0:	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 24, $noreg :: (load 8 from %stack.3)
$xmm0:	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 40, $noreg :: (load 8 from %stack.5)
$xmm1:	$xmm1 = MOVAPSrr $xmm0
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrm killed renamable $xmm1(tied-def 0), $rsp, 1, $noreg, 32, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrm killed renamable $xmm1(tied-def 0), $rsp, 1, $noreg, 16, $noreg, implicit $mxcsr :: (load 8 from %stack.4)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 8, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
********** BREAK FALSE DEPENDENCIES **********
Clearance: 2, want 64: Break dependency.
Clearance: 2, want 64: Break dependency.
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
FixLEA: Candidate to replace:  renamable $ebp = LEA64_32r renamable $rbx, 1, killed renamable $rax, 1, $noreg
FixLEA: Replaced by:   renamable $ebp = LEA64_32r renamable $rbx, 1, killed renamable $rax, 0, $noreg
  $ebp = ADD32ri8 $ebp(tied-def 0), 1, implicit-def $eflags
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: _Z7simpsonPFddEddi **********

Debug Range Extension
X86 Indirect Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : _Z7simpsonPFddEddi *****
[SafeStack] Function: _Z4funcd
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _Z4funcd ----

Computing probabilities for entry



=== _Z4funcd
Creating new node: t2: f64,ch = CopyFromReg t0, Register:f64 %0
Creating fp constant: t4: f64 = ConstantFP<4.000000e+00>
Creating new node: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
Creating new node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
Creating constant: t10: i32 = TargetConstant<0>
Creating new node: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1
Initial selection DAG: %bb.0 '_Z4funcd:entry'
SelectionDAG has 13 nodes:
  t0: ch = EntryToken
  t3: i64 = GlobalAddress<double (double, double)* @pow> 0
    t2: f64,ch = CopyFromReg t0, Register:f64 %0
  t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
  t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1



Combining: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1

Combining: t11: Untyped = RegisterMask

Combining: t10: i32 = TargetConstant<0>

Combining: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Combining: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1

Combining: t7: f64 = Register $xmm1

Combining: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

Combining: t5: f64 = Register $xmm0

Combining: t4: f64 = ConstantFP<4.000000e+00>

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %0

Combining: t1: f64 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 '_Z4funcd:entry'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
    t2: f64,ch = CopyFromReg t0, Register:f64 %0
  t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
  t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1


Legalizing node: t11: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t11: Untyped = RegisterMask

Legalizing node: t10: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t10: i32 = TargetConstant<0>

Legalizing node: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Analyzing result type: i64
Legal result type
Legally typed node: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Legalizing node: t7: f64 = Register $xmm1
Ignoring node results
Legally typed node: t7: f64 = Register $xmm1

Legalizing node: t5: f64 = Register $xmm0
Ignoring node results
Legally typed node: t5: f64 = Register $xmm0

Legalizing node: t4: f64 = ConstantFP<4.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t4: f64 = ConstantFP<4.000000e+00>

Legalizing node: t1: f64 = Register %0
Ignoring node results
Legally typed node: t1: f64 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: f64,ch = CopyFromReg t0, Register:f64 %0
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: f64,ch = CopyFromReg t0, Register:f64 %0

Legalizing node: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t2: f64,ch = CopyFromReg t0, Register:f64 %0
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

Legalizing node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
Legal operand
Analyzing operand: t4: f64 = ConstantFP<4.000000e+00>
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
Legal operand
Legally typed node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1

Legalizing node: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
Legal operand
Analyzing operand: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal operand
Analyzing operand: t11: Untyped = RegisterMask
Legal operand
Analyzing operand: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
Legal operand
Legally typed node: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1

Legalizing node: t65535: ch = handlenode t12
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1
Legal operand
Legally typed node: t65535: ch = handlenode t12

Type-legalized selection DAG: %bb.0 '_Z4funcd:entry'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
    t2: f64,ch = CopyFromReg t0, Register:f64 %0
  t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
  t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1



Legalizing: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1
Legal node: nothing to do

Legalizing: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
Legal node: nothing to do

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %0
Legal node: nothing to do

Legalizing: t11: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t10: i32 = TargetConstant<0>

Legalizing: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal node: nothing to do

Legalizing: t7: f64 = Register $xmm1

Legalizing: t5: f64 = Register $xmm0

Legalizing: t4: f64 = ConstantFP<4.000000e+00>
Trying to expand node
Creating new constant pool: t13: i64 = ConstantPool<double 4.000000e+00> 0
Creating new node: t14: i64 = undef
Creating new node: t15: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t4: f64 = ConstantFP<4.000000e+00>
     with:      t15: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64

Legalizing: t1: f64 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t15: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t14: i64 = undef
Legal node: nothing to do

Legalizing: t13: i64 = ConstantPool<double 4.000000e+00> 0
Trying custom legalization
Creating new constant pool: t16: i64 = TargetConstantPool<double 4.000000e+00> 0
Creating new node: t17: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Successfully custom legalized node
 ... replacing: t13: i64 = ConstantPool<double 4.000000e+00> 0
     with:      t17: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t17: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t16: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.0 '_Z4funcd:entry'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
    t2: f64,ch = CopyFromReg t0, Register:f64 %0
  t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
      t17: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
    t15: f64,ch = load<(load 8 from constant-pool)> t0, t17, undef:i64
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1
  t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1



Legalizing: t17: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t17: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t16: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t16: i64 = TargetConstantPool<double 4.000000e+00> 0

Legalizing: t15: f64,ch = load<(load 8 from constant-pool)> t0, t17, undef:i64
Legalizing non-extending load operation

Combining: t15: f64,ch = load<(load 8 from constant-pool)> t0, t17, undef:i64

Legalizing: t14: i64 = undef
Legal node: nothing to do

Combining: t14: i64 = undef

Legalizing: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1
Legal node: nothing to do

Combining: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1

Legalizing: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1
Legal node: nothing to do

Combining: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1

Legalizing: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %0
Legal node: nothing to do

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %0

Legalizing: t11: Untyped = RegisterMask
Legal node: nothing to do

Combining: t11: Untyped = RegisterMask

Legalizing: t10: i32 = TargetConstant<0>

Combining: t10: i32 = TargetConstant<0>

Legalizing: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal node: nothing to do

Combining: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Legalizing: t7: f64 = Register $xmm1

Combining: t7: f64 = Register $xmm1

Legalizing: t5: f64 = Register $xmm0

Combining: t5: f64 = Register $xmm0

Legalizing: t1: f64 = Register %0

Combining: t1: f64 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 '_Z4funcd:entry'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
    t2: f64,ch = CopyFromReg t0, Register:f64 %0
  t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
      t17: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
    t15: f64,ch = load<(load 8 from constant-pool)> t0, t17, undef:i64
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1
  t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t12: ch,glue = X86ISD::TC_RETURN t8, TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8:1
ISEL: Starting pattern match
  Initial Opcode index to 43826
  Match failed at index 43831
  Continuing at 43895
  OpcodeSwitch from 43901 to 43905
  TypeSwitch[i64] from 43905 to 43927
  Morphed node: t12: ch = TCRETURNdi64 TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8, t8:1
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1

ISEL: Starting selection on root node: t15: f64,ch = load<(load 8 from constant-pool)> t0, t17, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t19: i8 = TargetConstant<1>
Creating new constant pool: t21: i32 = TargetConstantPool<double 4.000000e+00> 0
  Morphed node: t15: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

ISEL: Starting selection on root node: t2: f64,ch = CopyFromReg t0, Register:f64 %0

ISEL: Starting selection on root node: t11: Untyped = RegisterMask

ISEL: Starting selection on root node: t10: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t9: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

ISEL: Starting selection on root node: t7: f64 = Register $xmm1

ISEL: Starting selection on root node: t5: f64 = Register $xmm0

ISEL: Starting selection on root node: t1: f64 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 '_Z4funcd:entry'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
    t2: f64,ch = CopyFromReg t0, Register:f64 %0
  t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2
    t15: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
  t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1
  t12: ch = TCRETURNdi64 TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8, t8:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t12: ch = TCRETURNdi64 TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8, t8:1

    t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

    t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
    SU(2): Data Latency=1
SU(1): t15: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t12: ch = TCRETURNdi64 TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8, t8:1

    t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

    t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1


*** Scheduling [0]: SU(0): t12: ch = TCRETURNdi64 TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8, t8:1

    t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

    t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1


Examining Available:
Height 1: SU(1): t15: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

Height 1: SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %0


*** Scheduling [1]: SU(1): t15: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 1: SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %0


*** Scheduling [2]: SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %0

*** Final schedule ***
SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %0

SU(1): t15: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

SU(0): t12: ch = TCRETURNdi64 TargetGlobalAddress:i64<double (double, double)* @pow> 0, TargetConstant:i32<0>, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t8, t8:1

    t6: ch,glue = CopyToReg t0, Register:f64 $xmm0, t2

    t8: ch,glue = CopyToReg t6, Register:f64 $xmm1, t15, t6:1


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _Z4funcd: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

bb.0.entry:
  liveins: $xmm0
  %0:fr64 = COPY $xmm0
  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %0:fr64
  $xmm1 = COPY %1:fr64
  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1

# End machine code for function _Z4funcd.

***** Machine Function before Domain Reassignment *****
# Machine code for function _Z4funcd: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

bb.0.entry:
  liveins: $xmm0
  %0:fr64 = COPY $xmm0
  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %0:fr64
  $xmm1 = COPY %1:fr64
  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1

# End machine code for function _Z4funcd.

# Machine code for function _Z4funcd: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

0B	bb.0.entry:
	  liveins: $xmm0
16B	  %0:fr64 = COPY $xmm0
32B	  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  $xmm0 = COPY %0:fr64
64B	  $xmm1 = COPY %1:fr64
80B	  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1

# End machine code for function _Z4funcd.

********** Stack Coloring **********
********** Function: _Z4funcd
********** EARLY IF-CONVERSION **********
********** Function: _Z4funcd
Machine InstCombiner: _Z4funcd
Combining MBB entry
********** X86 cmov Conversion : _Z4funcd**********

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - BB0[entry]: float = 1.0, int = 8

******** Pre-regalloc Machine LICM: _Z4funcd ********

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - BB0[entry]: float = 1.0, int = 8

Entering: entry
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: _Z4funcd
Encountered load fold barrier on TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1
**** Analysing _Z4funcd
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : _Z4funcd **********
********** X86 EFLAGS copy lowering : _Z4funcd **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: _Z4funcd
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _Z4funcd
# Machine code for function _Z4funcd: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

0B	bb.0.entry:
	  liveins: $xmm0
16B	  %0:fr64 = COPY killed $xmm0
32B	  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  $xmm0 = COPY killed %0:fr64
64B	  $xmm1 = COPY killed %1:fr64
80B	  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1

# End machine code for function _Z4funcd.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 XMM0#0
Created 1 new intervals.
********** INTERVALS **********
XMM0 [0B,16r:0)[48r,80r:1)  0@0B-phi 1@48r
%0 [16r,48r:0)  0@16r weight:0.000000e+00
%1 [32r,64r:0)  0@32r weight:0.000000e+00
RegMasks: 80r
********** MACHINEINSTRS **********
# Machine code for function _Z4funcd: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

0B	bb.0.entry:
	  liveins: $xmm0
16B	  %0:fr64 = COPY $xmm0
32B	  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  $xmm0 = COPY %0:fr64
64B	  $xmm1 = COPY %1:fr64
80B	  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit killed $xmm1

# End machine code for function _Z4funcd.

********** SIMPLE REGISTER COALESCING **********
********** Function: _Z4funcd
********** JOINING INTERVALS ***********
entry:
16B	%0:fr64 = COPY $xmm0
	Considering merging %0 with $xmm0
	Can only merge into reserved registers.
48B	$xmm0 = COPY %0:fr64
	Considering merging %0 with $xmm0
	Can only merge into reserved registers.
64B	$xmm1 = COPY %1:fr64
	Considering merging %1 with $xmm1
	Can only merge into reserved registers.
48B	$xmm0 = COPY %0:fr64
	Considering merging %0 with $xmm0
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
XMM0 [0B,16r:0)[48r,80r:1)  0@0B-phi 1@48r
%0 [16r,48r:0)  0@16r weight:0.000000e+00
%1 [32r,64r:0)  0@32r weight:0.000000e+00
RegMasks: 80r
********** MACHINEINSTRS **********
# Machine code for function _Z4funcd: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

0B	bb.0.entry:
	  liveins: $xmm0
16B	  %0:fr64 = COPY $xmm0
32B	  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  $xmm0 = COPY %0:fr64
64B	  $xmm1 = COPY %1:fr64
80B	  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit killed $xmm1

# End machine code for function _Z4funcd.

Before MISched:
# Machine code for function _Z4funcd: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

bb.0.entry:
  liveins: $xmm0
  %0:fr64 = COPY $xmm0
  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %0:fr64
  $xmm1 = COPY %1:fr64
  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit killed $xmm1

# End machine code for function _Z4funcd.

********** MI Scheduling **********
_Z4funcd:%bb.0 entry
  From: %0:fr64 = COPY $xmm0
    To: TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit killed $xmm1
 RegionInstrs: 4
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %0:fr64 = COPY $xmm0
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(2): Data Latency=0 Reg=%0
    SU(2): Anti Latency=0
  Single Issue       : false;
SU(1):   %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 6
  Successors:
    SU(3): Data Latency=6 Reg=%1
  Single Issue       : false;
SU(2):   $xmm0 = COPY %0:fr64
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Data Latency=0 Reg=%0
    SU(0): Anti Latency=0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(3):   $xmm1 = COPY %1:fr64
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(1): Data Latency=6 Reg=%1
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit killed $xmm1
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=0 Artificial
    SU(2): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 6
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 2 
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) $xmm1 = COPY %1:fr64
  Ready @0c
  BotQ.A TopLatency SU(3) 6c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(2) $xmm0 = COPY %0:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  Ready @6c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 6c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %0:fr64 = COPY $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %0:fr64 = COPY $xmm0
SU(1):   %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(2):   $xmm0 = COPY %0:fr64
SU(3):   $xmm1 = COPY %1:fr64

********** INTERVALS **********
XMM0 [0B,16r:0)[48r,80r:1)  0@0B-phi 1@48r
%0 [16r,48r:0)  0@16r weight:0.000000e+00
%1 [32r,64r:0)  0@32r weight:0.000000e+00
RegMasks: 80r
********** MACHINEINSTRS **********
# Machine code for function _Z4funcd: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 4.000000e+00, align=8
Function Live Ins: $xmm0 in %0

0B	bb.0.entry:
	  liveins: $xmm0
16B	  %0:fr64 = COPY $xmm0
32B	  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  $xmm0 = COPY %0:fr64
64B	  $xmm1 = COPY %1:fr64
80B	  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit killed $xmm1

# End machine code for function _Z4funcd.


block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - BB0[entry]: float = 1.0, int = 8

********** BASIC REGISTER ALLOCATION **********
********** Function: _Z4funcd
********** Compute Spill Weights **********
********** Function: _Z4funcd
VirtReg:0-> 0(group: FR64)
hints: $xmm0
0 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:1-> 1(group: FR64)
hints: $xmm1
1 can be allocatable among $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
test!!! regcount = 2

selectOrSplit FR64:%0 [16r,48r:0)  0@16r weight:4.675926e-03 w=4.675926e-03
hints: $xmm0
assigning %0 to $xmm0: XMM0 [16r,48r:0)  0@16r

selectOrSplit FR64:%1 [32r,64r:0)  0@32r weight:2.337963e-03 w=2.337963e-03
hints: $xmm1
assigning %1 to $xmm1: XMM1 [32r,64r:0)  0@32r
Post alloc VirtRegMap:
********** REGISTER MAP **********
[%0 -> $xmm0] FR64
[%1 -> $xmm1] FR64


********** REWRITE VIRTUAL REGISTERS **********
********** Function: _Z4funcd
********** REGISTER MAP **********
[%0 -> $xmm0] FR64
[%1 -> $xmm1] FR64

0B	bb.0.entry:
	  liveins: $xmm0
16B	  %0:fr64 = COPY $xmm0
32B	  %1:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  $xmm0 = COPY killed %0:fr64
64B	  $xmm1 = COPY killed %1:fr64
80B	  TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1
> renamable $xmm0 = COPY $xmm0
Identity copy: renamable $xmm0 = COPY $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> $xmm1 = COPY killed renamable $xmm1
Identity copy: $xmm1 = COPY killed renamable $xmm1
  deleted.
> TCRETURNdi64 @pow, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1
********** Stack Slot Coloring **********
********** Function: _Z4funcd
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
******** Post-regalloc Machine LICM: _Z4funcd ********
***** X86 Load Value Injection (LVI) Load Hardening : _Z4funcd *****

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
**** Analysing _Z4funcd
Look into: 0 entry
No Shrink wrap candidate found
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _Z4funcd

block-frequency: _Z4funcd
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _Z4funcd
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
$st6:	0	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
********** BREAK FALSE DEPENDENCIES **********
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: _Z4funcd **********

Debug Range Extension
X86 Indirect Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : _Z4funcd *****
[SafeStack] Function: main
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %if.then.i
Found a new trivial root: %if.then.i64
Last visited node: %if.then.i64
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %_ZNKSt5ctypeIcE5widenEc.exit
4: %if.end.i
5: %_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
6: %_Z7simpsonPFddEddi.exit
7: %for.end.loopexit.i
8: %for.body.i
9: %for.body.i.preheader
10: %for.body
11: %entry
12: %if.then.i
13: %if.then.i64
Found roots: %for.cond.cleanup %if.then.i64 
---- Branch Probability Info : main ----

BPI: SCC 2: if.then.i _ZNKSt5ctypeIcE5widenEc.exit if.end.i _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit _Z7simpsonPFddEddi.exit for.end.loopexit.i for.body.i for.body.i.preheader for.body
Computing probabilities for if.then.i64
Computing probabilities for for.cond.cleanup
Computing probabilities for _ZNKSt5ctypeIcE5widenEc.exit
eraseBlock _ZNKSt5ctypeIcE5widenEc.exit
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge _ZNKSt5ctypeIcE5widenEc.exit -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.end.i
Computing probabilities for if.then.i
Computing probabilities for _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
eraseBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 0 successor probability to 0x30000000 / 0x80000000 = 37.50%
set edge _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit -> 1 successor probability to 0x50000000 / 0x80000000 = 62.50%
Computing probabilities for _Z7simpsonPFddEddi.exit
eraseBlock _Z7simpsonPFddEddi.exit
set edge _Z7simpsonPFddEddi.exit -> 0 successor probability to 0x00000800 / 0x80000000 = 0.00%
set edge _Z7simpsonPFddEddi.exit -> 1 successor probability to 0x7ffff800 / 0x80000000 = 100.00%
Computing probabilities for for.end.loopexit.i
Computing probabilities for for.body.i
eraseBlock for.body.i
set edge for.body.i -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge for.body.i -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for for.body.i.preheader
Computing probabilities for for.body
Computing probabilities for entry



=== main
Creating constant: t1: i32 = Constant<2>
Creating new node: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
Creating new node: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>
Initial selection DAG: %bb.0 'main:entry'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
  t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>



Combining: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>

Combining: t4: ch = BasicBlock<for.body 0x7fffc1df5388>

Combining: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>

Combining: t2: i32 = Register %21

Combining: t1: i32 = Constant<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'main:entry'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
  t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>


Legalizing node: t4: ch = BasicBlock<for.body 0x7fffc1df5388>
Analyzing result type: ch
Legal result type
Legally typed node: t4: ch = BasicBlock<for.body 0x7fffc1df5388>

Legalizing node: t2: i32 = Register %21
Ignoring node results
Legally typed node: t2: i32 = Register %21

Legalizing node: t1: i32 = Constant<2>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = Constant<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<2>
Legal operand
Legally typed node: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>

Legalizing node: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>
Analyzing result type: ch
Legal result type
Analyzing operand: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
Legal operand
Analyzing operand: t4: ch = BasicBlock<for.body 0x7fffc1df5388>
Legal operand
Legally typed node: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>

Legalizing node: t65535: ch = handlenode t5
Analyzing result type: ch
Legal result type
Analyzing operand: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>
Legal operand
Legally typed node: t65535: ch = handlenode t5

Type-legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
  t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>



Legalizing: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>
Legal node: nothing to do

Legalizing: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
Legal node: nothing to do

Legalizing: t4: ch = BasicBlock<for.body 0x7fffc1df5388>
Legal node: nothing to do

Legalizing: t2: i32 = Register %21

Legalizing: t1: i32 = Constant<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
  t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>



Legalizing: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>
Legal node: nothing to do

Combining: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>

Legalizing: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
Legal node: nothing to do

Combining: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>

Legalizing: t4: ch = BasicBlock<for.body 0x7fffc1df5388>
Legal node: nothing to do

Combining: t4: ch = BasicBlock<for.body 0x7fffc1df5388>

Legalizing: t2: i32 = Register %21

Combining: t2: i32 = Register %21

Legalizing: t1: i32 = Constant<2>
Legal node: nothing to do

Combining: t1: i32 = Constant<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 6 nodes:
      t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>
  t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t5: ch = br t3, BasicBlock:ch<for.body 0x7fffc1df5388>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t5: ch = JMP_1 BasicBlock:ch<for.body 0x7fffc1df5388>, t3
ISEL: Match complete!

ISEL: Starting selection on root node: t3: ch = CopyToReg t0, Register:i32 %21, Constant:i32<2>

ISEL: Starting selection on root node: t4: ch = BasicBlock<for.body 0x7fffc1df5388>

ISEL: Starting selection on root node: t2: i32 = Register %21

ISEL: Starting selection on root node: t1: i32 = Constant<2>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i32] from 124159 to 124162
  Match failed at index 124166
  Continuing at 124177
Creating constant: t6: i32 = TargetConstant<2>
  Morphed node: t1: i32 = MOV32ri TargetConstant:i32<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'main:entry'
SelectionDAG has 7 nodes:
      t0: ch = EntryToken
      t1: i32 = MOV32ri TargetConstant:i32<2>
    t3: ch = CopyToReg t0, Register:i32 %21, t1
  t5: ch = JMP_1 BasicBlock:ch<for.body 0x7fffc1df5388>, t3


********** List Scheduling %bb.0 'entry' **********
SU(0): t5: ch = JMP_1 BasicBlock:ch<for.body 0x7fffc1df5388>, t3

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t3: ch = CopyToReg t0, Register:i32 %21, t1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t1: i32 = MOV32ri TargetConstant:i32<2>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t5: ch = JMP_1 BasicBlock:ch<for.body 0x7fffc1df5388>, t3


*** Scheduling [0]: SU(0): t5: ch = JMP_1 BasicBlock:ch<for.body 0x7fffc1df5388>, t3


Examining Available:
Height 1: SU(1): t3: ch = CopyToReg t0, Register:i32 %21, t1


*** Scheduling [1]: SU(1): t3: ch = CopyToReg t0, Register:i32 %21, t1


Examining Available:
Height 2: SU(2): t1: i32 = MOV32ri TargetConstant:i32<2>


*** Scheduling [2]: SU(2): t1: i32 = MOV32ri TargetConstant:i32<2>

*** Final schedule ***
SU(2): t1: i32 = MOV32ri TargetConstant:i32<2>

SU(1): t3: ch = CopyToReg t0, Register:i32 %21, t1

SU(0): t5: ch = JMP_1 BasicBlock:ch<for.body 0x7fffc1df5388>, t3


Total amount of phi nodes to update: 1
Node 0 : (0x7fffc1df5460, 2147483669)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Creating constant: t3: i32 = Constant<1>
Creating new node: t4: i32 = or t2, Constant:i32<1>
Creating constant: t5: i32 = Constant<2>
Creating new node: t6: i32 = sdiv t4, Constant:i32<2>
Creating constant: t7: i8 = Constant<1>
Creating new node: t8: i32 = shl nuw nsw t6, Constant:i8<1>
Creating new node: t10: ch = CopyToReg t0, Register:i32 %1, t8
Creating new node: t11: f64 = sint_to_fp t8
Creating fp constant: t12: f64 = ConstantFP<1.000000e+00>
Creating new node: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
Creating new node: t15: ch = CopyToReg t0, Register:f64 %2, t13
Creating fp constant: t16: f64 = ConstantFP<0.000000e+00>
Creating new node: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
Creating fp constant: t19: f64 = ConstantFP<4.000000e+00>
Creating constant: t20: i64 = TargetConstant<0>
Creating new node: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
Creating new node: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
Creating new node: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
Creating new node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Creating new node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Creating new node: t32: ch = CopyToReg t0, Register:f64 %3, t30
Creating new node: t34: i1 = setcc t2, Constant:i32<2>, setgt:ch
Creating new node: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
Creating constant: t37: i1 = Constant<-1>
Creating new node: t38: i1 = xor t34, Constant:i1<-1>
Creating new node: t40: ch = TokenFactor t10, t15, t32, t36, t30:1
Creating new node: t41: ch = brcond t40, t38, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Creating new node: t43: ch = br t41, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>
Initial selection DAG: %bb.2 'main:for.body'
SelectionDAG has 44 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %0
      t4: i32 = or t2, Constant:i32<1>
    t6: i32 = sdiv t4, Constant:i32<2>
  t8: i32 = shl nuw nsw t6, Constant:i8<1>
    t11: f64 = sint_to_fp t8
  t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
  t18: i64 = GlobalAddress<double (double, double)* @pow> 0
    t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
  t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
  t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
  t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
        t10: ch = CopyToReg t0, Register:i32 %1, t8
        t15: ch = CopyToReg t0, Register:f64 %2, t13
        t32: ch = CopyToReg t0, Register:f64 %3, t30
        t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
      t40: ch = TokenFactor t10, t15, t32, t36, t30:1
        t34: i1 = setcc t2, Constant:i32<2>, setgt:ch
      t38: i1 = xor t34, Constant:i1<-1>
    t41: ch = brcond t40, t38, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
  t43: ch = br t41, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>



Combining: t43: ch = br t41, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>

Combining: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>

Combining: t41: ch = brcond t40, t38, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Creating new node: t45: i1 = setcc t2, Constant:i32<2>, setle:ch
Creating new node: t46: ch = brcond t40, t45, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
 ... into: t46: ch = brcond t40, t45, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Combining: t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>

Combining: t46: ch = brcond t40, t45, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Combining: t45: i1 = setcc t2, Constant:i32<2>, setle:ch
Creating constant: t47: i32 = Constant<3>
Creating new node: t49: i1 = setcc t2, Constant:i32<3>, setlt:ch
 ... into: t49: i1 = setcc t2, Constant:i32<3>, setlt:ch

Combining: t46: ch = brcond t40, t49, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Combining: t49: i1 = setcc t2, Constant:i32<3>, setlt:ch

Combining: t48: ch = setlt

Combining: t47: i32 = Constant<3>

Combining: t40: ch = TokenFactor t10, t15, t32, t36, t30:1

Combining: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Combining: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>

Combining: t35: f64 = Register %22

Combining: t32: ch = CopyToReg t0, Register:f64 %3, t30

Combining: t31: f64 = Register %3

Combining: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Combining: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Combining: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1

Combining: t27: Untyped = RegisterMask

Combining: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Combining: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1

Combining: t24: f64 = Register $xmm1

Combining: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17

Combining: t22: f64 = Register $xmm0

Combining: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t20: i64 = TargetConstant<0>

Combining: t19: f64 = ConstantFP<4.000000e+00>

Combining: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
Creating fp constant: t50: f64 = ConstantFP<-0.000000e+00>

Combining: t16: f64 = ConstantFP<0.000000e+00>

Combining: t15: ch = CopyToReg t0, Register:f64 %2, t13

Combining: t14: f64 = Register %2

Combining: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
Creating fp constant: t51: f64 = ConstantFP<-1.000000e+00>

Combining: t12: f64 = ConstantFP<1.000000e+00>

Combining: t11: f64 = sint_to_fp t8

Combining: t10: ch = CopyToReg t0, Register:i32 %1, t8

Combining: t9: i32 = Register %1

Combining: t8: i32 = shl nuw nsw t6, Constant:i8<1>

Combining: t7: i8 = Constant<1>

Combining: t6: i32 = sdiv t4, Constant:i32<2>
Creating constant: t52: i64 = Constant<32>
Creating constant: t53: i64 = Constant<1>
Creating constant: t54: i64 = Constant<31>
Creating new node: t55: i32 = sra t4, Constant:i64<31>
Creating new node: t56: i32 = srl t55, Constant:i64<31>
Creating new node: t57: i32 = add t4, t56
Creating new node: t58: i32 = sra t57, Constant:i64<1>
Creating constant: t59: i32 = Constant<-1>
Creating constant: t61: i8 = Constant<0>
Creating constant: t62: i32 = Constant<0>
Creating new node: t63: i32 = sub Constant:i32<0>, t58
 ... into: t58: i32 = sra t57, Constant:i64<1>

Combining: t8: i32 = shl nuw nsw t58, Constant:i8<1>

Replacing.2 t55: i32 = sra t4, Constant:i64<31>

With: t4: i32 = or t2, Constant:i32<1>


Combining: t8: i32 = shl nuw nsw t58, Constant:i8<1>
Creating new node: t64: i32 = srl t57, Constant:i64<1>

Replacing.2 t58: i32 = sra t57, Constant:i64<1>

With: t64: i32 = srl t57, Constant:i64<1>


Combining: t64: i32 = srl t57, Constant:i64<1>

Combining: t53: i64 = Constant<1>

Combining: t8: i32 = shl nuw nsw t64, Constant:i8<1>
Creating constant: t65: i8 = Constant<0>
Creating constant: t66: i32 = Constant<-2>
Creating new node: t67: i32 = and t57, Constant:i32<-2>
 ... into: t67: i32 = and t57, Constant:i32<-2>

Combining: t11: f64 = sint_to_fp t67

Combining: t10: ch = CopyToReg t0, Register:i32 %1, t67

Combining: t67: i32 = and t57, Constant:i32<-2>

Combining: t66: i32 = Constant<-2>

Combining: t57: i32 = add t4, t56

Combining: t56: i32 = srl t4, Constant:i64<31>

Combining: t54: i64 = Constant<31>

Combining: t4: i32 = or t2, Constant:i32<1>

Combining: t3: i32 = Constant<1>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t1: i32 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.2 'main:for.body'
SelectionDAG has 43 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %0
  t4: i32 = or t2, Constant:i32<1>
    t11: f64 = sint_to_fp t67
  t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
    t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
  t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
  t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
  t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
      t56: i32 = srl t4, Constant:i64<31>
    t57: i32 = add t4, t56
  t67: i32 = and t57, Constant:i32<-2>
        t10: ch = CopyToReg t0, Register:i32 %1, t67
        t15: ch = CopyToReg t0, Register:f64 %2, t13
        t32: ch = CopyToReg t0, Register:f64 %3, t30
        t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
      t40: ch = TokenFactor t10, t15, t32, t36, t30:1
      t49: i1 = setcc t2, Constant:i32<3>, setlt:ch
    t46: ch = brcond t40, t49, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
  t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>


Legalizing node: t66: i32 = Constant<-2>
Analyzing result type: i32
Legal result type
Legally typed node: t66: i32 = Constant<-2>

Legalizing node: t54: i64 = Constant<31>
Analyzing result type: i64
Legal result type
Legally typed node: t54: i64 = Constant<31>

Legalizing node: t48: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t48: ch = setlt

Legalizing node: t47: i32 = Constant<3>
Analyzing result type: i32
Legal result type
Legally typed node: t47: i32 = Constant<3>

Legalizing node: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>
Analyzing result type: ch
Legal result type
Legally typed node: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>

Legalizing node: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Analyzing result type: ch
Legal result type
Legally typed node: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Legalizing node: t35: f64 = Register %22
Ignoring node results
Legally typed node: t35: f64 = Register %22

Legalizing node: t31: f64 = Register %3
Ignoring node results
Legally typed node: t31: f64 = Register %3

Legalizing node: t27: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t27: Untyped = RegisterMask

Legalizing node: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Analyzing result type: i64
Legal result type
Legally typed node: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Legalizing node: t24: f64 = Register $xmm1
Ignoring node results
Legally typed node: t24: f64 = Register $xmm1

Legalizing node: t22: f64 = Register $xmm0
Ignoring node results
Legally typed node: t22: f64 = Register $xmm0

Legalizing node: t20: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t20: i64 = TargetConstant<0>

Legalizing node: t19: f64 = ConstantFP<4.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t19: f64 = ConstantFP<4.000000e+00>

Legalizing node: t16: f64 = ConstantFP<0.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t16: f64 = ConstantFP<0.000000e+00>

Legalizing node: t14: f64 = Register %2
Ignoring node results
Legally typed node: t14: f64 = Register %2

Legalizing node: t12: f64 = ConstantFP<1.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t12: f64 = ConstantFP<1.000000e+00>

Legalizing node: t9: i32 = Register %1
Ignoring node results
Legally typed node: t9: i32 = Register %1

Legalizing node: t3: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = Constant<1>

Legalizing node: t1: i32 = Register %0
Ignoring node results
Legally typed node: t1: i32 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t4: i32 = or t2, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t3: i32 = Constant<1>
Legal operand
Legally typed node: t4: i32 = or t2, Constant:i32<1>

Legalizing node: t56: i32 = srl t4, Constant:i64<31>
Analyzing result type: i32
Legal result type
Analyzing operand: t4: i32 = or t2, Constant:i32<1>
Legal operand
Analyzing operand: t54: i64 = Constant<31>
Legal operand
Legally typed node: t56: i32 = srl t4, Constant:i64<31>

Legalizing node: t57: i32 = add t4, t56
Analyzing result type: i32
Legal result type
Analyzing operand: t4: i32 = or t2, Constant:i32<1>
Legal operand
Analyzing operand: t56: i32 = srl t4, Constant:i64<31>
Legal operand
Legally typed node: t57: i32 = add t4, t56

Legalizing node: t67: i32 = and t57, Constant:i32<-2>
Analyzing result type: i32
Legal result type
Analyzing operand: t57: i32 = add t4, t56
Legal operand
Analyzing operand: t66: i32 = Constant<-2>
Legal operand
Legally typed node: t67: i32 = and t57, Constant:i32<-2>

Legalizing node: t11: f64 = sint_to_fp t67
Analyzing result type: f64
Legal result type
Analyzing operand: t67: i32 = and t57, Constant:i32<-2>
Legal operand
Legally typed node: t11: f64 = sint_to_fp t67

Legalizing node: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
Analyzing result type: f64
Legal result type
Analyzing operand: t12: f64 = ConstantFP<1.000000e+00>
Legal operand
Analyzing operand: t11: f64 = sint_to_fp t67
Legal operand
Legally typed node: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11

Legalizing node: t15: ch = CopyToReg t0, Register:f64 %2, t13
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
Legal operand
Legally typed node: t15: ch = CopyToReg t0, Register:f64 %2, t13

Legalizing node: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
Legal operand
Analyzing operand: t16: f64 = ConstantFP<0.000000e+00>
Legal operand
Legally typed node: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>

Legalizing node: t10: ch = CopyToReg t0, Register:i32 %1, t67
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t67: i32 = and t57, Constant:i32<-2>
Legal operand
Legally typed node: t10: ch = CopyToReg t0, Register:i32 %1, t67

Legalizing node: t49: i1 = setcc t2, Constant:i32<3>, setlt:ch
Analyzing result type: i1
Promote integer result: t49: i1 = setcc t2, Constant:i32<3>, setlt:ch

Creating new node: t68: i8 = setcc t2, Constant:i32<3>, setlt:ch
Legalizing node: t68: i8 = setcc t2, Constant:i32<3>, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t47: i32 = Constant<3>
Legal operand
Analyzing operand: t48: ch = setlt
Legal operand
Legally typed node: t68: i8 = setcc t2, Constant:i32<3>, setlt:ch

Legalizing node: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
Legal operand
Legally typed node: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17

Legalizing node: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
Legal operand
Analyzing operand: t19: f64 = ConstantFP<4.000000e+00>
Legal operand
Analyzing operand: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
Legal operand
Legally typed node: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1

Legalizing node: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
Legal operand
Analyzing operand: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal operand
Analyzing operand: t27: Untyped = RegisterMask
Legal operand
Analyzing operand: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
Legal operand
Legally typed node: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1

Legalizing node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
Legal operand
Analyzing operand: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
Legal operand
Legally typed node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Legalizing node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Legal operand
Analyzing operand: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
Legal operand
Legally typed node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Legalizing node: t32: ch = CopyToReg t0, Register:f64 %3, t30
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal operand
Legally typed node: t32: ch = CopyToReg t0, Register:f64 %3, t30

Legalizing node: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t16: f64 = ConstantFP<0.000000e+00>
Legal operand
Legally typed node: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>

Legalizing node: t40: ch = TokenFactor t10, t15, t32, t36, t30:1
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = CopyToReg t0, Register:i32 %1, t67
Legal operand
Analyzing operand: t15: ch = CopyToReg t0, Register:f64 %2, t13
Legal operand
Analyzing operand: t32: ch = CopyToReg t0, Register:f64 %3, t30
Legal operand
Analyzing operand: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
Legal operand
Analyzing operand: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal operand
Legally typed node: t40: ch = TokenFactor t10, t15, t32, t36, t30:1

Legalizing node: t46: ch = brcond t40, t49, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Analyzing result type: ch
Legal result type
Analyzing operand: t40: ch = TokenFactor t10, t15, t32, t36, t30:1
Legal operand
Analyzing operand: t49: i1 = setcc t2, Constant:i32<3>, setlt:ch
Promote integer operand: t46: ch = brcond t40, t49, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Creating new node: t69: i8 = zero_extend t49
Legalizing node: t69: i8 = zero_extend t49
Analyzing result type: i8
Legal result type
Analyzing operand: t49: i1 = setcc t2, Constant:i32<3>, setlt:ch
Promote integer operand: t69: i8 = zero_extend t49

Creating constant: t70: i8 = Constant<1>
Creating new node: t71: i8 = and t68, Constant:i8<1>
Replacing: t69: i8 = zero_extend t49
     with: t71: i8 = and t68, Constant:i8<1>
Legalizing node: t70: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t70: i8 = Constant<1>

Legalizing node: t71: i8 = and t68, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t68: i8 = setcc t2, Constant:i32<3>, setlt:ch
Legal operand
Analyzing operand: t70: i8 = Constant<1>
Legal operand
Legally typed node: t71: i8 = and t68, Constant:i8<1>

Legalizing node: t46: ch = brcond t40, t71, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Analyzing result type: ch
Legal result type
Analyzing operand: t40: ch = TokenFactor t10, t15, t32, t36, t30:1
Legal operand
Analyzing operand: t71: i8 = and t68, Constant:i8<1>
Legal operand
Analyzing operand: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Legal operand
Legally typed node: t46: ch = brcond t40, t71, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Legalizing node: t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>
Analyzing result type: ch
Legal result type
Analyzing operand: t46: ch = brcond t40, t71, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Legal operand
Analyzing operand: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>
Legal operand
Legally typed node: t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>

Legalizing node: t65535: ch = handlenode t43
Analyzing result type: ch
Legal result type
Analyzing operand: t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>
Legal operand
Legally typed node: t65535: ch = handlenode t43

Type-legalized selection DAG: %bb.2 'main:for.body'
SelectionDAG has 45 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %0
  t4: i32 = or t2, Constant:i32<1>
    t11: f64 = sint_to_fp t67
  t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
    t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
  t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
  t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
  t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
      t56: i32 = srl t4, Constant:i64<31>
    t57: i32 = add t4, t56
  t67: i32 = and t57, Constant:i32<-2>
        t10: ch = CopyToReg t0, Register:i32 %1, t67
        t15: ch = CopyToReg t0, Register:f64 %2, t13
        t32: ch = CopyToReg t0, Register:f64 %3, t30
        t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
      t40: ch = TokenFactor t10, t15, t32, t36, t30:1
        t68: i8 = setcc t2, Constant:i32<3>, setlt:ch
      t71: i8 = and t68, Constant:i8<1>
    t46: ch = brcond t40, t71, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
  t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>



Combining: t71: i8 = and t68, Constant:i8<1>

Replacing.2 t71: i8 = and t68, Constant:i8<1>

With: t68: i8 = setcc t2, Constant:i32<3>, setlt:ch


Combining: t68: i8 = setcc t2, Constant:i32<3>, setlt:ch

Combining: t67: i32 = and t57, Constant:i32<-2>

Combining: t66: i32 = Constant<-2>

Combining: t57: i32 = add t4, t56

Combining: t56: i32 = srl t4, Constant:i64<31>

Combining: t54: i64 = Constant<31>

Combining: t48: ch = setlt

Combining: t47: i32 = Constant<3>

Combining: t46: ch = brcond t40, t68, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Combining: t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>

Combining: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>

Combining: t40: ch = TokenFactor t10, t15, t32, t36, t30:1

Combining: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Combining: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>

Combining: t35: f64 = Register %22

Combining: t32: ch = CopyToReg t0, Register:f64 %3, t30

Combining: t31: f64 = Register %3

Combining: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Combining: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Combining: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1

Combining: t27: Untyped = RegisterMask

Combining: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Combining: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1

Combining: t24: f64 = Register $xmm1

Combining: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17

Combining: t22: f64 = Register $xmm0

Combining: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t20: i64 = TargetConstant<0>

Combining: t19: f64 = ConstantFP<4.000000e+00>

Combining: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
Creating fp constant: t72: f64 = ConstantFP<-0.000000e+00>

Combining: t16: f64 = ConstantFP<0.000000e+00>

Combining: t15: ch = CopyToReg t0, Register:f64 %2, t13

Combining: t14: f64 = Register %2

Combining: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
Creating fp constant: t73: f64 = ConstantFP<-1.000000e+00>

Combining: t12: f64 = ConstantFP<1.000000e+00>

Combining: t11: f64 = sint_to_fp t67

Combining: t10: ch = CopyToReg t0, Register:i32 %1, t67

Combining: t9: i32 = Register %1

Combining: t4: i32 = or t2, Constant:i32<1>

Combining: t3: i32 = Constant<1>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t1: i32 = Register %0

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.2 'main:for.body'
SelectionDAG has 43 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %0
  t4: i32 = or t2, Constant:i32<1>
    t11: f64 = sint_to_fp t67
  t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
    t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
  t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
  t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
  t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
      t56: i32 = srl t4, Constant:i64<31>
    t57: i32 = add t4, t56
  t67: i32 = and t57, Constant:i32<-2>
        t10: ch = CopyToReg t0, Register:i32 %1, t67
        t15: ch = CopyToReg t0, Register:f64 %2, t13
        t32: ch = CopyToReg t0, Register:f64 %3, t30
        t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
      t40: ch = TokenFactor t10, t15, t32, t36, t30:1
      t68: i8 = setcc t2, Constant:i32<3>, setlt:ch
    t46: ch = brcond t40, t68, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
  t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>



Legalizing: t43: ch = br t46, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>
Legal node: nothing to do

Legalizing: t46: ch = brcond t40, t68, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Trying custom legalization
Creating new node: t74: i32,i32 = X86ISD::SUB t2, Constant:i32<3>
Creating constant: t75: i8 = TargetConstant<12>
Creating new node: t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1
Successfully custom legalized node
 ... replacing: t46: ch = brcond t40, t68, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
     with:      t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1

Legalizing: t40: ch = TokenFactor t10, t15, t32, t36, t30:1
Legal node: nothing to do

Legalizing: t32: ch = CopyToReg t0, Register:f64 %3, t30
Legal node: nothing to do

Legalizing: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal node: nothing to do

Legalizing: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Legalizing: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
Legal node: nothing to do

Legalizing: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t23:1
Legal node: nothing to do

Legalizing: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
Legal node: nothing to do

Legalizing: t15: ch = CopyToReg t0, Register:f64 %2, t13
Legal node: nothing to do

Legalizing: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
Trying custom legalization

Legalizing: t13: f64 = fdiv ConstantFP:f64<1.000000e+00>, t11
Legal node: nothing to do

Legalizing: t11: f64 = sint_to_fp t67
Trying custom legalization

Legalizing: t10: ch = CopyToReg t0, Register:i32 %1, t67
Legal node: nothing to do

Legalizing: t67: i32 = and t57, Constant:i32<-2>
Legal node: nothing to do

Legalizing: t57: i32 = add t4, t56
Legal node: nothing to do

Legalizing: t56: i32 = srl t4, Constant:i64<31>
Creating constant: t77: i8 = Constant<31>
Legal node: nothing to do

Legalizing: t4: i32 = or t2, Constant:i32<1>
Legal node: nothing to do

Legalizing: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Legalizing: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t66: i32 = Constant<-2>
Legal node: nothing to do

Legalizing: t47: i32 = Constant<3>
Legal node: nothing to do

Legalizing: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>
Legal node: nothing to do

Legalizing: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Legal node: nothing to do

Legalizing: t35: f64 = Register %22

Legalizing: t31: f64 = Register %3

Legalizing: t27: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal node: nothing to do

Legalizing: t24: f64 = Register $xmm1

Legalizing: t22: f64 = Register $xmm0

Legalizing: t20: i64 = TargetConstant<0>

Legalizing: t19: f64 = ConstantFP<4.000000e+00>
Trying to expand node
Creating new constant pool: t78: i64 = ConstantPool<double 4.000000e+00> 0
Creating new node: t79: i64 = undef
Creating new node: t80: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t19: f64 = ConstantFP<4.000000e+00>
     with:      t80: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64

Legalizing: t16: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Legalizing: t14: f64 = Register %2

Legalizing: t12: f64 = ConstantFP<1.000000e+00>
Trying to expand node
Creating new constant pool: t81: i64 = ConstantPool<double 1.000000e+00> 0
Creating new node: t82: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t12: f64 = ConstantFP<1.000000e+00>
     with:      t82: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64

Legalizing: t9: i32 = Register %1

Legalizing: t3: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t1: i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t82: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t81: i64 = ConstantPool<double 1.000000e+00> 0
Trying custom legalization
Creating new constant pool: t83: i64 = TargetConstantPool<double 1.000000e+00> 0
Creating new node: t84: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Successfully custom legalized node
 ... replacing: t81: i64 = ConstantPool<double 1.000000e+00> 0
     with:      t84: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t80: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t79: i64 = undef
Legal node: nothing to do

Legalizing: t78: i64 = ConstantPool<double 4.000000e+00> 0
Trying custom legalization
Creating new constant pool: t85: i64 = TargetConstantPool<double 4.000000e+00> 0
Creating new node: t86: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Successfully custom legalized node
 ... replacing: t78: i64 = ConstantPool<double 4.000000e+00> 0
     with:      t86: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t77: i8 = Constant<31>
Legal node: nothing to do

Legalizing: t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1
Legal node: nothing to do

Legalizing: t75: i8 = TargetConstant<12>

Legalizing: t74: i32,i32 = X86ISD::SUB t2, Constant:i32<3>
Legal node: nothing to do

Legalizing: t86: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t85: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t84: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Legalizing: t83: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.2 'main:for.body'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %0
  t4: i32 = or t2, Constant:i32<1>
      t56: i32 = srl t4, Constant:i8<31>
    t57: i32 = add t4, t56
  t67: i32 = and t57, Constant:i32<-2>
      t84: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
    t82: f64,ch = load<(load 8 from constant-pool)> t0, t84, undef:i64
    t11: f64 = sint_to_fp t67
  t13: f64 = fdiv t82, t11
    t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
  t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
      t86: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
    t80: f64,ch = load<(load 8 from constant-pool)> t0, t86, undef:i64
  t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1
  t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
        t10: ch = CopyToReg t0, Register:i32 %1, t67
        t15: ch = CopyToReg t0, Register:f64 %2, t13
        t32: ch = CopyToReg t0, Register:f64 %3, t30
        t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
      t40: ch = TokenFactor t10, t15, t32, t36, t30:1
      t74: i32,i32 = X86ISD::SUB t2, Constant:i32<3>
    t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1
  t43: ch = br t76, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>



Legalizing: t86: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t86: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t85: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t85: i64 = TargetConstantPool<double 4.000000e+00> 0

Legalizing: t84: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t84: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t83: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t83: i64 = TargetConstantPool<double 1.000000e+00> 0

Legalizing: t82: f64,ch = load<(load 8 from constant-pool)> t0, t84, undef:i64
Legalizing non-extending load operation

Combining: t82: f64,ch = load<(load 8 from constant-pool)> t0, t84, undef:i64

Legalizing: t80: f64,ch = load<(load 8 from constant-pool)> t0, t86, undef:i64
Legalizing non-extending load operation

Combining: t80: f64,ch = load<(load 8 from constant-pool)> t0, t86, undef:i64

Legalizing: t79: i64 = undef
Legal node: nothing to do

Combining: t79: i64 = undef

Legalizing: t77: i8 = Constant<31>
Legal node: nothing to do

Combining: t77: i8 = Constant<31>

Legalizing: t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1
Legal node: nothing to do

Combining: t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1

Legalizing: t75: i8 = TargetConstant<12>

Combining: t75: i8 = TargetConstant<12>

Legalizing: t74: i32,i32 = X86ISD::SUB t2, Constant:i32<3>
Legal node: nothing to do

Combining: t74: i32,i32 = X86ISD::SUB t2, Constant:i32<3>

Legalizing: t43: ch = br t76, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>
Legal node: nothing to do

Combining: t43: ch = br t76, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>

Legalizing: t40: ch = TokenFactor t10, t15, t32, t36, t30:1
Legal node: nothing to do

Combining: t40: ch = TokenFactor t10, t15, t32, t36, t30:1

Legalizing: t32: ch = CopyToReg t0, Register:f64 %3, t30
Legal node: nothing to do

Combining: t32: ch = CopyToReg t0, Register:f64 %3, t30

Legalizing: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
Legal node: nothing to do

Combining: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

Legalizing: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Combining: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1

Legalizing: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
Legal node: nothing to do

Combining: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1

Legalizing: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1
Legal node: nothing to do

Combining: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1

Legalizing: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
Legal node: nothing to do

Combining: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17

Legalizing: t15: ch = CopyToReg t0, Register:f64 %2, t13
Legal node: nothing to do

Combining: t15: ch = CopyToReg t0, Register:f64 %2, t13

Legalizing: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
Trying custom legalization

Combining: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>

Legalizing: t13: f64 = fdiv t82, t11
Legal node: nothing to do

Combining: t13: f64 = fdiv t82, t11

Legalizing: t11: f64 = sint_to_fp t67
Trying custom legalization

Combining: t11: f64 = sint_to_fp t67

Legalizing: t10: ch = CopyToReg t0, Register:i32 %1, t67
Legal node: nothing to do

Combining: t10: ch = CopyToReg t0, Register:i32 %1, t67

Legalizing: t67: i32 = and t57, Constant:i32<-2>
Legal node: nothing to do

Combining: t67: i32 = and t57, Constant:i32<-2>

Legalizing: t57: i32 = add t4, t56
Legal node: nothing to do

Combining: t57: i32 = add t4, t56

Legalizing: t56: i32 = srl t4, Constant:i8<31>
Legal node: nothing to do

Combining: t56: i32 = srl t4, Constant:i8<31>

Legalizing: t4: i32 = or t2, Constant:i32<1>
Legal node: nothing to do

Combining: t4: i32 = or t2, Constant:i32<1>

Legalizing: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Combining: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>

Legalizing: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t66: i32 = Constant<-2>
Legal node: nothing to do

Combining: t66: i32 = Constant<-2>

Legalizing: t47: i32 = Constant<3>
Legal node: nothing to do

Combining: t47: i32 = Constant<3>

Legalizing: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>
Legal node: nothing to do

Combining: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>

Legalizing: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>
Legal node: nothing to do

Combining: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

Legalizing: t35: f64 = Register %22

Combining: t35: f64 = Register %22

Legalizing: t31: f64 = Register %3

Combining: t31: f64 = Register %3

Legalizing: t27: Untyped = RegisterMask
Legal node: nothing to do

Combining: t27: Untyped = RegisterMask

Legalizing: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal node: nothing to do

Combining: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Legalizing: t24: f64 = Register $xmm1

Combining: t24: f64 = Register $xmm1

Legalizing: t22: f64 = Register $xmm0

Combining: t22: f64 = Register $xmm0

Legalizing: t20: i64 = TargetConstant<0>

Combining: t20: i64 = TargetConstant<0>

Legalizing: t16: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Combining: t16: f64 = ConstantFP<0.000000e+00>

Legalizing: t14: f64 = Register %2

Combining: t14: f64 = Register %2

Legalizing: t9: i32 = Register %1

Combining: t9: i32 = Register %1

Legalizing: t3: i32 = Constant<1>
Legal node: nothing to do

Combining: t3: i32 = Constant<1>

Legalizing: t1: i32 = Register %0

Combining: t1: i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.2 'main:for.body'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %0
  t4: i32 = or t2, Constant:i32<1>
      t56: i32 = srl t4, Constant:i8<31>
    t57: i32 = add t4, t56
  t67: i32 = and t57, Constant:i32<-2>
      t84: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
    t82: f64,ch = load<(load 8 from constant-pool)> t0, t84, undef:i64
    t11: f64 = sint_to_fp t67
  t13: f64 = fdiv t82, t11
    t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
  t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17
      t86: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
    t80: f64,ch = load<(load 8 from constant-pool)> t0, t86, undef:i64
  t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1
  t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
  t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
  t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1
        t10: ch = CopyToReg t0, Register:i32 %1, t67
        t15: ch = CopyToReg t0, Register:f64 %2, t13
        t32: ch = CopyToReg t0, Register:f64 %3, t30
        t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>
      t40: ch = TokenFactor t10, t15, t32, t36, t30:1
      t74: i32,i32 = X86ISD::SUB t2, Constant:i32<3>
    t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1
  t43: ch = br t76, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>


===== Instruction selection begins: %bb.2 'for.body'

ISEL: Starting selection on root node: t43: ch = br t76, BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t43: ch = JMP_1 BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>, t76
ISEL: Match complete!

ISEL: Starting selection on root node: t76: ch = X86ISD::BRCOND t40, BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t74:1
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t88: ch,glue = CopyToReg t40, Register:i32 $eflags, t74:1
  Morphed node: t76: ch = JCC_1 BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t88, t88:1
ISEL: Match complete!

ISEL: Starting selection on root node: t40: ch = TokenFactor t10, t15, t32, t36, t30:1

ISEL: Starting selection on root node: t32: ch = CopyToReg t0, Register:f64 %3, t30

ISEL: Starting selection on root node: t30: f64,ch,glue = CopyFromReg t29, Register:f64 $xmm0, t29:1

ISEL: Starting selection on root node: t29: ch,glue = callseq_end t28, TargetConstant:i64<0>, TargetConstant:i64<0>, t28:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1
ISEL: Match complete!

ISEL: Starting selection on root node: t28: ch,glue = X86ISD::CALL t25, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t28: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25, t25:1
ISEL: Match complete!

ISEL: Starting selection on root node: t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1

ISEL: Starting selection on root node: t23: ch,glue = CopyToReg t21, Register:f64 $xmm0, t17

ISEL: Starting selection on root node: t15: ch = CopyToReg t0, Register:f64 %2, t13

ISEL: Starting selection on root node: t17: f64 = fadd t13, ConstantFP:f64<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t17: f64 = ADDSDrr nofpexcept t13, ConstantFP:f64<0.000000e+00>
ISEL: Match complete!

ISEL: Starting selection on root node: t13: f64 = fdiv t82, t11
ISEL: Starting pattern match
  Initial Opcode index to 157809
  Match failed at index 157814
  Continuing at 158106
  OpcodeSwitch from 158109 to 158114
  TypeSwitch[f64] from 158126 to 158150
  Match failed at index 158150
  Continuing at 158170
  Match failed at index 158171
  Continuing at 158246
  Continuing at 158410
  Match failed at index 158417
  Continuing at 158553
  TypeSwitch[f64] from 158555 to 158607
  Skipped scope entry (due to false predicate) at index 158609, continuing at 158620
  Skipped scope entry (due to false predicate) at index 158621, continuing at 158631
  Morphed node: t13: f64 = DIVSDrr nofpexcept t82, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t11: f64 = sint_to_fp t67
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t11: f64 = CVTSI2SDrr t67
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = CopyToReg t0, Register:i32 %1, t67

ISEL: Starting selection on root node: t67: i32 = and t57, Constant:i32<-2>
ISEL: Starting pattern match
  Initial Opcode index to 44172
  Match failed at index 44176
  Continuing at 44491
  Match failed at index 44494
  Continuing at 44597
  OpcodeSwitch from 44600 to 44804
  Skipped scope entry (due to false predicate) at index 44807, continuing at 44854
  Skipped scope entry (due to false predicate) at index 44855, continuing at 44911
  Match failed at index 44805
  Continuing at 44913
  Match failed at index 44917
  Continuing at 45047
  Match failed at index 45050
  Continuing at 45183
  Match failed at index 45184
  Continuing at 45256
  Match failed at index 45257
  Continuing at 45292
  Match failed at index 45295
  Continuing at 45407
  OpcodeSwitch from 45409 to 45413
  Skipped scope entry (due to false predicate) at index 45416, continuing at 45456
  Skipped scope entry (due to false predicate) at index 45457, continuing at 45488
  Match failed at index 45414
  Continuing at 45525
  Match failed at index 45528
  Continuing at 45635
  Match failed at index 45637
  Continuing at 45745
  Match failed at index 45746
  Continuing at 45771
  Match failed at index 45772
  Continuing at 45829
  Match failed at index 45830
  Continuing at 45872
  Match failed at index 45873
  Continuing at 45913
  Match failed at index 45914
  Continuing at 45953
  Skipped scope entry (due to false predicate) at index 45963, continuing at 45984
  Skipped scope entry (due to false predicate) at index 45985, continuing at 46030
  Skipped scope entry (due to false predicate) at index 46031, continuing at 46076
  Skipped scope entry (due to false predicate) at index 46077, continuing at 46098
  Match failed at index 46102
  Continuing at 46115
Creating constant: t89: i32 = TargetConstant<-2>
  Morphed node: t67: i32,i32 = AND32ri8 t57, TargetConstant:i32<-2>
ISEL: Match complete!

ISEL: Starting selection on root node: t57: i32 = add t4, t56
ISEL: Starting pattern match
  Initial Opcode index to 97341
  Match failed at index 97345
  Continuing at 97448
  Match failed at index 97450
  Continuing at 97557
  TypeSwitch[i32] from 97559 to 97562
  Skipped scope entry (due to false predicate) at index 97564, continuing at 97580
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg t4: i32 = or t2, Constant:i32<1>
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 97583
  Continuing at 97597
  Continuing at 97615
  Match failed at index 97618
  Continuing at 97639
  Match failed at index 97641
  Continuing at 97663
  Skipped scope entry (due to false predicate) at index 97668, continuing at 97720
  Skipped scope entry (due to false predicate) at index 97721, continuing at 97782
  Skipped scope entry (due to false predicate) at index 97783, continuing at 97857
  Skipped scope entry (due to false predicate) at index 97858, continuing at 97887
  Match failed at index 97893
  Continuing at 98009
  Match failed at index 98010
  Continuing at 98021
  Match failed at index 98022
  Continuing at 98033
  Morphed node: t57: i32,i32 = ADD32rr t4, t56
ISEL: Match complete!

ISEL: Starting selection on root node: t56: i32 = srl t4, Constant:i8<31>
ISEL: Starting pattern match
  Initial Opcode index to 42373
  Match failed at index 42377
  Continuing at 42633
  Match failed at index 42640
  Continuing at 42783
  Match failed at index 42784
  Continuing at 42830
  Match failed at index 42831
  Continuing at 42866
  TypeSwitch[i32] from 42878 to 42907
Creating constant: t91: i8 = TargetConstant<31>
  Morphed node: t56: i32,i32 = SHR32ri t4, TargetConstant:i8<31>
ISEL: Match complete!

ISEL: Starting selection on root node: t80: f64,ch = load<(load 8 from constant-pool)> t0, t86, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t93: i8 = TargetConstant<1>
Creating new constant pool: t95: i32 = TargetConstantPool<double 4.000000e+00> 0
  Morphed node: t80: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t82: f64,ch = load<(load 8 from constant-pool)> t0, t84, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t97: i32 = TargetConstantPool<double 1.000000e+00> 0
  Morphed node: t82: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32 = or t2, Constant:i32<1>
ISEL: Starting pattern match
  Initial Opcode index to 102491
  Match failed at index 102495
  Continuing at 102598
  Match failed at index 102600
  Continuing at 102707
  Match failed at index 102710
  Continuing at 102760
  Match failed at index 102763
  Continuing at 103022
  TypeSwitch[i32] from 103024 to 103027
  Skipped scope entry (due to false predicate) at index 103029, continuing at 103045
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 103048
  Continuing at 103062
  Continuing at 103080
  Match failed at index 103083
  Continuing at 103204
  Match failed at index 103206
  Continuing at 103330
  Match failed at index 103333
  Continuing at 103454
  Match failed at index 103456
  Continuing at 103581
  Match failed at index 103584
  Continuing at 103682
  Match failed at index 103684
  Continuing at 103783
  Match failed at index 103799
  Continuing at 103814
  Match failed at index 103818
  Continuing at 103833
  Match failed at index 103837
  Continuing at 103852
  Match failed at index 103856
  Continuing at 103871
  Match failed at index 103872
  Continuing at 103893
  Match failed at index 103895
  Continuing at 103938
  Match failed at index 103942
  Continuing at 103955
Creating constant: t98: i32 = TargetConstant<1>
  Morphed node: t4: i32,i32 = OR32ri8 t2, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t74: i32,i32 = X86ISD::SUB t2, Constant:i32<3>
ISEL: Starting pattern match
  Initial Opcode index to 89092
  Match failed at index 89099
  Continuing at 89202
  Match failed at index 89203
  Continuing at 89249
  Match failed at index 89250
  Continuing at 89313
  Continuing at 89314
  Match failed at index 89315
  Continuing at 89360
  Match failed at index 89379
  Continuing at 89392
  Match failed at index 89398
  Continuing at 89411
Creating constant: t99: i32 = TargetConstant<3>
  Morphed node: t74: i32,i32 = SUB32ri8 t2, TargetConstant:i32<3>
ISEL: Match complete!

ISEL: Starting selection on root node: t36: ch = CopyToReg t0, Register:f64 %22, ConstantFP:f64<0.000000e+00>

ISEL: Starting selection on root node: t21: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t100: i32 = TargetConstant<0>
  Morphed node: t21: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t75: i8 = TargetConstant<12>

ISEL: Starting selection on root node: t42: ch = BasicBlock<for.body.i.preheader 0x7fffc1df54c8>

ISEL: Starting selection on root node: t39: ch = BasicBlock<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>

ISEL: Starting selection on root node: t35: f64 = Register %22

ISEL: Starting selection on root node: t31: f64 = Register %3

ISEL: Starting selection on root node: t27: Untyped = RegisterMask

ISEL: Starting selection on root node: t26: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

ISEL: Starting selection on root node: t24: f64 = Register $xmm1

ISEL: Starting selection on root node: t22: f64 = Register $xmm0

ISEL: Starting selection on root node: t20: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t16: f64 = ConstantFP<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 195000
  TypeSwitch[f64] from 195000 to 195094
  Match failed at index 195098
  Continuing at 195107
  Match failed at index 195108
  Continuing at 195119
  Morphed node: t16: f64 = FsFLD0SD
ISEL: Match complete!

ISEL: Starting selection on root node: t14: f64 = Register %2

ISEL: Starting selection on root node: t9: i32 = Register %1

ISEL: Starting selection on root node: t1: i32 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 'main:for.body'
SelectionDAG has 53 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %0
  t4: i32,i32 = OR32ri8 t2, TargetConstant:i32<1>
      t56: i32,i32 = SHR32ri t4, TargetConstant:i8<31>
    t57: i32,i32 = ADD32rr t4, t56
  t67: i32,i32 = AND32ri8 t57, TargetConstant:i32<-2>
    t82: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
    t11: f64 = CVTSI2SDrr t67
  t13: f64 = DIVSDrr nofpexcept t82, t11
    t21: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t17: f64 = ADDSDrr nofpexcept t13, FsFLD0SD:f64
  t23: ch,glue = CopyToReg t21:1, Register:f64 $xmm0, t17
    t80: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
  t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1
  t28: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25, t25:1
  t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1
  t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2
      t10: ch = CopyToReg t0, Register:i32 %1, t67
      t15: ch = CopyToReg t0, Register:f64 %2, t13
      t32: ch = CopyToReg t0, Register:f64 %3, t30
      t36: ch = CopyToReg t0, Register:f64 %22, FsFLD0SD:f64
    t40: ch = TokenFactor t10, t15, t32, t36, t30:1
    t74: i32,i32 = SUB32ri8 t2, TargetConstant:i32<3>
  t88: ch,glue = CopyToReg t40, Register:i32 $eflags, t74:1
  t90: i32 = Register $noreg
    t76: ch = JCC_1 BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t88, t88:1
  t43: ch = JMP_1 BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>, t76


********** List Scheduling %bb.2 'for.body' **********
SU(0): t43: ch = JMP_1 BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>, t76

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 11
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t76: ch = JCC_1 BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t88, t88:1

    t88: ch,glue = CopyToReg t40, Register:i32 $eflags, t74:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t74: i32,i32 = SUB32ri8 t2, TargetConstant:i32<3>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 11
  Successors:
    SU(2): Data Latency=1
    SU(14): Data Latency=1
SU(4): t40: ch = TokenFactor t10, t15, t32, t36, t30:1

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 10
  Height             : 1
  Predecessors:
    SU(20): Ord  Latency=1 Barrier
    SU(19): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t23: ch,glue = CopyToReg t21:1, Register:f64 $xmm0, t17

    t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1

    t28: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25, t25:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(18): Data Latency=1
SU(6): t80: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(7): t17: f64 = ADDSDrr nofpexcept t13, FsFLD0SD:f64

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 4
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(8): t16: f64 = FsFLD0SD

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(7): Data Latency=1
    SU(17): Data Latency=1
SU(9): t13: f64 = DIVSDrr nofpexcept t82, t11

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 5
  Predecessors:
    SU(15): Data Latency=1
    SU(10): Data Latency=1
  Successors:
    SU(7): Data Latency=1
    SU(19): Data Latency=1
SU(10): t11: f64 = CVTSI2SDrr t67

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 6
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(9): Data Latency=1
SU(11): t67: i32,i32 = AND32ri8 t57, TargetConstant:i32<-2>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 7
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(10): Data Latency=1
    SU(20): Data Latency=1
SU(12): t57: i32,i32 = ADD32rr t4, t56

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 8
  Predecessors:
    SU(14): Data Latency=1
    SU(13): Data Latency=1
  Successors:
    SU(11): Data Latency=1
SU(13): t56: i32,i32 = SHR32ri t4, TargetConstant:i8<31>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 9
  Predecessors:
    SU(14): Data Latency=1
  Successors:
    SU(12): Data Latency=1
SU(14): t4: i32,i32 = OR32ri8 t2, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 10
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(12): Data Latency=1
    SU(13): Data Latency=1
SU(15): t82: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(9): Data Latency=1
SU(16): t21: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(17): t36: ch = CopyToReg t0, Register:f64 %22, FsFLD0SD:f64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(18): t32: ch = CopyToReg t0, Register:f64 %3, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 2
  Predecessors:
    SU(9): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t43: ch = JMP_1 BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>, t76


*** Scheduling [0]: SU(0): t43: ch = JMP_1 BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>, t76


Examining Available:
Height 1: SU(1): t76: ch = JCC_1 BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t88, t88:1

    t88: ch,glue = CopyToReg t40, Register:i32 $eflags, t74:1


*** Scheduling [1]: SU(1): t76: ch = JCC_1 BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t88, t88:1

    t88: ch,glue = CopyToReg t40, Register:i32 $eflags, t74:1


Examining Available:
Height 1: SU(4): t40: ch = TokenFactor t10, t15, t32, t36, t30:1

Height 2: SU(2): t74: i32,i32 = SUB32ri8 t2, TargetConstant:i32<3>


*** Scheduling [2]: SU(4): t40: ch = TokenFactor t10, t15, t32, t36, t30:1


Examining Available:
  SU (2)  defines a physreg SU(17)  has no physreg
Height 2: SU(2): t74: i32,i32 = SUB32ri8 t2, TargetConstant:i32<3>

Height 3: SU(17): t36: ch = CopyToReg t0, Register:f64 %22, FsFLD0SD:f64

Height 3: SU(18): t32: ch = CopyToReg t0, Register:f64 %3, t30

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67

  SU (2)  defines a physreg SU(17)  has no physreg

*** Scheduling [3]: SU(2): t74: i32,i32 = SUB32ri8 t2, TargetConstant:i32<3>


Examining Available:
Height 3: SU(17): t36: ch = CopyToReg t0, Register:f64 %22, FsFLD0SD:f64

Height 3: SU(18): t32: ch = CopyToReg t0, Register:f64 %3, t30

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [4]: SU(17): t36: ch = CopyToReg t0, Register:f64 %22, FsFLD0SD:f64


Examining Available:
Height 3: SU(18): t32: ch = CopyToReg t0, Register:f64 %3, t30

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [5]: SU(18): t32: ch = CopyToReg t0, Register:f64 %3, t30


Examining Available:
Height 6: SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t23: ch,glue = CopyToReg t21:1, Register:f64 $xmm0, t17

    t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1

    t28: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25, t25:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [6]: SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t23: ch,glue = CopyToReg t21:1, Register:f64 $xmm0, t17

    t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1

    t28: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25, t25:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1


Examining Available:
Height 7: SU(6): t80: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

Height 7: SU(16): t21: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 7: SU(7): t17: f64 = ADDSDrr nofpexcept t13, FsFLD0SD:f64

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [7]: SU(6): t80: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 7: SU(16): t21: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 7: SU(7): t17: f64 = ADDSDrr nofpexcept t13, FsFLD0SD:f64

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [8]: SU(16): t21: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


Examining Available:
Height 7: SU(7): t17: f64 = ADDSDrr nofpexcept t13, FsFLD0SD:f64

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [9]: SU(7): t17: f64 = ADDSDrr nofpexcept t13, FsFLD0SD:f64


Examining Available:
Height 10: SU(8): t16: f64 = FsFLD0SD

Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [10]: SU(8): t16: f64 = FsFLD0SD


Examining Available:
Height 3: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [11]: SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13


Examining Available:
Height 12: SU(9): t13: f64 = DIVSDrr nofpexcept t82, t11

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [12]: SU(9): t13: f64 = DIVSDrr nofpexcept t82, t11


Examining Available:
Height 13: SU(15): t82: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

Height 13: SU(10): t11: f64 = CVTSI2SDrr t67

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [13]: SU(15): t82: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 13: SU(10): t11: f64 = CVTSI2SDrr t67

Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [14]: SU(10): t11: f64 = CVTSI2SDrr t67


Examining Available:
Height 3: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


*** Scheduling [15]: SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67


Examining Available:
Height 16: SU(11): t67: i32,i32 = AND32ri8 t57, TargetConstant:i32<-2>


*** Scheduling [16]: SU(11): t67: i32,i32 = AND32ri8 t57, TargetConstant:i32<-2>


Examining Available:
Height 17: SU(12): t57: i32,i32 = ADD32rr t4, t56


*** Scheduling [17]: SU(12): t57: i32,i32 = ADD32rr t4, t56


Examining Available:
Height 18: SU(13): t56: i32,i32 = SHR32ri t4, TargetConstant:i8<31>


*** Scheduling [18]: SU(13): t56: i32,i32 = SHR32ri t4, TargetConstant:i8<31>


Examining Available:
Height 19: SU(14): t4: i32,i32 = OR32ri8 t2, TargetConstant:i32<1>


*** Scheduling [19]: SU(14): t4: i32,i32 = OR32ri8 t2, TargetConstant:i32<1>


Examining Available:
Height 20: SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %0


*** Scheduling [20]: SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %0

*** Final schedule ***
SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %0

SU(14): t4: i32,i32 = OR32ri8 t2, TargetConstant:i32<1>

SU(13): t56: i32,i32 = SHR32ri t4, TargetConstant:i8<31>

SU(12): t57: i32,i32 = ADD32rr t4, t56

SU(11): t67: i32,i32 = AND32ri8 t57, TargetConstant:i32<-2>

SU(20): t10: ch = CopyToReg t0, Register:i32 %1, t67

SU(10): t11: f64 = CVTSI2SDrr t67

SU(15): t82: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

SU(9): t13: f64 = DIVSDrr nofpexcept t82, t11

SU(19): t15: ch = CopyToReg t0, Register:f64 %2, t13

SU(8): t16: f64 = FsFLD0SD

SU(7): t17: f64 = ADDSDrr nofpexcept t13, FsFLD0SD:f64

SU(16): t21: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(6): t80: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

SU(5): t30: f64,ch,glue = CopyFromReg t29:1, Register:f64 $xmm0, t29:2

    t23: ch,glue = CopyToReg t21:1, Register:f64 $xmm0, t17

    t25: ch,glue = CopyToReg t23, Register:f64 $xmm1, t80, t23:1

    t28: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t25, t25:1

    t29: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t28, t28:1

SU(18): t32: ch = CopyToReg t0, Register:f64 %3, t30

SU(17): t36: ch = CopyToReg t0, Register:f64 %22, FsFLD0SD:f64

SU(2): t74: i32,i32 = SUB32ri8 t2, TargetConstant:i32<3>

SU(4): t40: ch = TokenFactor t10, t15, t32, t36, t30:1

SU(1): t76: ch = JCC_1 BasicBlock:ch<_Z7simpsonPFddEddi.exit 0x7fffc1df58f0>, TargetConstant:i8<12>, t88, t88:1

    t88: ch,glue = CopyToReg t40, Register:i32 $eflags, t74:1

SU(0): t43: ch = JMP_1 BasicBlock:ch<for.body.i.preheader 0x7fffc1df54c8>, t76


Total amount of phi nodes to update: 2
Node 0 : (0x7fffc1df59c8, 2147483670)
Node 1 : (0x7fffc1df5a30, 2147483651)
Creating fp constant: t1: f64 = ConstantFP<3.000000e+00>
Creating new node: t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>
Creating constant: t4: i32 = Constant<2>
Creating new node: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
Creating fp constant: t7: f64 = ConstantFP<0.000000e+00>
Creating new node: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
Creating new node: t10: ch = TokenFactor t3, t6, t9
Initial selection DAG: %bb.3 'main:for.body.i.preheader'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>
    t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9



Combining: t10: ch = TokenFactor t3, t6, t9

Combining: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>

Combining: t8: f64 = Register %34

Combining: t7: f64 = ConstantFP<0.000000e+00>

Combining: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>

Combining: t5: i32 = Register %33

Combining: t4: i32 = Constant<2>

Combining: t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>

Combining: t2: f64 = Register %32

Combining: t1: f64 = ConstantFP<3.000000e+00>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.3 'main:for.body.i.preheader'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>
    t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9


Legalizing node: t8: f64 = Register %34
Ignoring node results
Legally typed node: t8: f64 = Register %34

Legalizing node: t7: f64 = ConstantFP<0.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t7: f64 = ConstantFP<0.000000e+00>

Legalizing node: t5: i32 = Register %33
Ignoring node results
Legally typed node: t5: i32 = Register %33

Legalizing node: t4: i32 = Constant<2>
Analyzing result type: i32
Legal result type
Legally typed node: t4: i32 = Constant<2>

Legalizing node: t2: f64 = Register %32
Ignoring node results
Legally typed node: t2: f64 = Register %32

Legalizing node: t1: f64 = ConstantFP<3.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t1: f64 = ConstantFP<3.000000e+00>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: f64 = ConstantFP<3.000000e+00>
Legal operand
Legally typed node: t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>

Legalizing node: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t4: i32 = Constant<2>
Legal operand
Legally typed node: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>

Legalizing node: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: f64 = ConstantFP<0.000000e+00>
Legal operand
Legally typed node: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>

Legalizing node: t10: ch = TokenFactor t3, t6, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>
Legal operand
Analyzing operand: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
Legal operand
Analyzing operand: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
Legal operand
Legally typed node: t10: ch = TokenFactor t3, t6, t9

Legalizing node: t65535: ch = handlenode t10
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = TokenFactor t3, t6, t9
Legal operand
Legally typed node: t65535: ch = handlenode t10

Type-legalized selection DAG: %bb.3 'main:for.body.i.preheader'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
    t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>
    t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9



Legalizing: t10: ch = TokenFactor t3, t6, t9
Legal node: nothing to do

Legalizing: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Legalizing: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
Legal node: nothing to do

Legalizing: t3: ch = CopyToReg t0, Register:f64 %32, ConstantFP:f64<3.000000e+00>
Legal node: nothing to do

Legalizing: t8: f64 = Register %34

Legalizing: t7: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Legalizing: t5: i32 = Register %33

Legalizing: t4: i32 = Constant<2>
Legal node: nothing to do

Legalizing: t2: f64 = Register %32

Legalizing: t1: f64 = ConstantFP<3.000000e+00>
Trying to expand node
Creating new constant pool: t11: i64 = ConstantPool<double 3.000000e+00> 0
Creating new node: t12: i64 = undef
Creating new node: t13: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t1: f64 = ConstantFP<3.000000e+00>
     with:      t13: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t13: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t12: i64 = undef
Legal node: nothing to do

Legalizing: t11: i64 = ConstantPool<double 3.000000e+00> 0
Trying custom legalization
Creating new constant pool: t14: i64 = TargetConstantPool<double 3.000000e+00> 0
Creating new node: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Successfully custom legalized node
 ... replacing: t11: i64 = ConstantPool<double 3.000000e+00> 0
     with:      t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Legalizing: t14: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.3 'main:for.body.i.preheader'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
        t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
    t3: ch = CopyToReg t0, Register:f64 %32, t13
    t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9



Legalizing: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t14: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t14: i64 = TargetConstantPool<double 3.000000e+00> 0

Legalizing: t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
Legalizing non-extending load operation

Combining: t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64

Legalizing: t12: i64 = undef
Legal node: nothing to do

Combining: t12: i64 = undef

Legalizing: t10: ch = TokenFactor t3, t6, t9
Legal node: nothing to do

Combining: t10: ch = TokenFactor t3, t6, t9

Legalizing: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
Legal node: nothing to do

Combining: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>

Legalizing: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
Legal node: nothing to do

Combining: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>

Legalizing: t3: ch = CopyToReg t0, Register:f64 %32, t13
Legal node: nothing to do

Combining: t3: ch = CopyToReg t0, Register:f64 %32, t13

Legalizing: t8: f64 = Register %34

Combining: t8: f64 = Register %34

Legalizing: t7: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Combining: t7: f64 = ConstantFP<0.000000e+00>

Legalizing: t5: i32 = Register %33

Combining: t5: i32 = Register %33

Legalizing: t4: i32 = Constant<2>
Legal node: nothing to do

Combining: t4: i32 = Constant<2>

Legalizing: t2: f64 = Register %32

Combining: t2: f64 = Register %32

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.3 'main:for.body.i.preheader'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
        t15: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
    t3: ch = CopyToReg t0, Register:f64 %32, t13
    t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>
    t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>
  t10: ch = TokenFactor t3, t6, t9


===== Instruction selection begins: %bb.3 'for.body.i.preheader'

ISEL: Starting selection on root node: t10: ch = TokenFactor t3, t6, t9

ISEL: Starting selection on root node: t3: ch = CopyToReg t0, Register:f64 %32, t13

ISEL: Starting selection on root node: t13: f64,ch = load<(load 8 from constant-pool)> t0, t15, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t17: i8 = TargetConstant<1>
Creating new constant pool: t19: i32 = TargetConstantPool<double 3.000000e+00> 0
  Morphed node: t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch = CopyToReg t0, Register:f64 %34, ConstantFP:f64<0.000000e+00>

ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:i32 %33, Constant:i32<2>

ISEL: Starting selection on root node: t8: f64 = Register %34

ISEL: Starting selection on root node: t7: f64 = ConstantFP<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 195000
  TypeSwitch[f64] from 195000 to 195094
  Match failed at index 195098
  Continuing at 195107
  Match failed at index 195108
  Continuing at 195119
  Morphed node: t7: f64 = FsFLD0SD
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i32 = Register %33

ISEL: Starting selection on root node: t4: i32 = Constant<2>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i32] from 124159 to 124162
  Match failed at index 124166
  Continuing at 124177
Creating constant: t21: i32 = TargetConstant<2>
  Morphed node: t4: i32 = MOV32ri TargetConstant:i32<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t2: f64 = Register %32

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.3 'main:for.body.i.preheader'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
      t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
    t3: ch = CopyToReg t0, Register:f64 %32, t13
      t4: i32 = MOV32ri TargetConstant:i32<2>
    t6: ch = CopyToReg t0, Register:i32 %33, t4
    t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64
  t10: ch = TokenFactor t3, t6, t9


********** List Scheduling %bb.3 'for.body.i.preheader' **********
SU(0): t10: ch = TokenFactor t3, t6, t9

  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t7: f64 = FsFLD0SD

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t6: ch = CopyToReg t0, Register:i32 %33, t4

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(3): Data Latency=1
SU(5): t3: ch = CopyToReg t0, Register:f64 %32, t13

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t10: ch = TokenFactor t3, t6, t9


*** Scheduling [0]: SU(0): t10: ch = TokenFactor t3, t6, t9


Examining Available:
Height 1: SU(5): t3: ch = CopyToReg t0, Register:f64 %32, t13

Height 1: SU(3): t6: ch = CopyToReg t0, Register:i32 %33, t4

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64


*** Scheduling [1]: SU(5): t3: ch = CopyToReg t0, Register:f64 %32, t13


Examining Available:
Height 2: SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

Height 1: SU(3): t6: ch = CopyToReg t0, Register:i32 %33, t4

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64


*** Scheduling [2]: SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 1: SU(3): t6: ch = CopyToReg t0, Register:i32 %33, t4

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64


*** Scheduling [3]: SU(3): t6: ch = CopyToReg t0, Register:i32 %33, t4


Examining Available:
Height 4: SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>

Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64


*** Scheduling [4]: SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>


Examining Available:
Height 1: SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64


*** Scheduling [5]: SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64


Examining Available:
Height 6: SU(2): t7: f64 = FsFLD0SD


*** Scheduling [6]: SU(2): t7: f64 = FsFLD0SD

*** Final schedule ***
SU(2): t7: f64 = FsFLD0SD

SU(1): t9: ch = CopyToReg t0, Register:f64 %34, FsFLD0SD:f64

SU(4): t4: i32 = MOV32ri TargetConstant:i32<2>

SU(3): t6: ch = CopyToReg t0, Register:i32 %33, t4

SU(6): t13: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

SU(5): t3: ch = CopyToReg t0, Register:f64 %32, t13

SU(0): t10: ch = TokenFactor t3, t6, t9


Total amount of phi nodes to update: 4
Node 0 : (0x7fffc1df5678, 2147483680)
Node 1 : (0x7fffc1df56e0, 2147483681)
Node 2 : (0x7fffc1df5748, 2147483651)
Node 3 : (0x7fffc1df57b0, 2147483682)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %5
Creating new node: t3: f64 = sint_to_fp t2
Creating new node: t5: f64,ch = CopyFromReg t0, Register:f64 %2
Creating new node: t6: f64 = fmul t5, t3
Creating fp constant: t7: f64 = ConstantFP<0.000000e+00>
Creating new node: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
Creating fp constant: t10: f64 = ConstantFP<4.000000e+00>
Creating constant: t11: i64 = TargetConstant<0>
Creating new node: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
Creating new node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
Creating new node: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
Creating new node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Creating new node: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
Creating new node: t23: f64,ch = CopyFromReg t0, Register:f64 %7
Creating new node: t24: f64 = fadd t23, t21
Creating new node: t26: ch = CopyToReg t0, Register:f64 %8, t24
Creating new node: t28: f64,ch = CopyFromReg t0, Register:f64 %4
Creating new node: t29: f64 = fmul t5, t28
Creating new node: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
Creating new node: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
Creating new node: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
Creating new node: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
Creating new node: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
Creating new node: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
Creating new node: t38: f64,ch = CopyFromReg t0, Register:f64 %6
Creating new node: t39: f64 = fadd t38, t36
Creating new node: t41: ch = CopyToReg t0, Register:f64 %9, t39
Creating constant: t42: i32 = Constant<2>
Creating new node: t43: i32 = add nuw nsw t2, Constant:i32<2>
Creating new node: t45: ch = CopyToReg t0, Register:i32 %10, t43
Creating fp constant: t46: f64 = ConstantFP<2.000000e+00>
Creating new node: t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
Creating new node: t49: ch = CopyToReg t0, Register:f64 %11, t47
Creating new node: t51: i32,ch = CopyFromReg t0, Register:i32 %1
Creating new node: t53: i1 = setcc t43, t51, setlt:ch
Creating new node: t55: ch = TokenFactor t26, t41, t45, t49, t36:1
Creating new node: t56: ch = brcond t55, t53, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
Creating new node: t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>
Initial selection DAG: %bb.4 'main:for.body.i'
SelectionDAG has 59 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %5
  t5: f64,ch = CopyFromReg t0, Register:f64 %2
  t9: i64 = GlobalAddress<double (double, double)* @pow> 0
    t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
  t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
  t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
  t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
  t28: f64,ch = CopyFromReg t0, Register:f64 %4
    t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t29: f64 = fmul t5, t28
    t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
  t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
  t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
  t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
  t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
  t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
  t43: i32 = add nuw nsw t2, Constant:i32<2>
            t23: f64,ch = CopyFromReg t0, Register:f64 %7
          t24: f64 = fadd t23, t21
        t26: ch = CopyToReg t0, Register:f64 %8, t24
            t38: f64,ch = CopyFromReg t0, Register:f64 %6
          t39: f64 = fadd t38, t36
        t41: ch = CopyToReg t0, Register:f64 %9, t39
        t45: ch = CopyToReg t0, Register:i32 %10, t43
          t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
        t49: ch = CopyToReg t0, Register:f64 %11, t47
      t55: ch = TokenFactor t26, t41, t45, t49, t36:1
        t51: i32,ch = CopyFromReg t0, Register:i32 %1
      t53: i1 = setcc t43, t51, setlt:ch
    t56: ch = brcond t55, t53, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
  t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>



Combining: t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>

Combining: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>

Combining: t56: ch = brcond t55, t53, BasicBlock:ch<for.body.i 0x7fffc1df55a0>

Combining: t55: ch = TokenFactor t26, t41, t45, t49, t36:1

Combining: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>

Combining: t53: i1 = setcc t43, t51, setlt:ch

Combining: t52: ch = setlt

Combining: t51: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t50: i32 = Register %1

Combining: t49: ch = CopyToReg t0, Register:f64 %11, t47

Combining: t48: f64 = Register %11

Combining: t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
Creating fp constant: t59: f64 = ConstantFP<-2.000000e+00>

Combining: t46: f64 = ConstantFP<2.000000e+00>

Combining: t45: ch = CopyToReg t0, Register:i32 %10, t43

Combining: t44: i32 = Register %10

Combining: t43: i32 = add nuw nsw t2, Constant:i32<2>

Combining: t42: i32 = Constant<2>

Combining: t41: ch = CopyToReg t0, Register:f64 %9, t39

Combining: t40: f64 = Register %9

Combining: t39: f64 = fadd t38, t36

Combining: t38: f64,ch = CopyFromReg t0, Register:f64 %6

Combining: t37: f64 = Register %6

Combining: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1

Combining: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1

Combining: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1

Combining: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1

Combining: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30

Combining: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
Creating fp constant: t60: f64 = ConstantFP<-0.000000e+00>

Combining: t29: f64 = fmul t5, t28

Combining: t28: f64,ch = CopyFromReg t0, Register:f64 %4

Combining: t27: f64 = Register %4

Combining: t26: ch = CopyToReg t0, Register:f64 %8, t24

Combining: t25: f64 = Register %8

Combining: t24: f64 = fadd t23, t21

Combining: t23: f64,ch = CopyFromReg t0, Register:f64 %7

Combining: t22: f64 = Register %7

Combining: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1

Combining: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Combining: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1

Combining: t18: Untyped = RegisterMask

Combining: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Combining: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1

Combining: t15: f64 = Register $xmm1

Combining: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8

Combining: t13: f64 = Register $xmm0

Combining: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t11: i64 = TargetConstant<0>

Combining: t10: f64 = ConstantFP<4.000000e+00>

Combining: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
Creating fp constant: t61: f64 = ConstantFP<-0.000000e+00>

Combining: t7: f64 = ConstantFP<0.000000e+00>

Combining: t6: f64 = fmul t5, t3

Combining: t5: f64,ch = CopyFromReg t0, Register:f64 %2

Combining: t4: f64 = Register %2

Combining: t3: f64 = sint_to_fp t2

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %5

Combining: t1: i32 = Register %5

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.4 'main:for.body.i'
SelectionDAG has 58 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %5
  t5: f64,ch = CopyFromReg t0, Register:f64 %2
    t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
  t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
  t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
  t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
  t28: f64,ch = CopyFromReg t0, Register:f64 %4
    t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t29: f64 = fmul t5, t28
    t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
  t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
  t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
  t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
  t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
  t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
  t43: i32 = add nuw nsw t2, Constant:i32<2>
            t23: f64,ch = CopyFromReg t0, Register:f64 %7
          t24: f64 = fadd t23, t21
        t26: ch = CopyToReg t0, Register:f64 %8, t24
            t38: f64,ch = CopyFromReg t0, Register:f64 %6
          t39: f64 = fadd t38, t36
        t41: ch = CopyToReg t0, Register:f64 %9, t39
        t45: ch = CopyToReg t0, Register:i32 %10, t43
          t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
        t49: ch = CopyToReg t0, Register:f64 %11, t47
      t55: ch = TokenFactor t26, t41, t45, t49, t36:1
        t51: i32,ch = CopyFromReg t0, Register:i32 %1
      t53: i1 = setcc t43, t51, setlt:ch
    t56: ch = brcond t55, t53, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
  t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>


Legalizing node: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>
Analyzing result type: ch
Legal result type
Legally typed node: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>

Legalizing node: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>
Analyzing result type: ch
Legal result type
Legally typed node: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>

Legalizing node: t52: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t52: ch = setlt

Legalizing node: t50: i32 = Register %1
Ignoring node results
Legally typed node: t50: i32 = Register %1

Legalizing node: t48: f64 = Register %11
Ignoring node results
Legally typed node: t48: f64 = Register %11

Legalizing node: t46: f64 = ConstantFP<2.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t46: f64 = ConstantFP<2.000000e+00>

Legalizing node: t44: i32 = Register %10
Ignoring node results
Legally typed node: t44: i32 = Register %10

Legalizing node: t42: i32 = Constant<2>
Analyzing result type: i32
Legal result type
Legally typed node: t42: i32 = Constant<2>

Legalizing node: t40: f64 = Register %9
Ignoring node results
Legally typed node: t40: f64 = Register %9

Legalizing node: t37: f64 = Register %6
Ignoring node results
Legally typed node: t37: f64 = Register %6

Legalizing node: t27: f64 = Register %4
Ignoring node results
Legally typed node: t27: f64 = Register %4

Legalizing node: t25: f64 = Register %8
Ignoring node results
Legally typed node: t25: f64 = Register %8

Legalizing node: t22: f64 = Register %7
Ignoring node results
Legally typed node: t22: f64 = Register %7

Legalizing node: t18: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t18: Untyped = RegisterMask

Legalizing node: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Analyzing result type: i64
Legal result type
Legally typed node: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Legalizing node: t15: f64 = Register $xmm1
Ignoring node results
Legally typed node: t15: f64 = Register $xmm1

Legalizing node: t13: f64 = Register $xmm0
Ignoring node results
Legally typed node: t13: f64 = Register $xmm0

Legalizing node: t11: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t11: i64 = TargetConstant<0>

Legalizing node: t10: f64 = ConstantFP<4.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t10: f64 = ConstantFP<4.000000e+00>

Legalizing node: t7: f64 = ConstantFP<0.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t7: f64 = ConstantFP<0.000000e+00>

Legalizing node: t4: f64 = Register %2
Ignoring node results
Legally typed node: t4: f64 = Register %2

Legalizing node: t1: i32 = Register %5
Ignoring node results
Legally typed node: t1: i32 = Register %5

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %5
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %5

Legalizing node: t3: f64 = sint_to_fp t2
Analyzing result type: f64
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %5
Legal operand
Legally typed node: t3: f64 = sint_to_fp t2

Legalizing node: t43: i32 = add nuw nsw t2, Constant:i32<2>
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %5
Legal operand
Analyzing operand: t42: i32 = Constant<2>
Legal operand
Legally typed node: t43: i32 = add nuw nsw t2, Constant:i32<2>

Legalizing node: t45: ch = CopyToReg t0, Register:i32 %10, t43
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t43: i32 = add nuw nsw t2, Constant:i32<2>
Legal operand
Legally typed node: t45: ch = CopyToReg t0, Register:i32 %10, t43

Legalizing node: t5: f64,ch = CopyFromReg t0, Register:f64 %2
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t5: f64,ch = CopyFromReg t0, Register:f64 %2

Legalizing node: t6: f64 = fmul t5, t3
Analyzing result type: f64
Legal result type
Analyzing operand: t5: f64,ch = CopyFromReg t0, Register:f64 %2
Legal operand
Analyzing operand: t3: f64 = sint_to_fp t2
Legal operand
Legally typed node: t6: f64 = fmul t5, t3

Legalizing node: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t6: f64 = fmul t5, t3
Legal operand
Analyzing operand: t7: f64 = ConstantFP<0.000000e+00>
Legal operand
Legally typed node: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>

Legalizing node: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
Legal operand
Legally typed node: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8

Legalizing node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
Legal operand
Analyzing operand: t10: f64 = ConstantFP<4.000000e+00>
Legal operand
Analyzing operand: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
Legal operand
Legally typed node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1

Legalizing node: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
Legal operand
Analyzing operand: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal operand
Analyzing operand: t18: Untyped = RegisterMask
Legal operand
Analyzing operand: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
Legal operand
Legally typed node: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1

Legalizing node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
Legal operand
Analyzing operand: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
Legal operand
Legally typed node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing node: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Legal operand
Analyzing operand: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
Legal operand
Legally typed node: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1

Legalizing node: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
Legal operand
Legally typed node: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t23: f64,ch = CopyFromReg t0, Register:f64 %7
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t23: f64,ch = CopyFromReg t0, Register:f64 %7

Legalizing node: t24: f64 = fadd t23, t21
Analyzing result type: f64
Legal result type
Analyzing operand: t23: f64,ch = CopyFromReg t0, Register:f64 %7
Legal operand
Analyzing operand: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
Legal operand
Legally typed node: t24: f64 = fadd t23, t21

Legalizing node: t26: ch = CopyToReg t0, Register:f64 %8, t24
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: f64 = fadd t23, t21
Legal operand
Legally typed node: t26: ch = CopyToReg t0, Register:f64 %8, t24

Legalizing node: t28: f64,ch = CopyFromReg t0, Register:f64 %4
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t28: f64,ch = CopyFromReg t0, Register:f64 %4

Legalizing node: t29: f64 = fmul t5, t28
Analyzing result type: f64
Legal result type
Analyzing operand: t5: f64,ch = CopyFromReg t0, Register:f64 %2
Legal operand
Analyzing operand: t28: f64,ch = CopyFromReg t0, Register:f64 %4
Legal operand
Legally typed node: t29: f64 = fmul t5, t28

Legalizing node: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t29: f64 = fmul t5, t28
Legal operand
Analyzing operand: t7: f64 = ConstantFP<0.000000e+00>
Legal operand
Legally typed node: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>

Legalizing node: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
Legal operand
Legally typed node: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30

Legalizing node: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
Legal operand
Analyzing operand: t10: f64 = ConstantFP<4.000000e+00>
Legal operand
Analyzing operand: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
Legal operand
Legally typed node: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1

Legalizing node: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
Legal operand
Analyzing operand: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal operand
Analyzing operand: t18: Untyped = RegisterMask
Legal operand
Analyzing operand: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
Legal operand
Legally typed node: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1

Legalizing node: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
Legal operand
Analyzing operand: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
Legal operand
Legally typed node: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1

Legalizing node: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
Legal operand
Analyzing operand: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
Legal operand
Legally typed node: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1

Legalizing node: t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t28: f64,ch = CopyFromReg t0, Register:f64 %4
Legal operand
Analyzing operand: t46: f64 = ConstantFP<2.000000e+00>
Legal operand
Legally typed node: t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>

Legalizing node: t49: ch = CopyToReg t0, Register:f64 %11, t47
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
Legal operand
Legally typed node: t49: ch = CopyToReg t0, Register:f64 %11, t47

Legalizing node: t38: f64,ch = CopyFromReg t0, Register:f64 %6
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t38: f64,ch = CopyFromReg t0, Register:f64 %6

Legalizing node: t39: f64 = fadd t38, t36
Analyzing result type: f64
Legal result type
Analyzing operand: t38: f64,ch = CopyFromReg t0, Register:f64 %6
Legal operand
Analyzing operand: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
Legal operand
Legally typed node: t39: f64 = fadd t38, t36

Legalizing node: t41: ch = CopyToReg t0, Register:f64 %9, t39
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t39: f64 = fadd t38, t36
Legal operand
Legally typed node: t41: ch = CopyToReg t0, Register:f64 %9, t39

Legalizing node: t55: ch = TokenFactor t26, t41, t45, t49, t36:1
Analyzing result type: ch
Legal result type
Analyzing operand: t26: ch = CopyToReg t0, Register:f64 %8, t24
Legal operand
Analyzing operand: t41: ch = CopyToReg t0, Register:f64 %9, t39
Legal operand
Analyzing operand: t45: ch = CopyToReg t0, Register:i32 %10, t43
Legal operand
Analyzing operand: t49: ch = CopyToReg t0, Register:f64 %11, t47
Legal operand
Analyzing operand: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
Legal operand
Legally typed node: t55: ch = TokenFactor t26, t41, t45, t49, t36:1

Legalizing node: t51: i32,ch = CopyFromReg t0, Register:i32 %1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t51: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing node: t53: i1 = setcc t43, t51, setlt:ch
Analyzing result type: i1
Promote integer result: t53: i1 = setcc t43, t51, setlt:ch

Creating new node: t62: i8 = setcc t43, t51, setlt:ch
Legalizing node: t56: ch = brcond t55, t53, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch = TokenFactor t26, t41, t45, t49, t36:1
Legal operand
Analyzing operand: t53: i1 = setcc t43, t51, setlt:ch
Promote integer operand: t56: ch = brcond t55, t53, BasicBlock:ch<for.body.i 0x7fffc1df55a0>

Creating new node: t63: i8 = zero_extend t53
Legalizing node: t63: i8 = zero_extend t53
Analyzing result type: i8
Legal result type
Analyzing operand: t53: i1 = setcc t43, t51, setlt:ch
Promote integer operand: t63: i8 = zero_extend t53

Creating constant: t64: i8 = Constant<1>
Creating new node: t65: i8 = and t62, Constant:i8<1>
Replacing: t63: i8 = zero_extend t53
     with: t65: i8 = and t62, Constant:i8<1>
Legalizing node: t64: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t64: i8 = Constant<1>

Legalizing node: t62: i8 = setcc t43, t51, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t43: i32 = add nuw nsw t2, Constant:i32<2>
Legal operand
Analyzing operand: t51: i32,ch = CopyFromReg t0, Register:i32 %1
Legal operand
Analyzing operand: t52: ch = setlt
Legal operand
Legally typed node: t62: i8 = setcc t43, t51, setlt:ch

Legalizing node: t65: i8 = and t62, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t62: i8 = setcc t43, t51, setlt:ch
Legal operand
Analyzing operand: t64: i8 = Constant<1>
Legal operand
Legally typed node: t65: i8 = and t62, Constant:i8<1>

Legalizing node: t56: ch = brcond t55, t65, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch = TokenFactor t26, t41, t45, t49, t36:1
Legal operand
Analyzing operand: t65: i8 = and t62, Constant:i8<1>
Legal operand
Analyzing operand: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>
Legal operand
Legally typed node: t56: ch = brcond t55, t65, BasicBlock:ch<for.body.i 0x7fffc1df55a0>

Legalizing node: t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>
Analyzing result type: ch
Legal result type
Analyzing operand: t56: ch = brcond t55, t65, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
Legal operand
Analyzing operand: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>
Legal operand
Legally typed node: t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>

Legalizing node: t65535: ch = handlenode t58
Analyzing result type: ch
Legal result type
Analyzing operand: t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>
Legal operand
Legally typed node: t65535: ch = handlenode t58

Type-legalized selection DAG: %bb.4 'main:for.body.i'
SelectionDAG has 60 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %5
  t5: f64,ch = CopyFromReg t0, Register:f64 %2
    t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
  t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
  t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
  t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
  t28: f64,ch = CopyFromReg t0, Register:f64 %4
    t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t29: f64 = fmul t5, t28
    t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
  t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
  t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
  t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
  t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
  t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
  t43: i32 = add nuw nsw t2, Constant:i32<2>
            t23: f64,ch = CopyFromReg t0, Register:f64 %7
          t24: f64 = fadd t23, t21
        t26: ch = CopyToReg t0, Register:f64 %8, t24
            t38: f64,ch = CopyFromReg t0, Register:f64 %6
          t39: f64 = fadd t38, t36
        t41: ch = CopyToReg t0, Register:f64 %9, t39
        t45: ch = CopyToReg t0, Register:i32 %10, t43
          t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
        t49: ch = CopyToReg t0, Register:f64 %11, t47
      t55: ch = TokenFactor t26, t41, t45, t49, t36:1
          t51: i32,ch = CopyFromReg t0, Register:i32 %1
        t62: i8 = setcc t43, t51, setlt:ch
      t65: i8 = and t62, Constant:i8<1>
    t56: ch = brcond t55, t65, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
  t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>



Combining: t65: i8 = and t62, Constant:i8<1>

Replacing.2 t65: i8 = and t62, Constant:i8<1>

With: t62: i8 = setcc t43, t51, setlt:ch


Combining: t62: i8 = setcc t43, t51, setlt:ch

Combining: t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>

Combining: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>

Combining: t56: ch = brcond t55, t62, BasicBlock:ch<for.body.i 0x7fffc1df55a0>

Combining: t55: ch = TokenFactor t26, t41, t45, t49, t36:1

Combining: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>

Combining: t52: ch = setlt

Combining: t51: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t50: i32 = Register %1

Combining: t49: ch = CopyToReg t0, Register:f64 %11, t47

Combining: t48: f64 = Register %11

Combining: t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
Creating fp constant: t66: f64 = ConstantFP<-2.000000e+00>

Combining: t46: f64 = ConstantFP<2.000000e+00>

Combining: t45: ch = CopyToReg t0, Register:i32 %10, t43

Combining: t44: i32 = Register %10

Combining: t43: i32 = add nuw nsw t2, Constant:i32<2>

Combining: t42: i32 = Constant<2>

Combining: t41: ch = CopyToReg t0, Register:f64 %9, t39

Combining: t40: f64 = Register %9

Combining: t39: f64 = fadd t38, t36

Combining: t38: f64,ch = CopyFromReg t0, Register:f64 %6

Combining: t37: f64 = Register %6

Combining: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1

Combining: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1

Combining: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1

Combining: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1

Combining: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30

Combining: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
Creating fp constant: t67: f64 = ConstantFP<-0.000000e+00>

Combining: t29: f64 = fmul t5, t28

Combining: t28: f64,ch = CopyFromReg t0, Register:f64 %4

Combining: t27: f64 = Register %4

Combining: t26: ch = CopyToReg t0, Register:f64 %8, t24

Combining: t25: f64 = Register %8

Combining: t24: f64 = fadd t23, t21

Combining: t23: f64,ch = CopyFromReg t0, Register:f64 %7

Combining: t22: f64 = Register %7

Combining: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1

Combining: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Combining: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1

Combining: t18: Untyped = RegisterMask

Combining: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Combining: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1

Combining: t15: f64 = Register $xmm1

Combining: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8

Combining: t13: f64 = Register $xmm0

Combining: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t11: i64 = TargetConstant<0>

Combining: t10: f64 = ConstantFP<4.000000e+00>

Combining: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
Creating fp constant: t68: f64 = ConstantFP<-0.000000e+00>

Combining: t7: f64 = ConstantFP<0.000000e+00>

Combining: t6: f64 = fmul t5, t3

Combining: t5: f64,ch = CopyFromReg t0, Register:f64 %2

Combining: t4: f64 = Register %2

Combining: t3: f64 = sint_to_fp t2

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %5

Combining: t1: i32 = Register %5

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.4 'main:for.body.i'
SelectionDAG has 58 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %5
  t5: f64,ch = CopyFromReg t0, Register:f64 %2
    t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
  t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
  t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
  t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
  t28: f64,ch = CopyFromReg t0, Register:f64 %4
    t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t29: f64 = fmul t5, t28
    t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
  t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
  t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
  t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
  t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
  t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
  t43: i32 = add nuw nsw t2, Constant:i32<2>
            t23: f64,ch = CopyFromReg t0, Register:f64 %7
          t24: f64 = fadd t23, t21
        t26: ch = CopyToReg t0, Register:f64 %8, t24
            t38: f64,ch = CopyFromReg t0, Register:f64 %6
          t39: f64 = fadd t38, t36
        t41: ch = CopyToReg t0, Register:f64 %9, t39
        t45: ch = CopyToReg t0, Register:i32 %10, t43
          t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
        t49: ch = CopyToReg t0, Register:f64 %11, t47
      t55: ch = TokenFactor t26, t41, t45, t49, t36:1
        t51: i32,ch = CopyFromReg t0, Register:i32 %1
      t62: i8 = setcc t43, t51, setlt:ch
    t56: ch = brcond t55, t62, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
  t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>



Legalizing: t58: ch = br t56, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>
Legal node: nothing to do

Legalizing: t56: ch = brcond t55, t62, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
Trying custom legalization
Creating new node: t69: i32,i32 = X86ISD::SUB t43, t51
Creating constant: t70: i8 = TargetConstant<12>
Creating new node: t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1
Successfully custom legalized node
 ... replacing: t56: ch = brcond t55, t62, BasicBlock:ch<for.body.i 0x7fffc1df55a0>
     with:      t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1

Legalizing: t55: ch = TokenFactor t26, t41, t45, t49, t36:1
Legal node: nothing to do

Legalizing: t41: ch = CopyToReg t0, Register:f64 %9, t39
Legal node: nothing to do

Legalizing: t39: f64 = fadd t38, t36
Trying custom legalization

Legalizing: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
Legal node: nothing to do

Legalizing: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1

Legalizing: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
Legal node: nothing to do

Legalizing: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t32:1
Legal node: nothing to do

Legalizing: t26: ch = CopyToReg t0, Register:f64 %8, t24
Legal node: nothing to do

Legalizing: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
Legal node: nothing to do

Legalizing: t24: f64 = fadd t23, t21
Trying custom legalization

Legalizing: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
Legal node: nothing to do

Legalizing: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
Legal node: nothing to do

Legalizing: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, ConstantFP:f64<4.000000e+00>, t14:1
Legal node: nothing to do

Legalizing: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
Legal node: nothing to do

Legalizing: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
Trying custom legalization

Legalizing: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
Trying custom legalization

Legalizing: t49: ch = CopyToReg t0, Register:f64 %11, t47
Legal node: nothing to do

Legalizing: t6: f64 = fmul t5, t3
Legal node: nothing to do

Legalizing: t45: ch = CopyToReg t0, Register:i32 %10, t43
Legal node: nothing to do

Legalizing: t29: f64 = fmul t5, t28
Legal node: nothing to do

Legalizing: t47: f64 = fadd t28, ConstantFP:f64<2.000000e+00>
Trying custom legalization

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Legalizing: t43: i32 = add nuw nsw t2, Constant:i32<2>
Legal node: nothing to do

Legalizing: t51: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Legalizing: t38: f64,ch = CopyFromReg t0, Register:f64 %6
Legal node: nothing to do

Legalizing: t28: f64,ch = CopyFromReg t0, Register:f64 %4
Legal node: nothing to do

Legalizing: t23: f64,ch = CopyFromReg t0, Register:f64 %7
Legal node: nothing to do

Legalizing: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: f64,ch = CopyFromReg t0, Register:f64 %2
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %5
Legal node: nothing to do

Legalizing: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>
Legal node: nothing to do

Legalizing: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>
Legal node: nothing to do

Legalizing: t50: i32 = Register %1

Legalizing: t48: f64 = Register %11

Legalizing: t46: f64 = ConstantFP<2.000000e+00>
Trying to expand node
Creating new constant pool: t72: i64 = ConstantPool<double 2.000000e+00> 0
Creating new node: t73: i64 = undef
Creating new node: t74: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 2.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t46: f64 = ConstantFP<2.000000e+00>
     with:      t74: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 2.000000e+00> 0, undef:i64

Legalizing: t44: i32 = Register %10

Legalizing: t42: i32 = Constant<2>
Legal node: nothing to do

Legalizing: t40: f64 = Register %9

Legalizing: t37: f64 = Register %6

Legalizing: t27: f64 = Register %4

Legalizing: t25: f64 = Register %8

Legalizing: t22: f64 = Register %7

Legalizing: t18: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal node: nothing to do

Legalizing: t15: f64 = Register $xmm1

Legalizing: t13: f64 = Register $xmm0

Legalizing: t11: i64 = TargetConstant<0>

Legalizing: t10: f64 = ConstantFP<4.000000e+00>
Trying to expand node
Creating new constant pool: t75: i64 = ConstantPool<double 4.000000e+00> 0
Creating new node: t76: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t10: f64 = ConstantFP<4.000000e+00>
     with:      t76: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64

Legalizing: t7: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Legalizing: t4: f64 = Register %2

Legalizing: t1: i32 = Register %5

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t76: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t75: i64 = ConstantPool<double 4.000000e+00> 0
Trying custom legalization
Creating new constant pool: t77: i64 = TargetConstantPool<double 4.000000e+00> 0
Creating new node: t78: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Successfully custom legalized node
 ... replacing: t75: i64 = ConstantPool<double 4.000000e+00> 0
     with:      t78: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t74: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 2.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t73: i64 = undef
Legal node: nothing to do

Legalizing: t72: i64 = ConstantPool<double 2.000000e+00> 0
Trying custom legalization
Creating new constant pool: t79: i64 = TargetConstantPool<double 2.000000e+00> 0
Creating new node: t80: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
Successfully custom legalized node
 ... replacing: t72: i64 = ConstantPool<double 2.000000e+00> 0
     with:      t80: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0

Legalizing: t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1
Legal node: nothing to do

Legalizing: t70: i8 = TargetConstant<12>

Legalizing: t69: i32,i32 = X86ISD::SUB t43, t51
Legal node: nothing to do

Legalizing: t80: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
Legal node: nothing to do

Legalizing: t79: i64 = TargetConstantPool<double 2.000000e+00> 0
Legal node: nothing to do

Legalizing: t78: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t77: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.4 'main:for.body.i'
SelectionDAG has 63 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %5
  t5: f64,ch = CopyFromReg t0, Register:f64 %2
  t28: f64,ch = CopyFromReg t0, Register:f64 %4
  t43: i32 = add nuw nsw t2, Constant:i32<2>
    t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
  t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1
  t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
  t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
    t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t29: f64 = fmul t5, t28
    t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
  t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
  t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1
  t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
  t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
  t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
    t78: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
  t76: f64,ch = load<(load 8 from constant-pool)> t0, t78, undef:i64
            t23: f64,ch = CopyFromReg t0, Register:f64 %7
          t24: f64 = fadd t23, t21
        t26: ch = CopyToReg t0, Register:f64 %8, t24
            t38: f64,ch = CopyFromReg t0, Register:f64 %6
          t39: f64 = fadd t38, t36
        t41: ch = CopyToReg t0, Register:f64 %9, t39
        t45: ch = CopyToReg t0, Register:i32 %10, t43
              t80: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
            t74: f64,ch = load<(load 8 from constant-pool)> t0, t80, undef:i64
          t47: f64 = fadd t28, t74
        t49: ch = CopyToReg t0, Register:f64 %11, t47
      t55: ch = TokenFactor t26, t41, t45, t49, t36:1
        t51: i32,ch = CopyFromReg t0, Register:i32 %1
      t69: i32,i32 = X86ISD::SUB t43, t51
    t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1
  t58: ch = br t71, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>



Legalizing: t80: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
Legal node: nothing to do

Combining: t80: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0

Legalizing: t79: i64 = TargetConstantPool<double 2.000000e+00> 0
Legal node: nothing to do

Combining: t79: i64 = TargetConstantPool<double 2.000000e+00> 0

Legalizing: t78: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t78: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t77: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t77: i64 = TargetConstantPool<double 4.000000e+00> 0

Legalizing: t76: f64,ch = load<(load 8 from constant-pool)> t0, t78, undef:i64
Legalizing non-extending load operation

Combining: t76: f64,ch = load<(load 8 from constant-pool)> t0, t78, undef:i64

Legalizing: t74: f64,ch = load<(load 8 from constant-pool)> t0, t80, undef:i64
Legalizing non-extending load operation

Combining: t74: f64,ch = load<(load 8 from constant-pool)> t0, t80, undef:i64

Legalizing: t73: i64 = undef
Legal node: nothing to do

Combining: t73: i64 = undef

Legalizing: t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1
Legal node: nothing to do

Combining: t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1

Legalizing: t70: i8 = TargetConstant<12>

Combining: t70: i8 = TargetConstant<12>

Legalizing: t69: i32,i32 = X86ISD::SUB t43, t51
Legal node: nothing to do

Combining: t69: i32,i32 = X86ISD::SUB t43, t51

Legalizing: t58: ch = br t71, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>
Legal node: nothing to do

Combining: t58: ch = br t71, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>

Legalizing: t55: ch = TokenFactor t26, t41, t45, t49, t36:1
Legal node: nothing to do

Combining: t55: ch = TokenFactor t26, t41, t45, t49, t36:1

Legalizing: t41: ch = CopyToReg t0, Register:f64 %9, t39
Legal node: nothing to do

Combining: t41: ch = CopyToReg t0, Register:f64 %9, t39

Legalizing: t39: f64 = fadd t38, t36
Trying custom legalization

Combining: t39: f64 = fadd t38, t36

Legalizing: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
Legal node: nothing to do

Combining: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1

Legalizing: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1

Combining: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1

Legalizing: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
Legal node: nothing to do

Combining: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1

Legalizing: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1
Legal node: nothing to do

Combining: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1

Legalizing: t26: ch = CopyToReg t0, Register:f64 %8, t24
Legal node: nothing to do

Combining: t26: ch = CopyToReg t0, Register:f64 %8, t24

Legalizing: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
Legal node: nothing to do

Combining: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30

Legalizing: t24: f64 = fadd t23, t21
Trying custom legalization

Combining: t24: f64 = fadd t23, t21

Legalizing: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
Legal node: nothing to do

Combining: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1

Legalizing: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Combining: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1

Legalizing: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
Legal node: nothing to do

Combining: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1

Legalizing: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1
Legal node: nothing to do

Combining: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1

Legalizing: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
Legal node: nothing to do

Combining: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8

Legalizing: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
Trying custom legalization

Combining: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>

Legalizing: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
Trying custom legalization

Combining: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>

Legalizing: t49: ch = CopyToReg t0, Register:f64 %11, t47
Legal node: nothing to do

Combining: t49: ch = CopyToReg t0, Register:f64 %11, t47

Legalizing: t6: f64 = fmul t5, t3
Legal node: nothing to do

Combining: t6: f64 = fmul t5, t3

Legalizing: t45: ch = CopyToReg t0, Register:i32 %10, t43
Legal node: nothing to do

Combining: t45: ch = CopyToReg t0, Register:i32 %10, t43

Legalizing: t29: f64 = fmul t5, t28
Legal node: nothing to do

Combining: t29: f64 = fmul t5, t28

Legalizing: t47: f64 = fadd t28, t74
Trying custom legalization

Combining: t47: f64 = fadd t28, t74

Legalizing: t3: f64 = sint_to_fp t2
Trying custom legalization

Combining: t3: f64 = sint_to_fp t2

Legalizing: t43: i32 = add nuw nsw t2, Constant:i32<2>
Legal node: nothing to do

Combining: t43: i32 = add nuw nsw t2, Constant:i32<2>

Legalizing: t51: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Combining: t51: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing: t38: f64,ch = CopyFromReg t0, Register:f64 %6
Legal node: nothing to do

Combining: t38: f64,ch = CopyFromReg t0, Register:f64 %6

Legalizing: t28: f64,ch = CopyFromReg t0, Register:f64 %4
Legal node: nothing to do

Combining: t28: f64,ch = CopyFromReg t0, Register:f64 %4

Legalizing: t23: f64,ch = CopyFromReg t0, Register:f64 %7
Legal node: nothing to do

Combining: t23: f64,ch = CopyFromReg t0, Register:f64 %7

Legalizing: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: f64,ch = CopyFromReg t0, Register:f64 %2
Legal node: nothing to do

Combining: t5: f64,ch = CopyFromReg t0, Register:f64 %2

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %5
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %5

Legalizing: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>
Legal node: nothing to do

Combining: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>

Legalizing: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>
Legal node: nothing to do

Combining: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>

Legalizing: t50: i32 = Register %1

Combining: t50: i32 = Register %1

Legalizing: t48: f64 = Register %11

Combining: t48: f64 = Register %11

Legalizing: t44: i32 = Register %10

Combining: t44: i32 = Register %10

Legalizing: t42: i32 = Constant<2>
Legal node: nothing to do

Combining: t42: i32 = Constant<2>

Legalizing: t40: f64 = Register %9

Combining: t40: f64 = Register %9

Legalizing: t37: f64 = Register %6

Combining: t37: f64 = Register %6

Legalizing: t27: f64 = Register %4

Combining: t27: f64 = Register %4

Legalizing: t25: f64 = Register %8

Combining: t25: f64 = Register %8

Legalizing: t22: f64 = Register %7

Combining: t22: f64 = Register %7

Legalizing: t18: Untyped = RegisterMask
Legal node: nothing to do

Combining: t18: Untyped = RegisterMask

Legalizing: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0
Legal node: nothing to do

Combining: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

Legalizing: t15: f64 = Register $xmm1

Combining: t15: f64 = Register $xmm1

Legalizing: t13: f64 = Register $xmm0

Combining: t13: f64 = Register $xmm0

Legalizing: t11: i64 = TargetConstant<0>

Combining: t11: i64 = TargetConstant<0>

Legalizing: t7: f64 = ConstantFP<0.000000e+00>
Trying to expand node
Cannot expand node
Trying to convert node to libcall
Could not convert node to libcall

Combining: t7: f64 = ConstantFP<0.000000e+00>

Legalizing: t4: f64 = Register %2

Combining: t4: f64 = Register %2

Legalizing: t1: i32 = Register %5

Combining: t1: i32 = Register %5

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.4 'main:for.body.i'
SelectionDAG has 63 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %5
  t5: f64,ch = CopyFromReg t0, Register:f64 %2
  t28: f64,ch = CopyFromReg t0, Register:f64 %4
  t43: i32 = add nuw nsw t2, Constant:i32<2>
    t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
        t3: f64 = sint_to_fp t2
      t6: f64 = fmul t5, t3
    t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
  t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1
  t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
  t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
  t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1
    t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
      t29: f64 = fmul t5, t28
    t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
  t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30
  t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1
  t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
  t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
  t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1
    t78: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
  t76: f64,ch = load<(load 8 from constant-pool)> t0, t78, undef:i64
            t23: f64,ch = CopyFromReg t0, Register:f64 %7
          t24: f64 = fadd t23, t21
        t26: ch = CopyToReg t0, Register:f64 %8, t24
            t38: f64,ch = CopyFromReg t0, Register:f64 %6
          t39: f64 = fadd t38, t36
        t41: ch = CopyToReg t0, Register:f64 %9, t39
        t45: ch = CopyToReg t0, Register:i32 %10, t43
              t80: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 2.000000e+00> 0
            t74: f64,ch = load<(load 8 from constant-pool)> t0, t80, undef:i64
          t47: f64 = fadd t28, t74
        t49: ch = CopyToReg t0, Register:f64 %11, t47
      t55: ch = TokenFactor t26, t41, t45, t49, t36:1
        t51: i32,ch = CopyFromReg t0, Register:i32 %1
      t69: i32,i32 = X86ISD::SUB t43, t51
    t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1
  t58: ch = br t71, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>


===== Instruction selection begins: %bb.4 'for.body.i'

ISEL: Starting selection on root node: t58: ch = br t71, BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t58: ch = JMP_1 BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>, t71
ISEL: Match complete!

ISEL: Starting selection on root node: t71: ch = X86ISD::BRCOND t55, BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t69:1
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t82: ch,glue = CopyToReg t55, Register:i32 $eflags, t69:1
  Morphed node: t71: ch = JCC_1 BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t82, t82:1
ISEL: Match complete!

ISEL: Starting selection on root node: t55: ch = TokenFactor t26, t41, t45, t49, t36:1

ISEL: Starting selection on root node: t41: ch = CopyToReg t0, Register:f64 %9, t39

ISEL: Starting selection on root node: t39: f64 = fadd t38, t36
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t39: f64 = ADDSDrr nofpexcept t38, t36
ISEL: Match complete!

ISEL: Starting selection on root node: t36: f64,ch,glue = CopyFromReg t35, Register:f64 $xmm0, t35:1

ISEL: Starting selection on root node: t35: ch,glue = callseq_end t34, TargetConstant:i64<0>, TargetConstant:i64<0>, t34:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t35: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t34, t34:1
ISEL: Match complete!

ISEL: Starting selection on root node: t34: ch,glue = X86ISD::CALL t33, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t34: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33, t33:1
ISEL: Match complete!

ISEL: Starting selection on root node: t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1

ISEL: Starting selection on root node: t26: ch = CopyToReg t0, Register:f64 %8, t24

ISEL: Starting selection on root node: t32: ch,glue = CopyToReg t31, Register:f64 $xmm0, t30

ISEL: Starting selection on root node: t24: f64 = fadd t23, t21
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t24: f64 = ADDSDrr nofpexcept t23, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t31: ch,glue = callseq_start t21:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t83: i32 = TargetConstant<0>
  Morphed node: t31: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t21:1
ISEL: Match complete!

ISEL: Starting selection on root node: t21: f64,ch,glue = CopyFromReg t20, Register:f64 $xmm0, t20:1

ISEL: Starting selection on root node: t20: ch,glue = callseq_end t19, TargetConstant:i64<0>, TargetConstant:i64<0>, t19:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch,glue = X86ISD::CALL t16, TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16, t16:1
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1

ISEL: Starting selection on root node: t14: ch,glue = CopyToReg t12, Register:f64 $xmm0, t8

ISEL: Starting selection on root node: t49: ch = CopyToReg t0, Register:f64 %11, t47

ISEL: Starting selection on root node: t8: f64 = fadd t6, ConstantFP:f64<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t8: f64 = ADDSDrr nofpexcept t6, ConstantFP:f64<0.000000e+00>
ISEL: Match complete!

ISEL: Starting selection on root node: t47: f64 = fadd t28, t74
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  OpcodeSwitch from 144649 to 144654
  TypeSwitch[f64] from 144665 to 144689
  Match failed at index 144689
  Continuing at 144709
  Match failed at index 144710
  Continuing at 144783
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  TypeSwitch[f64] from 145261 to 145325
  Skipped scope entry (due to false predicate) at index 145327, continuing at 145345
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t85: i8 = TargetConstant<1>
Creating new constant pool: t87: i32 = TargetConstantPool<double 2.000000e+00> 0
  Morphed node: t47: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t28, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t30: f64 = fadd t29, ConstantFP:f64<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t30: f64 = ADDSDrr nofpexcept t29, ConstantFP:f64<0.000000e+00>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: f64 = fmul t5, t3
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t6: f64 = MULSDrr nofpexcept t5, t3
ISEL: Match complete!

ISEL: Starting selection on root node: t45: ch = CopyToReg t0, Register:i32 %10, t43

ISEL: Starting selection on root node: t69: i32,i32 = X86ISD::SUB t43, t51
ISEL: Starting pattern match
  Initial Opcode index to 89092
  Match failed at index 89099
  Continuing at 89202
  Match failed at index 89203
  Continuing at 89249
  Match failed at index 89250
  Continuing at 89313
  Continuing at 89314
  Match failed at index 89315
  Continuing at 89360
  Skipped scope entry (due to false predicate) at index 89371, continuing at 89501
  Match failed at index 89505
  Continuing at 89519
  Match failed at index 89520
  Continuing at 89539
  Match failed at index 89543
  Continuing at 89557
  Match failed at index 89558
  Continuing at 89577
  Match failed at index 89583
  Continuing at 89595
  Match failed at index 89596
  Continuing at 89615
  Match failed at index 89616
  Continuing at 89635
  Continuing at 89636
  Match failed at index 89637
  Continuing at 89648
  Match failed at index 89649
  Continuing at 89660
  Morphed node: t69: i32,i32 = SUB32rr t43, t51
ISEL: Match complete!

ISEL: Starting selection on root node: t76: f64,ch = load<(load 8 from constant-pool)> t0, t78, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
  Match failed at index 115541
  Continuing at 115558
  Match failed at index 115559
  Continuing at 115601
  Match failed at index 115602
  Continuing at 115644
  Match failed at index 115645
  Continuing at 115707
  Match failed at index 115710
  Continuing at 115729
  Match failed at index 115730
  Continuing at 115770
  Match failed at index 115771
  Continuing at 115854
  Match failed at index 115856
  Continuing at 116030
  Match failed at index 116031
  Continuing at 116095
  Match failed at index 116096
  Continuing at 116130
  Match failed at index 116131
  Continuing at 116236
  Match failed at index 116237
  Continuing at 116269
  Match failed at index 116270
  Continuing at 116302
  TypeSwitch[f64] from 116305 to 116328
  Match failed at index 116328
  Continuing at 116365
  Match failed at index 116366
  Continuing at 116434
  TypeSwitch[f64] from 116438 to 116499
  Skipped scope entry (due to false predicate) at index 116501, continuing at 116518
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t89: i32 = TargetConstantPool<double 4.000000e+00> 0
  Morphed node: t76: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t29: f64 = fmul t5, t28
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t29: f64 = MULSDrr nofpexcept t5, t28
ISEL: Match complete!

ISEL: Starting selection on root node: t3: f64 = sint_to_fp t2
ISEL: Starting pattern match
  Initial Opcode index to 182962
  Match failed at index 182966
  Continuing at 183280
  TypeSwitch[f64] from 183287 to 183338
  Morphed node: t3: f64 = CVTSI2SDrr t2
ISEL: Match complete!

ISEL: Starting selection on root node: t43: i32 = add nuw nsw t2, Constant:i32<2>
ISEL: Starting pattern match
  Initial Opcode index to 97341
  Match failed at index 97345
  Continuing at 97448
  Match failed at index 97450
  Continuing at 97557
  TypeSwitch[i32] from 97559 to 97562
  Skipped scope entry (due to false predicate) at index 97564, continuing at 97580
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg t2: i32,ch = CopyFromReg t0, Register:i32 %5
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 97583
  Continuing at 97597
  Continuing at 97615
  Match failed at index 97618
  Continuing at 97639
  Match failed at index 97641
  Continuing at 97663
  Skipped scope entry (due to false predicate) at index 97668, continuing at 97720
  Skipped scope entry (due to false predicate) at index 97721, continuing at 97782
  Skipped scope entry (due to false predicate) at index 97783, continuing at 97857
  Skipped scope entry (due to false predicate) at index 97858, continuing at 97887
  Match failed at index 97901
  Continuing at 97914
Creating constant: t91: i32 = TargetConstant<2>
  Morphed node: t43: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t51: i32,ch = CopyFromReg t0, Register:i32 %1

ISEL: Starting selection on root node: t38: f64,ch = CopyFromReg t0, Register:f64 %6

ISEL: Starting selection on root node: t28: f64,ch = CopyFromReg t0, Register:f64 %4

ISEL: Starting selection on root node: t23: f64,ch = CopyFromReg t0, Register:f64 %7

ISEL: Starting selection on root node: t12: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t12: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: f64,ch = CopyFromReg t0, Register:f64 %2

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %5

ISEL: Starting selection on root node: t70: i8 = TargetConstant<12>

ISEL: Starting selection on root node: t57: ch = BasicBlock<for.end.loopexit.i 0x7fffc1df5818>

ISEL: Starting selection on root node: t54: ch = BasicBlock<for.body.i 0x7fffc1df55a0>

ISEL: Starting selection on root node: t50: i32 = Register %1

ISEL: Starting selection on root node: t48: f64 = Register %11

ISEL: Starting selection on root node: t44: i32 = Register %10

ISEL: Starting selection on root node: t40: f64 = Register %9

ISEL: Starting selection on root node: t37: f64 = Register %6

ISEL: Starting selection on root node: t27: f64 = Register %4

ISEL: Starting selection on root node: t25: f64 = Register %8

ISEL: Starting selection on root node: t22: f64 = Register %7

ISEL: Starting selection on root node: t18: Untyped = RegisterMask

ISEL: Starting selection on root node: t17: i64 = TargetGlobalAddress<double (double, double)* @pow> 0

ISEL: Starting selection on root node: t15: f64 = Register $xmm1

ISEL: Starting selection on root node: t13: f64 = Register $xmm0

ISEL: Starting selection on root node: t11: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t7: f64 = ConstantFP<0.000000e+00>
ISEL: Starting pattern match
  Initial Opcode index to 195000
  TypeSwitch[f64] from 195000 to 195094
  Match failed at index 195098
  Continuing at 195107
  Match failed at index 195108
  Continuing at 195119
  Morphed node: t7: f64 = FsFLD0SD
ISEL: Match complete!

ISEL: Starting selection on root node: t4: f64 = Register %2

ISEL: Starting selection on root node: t1: i32 = Register %5

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.4 'main:for.body.i'
SelectionDAG has 67 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %5
  t5: f64,ch = CopyFromReg t0, Register:f64 %2
  t28: f64,ch = CopyFromReg t0, Register:f64 %4
  t43: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>
  t76: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
    t12: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
        t3: f64 = CVTSI2SDrr t2
      t6: f64 = MULSDrr nofpexcept t5, t3
    t8: f64 = ADDSDrr nofpexcept t6, FsFLD0SD:f64
  t14: ch,glue = CopyToReg t12:1, Register:f64 $xmm0, t8
  t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1
  t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16, t16:1
  t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1
  t21: f64,ch,glue = CopyFromReg t20:1, Register:f64 $xmm0, t20:2
    t31: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t21:1
      t29: f64 = MULSDrr nofpexcept t5, t28
    t30: f64 = ADDSDrr nofpexcept t29, FsFLD0SD:f64
  t32: ch,glue = CopyToReg t31:1, Register:f64 $xmm0, t30
  t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1
  t34: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33, t33:1
  t35: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t34, t34:1
  t36: f64,ch,glue = CopyFromReg t35:1, Register:f64 $xmm0, t35:2
          t23: f64,ch = CopyFromReg t0, Register:f64 %7
        t24: f64 = ADDSDrr nofpexcept t23, t21
      t26: ch = CopyToReg t0, Register:f64 %8, t24
          t38: f64,ch = CopyFromReg t0, Register:f64 %6
        t39: f64 = ADDSDrr nofpexcept t38, t36
      t41: ch = CopyToReg t0, Register:f64 %9, t39
      t45: ch = CopyToReg t0, Register:i32 %10, t43
        t47: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t28, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0
      t49: ch = CopyToReg t0, Register:f64 %11, t47
    t55: ch = TokenFactor t26, t41, t45, t49, t36:1
      t51: i32,ch = CopyFromReg t0, Register:i32 %1
    t69: i32,i32 = SUB32rr t43, t51
  t82: ch,glue = CopyToReg t55, Register:i32 $eflags, t69:1
  t90: i32 = Register $noreg
    t71: ch = JCC_1 BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t82, t82:1
  t58: ch = JMP_1 BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>, t71


********** List Scheduling %bb.4 'for.body.i' **********
SU(0): t58: ch = JMP_1 BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>, t71

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t71: ch = JCC_1 BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t82, t82:1

    t82: ch,glue = CopyToReg t55, Register:i32 $eflags, t69:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(6): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t69: i32,i32 = SUB32rr t43, t51

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t51: i32,ch = CopyFromReg t0, Register:i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(4): t43: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(22): Data Latency=1
SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %5

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(4): Data Latency=1
    SU(18): Data Latency=1
SU(6): t55: ch = TokenFactor t26, t41, t45, t49, t36:1

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 9
  Height             : 1
  Predecessors:
    SU(26): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(22): Ord  Latency=1 Barrier
    SU(20): Ord  Latency=1 Barrier
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(7): t36: f64,ch,glue = CopyFromReg t35:1, Register:f64 $xmm0, t35:2

    t32: ch,glue = CopyToReg t31:1, Register:f64 $xmm0, t30

    t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1

    t34: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33, t33:1

    t35: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t34, t34:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
    SU(14): Ord  Latency=1 Barrier
    SU(9): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(24): Data Latency=1
SU(8): t76: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(7): Data Latency=1
    SU(15): Data Latency=1
SU(9): t30: f64 = ADDSDrr nofpexcept t29, FsFLD0SD:f64

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(11): Data Latency=1
    SU(10): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(10): t7: f64 = FsFLD0SD

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(9): Data Latency=1
    SU(16): Data Latency=1
SU(11): t29: f64 = MULSDrr nofpexcept t5, t28

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(13): Data Latency=1
    SU(12): Data Latency=1
  Successors:
    SU(9): Data Latency=1
SU(12): t28: f64,ch = CopyFromReg t0, Register:f64 %4

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(11): Data Latency=1
    SU(21): Data Latency=1
SU(13): t5: f64,ch = CopyFromReg t0, Register:f64 %2

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 9
  Successors:
    SU(11): Data Latency=1
    SU(17): Data Latency=1
SU(14): t31: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t21:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(15): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(15): t21: f64,ch,glue = CopyFromReg t20:1, Register:f64 $xmm0, t20:2

    t14: ch,glue = CopyToReg t12:1, Register:f64 $xmm0, t8

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16, t16:1

    t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 6
  Predecessors:
    SU(8): Data Latency=1
    SU(19): Ord  Latency=1 Barrier
    SU(16): Data Latency=1
  Successors:
    SU(14): Ord  Latency=1 Barrier
    SU(27): Data Latency=1
SU(16): t8: f64 = ADDSDrr nofpexcept t6, FsFLD0SD:f64

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 7
  Predecessors:
    SU(17): Data Latency=1
    SU(10): Data Latency=1
  Successors:
    SU(15): Data Latency=1
SU(17): t6: f64 = MULSDrr nofpexcept t5, t3

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
    SU(18): Data Latency=1
  Successors:
    SU(16): Data Latency=1
SU(18): t3: f64 = CVTSI2SDrr t2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 9
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(17): Data Latency=1
SU(19): t12: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(15): Ord  Latency=1 Barrier
SU(20): t49: ch = CopyToReg t0, Register:f64 %11, t47

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(21): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(21): t47: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t28, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(12): Data Latency=1
  Successors:
    SU(20): Data Latency=1
SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(24): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(24): t39: f64 = ADDSDrr nofpexcept t38, t36

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 7
  Height             : 3
  Predecessors:
    SU(25): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(23): Data Latency=1
SU(25): t38: f64,ch = CopyFromReg t0, Register:f64 %6

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(24): Data Latency=1
SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(27): Data Latency=1
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(27): t24: f64 = ADDSDrr nofpexcept t23, t21

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(28): Data Latency=1
    SU(15): Data Latency=1
  Successors:
    SU(26): Data Latency=1
SU(28): t23: f64,ch = CopyFromReg t0, Register:f64 %7

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(27): Data Latency=1
VRegCycle: SU(21)

Examining Available:
Height 0: SU(0): t58: ch = JMP_1 BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>, t71


*** Scheduling [0]: SU(0): t58: ch = JMP_1 BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>, t71


Examining Available:
Height 1: SU(1): t71: ch = JCC_1 BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t82, t82:1

    t82: ch,glue = CopyToReg t55, Register:i32 $eflags, t69:1


*** Scheduling [1]: SU(1): t71: ch = JCC_1 BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t82, t82:1

    t82: ch,glue = CopyToReg t55, Register:i32 $eflags, t69:1


Examining Available:
Height 1: SU(6): t55: ch = TokenFactor t26, t41, t45, t49, t36:1

Height 2: SU(2): t69: i32,i32 = SUB32rr t43, t51


*** Scheduling [2]: SU(6): t55: ch = TokenFactor t26, t41, t45, t49, t36:1


Examining Available:
Height 2: SU(2): t69: i32,i32 = SUB32rr t43, t51

Height 3: SU(20): t49: ch = CopyToReg t0, Register:f64 %11, t47

Height 3: SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43

Height 3: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [3]: SU(2): t69: i32,i32 = SUB32rr t43, t51


Examining Available:
Height 4: SU(3): t51: i32,ch = CopyFromReg t0, Register:i32 %1

Height 3: SU(20): t49: ch = CopyToReg t0, Register:f64 %11, t47

Height 3: SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43

Height 3: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [4]: SU(3): t51: i32,ch = CopyFromReg t0, Register:i32 %1


Examining Available:
Height 3: SU(20): t49: ch = CopyToReg t0, Register:f64 %11, t47

Height 3: SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43

Height 3: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [5]: SU(20): t49: ch = CopyToReg t0, Register:f64 %11, t47


Examining Available:
Height 6: SU(21): t47: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t28, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0

Height 3: SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43

Height 3: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [6]: SU(21): t47: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t28, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 3: SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43

Height 3: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [7]: SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43


Examining Available:
Height 8: SU(4): t43: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>

Height 3: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [8]: SU(4): t43: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>


Examining Available:
Height 3: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [9]: SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39


Examining Available:
Height 10: SU(24): t39: f64 = ADDSDrr nofpexcept t38, t36

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [10]: SU(24): t39: f64 = ADDSDrr nofpexcept t38, t36


Examining Available:
Height 11: SU(25): t38: f64,ch = CopyFromReg t0, Register:f64 %6

Height 11: SU(7): t36: f64,ch,glue = CopyFromReg t35:1, Register:f64 $xmm0, t35:2

    t32: ch,glue = CopyToReg t31:1, Register:f64 $xmm0, t30

    t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1

    t34: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33, t33:1

    t35: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t34, t34:1

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [11]: SU(25): t38: f64,ch = CopyFromReg t0, Register:f64 %6


Examining Available:
Height 11: SU(7): t36: f64,ch,glue = CopyFromReg t35:1, Register:f64 $xmm0, t35:2

    t32: ch,glue = CopyToReg t31:1, Register:f64 $xmm0, t30

    t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1

    t34: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33, t33:1

    t35: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t34, t34:1

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [12]: SU(7): t36: f64,ch,glue = CopyFromReg t35:1, Register:f64 $xmm0, t35:2

    t32: ch,glue = CopyToReg t31:1, Register:f64 $xmm0, t30

    t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1

    t34: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33, t33:1

    t35: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t34, t34:1


Examining Available:
Height 13: SU(14): t31: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t21:1

Height 13: SU(9): t30: f64 = ADDSDrr nofpexcept t29, FsFLD0SD:f64

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [13]: SU(14): t31: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t21:1


Examining Available:
Height 13: SU(9): t30: f64 = ADDSDrr nofpexcept t29, FsFLD0SD:f64

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [14]: SU(9): t30: f64 = ADDSDrr nofpexcept t29, FsFLD0SD:f64


Examining Available:
Height 15: SU(11): t29: f64 = MULSDrr nofpexcept t5, t28

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [15]: SU(11): t29: f64 = MULSDrr nofpexcept t5, t28


Examining Available:
Height 16: SU(12): t28: f64,ch = CopyFromReg t0, Register:f64 %4

Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [16]: SU(12): t28: f64,ch = CopyFromReg t0, Register:f64 %4


Examining Available:
Height 3: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


*** Scheduling [17]: SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24


Examining Available:
Height 18: SU(27): t24: f64 = ADDSDrr nofpexcept t23, t21


*** Scheduling [18]: SU(27): t24: f64 = ADDSDrr nofpexcept t23, t21


Examining Available:
Height 19: SU(28): t23: f64,ch = CopyFromReg t0, Register:f64 %7

Height 19: SU(15): t21: f64,ch,glue = CopyFromReg t20:1, Register:f64 $xmm0, t20:2

    t14: ch,glue = CopyToReg t12:1, Register:f64 $xmm0, t8

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16, t16:1

    t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1


*** Scheduling [19]: SU(28): t23: f64,ch = CopyFromReg t0, Register:f64 %7


Examining Available:
Height 19: SU(15): t21: f64,ch,glue = CopyFromReg t20:1, Register:f64 $xmm0, t20:2

    t14: ch,glue = CopyToReg t12:1, Register:f64 $xmm0, t8

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16, t16:1

    t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1


*** Scheduling [20]: SU(15): t21: f64,ch,glue = CopyFromReg t20:1, Register:f64 $xmm0, t20:2

    t14: ch,glue = CopyToReg t12:1, Register:f64 $xmm0, t8

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16, t16:1

    t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1


Examining Available:
Height 21: SU(8): t76: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

Height 21: SU(19): t12: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 21: SU(16): t8: f64 = ADDSDrr nofpexcept t6, FsFLD0SD:f64


*** Scheduling [21]: SU(8): t76: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 21: SU(19): t12: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 21: SU(16): t8: f64 = ADDSDrr nofpexcept t6, FsFLD0SD:f64


*** Scheduling [22]: SU(19): t12: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


Examining Available:
Height 21: SU(16): t8: f64 = ADDSDrr nofpexcept t6, FsFLD0SD:f64


*** Scheduling [23]: SU(16): t8: f64 = ADDSDrr nofpexcept t6, FsFLD0SD:f64


Examining Available:
Height 24: SU(10): t7: f64 = FsFLD0SD

Height 24: SU(17): t6: f64 = MULSDrr nofpexcept t5, t3


*** Scheduling [24]: SU(10): t7: f64 = FsFLD0SD


Examining Available:
Height 24: SU(17): t6: f64 = MULSDrr nofpexcept t5, t3


*** Scheduling [25]: SU(17): t6: f64 = MULSDrr nofpexcept t5, t3


Examining Available:
Height 26: SU(13): t5: f64,ch = CopyFromReg t0, Register:f64 %2

Height 26: SU(18): t3: f64 = CVTSI2SDrr t2


*** Scheduling [26]: SU(13): t5: f64,ch = CopyFromReg t0, Register:f64 %2


Examining Available:
Height 26: SU(18): t3: f64 = CVTSI2SDrr t2


*** Scheduling [27]: SU(18): t3: f64 = CVTSI2SDrr t2


Examining Available:
Height 28: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %5


*** Scheduling [28]: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %5

*** Final schedule ***
SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %5

SU(18): t3: f64 = CVTSI2SDrr t2

SU(13): t5: f64,ch = CopyFromReg t0, Register:f64 %2

SU(17): t6: f64 = MULSDrr nofpexcept t5, t3

SU(10): t7: f64 = FsFLD0SD

SU(16): t8: f64 = ADDSDrr nofpexcept t6, FsFLD0SD:f64

SU(19): t12: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(8): t76: f64,ch = MOVSDrm_alt<Mem:(load 8 from constant-pool)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

SU(15): t21: f64,ch,glue = CopyFromReg t20:1, Register:f64 $xmm0, t20:2

    t14: ch,glue = CopyToReg t12:1, Register:f64 $xmm0, t8

    t16: ch,glue = CopyToReg t14, Register:f64 $xmm1, t76, t14:1

    t19: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t16, t16:1

    t20: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t19, t19:1

SU(28): t23: f64,ch = CopyFromReg t0, Register:f64 %7

SU(27): t24: f64 = ADDSDrr nofpexcept t23, t21

SU(26): t26: ch = CopyToReg t0, Register:f64 %8, t24

SU(12): t28: f64,ch = CopyFromReg t0, Register:f64 %4

SU(11): t29: f64 = MULSDrr nofpexcept t5, t28

SU(9): t30: f64 = ADDSDrr nofpexcept t29, FsFLD0SD:f64

SU(14): t31: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t21:1

SU(7): t36: f64,ch,glue = CopyFromReg t35:1, Register:f64 $xmm0, t35:2

    t32: ch,glue = CopyToReg t31:1, Register:f64 $xmm0, t30

    t33: ch,glue = CopyToReg t32, Register:f64 $xmm1, t76, t32:1

    t34: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<double (double, double)* @pow> 0, Register:f64 $xmm0, Register:f64 $xmm1, RegisterMask:Untyped, t33, t33:1

    t35: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t34, t34:1

SU(25): t38: f64,ch = CopyFromReg t0, Register:f64 %6

SU(24): t39: f64 = ADDSDrr nofpexcept t38, t36

SU(23): t41: ch = CopyToReg t0, Register:f64 %9, t39

SU(4): t43: i32,i32 = ADD32ri8 nuw nsw t2, TargetConstant:i32<2>

SU(22): t45: ch = CopyToReg t0, Register:i32 %10, t43

SU(21): t47: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t28, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 2.000000e+00> 0, Register:i16 $noreg, t0

SU(20): t49: ch = CopyToReg t0, Register:f64 %11, t47

SU(3): t51: i32,ch = CopyFromReg t0, Register:i32 %1

SU(2): t69: i32,i32 = SUB32rr t43, t51

SU(6): t55: ch = TokenFactor t26, t41, t45, t49, t36:1

SU(1): t71: ch = JCC_1 BasicBlock:ch<for.body.i 0x7fffc1df55a0>, TargetConstant:i8<12>, t82, t82:1

    t82: ch,glue = CopyToReg t55, Register:i32 $eflags, t69:1

SU(0): t58: ch = JMP_1 BasicBlock:ch<for.end.loopexit.i 0x7fffc1df5818>, t71


Total amount of phi nodes to update: 4
Node 0 : (0x7fffc1df5678, 2147483659)
Node 1 : (0x7fffc1df56e0, 2147483658)
Node 2 : (0x7fffc1df5748, 2147483657)
Node 3 : (0x7fffc1df57b0, 2147483656)
Creating new node: t2: f64,ch = CopyFromReg t0, Register:f64 %8
Creating fp constant: t3: f64 = ConstantFP<2.000000e+00>
Creating new node: t4: f64 = fmul t2, ConstantFP:f64<2.000000e+00>
Creating new node: t6: ch = CopyToReg t0, Register:f64 %12, t4
Initial selection DAG: %bb.5 'main:for.end.loopexit.i'
SelectionDAG has 7 nodes:
  t0: ch = EntryToken
      t2: f64,ch = CopyFromReg t0, Register:f64 %8
    t4: f64 = fmul t2, ConstantFP:f64<2.000000e+00>
  t6: ch = CopyToReg t0, Register:f64 %12, t4



Combining: t6: ch = CopyToReg t0, Register:f64 %12, t4

Combining: t5: f64 = Register %12

Combining: t4: f64 = fmul t2, ConstantFP:f64<2.000000e+00>
Creating new node: t7: f64 = fadd t2, t2
 ... into: t7: f64 = fadd t2, t2

Combining: t6: ch = CopyToReg t0, Register:f64 %12, t7

Combining: t7: f64 = fadd t2, t2

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %8

Combining: t1: f64 = Register %8

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.5 'main:for.end.loopexit.i'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %8
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %12, t7


Legalizing node: t5: f64 = Register %12
Ignoring node results
Legally typed node: t5: f64 = Register %12

Legalizing node: t1: f64 = Register %8
Ignoring node results
Legally typed node: t1: f64 = Register %8

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: f64,ch = CopyFromReg t0, Register:f64 %8
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: f64,ch = CopyFromReg t0, Register:f64 %8

Legalizing node: t7: f64 = fadd t2, t2
Analyzing result type: f64
Legal result type
Analyzing operand: t2: f64,ch = CopyFromReg t0, Register:f64 %8
Legal operand
Analyzing operand: t2: f64,ch = CopyFromReg t0, Register:f64 %8
Legal operand
Legally typed node: t7: f64 = fadd t2, t2

Legalizing node: t6: ch = CopyToReg t0, Register:f64 %12, t7
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: f64 = fadd t2, t2
Legal operand
Legally typed node: t6: ch = CopyToReg t0, Register:f64 %12, t7

Legalizing node: t65535: ch = handlenode t6
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = CopyToReg t0, Register:f64 %12, t7
Legal operand
Legally typed node: t65535: ch = handlenode t6

Type-legalized selection DAG: %bb.5 'main:for.end.loopexit.i'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %8
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %12, t7



Legalizing: t6: ch = CopyToReg t0, Register:f64 %12, t7
Legal node: nothing to do

Legalizing: t7: f64 = fadd t2, t2
Trying custom legalization

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %8
Legal node: nothing to do

Legalizing: t5: f64 = Register %12

Legalizing: t1: f64 = Register %8

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.5 'main:for.end.loopexit.i'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %8
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %12, t7



Legalizing: t6: ch = CopyToReg t0, Register:f64 %12, t7
Legal node: nothing to do

Combining: t6: ch = CopyToReg t0, Register:f64 %12, t7

Legalizing: t7: f64 = fadd t2, t2
Trying custom legalization

Combining: t7: f64 = fadd t2, t2

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %8
Legal node: nothing to do

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %8

Legalizing: t5: f64 = Register %12

Combining: t5: f64 = Register %12

Legalizing: t1: f64 = Register %8

Combining: t1: f64 = Register %8

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.5 'main:for.end.loopexit.i'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %8
    t7: f64 = fadd t2, t2
  t6: ch = CopyToReg t0, Register:f64 %12, t7


===== Instruction selection begins: %bb.5 'for.end.loopexit.i'

ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:f64 %12, t7

ISEL: Starting selection on root node: t7: f64 = fadd t2, t2
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t7: f64 = ADDSDrr nofpexcept t2, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t2: f64,ch = CopyFromReg t0, Register:f64 %8

ISEL: Starting selection on root node: t5: f64 = Register %12

ISEL: Starting selection on root node: t1: f64 = Register %8

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.5 'main:for.end.loopexit.i'
SelectionDAG has 6 nodes:
  t0: ch = EntryToken
  t2: f64,ch = CopyFromReg t0, Register:f64 %8
    t7: f64 = ADDSDrr nofpexcept t2, t2
  t6: ch = CopyToReg t0, Register:f64 %12, t7


********** List Scheduling %bb.5 'for.end.loopexit.i' **********
SU(0): t6: ch = CopyToReg t0, Register:f64 %12, t7

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %8

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t6: ch = CopyToReg t0, Register:f64 %12, t7


*** Scheduling [0]: SU(0): t6: ch = CopyToReg t0, Register:f64 %12, t7


Examining Available:
Height 1: SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2


*** Scheduling [1]: SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2


Examining Available:
Height 2: SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %8


*** Scheduling [2]: SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %8

*** Final schedule ***
SU(2): t2: f64,ch = CopyFromReg t0, Register:f64 %8

SU(1): t7: f64 = ADDSDrr nofpexcept t2, t2

SU(0): t6: ch = CopyToReg t0, Register:f64 %12, t7


Total amount of phi nodes to update: 2
Node 0 : (0x7fffc1df59c8, 2147483660)
Node 1 : (0x7fffc1df5a30, 2147483657)
Creating new node: t2: f64,ch = CopyFromReg t0, Register:f64 %13
Creating fp constant: t3: f64 = ConstantFP<1.000000e+00>
Creating new node: t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
Creating new node: t6: f64,ch = CopyFromReg t0, Register:f64 %14
Creating fp constant: t7: f64 = ConstantFP<4.000000e+00>
Creating new node: t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
Creating new node: t9: f64 = fadd t4, t8
Creating new node: t11: f64,ch = CopyFromReg t0, Register:f64 %2
Creating new node: t12: f64 = fmul t11, t9
Creating fp constant: t13: f64 = ConstantFP<3.000000e+00>
Creating new node: t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
Creating constant: t18: i64 = Constant<2>
Creating constant: t19: i64 = TargetConstant<0>
Creating new node: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Creating new node: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
Creating new node: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
Creating new node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
Creating new node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Creating new node: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
Creating constant: t33: i64 = Constant<0>
Creating new node: t34: i64 = undef
Creating new node: t35: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t32:1, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
Creating constant: t36: i64 = Constant<-24>
Creating new node: t37: i64 = add t35, Constant:i64<-24>
Creating new node: t38: i64,ch = load<(load 8 from %ir.0)> t32:1, t37, undef:i64
Creating constant: t39: i64 = Constant<8>
Creating new node: t42: i64 = add GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16, t38
Creating constant: t43: i64 = Constant<6>
Creating new node: t44: ch = TokenFactor t35:1, t38:1
Creating new node: t45: ch = store<(store 8 into %ir.1, !tbaa !7)> t44, Constant:i64<6>, t42, undef:i64
Creating new node: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Creating new node: t49: ch,glue = callseq_start t45, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Creating new node: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
Creating new node: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
Creating new node: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
Creating new node: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Creating constant: t58: i64 = Constant<4>
Creating new node: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
Creating new node: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
Creating new node: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
Creating new node: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
Creating new node: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Creating new node: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
Creating new node: t66: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t65:1, t56, undef:i64
Creating new node: t67: i64 = add t66, Constant:i64<-24>
Creating new node: t68: i64,ch = load<(load 8 from %ir.3)> t65:1, t67, undef:i64
Creating new node: t69: i64 = add nuw t56, Constant:i64<8>
Creating constant: t70: i64 = Constant<16>
Creating new node: t71: i64 = add nuw t69, Constant:i64<16>
Creating new node: t72: i64 = add t71, t68
Creating new node: t73: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t65:1, t72, undef:i64
Creating constant: t74: i32 = Constant<-261>
Creating new node: t75: i32 = and t73, Constant:i32<-261>
Creating constant: t76: i32 = Constant<4>
Creating new node: t77: i32 = or t75, Constant:i32<4>
Creating new node: t78: ch = TokenFactor t66:1, t68:1, t73:1
Creating new node: t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t78, t77, t72, undef:i64
Creating new node: t80: i64,ch = load<(load 8 from %ir.3)> t79, t67, undef:i64
Creating new node: t81: i64 = add t69, t80
Creating new node: t82: ch = store<(store 8 into %ir.8, !tbaa !18)> t80:1, Constant:i64<16>, t81, undef:i64
Creating new node: t83: i64,ch = load<(load 8 from %ir.3)> t82, t67, undef:i64
Creating new node: t84: i64 = add nuw t69, Constant:i64<8>
Creating new node: t85: i64 = add t84, t83
Creating constant: t86: i64 = Constant<20>
Creating new node: t87: ch = store<(store 8 into %ir.10, !tbaa !7)> t83:1, Constant:i64<20>, t85, undef:i64
Creating new node: t89: ch,glue = callseq_start t87, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
Creating new node: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
Creating new node: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
Creating new node: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
Creating new node: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Creating new node: t98: ch = CopyToReg t0, Register:i64 %15, t96
Creating new node: t99: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t96:1, t96, undef:i64
Creating new node: t100: i64 = add t99, Constant:i64<-24>
Creating new node: t101: i64,ch = load<(load 8 from %ir.12)> t96:1, t100, undef:i64
Creating new node: t102: i64 = add nuw t96, Constant:i64<8>
Creating constant: t103: i64 = Constant<232>
Creating new node: t104: i64 = add nuw t102, Constant:i64<232>
Creating new node: t105: i64 = add t104, t101
Creating new node: t106: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t96:1, t105, undef:i64
Creating new node: t108: ch = CopyToReg t0, Register:i64 %16, t106
Creating new node: t110: i1 = setcc t106, Constant:i64<0>, seteq:ch
Creating constant: t111: i1 = Constant<-1>
Creating new node: t112: i1 = xor t110, Constant:i1<-1>
Creating new node: t114: ch = TokenFactor t98, t108, t96:1
Creating new node: t115: ch = brcond t114, t112, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Creating new node: t117: ch = br t115, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>
Initial selection DAG: %bb.6 'main:_Z7simpsonPFddEddi.exit'
SelectionDAG has 118 nodes:
  t0: ch = EntryToken
  t15: i64 = GlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0
    t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
  t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
  t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
  t35: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t32:1, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
    t37: i64 = add t35, Constant:i64<-24>
  t38: i64,ch = load<(load 8 from %ir.0)> t32:1, t37, undef:i64
  t40: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 8
  t46: i64 = GlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0
        t44: ch = TokenFactor t35:1, t38:1
        t42: i64 = add GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16, t38
      t45: ch = store<(store 8 into %ir.1, !tbaa !7)> t44, Constant:i64<6>, t42, undef:i64
    t49: ch,glue = callseq_start t45, TargetConstant:i64<0>, TargetConstant:i64<0>
  t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
    t48: i32,ch = CopyFromReg t0, Register:i32 %0
  t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
  t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
  t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
    t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
  t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
  t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
  t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
  t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
  t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
  t66: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t65:1, t56, undef:i64
  t67: i64 = add t66, Constant:i64<-24>
  t68: i64,ch = load<(load 8 from %ir.3)> t65:1, t67, undef:i64
  t69: i64 = add nuw t56, Constant:i64<8>
    t71: i64 = add nuw t69, Constant:i64<16>
  t72: i64 = add t71, t68
  t73: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t65:1, t72, undef:i64
      t78: ch = TokenFactor t66:1, t68:1, t73:1
        t75: i32 = and t73, Constant:i32<-261>
      t77: i32 = or t75, Constant:i32<4>
    t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t78, t77, t72, undef:i64
  t80: i64,ch = load<(load 8 from %ir.3)> t79, t67, undef:i64
      t81: i64 = add t69, t80
    t82: ch = store<(store 8 into %ir.8, !tbaa !18)> t80:1, Constant:i64<16>, t81, undef:i64
  t83: i64,ch = load<(load 8 from %ir.3)> t82, t67, undef:i64
  t88: i64 = GlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0
          t84: i64 = add nuw t69, Constant:i64<8>
        t85: i64 = add t84, t83
      t87: ch = store<(store 8 into %ir.10, !tbaa !7)> t83:1, Constant:i64<20>, t85, undef:i64
    t89: ch,glue = callseq_start t87, TargetConstant:i64<0>, TargetConstant:i64<0>
  t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
        t11: f64,ch = CopyFromReg t0, Register:f64 %2
            t2: f64,ch = CopyFromReg t0, Register:f64 %13
          t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
            t6: f64,ch = CopyFromReg t0, Register:f64 %14
          t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
        t9: f64 = fadd t4, t8
      t12: f64 = fmul t11, t9
    t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
  t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
  t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
  t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
  t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
        t102: i64 = add nuw t96, Constant:i64<8>
      t104: i64 = add nuw t102, Constant:i64<232>
          t99: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t96:1, t96, undef:i64
        t100: i64 = add t99, Constant:i64<-24>
      t101: i64,ch = load<(load 8 from %ir.12)> t96:1, t100, undef:i64
    t105: i64 = add t104, t101
  t106: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t96:1, t105, undef:i64
        t98: ch = CopyToReg t0, Register:i64 %15, t96
        t108: ch = CopyToReg t0, Register:i64 %16, t106
      t114: ch = TokenFactor t98, t108, t96:1
        t110: i1 = setcc t106, Constant:i64<0>, seteq:ch
      t112: i1 = xor t110, Constant:i1<-1>
    t115: ch = brcond t114, t112, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
  t117: ch = br t115, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>



Combining: t117: ch = br t115, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>

Combining: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>

Combining: t115: ch = brcond t114, t112, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Creating new node: t119: i1 = setcc t106, Constant:i64<0>, setne:ch
Creating new node: t120: ch = brcond t114, t119, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
 ... into: t120: ch = brcond t114, t119, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Combining: t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>

Combining: t120: ch = brcond t114, t119, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Combining: t119: i1 = setcc t106, Constant:i64<0>, setne:ch

Combining: t118: ch = setne

Combining: t114: ch = TokenFactor t98, t108, t96:1

Combining: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Combining: t108: ch = CopyToReg t0, Register:i64 %16, t106

Combining: t107: i64 = Register %16

Combining: t106: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t96:1, t105, undef:i64
Creating new node: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t105, undef:i64
Creating new node: t122: ch = TokenFactor t96:1, t121:1

Replacing.1 t106: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t96:1, t105, undef:i64

With: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t105, undef:i64
 and 1 other values

Combining: t119: i1 = setcc t121, Constant:i64<0>, setne:ch

Combining: t108: ch = CopyToReg t0, Register:i64 %16, t121

Combining: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t105, undef:i64

Combining: t105: i64 = add t104, t101
Creating new node: t123: i64 = add t102, t101
Creating new node: t124: i64 = add t123, Constant:i64<232>
 ... into: t124: i64 = add t123, Constant:i64<232>

Combining: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t124, undef:i64

Combining: t124: i64 = add t123, Constant:i64<232>

Combining: t123: i64 = add t102, t101
Creating new node: t125: i64 = add t96, t101
Creating new node: t126: i64 = add t125, Constant:i64<8>
 ... into: t126: i64 = add t125, Constant:i64<8>

Combining: t124: i64 = add t126, Constant:i64<232>
Creating constant: t127: i64 = Constant<240>
Creating new node: t128: i64 = add t125, Constant:i64<240>
 ... into: t128: i64 = add t125, Constant:i64<240>

Combining: t125: i64 = add t96, t101

Combining: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64

Combining: t128: i64 = add t125, Constant:i64<240>

Combining: t127: i64 = Constant<240>

Combining: t101: i64,ch = load<(load 8 from %ir.12)> t96:1, t100, undef:i64
Creating new node: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
Creating new node: t130: ch = TokenFactor t96:1, t129:1

Replacing.1 t101: i64,ch = load<(load 8 from %ir.12)> t96:1, t100, undef:i64

With: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
 and 1 other values

Combining: t125: i64 = add t96, t129

Combining: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64

Combining: t100: i64 = add t99, Constant:i64<-24>

Combining: t99: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t96:1, t96, undef:i64
Creating new node: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
Creating new node: t132: ch = TokenFactor t96:1, t131:1

Replacing.1 t99: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t96:1, t96, undef:i64

With: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
 and 1 other values

Combining: t100: i64 = add t131, Constant:i64<-24>

Combining: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64

Combining: t98: ch = CopyToReg t0, Register:i64 %15, t96

Combining: t97: i64 = Register %15

Combining: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1

Combining: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1

Combining: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1

Combining: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0

Combining: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

Combining: t91: f64 = Register $xmm0

Combining: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56

Combining: t89: ch,glue = callseq_start t87, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t87: ch = store<(store 8 into %ir.10, !tbaa !7)> t83:1, Constant:i64<20>, t85, undef:i64

Combining: t86: i64 = Constant<20>

Combining: t85: i64 = add t84, t83
Creating new node: t133: i64 = add t69, t83
Creating new node: t134: i64 = add t133, Constant:i64<8>
 ... into: t134: i64 = add t133, Constant:i64<8>

Combining: t87: ch = store<(store 8 into %ir.10, !tbaa !7)> t83:1, Constant:i64<20>, t134, undef:i64

Combining: t134: i64 = add t133, Constant:i64<8>

Combining: t133: i64 = add t69, t83

Combining: t83: i64,ch = load<(load 8 from %ir.3)> t82, t67, undef:i64

Combining: t82: ch = store<(store 8 into %ir.8, !tbaa !18)> t80:1, Constant:i64<16>, t81, undef:i64

Combining: t81: i64 = add t69, t80

Combining: t80: i64,ch = load<(load 8 from %ir.3)> t79, t67, undef:i64

Combining: t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t78, t77, t72, undef:i64

Combining: t78: ch = TokenFactor t66:1, t68:1, t73:1

Combining: t77: i32 = or t75, Constant:i32<4>

Combining: t76: i32 = Constant<4>

Combining: t75: i32 = and t73, Constant:i32<-261>

Combining: t74: i32 = Constant<-261>

Combining: t73: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t65:1, t72, undef:i64
Creating new node: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t72, undef:i64
Creating new node: t136: ch = TokenFactor t65:1, t135:1

Replacing.1 t73: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t65:1, t72, undef:i64

With: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t72, undef:i64
 and 1 other values

Combining: t78: ch = TokenFactor t66:1, t68:1, t136
Creating new node: t137: ch = TokenFactor t66:1, t68:1, t135:1
 ... into: t137: ch = TokenFactor t66:1, t68:1, t135:1

Combining: t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t137, t77, t72, undef:i64

Combining: t137: ch = TokenFactor t66:1, t68:1, t135:1

Combining: t75: i32 = and t135, Constant:i32<-261>

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t72, undef:i64

Combining: t72: i64 = add t71, t68
Creating new node: t138: i64 = add t69, t68
Creating new node: t139: i64 = add t138, Constant:i64<16>
 ... into: t139: i64 = add t138, Constant:i64<16>

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Combining: t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t137, t77, t139, undef:i64

Combining: t139: i64 = add t138, Constant:i64<16>

Combining: t138: i64 = add t69, t68

Combining: t70: i64 = Constant<16>

Combining: t69: i64 = add nuw t56, Constant:i64<8>

Combining: t68: i64,ch = load<(load 8 from %ir.3)> t65:1, t67, undef:i64
Creating new node: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
Creating new node: t141: ch = TokenFactor t65:1, t140:1

Replacing.1 t68: i64,ch = load<(load 8 from %ir.3)> t65:1, t67, undef:i64

With: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
 and 1 other values

Combining: t137: ch = TokenFactor t66:1, t141, t135:1
Creating new node: t142: ch = TokenFactor t66:1, t135:1, t140:1
 ... into: t142: ch = TokenFactor t66:1, t135:1, t140:1

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Combining: t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t142, t77, t139, undef:i64

Combining: t142: ch = TokenFactor t66:1, t135:1, t140:1

Combining: t138: i64 = add t69, t140

Combining: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64

Combining: t67: i64 = add t66, Constant:i64<-24>

Combining: t66: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t65:1, t56, undef:i64
Creating new node: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
Creating new node: t144: ch = TokenFactor t65:1, t143:1

Replacing.1 t66: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t65:1, t56, undef:i64

With: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
 and 1 other values

Combining: t142: ch = TokenFactor t144, t135:1, t140:1
Creating new node: t145: ch = TokenFactor t135:1, t140:1, t65:1, t143:1
 ... into: t145: ch = TokenFactor t135:1, t140:1, t65:1, t143:1

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Combining: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64

Combining: t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t145, t77, t139, undef:i64
Creating new node: t146: ch = TokenFactor t135:1, t140:1, t64, t143:1
Creating new node: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t146, t77, t139, undef:i64
Creating new node: t148: ch = TokenFactor t145, t147

Replacing.1 t79: ch = store<(store 4 into %ir.5, !tbaa !17)> t145, t77, t139, undef:i64

With: t148: ch = TokenFactor t145, t147
 and 0 other values

Combining: t148: ch = TokenFactor t145, t147
Creating new node: t149: ch = TokenFactor t147, t65:1
 ... into: t149: ch = TokenFactor t147, t65:1

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Combining: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64

Combining: t80: i64,ch = load<(load 8 from %ir.3)> t149, t67, undef:i64
Creating new node: t150: ch = TokenFactor t147, t64
Creating new node: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
Creating new node: t152: ch = TokenFactor t149, t151:1

Replacing.1 t80: i64,ch = load<(load 8 from %ir.3)> t149, t67, undef:i64

With: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
 and 1 other values

Combining: t82: ch = store<(store 8 into %ir.8, !tbaa !18)> t152, Constant:i64<16>, t81, undef:i64
Creating new node: t153: ch = TokenFactor t147, t64, t151:1
Creating new node: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t153, Constant:i64<16>, t81, undef:i64
Creating new node: t155: ch = TokenFactor t152, t154

Replacing.1 t82: ch = store<(store 8 into %ir.8, !tbaa !18)> t152, Constant:i64<16>, t81, undef:i64

With: t155: ch = TokenFactor t152, t154
 and 0 other values

Combining: t155: ch = TokenFactor t152, t154
Creating new node: t156: ch = TokenFactor t154, t65:1
 ... into: t156: ch = TokenFactor t154, t65:1

Combining: t83: i64,ch = load<(load 8 from %ir.3)> t156, t67, undef:i64
Creating new node: t157: ch = TokenFactor t154, t64
Creating new node: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
Creating new node: t159: ch = TokenFactor t156, t158:1

Replacing.1 t83: i64,ch = load<(load 8 from %ir.3)> t156, t67, undef:i64

With: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
 and 1 other values

Combining: t87: ch = store<(store 8 into %ir.10, !tbaa !7)> t159, Constant:i64<20>, t134, undef:i64
Creating new node: t160: ch = TokenFactor t154, t64, t158:1
Creating new node: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t160, Constant:i64<20>, t134, undef:i64
Creating new node: t162: ch = TokenFactor t159, t161

Replacing.1 t87: ch = store<(store 8 into %ir.10, !tbaa !7)> t159, Constant:i64<20>, t134, undef:i64

With: t162: ch = TokenFactor t159, t161
 and 0 other values

Combining: t162: ch = TokenFactor t159, t161
Creating new node: t163: ch = TokenFactor t161, t65:1
 ... into: t163: ch = TokenFactor t161, t65:1

Combining: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t163: ch = TokenFactor t161, t65:1

Combining: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t160, Constant:i64<20>, t134, undef:i64

Combining: t160: ch = TokenFactor t154, t64, t158:1
Creating new node: t164: ch = TokenFactor t154, t158:1
 ... into: t164: ch = TokenFactor t154, t158:1

Combining: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t164, Constant:i64<20>, t134, undef:i64

Combining: t164: ch = TokenFactor t154, t158:1
 ... into: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64

Combining: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64

Combining: t133: i64 = add t69, t158

Combining: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64

Combining: t157: ch = TokenFactor t154, t64

Combining: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t153, Constant:i64<16>, t81, undef:i64

Combining: t153: ch = TokenFactor t147, t64, t151:1
Creating new node: t165: ch = TokenFactor t147, t151:1
 ... into: t165: ch = TokenFactor t147, t151:1

Combining: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t165, Constant:i64<16>, t81, undef:i64

Combining: t165: ch = TokenFactor t147, t151:1
 ... into: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64

Combining: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64

Combining: t81: i64 = add t69, t151

Combining: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64

Combining: t150: ch = TokenFactor t147, t64

Combining: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t146, t77, t139, undef:i64

Combining: t146: ch = TokenFactor t135:1, t140:1, t64, t143:1
Creating new node: t166: ch = TokenFactor t135:1, t140:1, t143:1
 ... into: t166: ch = TokenFactor t135:1, t140:1, t143:1

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Combining: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64

Combining: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64

Combining: t166: ch = TokenFactor t135:1, t140:1, t143:1

Combining: t67: i64 = add t143, Constant:i64<-24>

Combining: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64

Combining: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1

Combining: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1

Combining: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1

Combining: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1

Combining: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1

Combining: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56

Combining: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t58: i64 = Constant<4>

Combining: t57: i64 = GlobalAddress<[5 x i8]* @.str.1> 0

Combining: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1

Combining: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1

Combining: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1

Combining: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0

Combining: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

Combining: t51: i32 = Register $esi

Combining: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Combining: t49: ch,glue = callseq_start t45, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t47: i32 = Register %0

Combining: t45: ch = store<(store 8 into %ir.1, !tbaa !7)> t44, Constant:i64<6>, t42, undef:i64

Combining: t44: ch = TokenFactor t35:1, t38:1

Combining: t43: i64 = Constant<6>

Combining: t42: i64 = add GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16, t38
Creating new node: t167: i64 = add t38, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
 ... into: t167: i64 = add t38, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Combining: t45: ch = store<(store 8 into %ir.1, !tbaa !7)> t44, Constant:i64<6>, t167, undef:i64

Combining: t167: i64 = add t38, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Combining: t41: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Combining: t39: i64 = Constant<8>

Combining: t38: i64,ch = load<(load 8 from %ir.0)> t32:1, t37, undef:i64
Creating new node: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
Creating new node: t169: ch = TokenFactor t32:1, t168:1

Replacing.1 t38: i64,ch = load<(load 8 from %ir.0)> t32:1, t37, undef:i64

With: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
 and 1 other values

Combining: t44: ch = TokenFactor t35:1, t169
Creating new node: t170: ch = TokenFactor t35:1, t168:1
 ... into: t170: ch = TokenFactor t35:1, t168:1

Combining: t45: ch = store<(store 8 into %ir.1, !tbaa !7)> t170, Constant:i64<6>, t167, undef:i64

Combining: t170: ch = TokenFactor t35:1, t168:1

Combining: t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Combining: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64

Combining: t37: i64 = add t35, Constant:i64<-24>

Combining: t36: i64 = Constant<-24>

Combining: t35: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t32:1, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
Creating new node: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
Creating new node: t172: ch = TokenFactor t32:1, t171:1

Replacing.1 t35: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t32:1, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64

With: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
 and 1 other values

Combining: t170: ch = TokenFactor t172, t168:1
Creating new node: t173: ch = TokenFactor t168:1, t32:1, t171:1
 ... into: t173: ch = TokenFactor t168:1, t32:1, t171:1

Combining: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64

Combining: t45: ch = store<(store 8 into %ir.1, !tbaa !7)> t173, Constant:i64<6>, t167, undef:i64
Creating new node: t174: ch = TokenFactor t168:1, t30, t171:1
Creating new node: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t174, Constant:i64<6>, t167, undef:i64
Creating new node: t176: ch = TokenFactor t173, t175

Replacing.1 t45: ch = store<(store 8 into %ir.1, !tbaa !7)> t173, Constant:i64<6>, t167, undef:i64

With: t176: ch = TokenFactor t173, t175
 and 0 other values

Combining: t176: ch = TokenFactor t173, t175
Creating new node: t177: ch = TokenFactor t175, t32:1
 ... into: t177: ch = TokenFactor t175, t32:1

Combining: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64

Combining: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t177: ch = TokenFactor t175, t32:1

Combining: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t174, Constant:i64<6>, t167, undef:i64

Combining: t174: ch = TokenFactor t168:1, t30, t171:1
Creating new node: t178: ch = TokenFactor t168:1, t171:1
 ... into: t178: ch = TokenFactor t168:1, t171:1

Combining: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64

Combining: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64

Combining: t178: ch = TokenFactor t168:1, t171:1

Combining: t37: i64 = add t171, Constant:i64<-24>

Combining: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64

Combining: t34: i64 = undef

Combining: t33: i64 = Constant<0>

Combining: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1

Combining: t31: i64 = Register $rax

Combining: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Combining: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1

Combining: t28: Untyped = RegisterMask

Combining: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0

Combining: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1

Combining: t25: i64 = Register $rdx

Combining: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1

Combining: t23: i64 = Register $rsi

Combining: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Combining: t21: i64 = Register $rdi

Combining: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t19: i64 = TargetConstant<0>

Combining: t18: i64 = Constant<2>

Combining: t17: i64 = GlobalAddress<[3 x i8]* @.str> 0

Combining: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0

Combining: t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
Creating fp constant: t179: f64 = ConstantFP<-3.000000e+00>

Combining: t13: f64 = ConstantFP<3.000000e+00>

Combining: t12: f64 = fmul t11, t9

Combining: t11: f64,ch = CopyFromReg t0, Register:f64 %2

Combining: t10: f64 = Register %2

Combining: t9: f64 = fadd t4, t8
Creating fp constant: t180: f64 = ConstantFP<-4.000000e+00>
Creating new node: t181: f64 = fmul t6, ConstantFP:f64<-4.000000e+00>

Combining: t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
Creating fp constant: t182: f64 = ConstantFP<-4.000000e+00>

Combining: t7: f64 = ConstantFP<4.000000e+00>

Combining: t6: f64,ch = CopyFromReg t0, Register:f64 %14

Combining: t5: f64 = Register %14

Combining: t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
Creating fp constant: t183: f64 = ConstantFP<-1.000000e+00>

Combining: t3: f64 = ConstantFP<1.000000e+00>

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %13

Combining: t1: f64 = Register %13

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.6 'main:_Z7simpsonPFddEddi.exit'
SelectionDAG has 115 nodes:
  t0: ch = EntryToken
    t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
  t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
  t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
          t178: ch = TokenFactor t168:1, t171:1
          t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
        t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
        t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
      t177: ch = TokenFactor t175, t32:1
    t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
  t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
    t48: i32,ch = CopyFromReg t0, Register:i32 %0
  t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
  t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
  t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
    t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
  t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
  t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
  t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
  t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
  t67: i64 = add t143, Constant:i64<-24>
  t69: i64 = add nuw t56, Constant:i64<8>
            t133: i64 = add t69, t158
          t134: i64 = add t133, Constant:i64<8>
        t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
        t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
      t163: ch = TokenFactor t161, t65:1
    t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
  t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
        t11: f64,ch = CopyFromReg t0, Register:f64 %2
            t2: f64,ch = CopyFromReg t0, Register:f64 %13
          t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
            t6: f64,ch = CopyFromReg t0, Register:f64 %14
          t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
        t9: f64 = fadd t4, t8
      t12: f64 = fmul t11, t9
    t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
  t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
  t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
  t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
  t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
            t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
          t100: i64 = add t131, Constant:i64<-24>
        t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
      t125: i64 = add t96, t129
    t128: i64 = add t125, Constant:i64<240>
  t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
  t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
    t138: i64 = add t69, t140
  t139: i64 = add t138, Constant:i64<16>
  t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
  t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
        t166: ch = TokenFactor t135:1, t140:1, t143:1
          t75: i32 = and t135, Constant:i32<-261>
        t77: i32 = or t75, Constant:i32<4>
      t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
    t150: ch = TokenFactor t147, t64
  t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
        t81: i64 = add t69, t151
      t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
    t157: ch = TokenFactor t154, t64
  t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
    t37: i64 = add t171, Constant:i64<-24>
  t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
  t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
        t98: ch = CopyToReg t0, Register:i64 %15, t96
        t108: ch = CopyToReg t0, Register:i64 %16, t121
      t114: ch = TokenFactor t98, t108, t96:1
      t119: i1 = setcc t121, Constant:i64<0>, setne:ch
    t120: ch = brcond t114, t119, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
  t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>


Legalizing node: t127: i64 = Constant<240>
Analyzing result type: i64
Legal result type
Legally typed node: t127: i64 = Constant<240>

Legalizing node: t118: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t118: ch = setne

Legalizing node: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>
Analyzing result type: ch
Legal result type
Legally typed node: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>

Legalizing node: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Analyzing result type: ch
Legal result type
Legally typed node: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Legalizing node: t107: i64 = Register %16
Ignoring node results
Legally typed node: t107: i64 = Register %16

Legalizing node: t97: i64 = Register %15
Ignoring node results
Legally typed node: t97: i64 = Register %15

Legalizing node: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0
Analyzing result type: i64
Legal result type
Legally typed node: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0

Legalizing node: t91: f64 = Register $xmm0
Ignoring node results
Legally typed node: t91: f64 = Register $xmm0

Legalizing node: t86: i64 = Constant<20>
Analyzing result type: i64
Legal result type
Legally typed node: t86: i64 = Constant<20>

Legalizing node: t76: i32 = Constant<4>
Analyzing result type: i32
Legal result type
Legally typed node: t76: i32 = Constant<4>

Legalizing node: t74: i32 = Constant<-261>
Analyzing result type: i32
Legal result type
Legally typed node: t74: i32 = Constant<-261>

Legalizing node: t70: i64 = Constant<16>
Analyzing result type: i64
Legal result type
Legally typed node: t70: i64 = Constant<16>

Legalizing node: t58: i64 = Constant<4>
Analyzing result type: i64
Legal result type
Legally typed node: t58: i64 = Constant<4>

Legalizing node: t57: i64 = GlobalAddress<[5 x i8]* @.str.1> 0
Analyzing result type: i64
Legal result type
Legally typed node: t57: i64 = GlobalAddress<[5 x i8]* @.str.1> 0

Legalizing node: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0
Analyzing result type: i64
Legal result type
Legally typed node: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0

Legalizing node: t51: i32 = Register $esi
Ignoring node results
Legally typed node: t51: i32 = Register $esi

Legalizing node: t47: i32 = Register %0
Ignoring node results
Legally typed node: t47: i32 = Register %0

Legalizing node: t43: i64 = Constant<6>
Analyzing result type: i64
Legal result type
Legally typed node: t43: i64 = Constant<6>

Legalizing node: t41: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Analyzing result type: i64
Legal result type
Legally typed node: t41: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Legalizing node: t39: i64 = Constant<8>
Analyzing result type: i64
Legal result type
Legally typed node: t39: i64 = Constant<8>

Legalizing node: t36: i64 = Constant<-24>
Analyzing result type: i64
Legal result type
Legally typed node: t36: i64 = Constant<-24>

Legalizing node: t34: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t34: i64 = undef

Legalizing node: t33: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t33: i64 = Constant<0>

Legalizing node: t31: i64 = Register $rax
Ignoring node results
Legally typed node: t31: i64 = Register $rax

Legalizing node: t28: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t28: Untyped = RegisterMask

Legalizing node: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0

Legalizing node: t25: i64 = Register $rdx
Ignoring node results
Legally typed node: t25: i64 = Register $rdx

Legalizing node: t23: i64 = Register $rsi
Ignoring node results
Legally typed node: t23: i64 = Register $rsi

Legalizing node: t21: i64 = Register $rdi
Ignoring node results
Legally typed node: t21: i64 = Register $rdi

Legalizing node: t19: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t19: i64 = TargetConstant<0>

Legalizing node: t18: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t18: i64 = Constant<2>

Legalizing node: t17: i64 = GlobalAddress<[3 x i8]* @.str> 0
Analyzing result type: i64
Legal result type
Legally typed node: t17: i64 = GlobalAddress<[3 x i8]* @.str> 0

Legalizing node: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0

Legalizing node: t13: f64 = ConstantFP<3.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t13: f64 = ConstantFP<3.000000e+00>

Legalizing node: t10: f64 = Register %2
Ignoring node results
Legally typed node: t10: f64 = Register %2

Legalizing node: t7: f64 = ConstantFP<4.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t7: f64 = ConstantFP<4.000000e+00>

Legalizing node: t5: f64 = Register %14
Ignoring node results
Legally typed node: t5: f64 = Register %14

Legalizing node: t3: f64 = ConstantFP<1.000000e+00>
Analyzing result type: f64
Legal result type
Legally typed node: t3: f64 = ConstantFP<1.000000e+00>

Legalizing node: t1: f64 = Register %13
Ignoring node results
Legally typed node: t1: f64 = Register %13

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: f64,ch = CopyFromReg t0, Register:f64 %13
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: f64,ch = CopyFromReg t0, Register:f64 %13

Legalizing node: t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t2: f64,ch = CopyFromReg t0, Register:f64 %13
Legal operand
Analyzing operand: t3: f64 = ConstantFP<1.000000e+00>
Legal operand
Legally typed node: t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>

Legalizing node: t6: f64,ch = CopyFromReg t0, Register:f64 %14
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: f64,ch = CopyFromReg t0, Register:f64 %14

Legalizing node: t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t6: f64,ch = CopyFromReg t0, Register:f64 %14
Legal operand
Analyzing operand: t7: f64 = ConstantFP<4.000000e+00>
Legal operand
Legally typed node: t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>

Legalizing node: t9: f64 = fadd t4, t8
Analyzing result type: f64
Legal result type
Analyzing operand: t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
Legal operand
Analyzing operand: t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
Legal operand
Legally typed node: t9: f64 = fadd t4, t8

Legalizing node: t11: f64,ch = CopyFromReg t0, Register:f64 %2
Analyzing result type: f64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t11: f64,ch = CopyFromReg t0, Register:f64 %2

Legalizing node: t12: f64 = fmul t11, t9
Analyzing result type: f64
Legal result type
Analyzing operand: t11: f64,ch = CopyFromReg t0, Register:f64 %2
Legal operand
Analyzing operand: t9: f64 = fadd t4, t8
Legal operand
Legally typed node: t12: f64 = fmul t11, t9

Legalizing node: t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
Analyzing result type: f64
Legal result type
Analyzing operand: t12: f64 = fmul t11, t9
Legal operand
Analyzing operand: t13: f64 = ConstantFP<3.000000e+00>
Legal operand
Legally typed node: t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>

Legalizing node: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal operand
Legally typed node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Legalizing node: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal operand
Analyzing operand: t17: i64 = GlobalAddress<[3 x i8]* @.str> 0
Legal operand
Analyzing operand: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal operand
Legally typed node: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1

Legalizing node: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
Legal operand
Analyzing operand: t18: i64 = Constant<2>
Legal operand
Analyzing operand: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
Legal operand
Legally typed node: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1

Legalizing node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
Legal operand
Analyzing operand: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0
Legal operand
Analyzing operand: t28: Untyped = RegisterMask
Legal operand
Analyzing operand: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
Legal operand
Legally typed node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1

Legalizing node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
Legal operand
Analyzing operand: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
Legal operand
Legally typed node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Legalizing node: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Legal operand
Analyzing operand: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Legal operand
Legally typed node: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1

Legalizing node: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Legal operand
Analyzing operand: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64

Legalizing node: t37: i64 = add t171, Constant:i64<-24>
Analyzing result type: i64
Legal result type
Analyzing operand: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
Legal operand
Analyzing operand: t36: i64 = Constant<-24>
Legal operand
Legally typed node: t37: i64 = add t171, Constant:i64<-24>

Legalizing node: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Legal operand
Analyzing operand: t37: i64 = add t171, Constant:i64<-24>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64

Legalizing node: t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Analyzing result type: i64
Legal result type
Analyzing operand: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
Legal operand
Analyzing operand: t41: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Legal operand
Legally typed node: t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Legalizing node: t178: ch = TokenFactor t168:1, t171:1
Analyzing result type: ch
Legal result type
Analyzing operand: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
Legal operand
Analyzing operand: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
Legal operand
Legally typed node: t178: ch = TokenFactor t168:1, t171:1

Legalizing node: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t178: ch = TokenFactor t168:1, t171:1
Legal operand
Analyzing operand: t43: i64 = Constant<6>
Legal operand
Analyzing operand: t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64

Legalizing node: t177: ch = TokenFactor t175, t32:1
Analyzing result type: ch
Legal result type
Analyzing operand: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
Legal operand
Analyzing operand: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
Legal operand
Legally typed node: t177: ch = TokenFactor t175, t32:1

Legalizing node: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t177: ch = TokenFactor t175, t32:1
Legal operand
Legally typed node: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal operand
Legally typed node: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Legalizing node: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal operand
Analyzing operand: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal operand
Legally typed node: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

Legalizing node: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
Legal operand
Analyzing operand: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0
Legal operand
Analyzing operand: t28: Untyped = RegisterMask
Legal operand
Analyzing operand: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
Legal operand
Legally typed node: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1

Legalizing node: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
Legal operand
Analyzing operand: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
Legal operand
Legally typed node: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1

Legalizing node: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
Legal operand
Analyzing operand: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
Legal operand
Legally typed node: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1

Legalizing node: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Legal operand
Legally typed node: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Legal operand
Legally typed node: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56

Legalizing node: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
Legal operand
Analyzing operand: t57: i64 = GlobalAddress<[5 x i8]* @.str.1> 0
Legal operand
Analyzing operand: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
Legal operand
Legally typed node: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1

Legalizing node: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
Legal operand
Analyzing operand: t58: i64 = Constant<4>
Legal operand
Analyzing operand: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
Legal operand
Legally typed node: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1

Legalizing node: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
Legal operand
Analyzing operand: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0
Legal operand
Analyzing operand: t28: Untyped = RegisterMask
Legal operand
Analyzing operand: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
Legal operand
Legally typed node: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1

Legalizing node: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
Legal operand
Analyzing operand: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
Legal operand
Legally typed node: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1

Legalizing node: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Legal operand
Analyzing operand: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Legal operand
Legally typed node: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1

Legalizing node: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Legal operand
Analyzing operand: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64

Legalizing node: t67: i64 = add t143, Constant:i64<-24>
Analyzing result type: i64
Legal result type
Analyzing operand: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
Legal operand
Analyzing operand: t36: i64 = Constant<-24>
Legal operand
Legally typed node: t67: i64 = add t143, Constant:i64<-24>

Legalizing node: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Legal operand
Analyzing operand: t67: i64 = add t143, Constant:i64<-24>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64

Legalizing node: t69: i64 = add nuw t56, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Legal operand
Analyzing operand: t39: i64 = Constant<8>
Legal operand
Legally typed node: t69: i64 = add nuw t56, Constant:i64<8>

Legalizing node: t138: i64 = add t69, t140
Analyzing result type: i64
Legal result type
Analyzing operand: t69: i64 = add nuw t56, Constant:i64<8>
Legal operand
Analyzing operand: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
Legal operand
Legally typed node: t138: i64 = add t69, t140

Legalizing node: t139: i64 = add t138, Constant:i64<16>
Analyzing result type: i64
Legal result type
Analyzing operand: t138: i64 = add t69, t140
Legal operand
Analyzing operand: t70: i64 = Constant<16>
Legal operand
Legally typed node: t139: i64 = add t138, Constant:i64<16>

Legalizing node: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Legal operand
Analyzing operand: t139: i64 = add t138, Constant:i64<16>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Legalizing node: t75: i32 = and t135, Constant:i32<-261>
Analyzing result type: i32
Legal result type
Analyzing operand: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
Legal operand
Analyzing operand: t74: i32 = Constant<-261>
Legal operand
Legally typed node: t75: i32 = and t135, Constant:i32<-261>

Legalizing node: t77: i32 = or t75, Constant:i32<4>
Analyzing result type: i32
Legal result type
Analyzing operand: t75: i32 = and t135, Constant:i32<-261>
Legal operand
Analyzing operand: t76: i32 = Constant<4>
Legal operand
Legally typed node: t77: i32 = or t75, Constant:i32<4>

Legalizing node: t166: ch = TokenFactor t135:1, t140:1, t143:1
Analyzing result type: ch
Legal result type
Analyzing operand: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
Legal operand
Analyzing operand: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
Legal operand
Analyzing operand: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
Legal operand
Legally typed node: t166: ch = TokenFactor t135:1, t140:1, t143:1

Legalizing node: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t166: ch = TokenFactor t135:1, t140:1, t143:1
Legal operand
Analyzing operand: t77: i32 = or t75, Constant:i32<4>
Legal operand
Analyzing operand: t139: i64 = add t138, Constant:i64<16>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64

Legalizing node: t150: ch = TokenFactor t147, t64
Analyzing result type: ch
Legal result type
Analyzing operand: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
Legal operand
Analyzing operand: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Legal operand
Legally typed node: t150: ch = TokenFactor t147, t64

Legalizing node: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t150: ch = TokenFactor t147, t64
Legal operand
Analyzing operand: t67: i64 = add t143, Constant:i64<-24>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64

Legalizing node: t81: i64 = add t69, t151
Analyzing result type: i64
Legal result type
Analyzing operand: t69: i64 = add nuw t56, Constant:i64<8>
Legal operand
Analyzing operand: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
Legal operand
Legally typed node: t81: i64 = add t69, t151

Legalizing node: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
Legal operand
Analyzing operand: t70: i64 = Constant<16>
Legal operand
Analyzing operand: t81: i64 = add t69, t151
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64

Legalizing node: t157: ch = TokenFactor t154, t64
Analyzing result type: ch
Legal result type
Analyzing operand: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
Legal operand
Analyzing operand: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
Legal operand
Legally typed node: t157: ch = TokenFactor t154, t64

Legalizing node: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t157: ch = TokenFactor t154, t64
Legal operand
Analyzing operand: t67: i64 = add t143, Constant:i64<-24>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64

Legalizing node: t133: i64 = add t69, t158
Analyzing result type: i64
Legal result type
Analyzing operand: t69: i64 = add nuw t56, Constant:i64<8>
Legal operand
Analyzing operand: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
Legal operand
Legally typed node: t133: i64 = add t69, t158

Legalizing node: t134: i64 = add t133, Constant:i64<8>
Analyzing result type: i64
Legal result type
Analyzing operand: t133: i64 = add t69, t158
Legal operand
Analyzing operand: t39: i64 = Constant<8>
Legal operand
Legally typed node: t134: i64 = add t133, Constant:i64<8>

Legalizing node: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
Legal operand
Analyzing operand: t86: i64 = Constant<20>
Legal operand
Analyzing operand: t134: i64 = add t133, Constant:i64<8>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64

Legalizing node: t163: ch = TokenFactor t161, t65:1
Analyzing result type: ch
Legal result type
Analyzing operand: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
Legal operand
Analyzing operand: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
Legal operand
Legally typed node: t163: ch = TokenFactor t161, t65:1

Legalizing node: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t163: ch = TokenFactor t161, t65:1
Legal operand
Legally typed node: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Legal operand
Legally typed node: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56

Legalizing node: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
Legal operand
Analyzing operand: t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
Legal operand
Analyzing operand: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
Legal operand
Legally typed node: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

Legalizing node: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
Legal operand
Analyzing operand: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0
Legal operand
Analyzing operand: t28: Untyped = RegisterMask
Legal operand
Analyzing operand: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
Legal operand
Legally typed node: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1

Legalizing node: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
Legal operand
Analyzing operand: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
Legal operand
Legally typed node: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1

Legalizing node: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
Legal operand
Analyzing operand: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
Legal operand
Legally typed node: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1

Legalizing node: t98: ch = CopyToReg t0, Register:i64 %15, t96
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Legal operand
Legally typed node: t98: ch = CopyToReg t0, Register:i64 %15, t96

Legalizing node: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
Legal operand
Analyzing operand: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64

Legalizing node: t100: i64 = add t131, Constant:i64<-24>
Analyzing result type: i64
Legal result type
Analyzing operand: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
Legal operand
Analyzing operand: t36: i64 = Constant<-24>
Legal operand
Legally typed node: t100: i64 = add t131, Constant:i64<-24>

Legalizing node: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
Legal operand
Analyzing operand: t100: i64 = add t131, Constant:i64<-24>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64

Legalizing node: t125: i64 = add t96, t129
Analyzing result type: i64
Legal result type
Analyzing operand: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Legal operand
Analyzing operand: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
Legal operand
Legally typed node: t125: i64 = add t96, t129

Legalizing node: t128: i64 = add t125, Constant:i64<240>
Analyzing result type: i64
Legal result type
Analyzing operand: t125: i64 = add t96, t129
Legal operand
Analyzing operand: t127: i64 = Constant<240>
Legal operand
Legally typed node: t128: i64 = add t125, Constant:i64<240>

Legalizing node: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
Legal operand
Analyzing operand: t128: i64 = add t125, Constant:i64<240>
Legal operand
Analyzing operand: t34: i64 = undef
Legal operand
Legally typed node: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64

Legalizing node: t119: i1 = setcc t121, Constant:i64<0>, setne:ch
Analyzing result type: i1
Promote integer result: t119: i1 = setcc t121, Constant:i64<0>, setne:ch

Creating new node: t184: i8 = setcc t121, Constant:i64<0>, setne:ch
Legalizing node: t184: i8 = setcc t121, Constant:i64<0>, setne:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
Legal operand
Analyzing operand: t33: i64 = Constant<0>
Legal operand
Analyzing operand: t118: ch = setne
Legal operand
Legally typed node: t184: i8 = setcc t121, Constant:i64<0>, setne:ch

Legalizing node: t108: ch = CopyToReg t0, Register:i64 %16, t121
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
Legal operand
Legally typed node: t108: ch = CopyToReg t0, Register:i64 %16, t121

Legalizing node: t114: ch = TokenFactor t98, t108, t96:1
Analyzing result type: ch
Legal result type
Analyzing operand: t98: ch = CopyToReg t0, Register:i64 %15, t96
Legal operand
Analyzing operand: t108: ch = CopyToReg t0, Register:i64 %16, t121
Legal operand
Analyzing operand: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Legal operand
Legally typed node: t114: ch = TokenFactor t98, t108, t96:1

Legalizing node: t120: ch = brcond t114, t119, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Analyzing result type: ch
Legal result type
Analyzing operand: t114: ch = TokenFactor t98, t108, t96:1
Legal operand
Analyzing operand: t119: i1 = setcc t121, Constant:i64<0>, setne:ch
Promote integer operand: t120: ch = brcond t114, t119, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Creating new node: t185: i8 = zero_extend t119
Legalizing node: t185: i8 = zero_extend t119
Analyzing result type: i8
Legal result type
Analyzing operand: t119: i1 = setcc t121, Constant:i64<0>, setne:ch
Promote integer operand: t185: i8 = zero_extend t119

Creating constant: t186: i8 = Constant<1>
Creating new node: t187: i8 = and t184, Constant:i8<1>
Replacing: t185: i8 = zero_extend t119
     with: t187: i8 = and t184, Constant:i8<1>
Legalizing node: t186: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t186: i8 = Constant<1>

Legalizing node: t187: i8 = and t184, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t184: i8 = setcc t121, Constant:i64<0>, setne:ch
Legal operand
Analyzing operand: t186: i8 = Constant<1>
Legal operand
Legally typed node: t187: i8 = and t184, Constant:i8<1>

Legalizing node: t120: ch = brcond t114, t187, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Analyzing result type: ch
Legal result type
Analyzing operand: t114: ch = TokenFactor t98, t108, t96:1
Legal operand
Analyzing operand: t187: i8 = and t184, Constant:i8<1>
Legal operand
Analyzing operand: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Legal operand
Legally typed node: t120: ch = brcond t114, t187, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Legalizing node: t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>
Analyzing result type: ch
Legal result type
Analyzing operand: t120: ch = brcond t114, t187, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Legal operand
Analyzing operand: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>
Legal operand
Legally typed node: t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>

Legalizing node: t65535: ch = handlenode t117
Analyzing result type: ch
Legal result type
Analyzing operand: t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>
Legal operand
Legally typed node: t65535: ch = handlenode t117

Type-legalized selection DAG: %bb.6 'main:_Z7simpsonPFddEddi.exit'
SelectionDAG has 117 nodes:
  t0: ch = EntryToken
    t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
  t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
  t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
          t178: ch = TokenFactor t168:1, t171:1
          t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
        t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
        t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
      t177: ch = TokenFactor t175, t32:1
    t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
  t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
    t48: i32,ch = CopyFromReg t0, Register:i32 %0
  t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
  t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
  t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
    t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
  t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
  t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
  t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
  t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
  t67: i64 = add t143, Constant:i64<-24>
  t69: i64 = add nuw t56, Constant:i64<8>
            t133: i64 = add t69, t158
          t134: i64 = add t133, Constant:i64<8>
        t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
        t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
      t163: ch = TokenFactor t161, t65:1
    t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
  t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
        t11: f64,ch = CopyFromReg t0, Register:f64 %2
            t2: f64,ch = CopyFromReg t0, Register:f64 %13
          t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
            t6: f64,ch = CopyFromReg t0, Register:f64 %14
          t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
        t9: f64 = fadd t4, t8
      t12: f64 = fmul t11, t9
    t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
  t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
  t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
  t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
  t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
            t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
          t100: i64 = add t131, Constant:i64<-24>
        t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
      t125: i64 = add t96, t129
    t128: i64 = add t125, Constant:i64<240>
  t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
  t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
    t138: i64 = add t69, t140
  t139: i64 = add t138, Constant:i64<16>
  t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
  t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
        t166: ch = TokenFactor t135:1, t140:1, t143:1
          t75: i32 = and t135, Constant:i32<-261>
        t77: i32 = or t75, Constant:i32<4>
      t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
    t150: ch = TokenFactor t147, t64
  t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
        t81: i64 = add t69, t151
      t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
    t157: ch = TokenFactor t154, t64
  t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
    t37: i64 = add t171, Constant:i64<-24>
  t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
  t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
        t98: ch = CopyToReg t0, Register:i64 %15, t96
        t108: ch = CopyToReg t0, Register:i64 %16, t121
      t114: ch = TokenFactor t98, t108, t96:1
        t184: i8 = setcc t121, Constant:i64<0>, setne:ch
      t187: i8 = and t184, Constant:i8<1>
    t120: ch = brcond t114, t187, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
  t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>



Combining: t187: i8 = and t184, Constant:i8<1>

Replacing.2 t187: i8 = and t184, Constant:i8<1>

With: t184: i8 = setcc t121, Constant:i64<0>, setne:ch


Combining: t184: i8 = setcc t121, Constant:i64<0>, setne:ch

Combining: t178: ch = TokenFactor t168:1, t171:1

Combining: t177: ch = TokenFactor t175, t32:1

Combining: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64

Combining: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64

Combining: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64

Combining: t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Combining: t166: ch = TokenFactor t135:1, t140:1, t143:1

Combining: t163: ch = TokenFactor t161, t65:1

Combining: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64

Combining: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64

Combining: t157: ch = TokenFactor t154, t64

Combining: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64

Combining: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64

Combining: t150: ch = TokenFactor t147, t64

Combining: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64

Combining: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64

Combining: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64

Combining: t139: i64 = add t138, Constant:i64<16>

Combining: t138: i64 = add t69, t140

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Combining: t134: i64 = add t133, Constant:i64<8>

Combining: t133: i64 = add t69, t158

Combining: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64

Combining: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64

Combining: t128: i64 = add t125, Constant:i64<240>

Combining: t127: i64 = Constant<240>

Combining: t125: i64 = add t96, t129

Combining: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64

Combining: t120: ch = brcond t114, t184, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Combining: t118: ch = setne

Combining: t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>

Combining: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>

Combining: t114: ch = TokenFactor t98, t108, t96:1

Combining: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Combining: t108: ch = CopyToReg t0, Register:i64 %16, t121

Combining: t107: i64 = Register %16

Combining: t100: i64 = add t131, Constant:i64<-24>

Combining: t98: ch = CopyToReg t0, Register:i64 %15, t96

Combining: t97: i64 = Register %15

Combining: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1

Combining: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1

Combining: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1

Combining: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0

Combining: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

Combining: t91: f64 = Register $xmm0

Combining: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56

Combining: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t86: i64 = Constant<20>

Combining: t81: i64 = add t69, t151

Combining: t77: i32 = or t75, Constant:i32<4>

Combining: t76: i32 = Constant<4>

Combining: t75: i32 = and t135, Constant:i32<-261>

Combining: t74: i32 = Constant<-261>

Combining: t70: i64 = Constant<16>

Combining: t69: i64 = add nuw t56, Constant:i64<8>

Combining: t67: i64 = add t143, Constant:i64<-24>

Combining: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1

Combining: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1

Combining: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1

Combining: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1

Combining: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1

Combining: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56

Combining: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t58: i64 = Constant<4>

Combining: t57: i64 = GlobalAddress<[5 x i8]* @.str.1> 0

Combining: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1

Combining: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1

Combining: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1

Combining: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0

Combining: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

Combining: t51: i32 = Register $esi

Combining: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Combining: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t47: i32 = Register %0

Combining: t43: i64 = Constant<6>

Combining: t41: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Combining: t39: i64 = Constant<8>

Combining: t37: i64 = add t171, Constant:i64<-24>

Combining: t36: i64 = Constant<-24>

Combining: t34: i64 = undef

Combining: t33: i64 = Constant<0>

Combining: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1

Combining: t31: i64 = Register $rax

Combining: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Combining: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1

Combining: t28: Untyped = RegisterMask

Combining: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0

Combining: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1

Combining: t25: i64 = Register $rdx

Combining: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1

Combining: t23: i64 = Register $rsi

Combining: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Combining: t21: i64 = Register $rdi

Combining: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t19: i64 = TargetConstant<0>

Combining: t18: i64 = Constant<2>

Combining: t17: i64 = GlobalAddress<[3 x i8]* @.str> 0

Combining: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0

Combining: t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
Creating fp constant: t188: f64 = ConstantFP<-3.000000e+00>

Combining: t13: f64 = ConstantFP<3.000000e+00>

Combining: t12: f64 = fmul t11, t9

Combining: t11: f64,ch = CopyFromReg t0, Register:f64 %2

Combining: t10: f64 = Register %2

Combining: t9: f64 = fadd t4, t8
Creating fp constant: t189: f64 = ConstantFP<-4.000000e+00>
Creating new node: t190: f64 = fmul t6, ConstantFP:f64<-4.000000e+00>

Combining: t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
Creating fp constant: t191: f64 = ConstantFP<-4.000000e+00>

Combining: t7: f64 = ConstantFP<4.000000e+00>

Combining: t6: f64,ch = CopyFromReg t0, Register:f64 %14

Combining: t5: f64 = Register %14

Combining: t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
Creating fp constant: t192: f64 = ConstantFP<-1.000000e+00>

Combining: t3: f64 = ConstantFP<1.000000e+00>

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %13

Combining: t1: f64 = Register %13

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.6 'main:_Z7simpsonPFddEddi.exit'
SelectionDAG has 115 nodes:
  t0: ch = EntryToken
    t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
  t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
  t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
          t178: ch = TokenFactor t168:1, t171:1
          t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
        t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
        t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
      t177: ch = TokenFactor t175, t32:1
    t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
  t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
    t48: i32,ch = CopyFromReg t0, Register:i32 %0
  t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
  t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
  t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
    t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
  t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
  t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
  t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
  t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
  t67: i64 = add t143, Constant:i64<-24>
  t69: i64 = add nuw t56, Constant:i64<8>
            t133: i64 = add t69, t158
          t134: i64 = add t133, Constant:i64<8>
        t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
        t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
      t163: ch = TokenFactor t161, t65:1
    t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
  t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
        t11: f64,ch = CopyFromReg t0, Register:f64 %2
            t2: f64,ch = CopyFromReg t0, Register:f64 %13
          t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
            t6: f64,ch = CopyFromReg t0, Register:f64 %14
          t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
        t9: f64 = fadd t4, t8
      t12: f64 = fmul t11, t9
    t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
  t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
  t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
  t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
  t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
            t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
          t100: i64 = add t131, Constant:i64<-24>
        t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
      t125: i64 = add t96, t129
    t128: i64 = add t125, Constant:i64<240>
  t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
  t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
    t138: i64 = add t69, t140
  t139: i64 = add t138, Constant:i64<16>
  t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
  t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
        t166: ch = TokenFactor t135:1, t140:1, t143:1
          t75: i32 = and t135, Constant:i32<-261>
        t77: i32 = or t75, Constant:i32<4>
      t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
    t150: ch = TokenFactor t147, t64
  t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
        t81: i64 = add t69, t151
      t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
    t157: ch = TokenFactor t154, t64
  t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
    t37: i64 = add t171, Constant:i64<-24>
  t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
  t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
        t98: ch = CopyToReg t0, Register:i64 %15, t96
        t108: ch = CopyToReg t0, Register:i64 %16, t121
      t114: ch = TokenFactor t98, t108, t96:1
      t184: i8 = setcc t121, Constant:i64<0>, setne:ch
    t120: ch = brcond t114, t184, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
  t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>



Legalizing: t117: ch = br t120, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>
Legal node: nothing to do

Legalizing: t120: ch = brcond t114, t184, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Trying custom legalization
Creating new node: t193: i32 = X86ISD::CMP t121, Constant:i64<0>
Creating constant: t194: i8 = TargetConstant<5>
Creating new node: t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193
Successfully custom legalized node
 ... replacing: t120: ch = brcond t114, t184, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
     with:      t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193

Legalizing: t114: ch = TokenFactor t98, t108, t96:1
Legal node: nothing to do

Legalizing: t108: ch = CopyToReg t0, Register:i64 %16, t121
Legal node: nothing to do

Legalizing: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
Legalizing non-extending load operation

Legalizing: t128: i64 = add t125, Constant:i64<240>
Legal node: nothing to do

Legalizing: t125: i64 = add t96, t129
Legal node: nothing to do

Legalizing: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
Legalizing non-extending load operation

Legalizing: t100: i64 = add t131, Constant:i64<-24>
Legal node: nothing to do

Legalizing: t98: ch = CopyToReg t0, Register:i64 %15, t96
Legal node: nothing to do

Legalizing: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
Legalizing non-extending load operation

Legalizing: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Legal node: nothing to do

Legalizing: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1

Legalizing: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
Legal node: nothing to do

Legalizing: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
Legal node: nothing to do

Legalizing: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
Legal node: nothing to do

Legalizing: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t163: ch = TokenFactor t161, t65:1
Legal node: nothing to do

Legalizing: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t134: i64 = add t133, Constant:i64<8>
Legal node: nothing to do

Legalizing: t133: i64 = add t69, t158
Legal node: nothing to do

Legalizing: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
Legalizing non-extending load operation

Legalizing: t157: ch = TokenFactor t154, t64
Legal node: nothing to do

Legalizing: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t81: i64 = add t69, t151
Legal node: nothing to do

Legalizing: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
Legalizing non-extending load operation

Legalizing: t150: ch = TokenFactor t147, t64
Legal node: nothing to do

Legalizing: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t77: i32 = or t75, Constant:i32<4>
Legal node: nothing to do

Legalizing: t75: i32 = and t135, Constant:i32<-261>
Legal node: nothing to do

Legalizing: t166: ch = TokenFactor t135:1, t140:1, t143:1
Legal node: nothing to do

Legalizing: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
Legalizing non-extending load operation

Legalizing: t139: i64 = add t138, Constant:i64<16>
Legal node: nothing to do

Legalizing: t138: i64 = add t69, t140
Legal node: nothing to do

Legalizing: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
Legalizing non-extending load operation

Legalizing: t67: i64 = add t143, Constant:i64<-24>
Legal node: nothing to do

Legalizing: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
Legal node: nothing to do

Legalizing: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
Legalizing non-extending load operation

Legalizing: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1

Legalizing: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
Legal node: nothing to do

Legalizing: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
Legal node: nothing to do

Legalizing: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, GlobalAddress:i64<[5 x i8]* @.str.1> 0, t60:1
Legal node: nothing to do

Legalizing: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
Legal node: nothing to do

Legalizing: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t69: i64 = add nuw t56, Constant:i64<8>
Legal node: nothing to do

Legalizing: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Legal node: nothing to do

Legalizing: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1

Legalizing: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
Legal node: nothing to do

Legalizing: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
Legal node: nothing to do

Legalizing: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal node: nothing to do

Legalizing: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t177: ch = TokenFactor t175, t32:1
Legal node: nothing to do

Legalizing: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t167: i64 = add t168, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Legal node: nothing to do

Legalizing: t178: ch = TokenFactor t168:1, t171:1
Legal node: nothing to do

Legalizing: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
Legalizing non-extending load operation

Legalizing: t37: i64 = add t171, Constant:i64<-24>
Legal node: nothing to do

Legalizing: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
Legal node: nothing to do

Legalizing: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Legalizing: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
Legal node: nothing to do

Legalizing: t14: f64 = fdiv t12, ConstantFP:f64<3.000000e+00>
Legal node: nothing to do

Legalizing: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
Legal node: nothing to do

Legalizing: t12: f64 = fmul t11, t9
Legal node: nothing to do

Legalizing: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, GlobalAddress:i64<[3 x i8]* @.str> 0, t22:1
Legal node: nothing to do

Legalizing: t9: f64 = fadd t4, t8
Trying custom legalization

Legalizing: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, GlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal node: nothing to do

Legalizing: t8: f64 = fmul t6, ConstantFP:f64<4.000000e+00>
Legal node: nothing to do

Legalizing: t4: f64 = fadd t2, ConstantFP:f64<1.000000e+00>
Trying custom legalization

Legalizing: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t11: f64,ch = CopyFromReg t0, Register:f64 %2
Legal node: nothing to do

Legalizing: t6: f64,ch = CopyFromReg t0, Register:f64 %14
Legal node: nothing to do

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %13
Legal node: nothing to do

Legalizing: t127: i64 = Constant<240>
Legal node: nothing to do

Legalizing: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>
Legal node: nothing to do

Legalizing: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Legal node: nothing to do

Legalizing: t107: i64 = Register %16

Legalizing: t97: i64 = Register %15

Legalizing: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0
Legal node: nothing to do

Legalizing: t91: f64 = Register $xmm0

Legalizing: t86: i64 = Constant<20>
Legal node: nothing to do

Legalizing: t76: i32 = Constant<4>
Legal node: nothing to do

Legalizing: t74: i32 = Constant<-261>
Legal node: nothing to do

Legalizing: t70: i64 = Constant<16>
Legal node: nothing to do

Legalizing: t58: i64 = Constant<4>
Legal node: nothing to do

Legalizing: t57: i64 = GlobalAddress<[5 x i8]* @.str.1> 0
Trying custom legalization
Creating new node: t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
Successfully custom legalized node
 ... replacing: t57: i64 = GlobalAddress<[5 x i8]* @.str.1> 0
     with:      t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0

Legalizing: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0
Legal node: nothing to do

Legalizing: t51: i32 = Register $esi

Legalizing: t47: i32 = Register %0

Legalizing: t43: i64 = Constant<6>
Legal node: nothing to do

Legalizing: t41: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Trying custom legalization
Creating new node: t199: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Successfully custom legalized node
 ... replacing: t41: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16
     with:      t199: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Legalizing: t39: i64 = Constant<8>
Legal node: nothing to do

Legalizing: t36: i64 = Constant<-24>
Legal node: nothing to do

Legalizing: t34: i64 = undef
Legal node: nothing to do

Legalizing: t33: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t31: i64 = Register $rax

Legalizing: t28: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0
Legal node: nothing to do

Legalizing: t25: i64 = Register $rdx

Legalizing: t23: i64 = Register $rsi

Legalizing: t21: i64 = Register $rdi

Legalizing: t19: i64 = TargetConstant<0>

Legalizing: t18: i64 = Constant<2>
Legal node: nothing to do

Legalizing: t17: i64 = GlobalAddress<[3 x i8]* @.str> 0
Trying custom legalization
Creating new node: t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0
Successfully custom legalized node
 ... replacing: t17: i64 = GlobalAddress<[3 x i8]* @.str> 0
     with:      t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0

Legalizing: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
Trying custom legalization
Creating new node: t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Successfully custom legalized node
 ... replacing: t16: i64 = GlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
     with:      t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Legalizing: t13: f64 = ConstantFP<3.000000e+00>
Trying to expand node
Creating new constant pool: t204: i64 = ConstantPool<double 3.000000e+00> 0
Creating new node: t205: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t13: f64 = ConstantFP<3.000000e+00>
     with:      t205: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64

Legalizing: t10: f64 = Register %2

Legalizing: t7: f64 = ConstantFP<4.000000e+00>
Trying to expand node
Creating new constant pool: t206: i64 = ConstantPool<double 4.000000e+00> 0
Creating new node: t207: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t7: f64 = ConstantFP<4.000000e+00>
     with:      t207: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64

Legalizing: t5: f64 = Register %14

Legalizing: t3: f64 = ConstantFP<1.000000e+00>
Trying to expand node
Creating new constant pool: t208: i64 = ConstantPool<double 1.000000e+00> 0
Creating new node: t209: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Successfully expanded node
 ... replacing: t3: f64 = ConstantFP<1.000000e+00>
     with:      t209: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64

Legalizing: t1: f64 = Register %13

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t209: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 1.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t208: i64 = ConstantPool<double 1.000000e+00> 0
Trying custom legalization
Creating new constant pool: t210: i64 = TargetConstantPool<double 1.000000e+00> 0
Creating new node: t211: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Successfully custom legalized node
 ... replacing: t208: i64 = ConstantPool<double 1.000000e+00> 0
     with:      t211: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t207: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 4.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t206: i64 = ConstantPool<double 4.000000e+00> 0
Trying custom legalization
Creating new constant pool: t212: i64 = TargetConstantPool<double 4.000000e+00> 0
Creating new node: t213: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Successfully custom legalized node
 ... replacing: t206: i64 = ConstantPool<double 4.000000e+00> 0
     with:      t213: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t205: f64,ch = load<(load 8 from constant-pool)> t0, ConstantPool:i64<double 3.000000e+00> 0, undef:i64
Legalizing non-extending load operation

Legalizing: t204: i64 = ConstantPool<double 3.000000e+00> 0
Trying custom legalization
Creating new constant pool: t214: i64 = TargetConstantPool<double 3.000000e+00> 0
Creating new node: t215: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Successfully custom legalized node
 ... replacing: t204: i64 = ConstantPool<double 3.000000e+00> 0
     with:      t215: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal node: nothing to do

Legalizing: t202: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal node: nothing to do

Legalizing: t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0
Legal node: nothing to do

Legalizing: t200: i64 = TargetGlobalAddress<[3 x i8]* @.str> 0
Legal node: nothing to do

Legalizing: t199: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Legal node: nothing to do

Legalizing: t198: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Legal node: nothing to do

Legalizing: t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
Legal node: nothing to do

Legalizing: t196: i64 = TargetGlobalAddress<[5 x i8]* @.str.1> 0
Legal node: nothing to do

Legalizing: t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193
Legal node: nothing to do

Legalizing: t194: i8 = TargetConstant<5>

Legalizing: t193: i32 = X86ISD::CMP t121, Constant:i64<0>
Legal node: nothing to do

Legalizing: t215: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Legalizing: t214: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do

Legalizing: t213: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t212: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Legalizing: t211: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Legalizing: t210: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do
Legalized selection DAG: %bb.6 'main:_Z7simpsonPFddEddi.exit'
SelectionDAG has 125 nodes:
  t0: ch = EntryToken
    t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t203
    t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0
  t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1
  t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, t203, undef:i64
    t37: i64 = add t171, Constant:i64<-24>
  t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
          t178: ch = TokenFactor t168:1, t171:1
            t199: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
          t167: i64 = add t168, t199
        t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
        t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
      t177: ch = TokenFactor t175, t32:1
    t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
  t50: ch,glue = CopyToReg t49, Register:i64 $rdi, t203
    t48: i32,ch = CopyFromReg t0, Register:i32 %0
  t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
  t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
  t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
  t69: i64 = add nuw t56, Constant:i64<8>
    t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
    t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
  t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1
  t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
  t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
  t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
  t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
  t67: i64 = add t143, Constant:i64<-24>
  t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
    t138: i64 = add t69, t140
  t139: i64 = add t138, Constant:i64<16>
  t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
        t166: ch = TokenFactor t135:1, t140:1, t143:1
          t75: i32 = and t135, Constant:i32<-261>
        t77: i32 = or t75, Constant:i32<4>
      t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
    t150: ch = TokenFactor t147, t64
  t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
        t81: i64 = add t69, t151
      t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
    t157: ch = TokenFactor t154, t64
  t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
            t133: i64 = add t69, t158
          t134: i64 = add t133, Constant:i64<8>
        t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
        t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
      t163: ch = TokenFactor t161, t65:1
    t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
  t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
        t11: f64,ch = CopyFromReg t0, Register:f64 %2
            t2: f64,ch = CopyFromReg t0, Register:f64 %13
              t211: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
            t209: f64,ch = load<(load 8 from constant-pool)> t0, t211, undef:i64
          t4: f64 = fadd t2, t209
            t6: f64,ch = CopyFromReg t0, Register:f64 %14
              t213: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
            t207: f64,ch = load<(load 8 from constant-pool)> t0, t213, undef:i64
          t8: f64 = fmul t6, t207
        t9: f64 = fadd t4, t8
      t12: f64 = fmul t11, t9
        t215: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t205: f64,ch = load<(load 8 from constant-pool)> t0, t215, undef:i64
    t14: f64 = fdiv t12, t205
  t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
  t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
  t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
  t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
            t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
          t100: i64 = add t131, Constant:i64<-24>
        t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
      t125: i64 = add t96, t129
    t128: i64 = add t125, Constant:i64<240>
  t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
  t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
        t98: ch = CopyToReg t0, Register:i64 %15, t96
        t108: ch = CopyToReg t0, Register:i64 %16, t121
      t114: ch = TokenFactor t98, t108, t96:1
      t193: i32 = X86ISD::CMP t121, Constant:i64<0>
    t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193
  t117: ch = br t195, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>



Legalizing: t215: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t215: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0

Legalizing: t214: i64 = TargetConstantPool<double 3.000000e+00> 0
Legal node: nothing to do

Combining: t214: i64 = TargetConstantPool<double 3.000000e+00> 0

Legalizing: t213: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t213: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0

Legalizing: t212: i64 = TargetConstantPool<double 4.000000e+00> 0
Legal node: nothing to do

Combining: t212: i64 = TargetConstantPool<double 4.000000e+00> 0

Legalizing: t211: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t211: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0

Legalizing: t210: i64 = TargetConstantPool<double 1.000000e+00> 0
Legal node: nothing to do

Combining: t210: i64 = TargetConstantPool<double 1.000000e+00> 0

Legalizing: t209: f64,ch = load<(load 8 from constant-pool)> t0, t211, undef:i64
Legalizing non-extending load operation

Combining: t209: f64,ch = load<(load 8 from constant-pool)> t0, t211, undef:i64

Legalizing: t207: f64,ch = load<(load 8 from constant-pool)> t0, t213, undef:i64
Legalizing non-extending load operation

Combining: t207: f64,ch = load<(load 8 from constant-pool)> t0, t213, undef:i64

Legalizing: t205: f64,ch = load<(load 8 from constant-pool)> t0, t215, undef:i64
Legalizing non-extending load operation

Combining: t205: f64,ch = load<(load 8 from constant-pool)> t0, t215, undef:i64

Legalizing: t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal node: nothing to do

Combining: t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Legalizing: t202: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0
Legal node: nothing to do

Combining: t202: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0

Legalizing: t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0
Legal node: nothing to do

Combining: t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0

Legalizing: t200: i64 = TargetGlobalAddress<[3 x i8]* @.str> 0
Legal node: nothing to do

Combining: t200: i64 = TargetGlobalAddress<[3 x i8]* @.str> 0

Legalizing: t199: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Legal node: nothing to do

Combining: t199: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Legalizing: t198: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16
Legal node: nothing to do

Combining: t198: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> + 16

Legalizing: t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
Legal node: nothing to do

Combining: t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0

Legalizing: t196: i64 = TargetGlobalAddress<[5 x i8]* @.str.1> 0
Legal node: nothing to do

Combining: t196: i64 = TargetGlobalAddress<[5 x i8]* @.str.1> 0

Legalizing: t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193
Legal node: nothing to do

Combining: t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193

Legalizing: t194: i8 = TargetConstant<5>

Combining: t194: i8 = TargetConstant<5>

Legalizing: t193: i32 = X86ISD::CMP t121, Constant:i64<0>
Legal node: nothing to do

Combining: t193: i32 = X86ISD::CMP t121, Constant:i64<0>

Legalizing: t117: ch = br t195, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>
Legal node: nothing to do

Combining: t117: ch = br t195, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>

Legalizing: t114: ch = TokenFactor t98, t108, t96:1
Legal node: nothing to do

Combining: t114: ch = TokenFactor t98, t108, t96:1

Legalizing: t108: ch = CopyToReg t0, Register:i64 %16, t121
Legal node: nothing to do

Combining: t108: ch = CopyToReg t0, Register:i64 %16, t121

Legalizing: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
Legalizing non-extending load operation

Combining: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64

Legalizing: t128: i64 = add t125, Constant:i64<240>
Legal node: nothing to do

Combining: t128: i64 = add t125, Constant:i64<240>

Legalizing: t125: i64 = add t96, t129
Legal node: nothing to do

Combining: t125: i64 = add t96, t129

Legalizing: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
Legalizing non-extending load operation

Combining: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64

Legalizing: t100: i64 = add t131, Constant:i64<-24>
Legal node: nothing to do

Combining: t100: i64 = add t131, Constant:i64<-24>

Legalizing: t98: ch = CopyToReg t0, Register:i64 %15, t96
Legal node: nothing to do

Combining: t98: ch = CopyToReg t0, Register:i64 %15, t96

Legalizing: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
Legalizing non-extending load operation

Combining: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64

Legalizing: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
Legal node: nothing to do

Combining: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1

Legalizing: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1

Combining: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1

Legalizing: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
Legal node: nothing to do

Combining: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1

Legalizing: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
Legal node: nothing to do

Combining: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

Legalizing: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
Legal node: nothing to do

Combining: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56

Legalizing: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t163: ch = TokenFactor t161, t65:1
Legal node: nothing to do

Combining: t163: ch = TokenFactor t161, t65:1

Legalizing: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64

Legalizing: t134: i64 = add t133, Constant:i64<8>
Legal node: nothing to do

Combining: t134: i64 = add t133, Constant:i64<8>

Legalizing: t133: i64 = add t69, t158
Legal node: nothing to do

Combining: t133: i64 = add t69, t158

Legalizing: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
Legalizing non-extending load operation

Combining: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64

Legalizing: t157: ch = TokenFactor t154, t64
Legal node: nothing to do

Combining: t157: ch = TokenFactor t154, t64

Legalizing: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64

Legalizing: t81: i64 = add t69, t151
Legal node: nothing to do

Combining: t81: i64 = add t69, t151

Legalizing: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
Legalizing non-extending load operation

Combining: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64

Legalizing: t150: ch = TokenFactor t147, t64
Legal node: nothing to do

Combining: t150: ch = TokenFactor t147, t64

Legalizing: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64

Legalizing: t77: i32 = or t75, Constant:i32<4>
Legal node: nothing to do

Combining: t77: i32 = or t75, Constant:i32<4>

Legalizing: t75: i32 = and t135, Constant:i32<-261>
Legal node: nothing to do

Combining: t75: i32 = and t135, Constant:i32<-261>

Legalizing: t166: ch = TokenFactor t135:1, t140:1, t143:1
Legal node: nothing to do

Combining: t166: ch = TokenFactor t135:1, t140:1, t143:1

Legalizing: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
Legalizing non-extending load operation

Combining: t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64

Legalizing: t139: i64 = add t138, Constant:i64<16>
Legal node: nothing to do

Combining: t139: i64 = add t138, Constant:i64<16>

Legalizing: t138: i64 = add t69, t140
Legal node: nothing to do

Combining: t138: i64 = add t69, t140

Legalizing: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
Legalizing non-extending load operation

Combining: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64

Legalizing: t67: i64 = add t143, Constant:i64<-24>
Legal node: nothing to do

Combining: t67: i64 = add t143, Constant:i64<-24>

Legalizing: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
Legal node: nothing to do

Combining: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1

Legalizing: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
Legalizing non-extending load operation

Combining: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64

Legalizing: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1

Combining: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1

Legalizing: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
Legal node: nothing to do

Combining: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1

Legalizing: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
Legal node: nothing to do

Combining: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1

Legalizing: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1
Legal node: nothing to do

Combining: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1

Legalizing: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
Legal node: nothing to do

Combining: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56

Legalizing: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t69: i64 = add nuw t56, Constant:i64<8>
Legal node: nothing to do

Combining: t69: i64 = add nuw t56, Constant:i64<8>

Legalizing: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
Legal node: nothing to do

Combining: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1

Legalizing: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1

Combining: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1

Legalizing: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
Legal node: nothing to do

Combining: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1

Legalizing: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
Legal node: nothing to do

Combining: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

Legalizing: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, t203
Legal node: nothing to do

Combining: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, t203

Legalizing: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t177: ch = TokenFactor t175, t32:1
Legal node: nothing to do

Combining: t177: ch = TokenFactor t175, t32:1

Legalizing: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64

Legalizing: t167: i64 = add t168, t199
Legal node: nothing to do

Combining: t167: i64 = add t168, t199

Legalizing: t178: ch = TokenFactor t168:1, t171:1
Legal node: nothing to do

Combining: t178: ch = TokenFactor t168:1, t171:1

Legalizing: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
Legalizing non-extending load operation

Combining: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64

Legalizing: t37: i64 = add t171, Constant:i64<-24>
Legal node: nothing to do

Combining: t37: i64 = add t171, Constant:i64<-24>

Legalizing: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
Legal node: nothing to do

Combining: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1

Legalizing: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, t203, undef:i64
Legalizing non-extending load operation

Combining: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, t203, undef:i64

Legalizing: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Combining: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Legalizing: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
Legal node: nothing to do

Combining: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1

Legalizing: t14: f64 = fdiv t12, t205
Legal node: nothing to do

Combining: t14: f64 = fdiv t12, t205

Legalizing: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
Legal node: nothing to do

Combining: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1

Legalizing: t12: f64 = fmul t11, t9
Legal node: nothing to do

Combining: t12: f64 = fmul t11, t9

Legalizing: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1
Legal node: nothing to do

Combining: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1

Legalizing: t9: f64 = fadd t4, t8
Trying custom legalization

Combining: t9: f64 = fadd t4, t8

Legalizing: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t203
Legal node: nothing to do

Combining: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t203

Legalizing: t8: f64 = fmul t6, t207
Legal node: nothing to do

Combining: t8: f64 = fmul t6, t207

Legalizing: t4: f64 = fadd t2, t209
Trying custom legalization

Combining: t4: f64 = fadd t2, t209

Legalizing: t48: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t48: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t11: f64,ch = CopyFromReg t0, Register:f64 %2
Legal node: nothing to do

Combining: t11: f64,ch = CopyFromReg t0, Register:f64 %2

Legalizing: t6: f64,ch = CopyFromReg t0, Register:f64 %14
Legal node: nothing to do

Combining: t6: f64,ch = CopyFromReg t0, Register:f64 %14

Legalizing: t2: f64,ch = CopyFromReg t0, Register:f64 %13
Legal node: nothing to do

Combining: t2: f64,ch = CopyFromReg t0, Register:f64 %13

Legalizing: t127: i64 = Constant<240>
Legal node: nothing to do

Combining: t127: i64 = Constant<240>

Legalizing: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>
Legal node: nothing to do

Combining: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>

Legalizing: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>
Legal node: nothing to do

Combining: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

Legalizing: t107: i64 = Register %16

Combining: t107: i64 = Register %16

Legalizing: t97: i64 = Register %15

Combining: t97: i64 = Register %15

Legalizing: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0
Legal node: nothing to do

Combining: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0

Legalizing: t91: f64 = Register $xmm0

Combining: t91: f64 = Register $xmm0

Legalizing: t86: i64 = Constant<20>
Legal node: nothing to do

Combining: t86: i64 = Constant<20>

Legalizing: t76: i32 = Constant<4>
Legal node: nothing to do

Combining: t76: i32 = Constant<4>

Legalizing: t74: i32 = Constant<-261>
Legal node: nothing to do

Combining: t74: i32 = Constant<-261>

Legalizing: t70: i64 = Constant<16>
Legal node: nothing to do

Combining: t70: i64 = Constant<16>

Legalizing: t58: i64 = Constant<4>
Legal node: nothing to do

Combining: t58: i64 = Constant<4>

Legalizing: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0
Legal node: nothing to do

Combining: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0

Legalizing: t51: i32 = Register $esi

Combining: t51: i32 = Register $esi

Legalizing: t47: i32 = Register %0

Combining: t47: i32 = Register %0

Legalizing: t43: i64 = Constant<6>
Legal node: nothing to do

Combining: t43: i64 = Constant<6>

Legalizing: t39: i64 = Constant<8>
Legal node: nothing to do

Combining: t39: i64 = Constant<8>

Legalizing: t36: i64 = Constant<-24>
Legal node: nothing to do

Combining: t36: i64 = Constant<-24>

Legalizing: t34: i64 = undef
Legal node: nothing to do

Combining: t34: i64 = undef

Legalizing: t33: i64 = Constant<0>
Legal node: nothing to do

Combining: t33: i64 = Constant<0>

Legalizing: t31: i64 = Register $rax

Combining: t31: i64 = Register $rax

Legalizing: t28: Untyped = RegisterMask
Legal node: nothing to do

Combining: t28: Untyped = RegisterMask

Legalizing: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0
Legal node: nothing to do

Combining: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0

Legalizing: t25: i64 = Register $rdx

Combining: t25: i64 = Register $rdx

Legalizing: t23: i64 = Register $rsi

Combining: t23: i64 = Register $rsi

Legalizing: t21: i64 = Register $rdi

Combining: t21: i64 = Register $rdi

Legalizing: t19: i64 = TargetConstant<0>

Combining: t19: i64 = TargetConstant<0>

Legalizing: t18: i64 = Constant<2>
Legal node: nothing to do

Combining: t18: i64 = Constant<2>

Legalizing: t10: f64 = Register %2

Combining: t10: f64 = Register %2

Legalizing: t5: f64 = Register %14

Combining: t5: f64 = Register %14

Legalizing: t1: f64 = Register %13

Combining: t1: f64 = Register %13

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.6 'main:_Z7simpsonPFddEddi.exit'
SelectionDAG has 125 nodes:
  t0: ch = EntryToken
    t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t203
    t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0
  t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1
  t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, t203, undef:i64
    t37: i64 = add t171, Constant:i64<-24>
  t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
          t178: ch = TokenFactor t168:1, t171:1
            t199: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> + 16
          t167: i64 = add t168, t199
        t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
        t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1
      t177: ch = TokenFactor t175, t32:1
    t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
  t50: ch,glue = CopyToReg t49, Register:i64 $rdi, t203
    t48: i32,ch = CopyFromReg t0, Register:i32 %0
  t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
  t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
  t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
  t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
  t69: i64 = add nuw t56, Constant:i64<8>
    t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56
    t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
  t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1
  t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1
  t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
  t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
  t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
  t67: i64 = add t143, Constant:i64<-24>
  t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
    t138: i64 = add t69, t140
  t139: i64 = add t138, Constant:i64<16>
  t135: i32,ch = load<(load 4 from %ir.5, !tbaa !17)> t64, t139, undef:i64
        t166: ch = TokenFactor t135:1, t140:1, t143:1
          t75: i32 = and t135, Constant:i32<-261>
        t77: i32 = or t75, Constant:i32<4>
      t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
    t150: ch = TokenFactor t147, t64
  t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
        t81: i64 = add t69, t151
      t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
    t157: ch = TokenFactor t154, t64
  t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
            t133: i64 = add t69, t158
          t134: i64 = add t133, Constant:i64<8>
        t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
        t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1
      t163: ch = TokenFactor t161, t65:1
    t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
  t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56
        t11: f64,ch = CopyFromReg t0, Register:f64 %2
            t2: f64,ch = CopyFromReg t0, Register:f64 %13
              t211: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 1.000000e+00> 0
            t209: f64,ch = load<(load 8 from constant-pool)> t0, t211, undef:i64
          t4: f64 = fadd t2, t209
            t6: f64,ch = CopyFromReg t0, Register:f64 %14
              t213: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 4.000000e+00> 0
            t207: f64,ch = load<(load 8 from constant-pool)> t0, t213, undef:i64
          t8: f64 = fmul t6, t207
        t9: f64 = fadd t4, t8
      t12: f64 = fmul t11, t9
        t215: i64 = X86ISD::Wrapper TargetConstantPool:i64<double 3.000000e+00> 0
      t205: f64,ch = load<(load 8 from constant-pool)> t0, t215, undef:i64
    t14: f64 = fdiv t12, t205
  t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
  t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
  t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
  t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
            t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
          t100: i64 = add t131, Constant:i64<-24>
        t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
      t125: i64 = add t96, t129
    t128: i64 = add t125, Constant:i64<240>
  t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
  t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
        t98: ch = CopyToReg t0, Register:i64 %15, t96
        t108: ch = CopyToReg t0, Register:i64 %16, t121
      t114: ch = TokenFactor t98, t108, t96:1
      t193: i32 = X86ISD::CMP t121, Constant:i64<0>
    t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193
  t117: ch = br t195, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>


===== Instruction selection begins: %bb.6 '_Z7simpsonPFddEddi.exit'

ISEL: Starting selection on root node: t117: ch = br t195, BasicBlock:ch<if.then.i64 0x7fffc1df5a98>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t117: ch = JMP_1 BasicBlock:ch<if.then.i64 0x7fffc1df5a98>, t195
ISEL: Match complete!

ISEL: Starting selection on root node: t195: ch = X86ISD::BRCOND t114, BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t193
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t217: ch,glue = CopyToReg t114, Register:i32 $eflags, t193
  Morphed node: t195: ch = JCC_1 BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t217, t217:1
ISEL: Match complete!

ISEL: Starting selection on root node: t114: ch = TokenFactor t98, t108, t96:1

ISEL: Starting selection on root node: t108: ch = CopyToReg t0, Register:i64 %16, t121

ISEL: Starting selection on root node: t193: i32 = X86ISD::CMP t121, Constant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 24481
  OpcodeSwitch from 24485 to 24984
  Match failed at index 24986
  Continuing at 25385
  Skipped scope entry (due to false predicate) at index 25390, continuing at 25421
  Skipped scope entry (due to false predicate) at index 25422, continuing at 25453
  Skipped scope entry (due to false predicate) at index 25454, continuing at 25485
  Match failed at index 25489
  Continuing at 25517
  Continuing at 25518
  OpcodeSwitch from 25521 to 25525
  Match failed at index 25527
  Continuing at 25905
  Skipped scope entry (due to false predicate) at index 25910, continuing at 25974
  Skipped scope entry (due to false predicate) at index 25975, continuing at 26075
  Skipped scope entry (due to false predicate) at index 26076, continuing at 26176
  Morphed node: t193: i32 = TEST64rr t121, t121
ISEL: Match complete!

ISEL: Starting selection on root node: t121: i64,ch = load<(load 8 from %ir.14, !tbaa !19)> t95, t128, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1
 Scale 1
IndexReg t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t218: i8 = TargetConstant<1>
Creating constant: t219: i32 = TargetConstant<240>
  Morphed node: t121: i64,ch = MOV64rm<Mem:(load 8 from %ir.14, !tbaa !19)> t96, TargetConstant:i8<1>, t129, TargetConstant:i32<240>, Register:i16 $noreg, t95
ISEL: Match complete!

ISEL: Starting selection on root node: t129: i64,ch = load<(load 8 from %ir.12)> t95, t100, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t222: i32 = TargetConstant<-24>
  Morphed node: t129: i64,ch = MOV64rm<Mem:(load 8 from %ir.12)> t131, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t95
ISEL: Match complete!

ISEL: Starting selection on root node: t98: ch = CopyToReg t0, Register:i64 %15, t96

ISEL: Starting selection on root node: t131: i64,ch = load<(dereferenceable load 8 from %ir.11, !tbaa !4)> t95, t96, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t223: i32 = TargetConstant<0>
  Morphed node: t131: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.11, !tbaa !4)> t96, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t95
ISEL: Match complete!

ISEL: Starting selection on root node: t96: i64,ch,glue = CopyFromReg t95, Register:i64 $rax, t95:1

ISEL: Starting selection on root node: t95: ch,glue = callseq_end t94, TargetConstant:i64<0>, TargetConstant:i64<0>, t94:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t95: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t94, t94:1
ISEL: Match complete!

ISEL: Starting selection on root node: t94: ch,glue = X86ISD::CALL t92, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t94: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92, t92:1
ISEL: Match complete!

ISEL: Starting selection on root node: t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

ISEL: Starting selection on root node: t90: ch,glue = CopyToReg t89, Register:i64 $rdi, t56

ISEL: Starting selection on root node: t89: ch,glue = callseq_start t163, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t89: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t163
ISEL: Match complete!

ISEL: Starting selection on root node: t163: ch = TokenFactor t161, t65:1

ISEL: Starting selection on root node: t161: ch = store<(store 8 into %ir.10, !tbaa !7)> t158:1, Constant:i64<20>, t134, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 14278
  Match failed at index 14282
  Continuing at 15344
  Match failed at index 15347
  Continuing at 15943
  Match failed at index 15944
  Continuing at 16041
  Match failed at index 16043
  Continuing at 16176
  Match failed at index 16189
  Continuing at 16266
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 8
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
 Disp 8
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t224: i32 = TargetConstant<16>
Creating constant: t225: i64 = TargetConstant<20>
  Morphed node: t161: ch = MOV64mi32<Mem:(store 8 into %ir.10, !tbaa !7)> t56, TargetConstant:i8<1>, t158, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<20>, t158:1
ISEL: Match complete!

ISEL: Starting selection on root node: t158: i64,ch = load<(load 8 from %ir.3)> t157, t67, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t158: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t157
ISEL: Match complete!

ISEL: Starting selection on root node: t157: ch = TokenFactor t154, t64

ISEL: Starting selection on root node: t154: ch = store<(store 8 into %ir.8, !tbaa !18)> t151:1, Constant:i64<16>, t81, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 14278
  Match failed at index 14282
  Continuing at 15344
  Match failed at index 15347
  Continuing at 15943
  Match failed at index 15944
  Continuing at 16041
  Match failed at index 16043
  Continuing at 16176
  Match failed at index 16189
  Continuing at 16266
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 8
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t226: i32 = TargetConstant<8>
Creating constant: t227: i64 = TargetConstant<16>
  Morphed node: t154: ch = MOV64mi32<Mem:(store 8 into %ir.8, !tbaa !18)> t56, TargetConstant:i8<1>, t151, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<16>, t151:1
ISEL: Match complete!

ISEL: Starting selection on root node: t151: i64,ch = load<(load 8 from %ir.3)> t150, t67, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t151: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t150
ISEL: Match complete!

ISEL: Starting selection on root node: t150: ch = TokenFactor t147, t64

ISEL: Starting selection on root node: t147: ch = store<(store 4 into %ir.5, !tbaa !17)> t166, t77, t139, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  OpcodeSwitch from 1029 to 9576
  Match failed at index 9580
  Continuing at 10100
  Match failed at index 10110
  Continuing at 10153
  Match failed at index 10154
  Continuing at 10203
  Match failed at index 10208
  Continuing at 10251
  Match failed at index 10252
  Continuing at 10301
  Match failed at index 10306
  Continuing at 10349
  Match failed at index 10350
  Continuing at 10399
  Match failed at index 10400
  Continuing at 10449
  Continuing at 10450
  Match failed at index 10453
  Continuing at 10580
  Match failed at index 10584
  Continuing at 10710
  Continuing at 14278
  Match failed at index 14282
  Continuing at 15344
  Match failed at index 15347
  Continuing at 15943
  Match failed at index 15944
  Continuing at 16041
  Match failed at index 16043
  Continuing at 16176
  Skipped scope entry (due to false predicate) at index 16182, continuing at 16299
  Match failed at index 16302
  Continuing at 16328
  Match failed at index 16331
  Continuing at 16357
  Match failed at index 16368
  Continuing at 16386
  Match failed at index 16387
  Continuing at 16417
  Continuing at 16418
  Match failed at index 16420
  Continuing at 16501
  Skipped scope entry (due to false predicate) at index 16506, continuing at 16588
  Skipped scope entry (due to false predicate) at index 16589, continuing at 16697
  Skipped scope entry (due to false predicate) at index 16698, continuing at 16767
  Skipped scope entry (due to false predicate) at index 16768, continuing at 16790
  Skipped scope entry (due to false predicate) at index 16791, continuing at 16813
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 8
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
 Disp 8
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t228: i32 = TargetConstant<24>
  Morphed node: t147: ch = MOV32mr<Mem:(store 4 into %ir.5, !tbaa !17)> t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t77, t166
ISEL: Match complete!

ISEL: Starting selection on root node: t77: i32 = or t75, Constant:i32<4>
ISEL: Starting pattern match
  Initial Opcode index to 102491
  Match failed at index 102495
  Continuing at 102598
  Match failed at index 102600
  Continuing at 102707
  Match failed at index 102710
  Continuing at 102760
  Match failed at index 102763
  Continuing at 103022
  TypeSwitch[i32] from 103024 to 103027
  Skipped scope entry (due to false predicate) at index 103029, continuing at 103045
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg t75: i32 = and t135, Constant:i32<-261>
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 103048
  Continuing at 103062
  Continuing at 103080
  Match failed at index 103083
  Continuing at 103204
  Match failed at index 103206
  Continuing at 103330
  Match failed at index 103333
  Continuing at 103454
  Match failed at index 103456
  Continuing at 103581
  Match failed at index 103584
  Continuing at 103682
  Match failed at index 103684
  Continuing at 103783
  Match failed at index 103801
  Continuing at 103814
Creating constant: t230: i32 = TargetConstant<4>
  Morphed node: t77: i32,i32 = ADD32ri8_DB t75, TargetConstant:i32<4>
ISEL: Match complete!

ISEL: Starting selection on root node: t75: i32 = and t135, Constant:i32<-261>
ISEL: Starting pattern match
  Initial Opcode index to 44172
  OpcodeSwitch from 44176 to 44181
  Match failed at index 44198
  Continuing at 44327
  Match failed at index 44332
  Continuing at 44369
  Match failed at index 44374
  Continuing at 44411
  Continuing at 44491
  Match failed at index 44494
  Continuing at 44597
  OpcodeSwitch from 44600 to 44604
  Match failed at index 44616
  Continuing at 44635
  Match failed at index 44640
  Continuing at 44659
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg nul
 Disp 8
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1
 Scale 1
IndexReg t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
 Disp 8
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t75: i32,i32,ch = AND32rm<Mem:(load 4 from %ir.5, !tbaa !17)> Constant:i32<-261>, t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t166: ch = TokenFactor t75:2, t140:1, t143:1

ISEL: Starting selection on root node: t140: i64,ch = load<(load 8 from %ir.3)> t64, t67, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t140: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t65: i64,ch,glue = CopyFromReg t64, Register:i64 $rax, t64:1

ISEL: Starting selection on root node: t143: i64,ch = load<(dereferenceable load 8 from %ir.2, !tbaa !4)> t64, t56, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t143: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.2, !tbaa !4)> t56, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t64
ISEL: Match complete!

ISEL: Starting selection on root node: t64: ch,glue = callseq_end t63, TargetConstant:i64<0>, TargetConstant:i64<0>, t63:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t64: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t63, t63:1
ISEL: Match complete!

ISEL: Starting selection on root node: t63: ch,glue = X86ISD::CALL t62, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t63: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62, t62:1
ISEL: Match complete!

ISEL: Starting selection on root node: t62: ch,glue = CopyToReg t61, Register:i64 $rdx, Constant:i64<4>, t61:1

ISEL: Starting selection on root node: t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1

ISEL: Starting selection on root node: t60: ch,glue = CopyToReg t59, Register:i64 $rdi, t56

ISEL: Starting selection on root node: t59: ch,glue = callseq_start t56:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1
ISEL: Match complete!

ISEL: Starting selection on root node: t56: i64,ch,glue = CopyFromReg t55, Register:i64 $rax, t55:1

ISEL: Starting selection on root node: t55: ch,glue = callseq_end t54, TargetConstant:i64<0>, TargetConstant:i64<0>, t54:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t54, t54:1
ISEL: Match complete!

ISEL: Starting selection on root node: t54: ch,glue = X86ISD::CALL t52, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t54: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52, t52:1
ISEL: Match complete!

ISEL: Starting selection on root node: t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

ISEL: Starting selection on root node: t50: ch,glue = CopyToReg t49, Register:i64 $rdi, t203

ISEL: Starting selection on root node: t49: ch,glue = callseq_start t177, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t177
ISEL: Match complete!

ISEL: Starting selection on root node: t177: ch = TokenFactor t175, t32:1

ISEL: Starting selection on root node: t175: ch = store<(store 8 into %ir.1, !tbaa !7)> t178, Constant:i64<6>, t167, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Skipped scope entry (due to false predicate) at index 368, continuing at 394
  Match failed at index 402
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 14278
  Match failed at index 14282
  Continuing at 15344
  Match failed at index 15347
  Continuing at 15943
  Match failed at index 15944
  Continuing at 16041
  Match failed at index 16043
  Continuing at 16176
  Match failed at index 16189
  Continuing at 16266
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t232: i64 = TargetConstant<6>
  Morphed node: t175: ch = MOV64mi32<Mem:(store 8 into %ir.1, !tbaa !7)> t168, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> + 16, Register:i16 $noreg, TargetConstant:i64<6>, t178
ISEL: Match complete!

ISEL: Starting selection on root node: t178: ch = TokenFactor t168:1, t171:1

ISEL: Starting selection on root node: t168: i64,ch = load<(load 8 from %ir.0)> t30, t37, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, t203, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t168: i64,ch = MOV64rm<Mem:(load 8 from %ir.0)> t171, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i64,ch,glue = CopyFromReg t30, Register:i64 $rax, t30:1

ISEL: Starting selection on root node: t171: i64,ch = load<(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> t30, t203, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t171: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> 0, Register:i16 $noreg, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t14: f64 = fdiv t12, t205
ISEL: Starting pattern match
  Initial Opcode index to 157809
  OpcodeSwitch from 157814 to 157819
  TypeSwitch[f64] from 157830 to 157854
  Match failed at index 157854
  Continuing at 157874
  Match failed at index 157875
  Continuing at 157948
  Continuing at 158106
  Match failed at index 158109
  Continuing at 158410
  TypeSwitch[f64] from 158429 to 158493
  Skipped scope entry (due to false predicate) at index 158495, continuing at 158513
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t235: i32 = TargetConstantPool<double 3.000000e+00> 0
  Morphed node: t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1
ISEL: Match complete!

ISEL: Starting selection on root node: t12: f64 = fmul t11, t9
ISEL: Starting pattern match
  Initial Opcode index to 154194
  Match failed at index 154199
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  Match failed at index 154799
  Continuing at 154935
  Match failed at index 154938
  Continuing at 155075
  TypeSwitch[f64] from 155081 to 155133
  Skipped scope entry (due to false predicate) at index 155135, continuing at 155146
  Skipped scope entry (due to false predicate) at index 155147, continuing at 155157
  Morphed node: t12: f64 = MULSDrr nofpexcept t11, t9
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26, t26:1
ISEL: Match complete!

ISEL: Starting selection on root node: t9: f64 = fadd t4, t8
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  Match failed at index 144649
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  Match failed at index 145249
  Continuing at 145385
  Match failed at index 145388
  Continuing at 145525
  TypeSwitch[f64] from 145531 to 145583
  Skipped scope entry (due to false predicate) at index 145585, continuing at 145596
  Skipped scope entry (due to false predicate) at index 145597, continuing at 145607
  Morphed node: t9: f64 = ADDSDrr nofpexcept t4, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch,glue = CopyToReg t24, Register:i64 $rdx, Constant:i64<2>, t24:1

ISEL: Starting selection on root node: t8: f64 = fmul t6, t207
ISEL: Starting pattern match
  Initial Opcode index to 154194
  OpcodeSwitch from 154199 to 154204
  TypeSwitch[f64] from 154215 to 154239
  Match failed at index 154239
  Continuing at 154259
  Match failed at index 154260
  Continuing at 154333
  Continuing at 154491
  Match failed at index 154494
  Continuing at 154795
  TypeSwitch[f64] from 154811 to 154875
  Skipped scope entry (due to false predicate) at index 154877, continuing at 154895
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t236: i32 = TargetConstantPool<double 4.000000e+00> 0
  Morphed node: t8: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t6, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: f64 = fadd t2, t209
ISEL: Starting pattern match
  Initial Opcode index to 144341
  Match failed at index 144346
  Continuing at 144493
  Match failed at index 144496
  Continuing at 144645
  OpcodeSwitch from 144649 to 144654
  TypeSwitch[f64] from 144665 to 144689
  Match failed at index 144689
  Continuing at 144709
  Match failed at index 144710
  Continuing at 144783
  Continuing at 144941
  Match failed at index 144944
  Continuing at 145245
  TypeSwitch[f64] from 145261 to 145325
  Skipped scope entry (due to false predicate) at index 145327, continuing at 145345
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating new constant pool: t237: i32 = TargetConstantPool<double 1.000000e+00> 0
  Morphed node: t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1

ISEL: Starting selection on root node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t203

ISEL: Starting selection on root node: t203: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
ISEL: Starting pattern match
  Initial Opcode index to 127392
  Morphed node: t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t201: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[3 x i8]* @.str> 0
ISEL: Starting pattern match
  Initial Opcode index to 127392
  Morphed node: t201: i64 = MOV32ri64 TargetGlobalAddress:i64<[3 x i8]* @.str> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t197: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
ISEL: Starting pattern match
  Initial Opcode index to 127392
  Morphed node: t197: i64 = MOV32ri64 TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t48: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t20: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t11: f64,ch = CopyFromReg t0, Register:f64 %2

ISEL: Starting selection on root node: t6: f64,ch = CopyFromReg t0, Register:f64 %14

ISEL: Starting selection on root node: t2: f64,ch = CopyFromReg t0, Register:f64 %13

ISEL: Starting selection on root node: t202: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* @_ZSt4cout> 0

ISEL: Starting selection on root node: t200: i64 = TargetGlobalAddress<[3 x i8]* @.str> 0

ISEL: Starting selection on root node: t196: i64 = TargetGlobalAddress<[5 x i8]* @.str.1> 0

ISEL: Starting selection on root node: t194: i8 = TargetConstant<5>

ISEL: Starting selection on root node: t116: ch = BasicBlock<if.then.i64 0x7fffc1df5a98>

ISEL: Starting selection on root node: t113: ch = BasicBlock<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>

ISEL: Starting selection on root node: t107: i64 = Register %16

ISEL: Starting selection on root node: t97: i64 = Register %15

ISEL: Starting selection on root node: t93: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0

ISEL: Starting selection on root node: t91: f64 = Register $xmm0

ISEL: Starting selection on root node: t74: i32 = Constant<-261>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i32] from 124159 to 124162
  Skipped scope entry (due to false predicate) at index 124164, continuing at 124177
Creating constant: t238: i32 = TargetConstant<-261>
  Morphed node: t74: i32 = MOV32ri TargetConstant:i32<-261>
ISEL: Match complete!

ISEL: Starting selection on root node: t58: i64 = Constant<4>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i64] from 124159 to 124190
  Match failed at index 124194
  Continuing at 124205
Creating constant: t239: i64 = TargetConstant<4>
  Morphed node: t58: i64 = MOV32ri64 TargetConstant:i64<4>
ISEL: Match complete!

ISEL: Starting selection on root node: t53: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0

ISEL: Starting selection on root node: t51: i32 = Register $esi

ISEL: Starting selection on root node: t47: i32 = Register %0

ISEL: Starting selection on root node: t31: i64 = Register $rax

ISEL: Starting selection on root node: t28: Untyped = RegisterMask

ISEL: Starting selection on root node: t27: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0

ISEL: Starting selection on root node: t25: i64 = Register $rdx

ISEL: Starting selection on root node: t23: i64 = Register $rsi

ISEL: Starting selection on root node: t21: i64 = Register $rdi

ISEL: Starting selection on root node: t19: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t18: i64 = Constant<2>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i64] from 124159 to 124190
  Match failed at index 124194
  Continuing at 124205
Creating constant: t240: i64 = TargetConstant<2>
  Morphed node: t18: i64 = MOV32ri64 TargetConstant:i64<2>
ISEL: Match complete!

ISEL: Starting selection on root node: t10: f64 = Register %2

ISEL: Starting selection on root node: t5: f64 = Register %14

ISEL: Starting selection on root node: t1: f64 = Register %13

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.6 'main:_Z7simpsonPFddEddi.exit'
SelectionDAG has 117 nodes:
  t0: ch = EntryToken
  t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0
    t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t203
    t201: i64 = MOV32ri64 TargetGlobalAddress:i64<[3 x i8]* @.str> 0
  t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1
    t18: i64 = MOV32ri64 TargetConstant:i64<2>
  t26: ch,glue = CopyToReg t24, Register:i64 $rdx, t18, t24:1
  t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26, t26:1
  t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1
  t171: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> 0, Register:i16 $noreg, t30:1
  t168: i64,ch = MOV64rm<Mem:(load 8 from %ir.0)> t171, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t30:1
          t178: ch = TokenFactor t168:1, t171:1
        t175: ch = MOV64mi32<Mem:(store 8 into %ir.1, !tbaa !7)> t168, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> + 16, Register:i16 $noreg, TargetConstant:i64<6>, t178
        t32: i64,ch,glue = CopyFromReg t30:1, Register:i64 $rax, t30:2
      t177: ch = TokenFactor t175, t32:1
    t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t177
  t50: ch,glue = CopyToReg t49:1, Register:i64 $rdi, t203
    t48: i32,ch = CopyFromReg t0, Register:i32 %0
  t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1
  t54: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52, t52:1
  t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t54, t54:1
  t56: i64,ch,glue = CopyFromReg t55:1, Register:i64 $rax, t55:2
    t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1
  t60: ch,glue = CopyToReg t59:1, Register:i64 $rdi, t56
    t197: i64 = MOV32ri64 TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0
  t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1
    t58: i64 = MOV32ri64 TargetConstant:i64<4>
  t62: ch,glue = CopyToReg t61, Register:i64 $rdx, t58, t61:1
  t63: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62, t62:1
  t64: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t63, t63:1
  t143: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.2, !tbaa !4)> t56, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t64:1
  t140: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t64:1
    t74: i32 = MOV32ri TargetConstant:i32<-261>
  t75: i32,i32,ch = AND32rm<Mem:(load 4 from %ir.5, !tbaa !17)> t74, t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t64:1
        t77: i32,i32 = ADD32ri8_DB t75, TargetConstant:i32<4>
        t166: ch = TokenFactor t75:2, t140:1, t143:1
      t147: ch = MOV32mr<Mem:(store 4 into %ir.5, !tbaa !17)> t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t77, t166
    t150: ch = TokenFactor t147, t64:1
  t151: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t150
      t154: ch = MOV64mi32<Mem:(store 8 into %ir.8, !tbaa !18)> t56, TargetConstant:i8<1>, t151, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<16>, t151:1
    t157: ch = TokenFactor t154, t64:1
  t158: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t157
        t161: ch = MOV64mi32<Mem:(store 8 into %ir.10, !tbaa !7)> t56, TargetConstant:i8<1>, t158, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<20>, t158:1
        t65: i64,ch,glue = CopyFromReg t64:1, Register:i64 $rax, t64:2
      t163: ch = TokenFactor t161, t65:1
    t89: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t163
  t90: ch,glue = CopyToReg t89:1, Register:i64 $rdi, t56
        t11: f64,ch = CopyFromReg t0, Register:f64 %2
            t2: f64,ch = CopyFromReg t0, Register:f64 %13
          t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0
            t6: f64,ch = CopyFromReg t0, Register:f64 %14
          t8: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t6, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0
        t9: f64 = ADDSDrr nofpexcept t4, t8
      t12: f64 = MULSDrr nofpexcept t11, t9
    t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0
  t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1
  t94: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92, t92:1
  t95: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t94, t94:1
  t96: i64,ch,glue = CopyFromReg t95:1, Register:i64 $rax, t95:2
      t131: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.11, !tbaa !4)> t96, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t95:1
    t129: i64,ch = MOV64rm<Mem:(load 8 from %ir.12)> t131, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t95:1
  t121: i64,ch = MOV64rm<Mem:(load 8 from %ir.14, !tbaa !19)> t96, TargetConstant:i8<1>, t129, TargetConstant:i32<240>, Register:i16 $noreg, t95:1
      t98: ch = CopyToReg t0, Register:i64 %15, t96
      t108: ch = CopyToReg t0, Register:i64 %16, t121
    t114: ch = TokenFactor t98, t108, t96:1
    t193: i32 = TEST64rr t121, t121
  t217: ch,glue = CopyToReg t114, Register:i32 $eflags, t193
  t229: i32 = Register $noreg
    t195: ch = JCC_1 BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t217, t217:1
  t117: ch = JMP_1 BasicBlock:ch<if.then.i64 0x7fffc1df5a98>, t195


********** List Scheduling %bb.6 '_Z7simpsonPFddEddi.exit' **********
SU(0): t117: ch = JMP_1 BasicBlock:ch<if.then.i64 0x7fffc1df5a98>, t195

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 25
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t195: ch = JCC_1 BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t217, t217:1

    t217: ch,glue = CopyToReg t114, Register:i32 $eflags, t193

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 24
  Height             : 1
  Predecessors:
    SU(47): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t193: i32 = TEST64rr t121, t121

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 23
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t121: i64,ch = MOV64rm<Mem:(load 8 from %ir.14, !tbaa !19)> t96, TargetConstant:i8<1>, t129, TargetConstant:i32<240>, Register:i16 $noreg, t95:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 22
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
    SU(45): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Data Latency=1
    SU(48): Data Latency=1
SU(4): t96: i64,ch,glue = CopyFromReg t95:1, Register:i64 $rax, t95:2

    t90: ch,glue = CopyToReg t89:1, Register:i64 $rdi, t56

    t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

    t94: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92, t92:1

    t95: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t94, t94:1

  # preds left       : 3
  # succs left       : 7
  # rdefs left       : 1
  Latency            : 1
  Depth              : 19
  Height             : 6
  Predecessors:
    SU(5): Data Latency=1
    SU(26): Ord  Latency=1 Barrier
    SU(13): Data Latency=1
  Successors:
    SU(3): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(45): Ord  Latency=1 Barrier
    SU(46): Data Latency=1
    SU(46): Ord  Latency=1 Barrier
    SU(47): Ord  Latency=1 Barrier
    SU(49): Data Latency=1
SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 7
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t12: f64 = MULSDrr nofpexcept t11, t9

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 8
  Predecessors:
    SU(12): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t9: f64 = ADDSDrr nofpexcept t4, t8

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 9
  Predecessors:
    SU(10): Data Latency=1
    SU(8): Data Latency=1
  Successors:
    SU(6): Data Latency=1
SU(8): t8: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t6, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 10
  Predecessors:
    SU(9): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(9): t6: f64,ch = CopyFromReg t0, Register:f64 %14

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 11
  Successors:
    SU(8): Data Latency=1
SU(10): t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 10
  Predecessors:
    SU(11): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(11): t2: f64,ch = CopyFromReg t0, Register:f64 %13

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 11
  Successors:
    SU(10): Data Latency=1
SU(12): t11: f64,ch = CopyFromReg t0, Register:f64 %2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 9
  Successors:
    SU(6): Data Latency=1
SU(13): t56: i64,ch,glue = CopyFromReg t55:1, Register:i64 $rax, t55:2

    t50: ch,glue = CopyToReg t49:1, Register:i64 $rdi, t203

    t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

    t54: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52, t52:1

    t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t54, t54:1

  # preds left       : 3
  # succs left       : 8
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 19
  Predecessors:
    SU(14): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
    SU(15): Data Latency=1
  Successors:
    SU(4): Data Latency=1
    SU(28): Data Latency=1
    SU(31): Ord  Latency=1 Barrier
    SU(32): Data Latency=1
    SU(35): Data Latency=1
    SU(38): Data Latency=1
    SU(40): Data Latency=1
    SU(44): Data Latency=1
SU(14): t48: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 20
  Successors:
    SU(13): Data Latency=1
SU(15): t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 25
  Successors:
    SU(13): Data Latency=1
    SU(18): Data Latency=1
SU(16): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t177

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 20
  Predecessors:
    SU(17): Ord  Latency=0 Barrier
  Successors:
    SU(13): Ord  Latency=1 Barrier
SU(17): t177: ch = TokenFactor t175, t32:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 20
  Predecessors:
    SU(22): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
  Successors:
    SU(16): Ord  Latency=0 Barrier
SU(18): t32: i64,ch,glue = CopyFromReg t30:1, Register:i64 $rax, t30:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t203

    t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1

    t26: ch,glue = CopyToReg t24, Register:i64 $rdx, t18, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26, t26:1

    t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1

  # preds left       : 4
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 24
  Predecessors:
    SU(19): Data Latency=1
    SU(20): Data Latency=1
    SU(21): Ord  Latency=1 Barrier
    SU(15): Data Latency=1
  Successors:
    SU(17): Ord  Latency=1 Barrier
    SU(24): Ord  Latency=1 Barrier
    SU(25): Ord  Latency=1 Barrier
SU(19): t18: i64 = MOV32ri64 TargetConstant:i64<2>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 25
  Successors:
    SU(18): Data Latency=1
SU(20): t201: i64 = MOV32ri64 TargetGlobalAddress:i64<[3 x i8]* @.str> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 25
  Successors:
    SU(18): Data Latency=1
SU(21): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 25
  Successors:
    SU(18): Ord  Latency=1 Barrier
SU(22): t175: ch = MOV64mi32<Mem:(store 8 into %ir.1, !tbaa !7)> t168, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> + 16, Register:i16 $noreg, TargetConstant:i64<6>, t178

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 21
  Predecessors:
    SU(25): Data Latency=1
    SU(23): Ord  Latency=0 Barrier
  Successors:
    SU(17): Ord  Latency=1 Barrier
SU(23): t178: ch = TokenFactor t168:1, t171:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 4
  Height             : 21
  Predecessors:
    SU(25): Ord  Latency=1 Barrier
    SU(24): Ord  Latency=1 Barrier
  Successors:
    SU(22): Ord  Latency=0 Barrier
SU(24): t171: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> 0, Register:i16 $noreg, t30:1

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 23
  Predecessors:
    SU(18): Ord  Latency=1 Barrier
  Successors:
    SU(23): Ord  Latency=1 Barrier
    SU(25): Data Latency=1
SU(25): t168: i64,ch = MOV64rm<Mem:(load 8 from %ir.0)> t171, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t30:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 22
  Predecessors:
    SU(24): Data Latency=1
    SU(18): Ord  Latency=1 Barrier
  Successors:
    SU(22): Data Latency=1
    SU(23): Ord  Latency=1 Barrier
SU(26): t89: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t163

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 18
  Height             : 7
  Predecessors:
    SU(27): Ord  Latency=0 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(27): t163: ch = TokenFactor t161, t65:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 18
  Height             : 7
  Predecessors:
    SU(32): Ord  Latency=1 Barrier
    SU(28): Ord  Latency=1 Barrier
  Successors:
    SU(26): Ord  Latency=0 Barrier
SU(28): t65: i64,ch,glue = CopyFromReg t64:1, Register:i64 $rax, t64:2

    t60: ch,glue = CopyToReg t59:1, Register:i64 $rdi, t56

    t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1

    t62: ch,glue = CopyToReg t61, Register:i64 $rdx, t58, t61:1

    t63: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62, t62:1

    t64: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t63, t63:1

  # preds left       : 4
  # succs left       : 6
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 17
  Predecessors:
    SU(29): Data Latency=1
    SU(30): Data Latency=1
    SU(31): Ord  Latency=1 Barrier
    SU(13): Data Latency=1
  Successors:
    SU(27): Ord  Latency=1 Barrier
    SU(34): Ord  Latency=1 Barrier
    SU(37): Ord  Latency=1 Barrier
    SU(40): Ord  Latency=1 Barrier
    SU(43): Ord  Latency=1 Barrier
    SU(44): Ord  Latency=1 Barrier
SU(29): t58: i64 = MOV32ri64 TargetConstant:i64<4>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 18
  Successors:
    SU(28): Data Latency=1
SU(30): t197: i64 = MOV32ri64 TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 18
  Successors:
    SU(28): Data Latency=1
SU(31): t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 18
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
  Successors:
    SU(28): Ord  Latency=1 Barrier
SU(32): t161: ch = MOV64mi32<Mem:(store 8 into %ir.10, !tbaa !7)> t56, TargetConstant:i8<1>, t158, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<20>, t158:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 17
  Height             : 8
  Predecessors:
    SU(13): Data Latency=1
    SU(33): Data Latency=1
    SU(33): Ord  Latency=1 Barrier
  Successors:
    SU(27): Ord  Latency=1 Barrier
SU(33): t158: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t157

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 16
  Height             : 9
  Predecessors:
    SU(44): Data Latency=1
    SU(34): Ord  Latency=0 Barrier
  Successors:
    SU(32): Data Latency=1
    SU(32): Ord  Latency=1 Barrier
SU(34): t157: ch = TokenFactor t154, t64:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 16
  Height             : 9
  Predecessors:
    SU(35): Ord  Latency=1 Barrier
    SU(28): Ord  Latency=1 Barrier
  Successors:
    SU(33): Ord  Latency=0 Barrier
SU(35): t154: ch = MOV64mi32<Mem:(store 8 into %ir.8, !tbaa !18)> t56, TargetConstant:i8<1>, t151, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<16>, t151:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 15
  Height             : 10
  Predecessors:
    SU(13): Data Latency=1
    SU(36): Data Latency=1
    SU(36): Ord  Latency=1 Barrier
  Successors:
    SU(34): Ord  Latency=1 Barrier
SU(36): t151: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t150

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 14
  Height             : 11
  Predecessors:
    SU(44): Data Latency=1
    SU(37): Ord  Latency=0 Barrier
  Successors:
    SU(35): Data Latency=1
    SU(35): Ord  Latency=1 Barrier
SU(37): t150: ch = TokenFactor t147, t64:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 14
  Height             : 11
  Predecessors:
    SU(38): Ord  Latency=1 Barrier
    SU(28): Ord  Latency=1 Barrier
  Successors:
    SU(36): Ord  Latency=0 Barrier
SU(38): t147: ch = MOV32mr<Mem:(store 4 into %ir.5, !tbaa !17)> t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t77, t166

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 13
  Height             : 12
  Predecessors:
    SU(13): Data Latency=1
    SU(43): Data Latency=1
    SU(42): Data Latency=1
    SU(39): Ord  Latency=0 Barrier
  Successors:
    SU(37): Ord  Latency=1 Barrier
SU(39): t166: ch = TokenFactor t75:2, t140:1, t143:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 12
  Height             : 12
  Predecessors:
    SU(40): Ord  Latency=1 Barrier
    SU(43): Ord  Latency=1 Barrier
    SU(44): Ord  Latency=1 Barrier
  Successors:
    SU(38): Ord  Latency=0 Barrier
SU(40): t75: i32,i32,ch = AND32rm<Mem:(load 4 from %ir.5, !tbaa !17)> t74, t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t64:1

  # preds left       : 4
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 11
  Height             : 14
  Predecessors:
    SU(41): Data Latency=1
    SU(13): Data Latency=1
    SU(43): Data Latency=1
    SU(28): Ord  Latency=1 Barrier
  Successors:
    SU(39): Ord  Latency=1 Barrier
    SU(42): Data Latency=1
SU(41): t74: i32 = MOV32ri TargetConstant:i32<-261>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 15
  Successors:
    SU(40): Data Latency=1
SU(42): t77: i32,i32 = ADD32ri8_DB t75, TargetConstant:i32<4>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 12
  Height             : 13
  Predecessors:
    SU(40): Data Latency=1
  Successors:
    SU(38): Data Latency=1
SU(43): t140: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t64:1

  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 10
  Height             : 15
  Predecessors:
    SU(44): Data Latency=1
    SU(28): Ord  Latency=1 Barrier
  Successors:
    SU(38): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
    SU(40): Data Latency=1
SU(44): t143: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.2, !tbaa !4)> t56, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t64:1

  # preds left       : 2
  # succs left       : 4
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 16
  Predecessors:
    SU(13): Data Latency=1
    SU(28): Ord  Latency=1 Barrier
  Successors:
    SU(33): Data Latency=1
    SU(36): Data Latency=1
    SU(39): Ord  Latency=1 Barrier
    SU(43): Data Latency=1
SU(45): t129: i64,ch = MOV64rm<Mem:(load 8 from %ir.12)> t131, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t95:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 21
  Height             : 4
  Predecessors:
    SU(46): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
SU(46): t131: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.11, !tbaa !4)> t96, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t95:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 20
  Height             : 5
  Predecessors:
    SU(4): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(45): Data Latency=1
SU(47): t114: ch = TokenFactor t98, t108, t96:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 24
  Height             : 1
  Predecessors:
    SU(49): Ord  Latency=1 Barrier
    SU(48): Ord  Latency=1 Barrier
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(48): t108: ch = CopyToReg t0, Register:i64 %16, t121

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 23
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(47): Ord  Latency=1 Barrier
SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 20
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(47): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t117: ch = JMP_1 BasicBlock:ch<if.then.i64 0x7fffc1df5a98>, t195


*** Scheduling [0]: SU(0): t117: ch = JMP_1 BasicBlock:ch<if.then.i64 0x7fffc1df5a98>, t195


Examining Available:
Height 1: SU(1): t195: ch = JCC_1 BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t217, t217:1

    t217: ch,glue = CopyToReg t114, Register:i32 $eflags, t193


*** Scheduling [1]: SU(1): t195: ch = JCC_1 BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t217, t217:1

    t217: ch,glue = CopyToReg t114, Register:i32 $eflags, t193


Examining Available:
Height 1: SU(47): t114: ch = TokenFactor t98, t108, t96:1

Height 2: SU(2): t193: i32 = TEST64rr t121, t121


*** Scheduling [2]: SU(47): t114: ch = TokenFactor t98, t108, t96:1


Examining Available:
Height 2: SU(2): t193: i32 = TEST64rr t121, t121

Height 3: SU(48): t108: ch = CopyToReg t0, Register:i64 %16, t121

Height 3: SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96


*** Scheduling [3]: SU(2): t193: i32 = TEST64rr t121, t121


Examining Available:
Height 3: SU(48): t108: ch = CopyToReg t0, Register:i64 %16, t121

Height 3: SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96


*** Scheduling [4]: SU(48): t108: ch = CopyToReg t0, Register:i64 %16, t121


Examining Available:
Height 5: SU(3): t121: i64,ch = MOV64rm<Mem:(load 8 from %ir.14, !tbaa !19)> t96, TargetConstant:i8<1>, t129, TargetConstant:i32<240>, Register:i16 $noreg, t95:1

Height 3: SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96


*** Scheduling [5]: SU(3): t121: i64,ch = MOV64rm<Mem:(load 8 from %ir.14, !tbaa !19)> t96, TargetConstant:i8<1>, t129, TargetConstant:i32<240>, Register:i16 $noreg, t95:1


Examining Available:
Height 6: SU(45): t129: i64,ch = MOV64rm<Mem:(load 8 from %ir.12)> t131, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t95:1

Height 3: SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96


*** Scheduling [6]: SU(45): t129: i64,ch = MOV64rm<Mem:(load 8 from %ir.12)> t131, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t95:1


Examining Available:
Height 7: SU(46): t131: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.11, !tbaa !4)> t96, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t95:1

Height 3: SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96


*** Scheduling [7]: SU(46): t131: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.11, !tbaa !4)> t96, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t95:1


Examining Available:
Height 3: SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96


*** Scheduling [8]: SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96


Examining Available:
Height 9: SU(4): t96: i64,ch,glue = CopyFromReg t95:1, Register:i64 $rax, t95:2

    t90: ch,glue = CopyToReg t89:1, Register:i64 $rdi, t56

    t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

    t94: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92, t92:1

    t95: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t94, t94:1


*** Scheduling [9]: SU(4): t96: i64,ch,glue = CopyFromReg t95:1, Register:i64 $rax, t95:2

    t90: ch,glue = CopyToReg t89:1, Register:i64 $rdi, t56

    t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

    t94: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92, t92:1

    t95: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t94, t94:1


Examining Available:
Height 10: SU(26): t89: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t163

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [10]: SU(26): t89: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t163


Examining Available:
Height 10: SU(27): t163: ch = TokenFactor t161, t65:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [11]: SU(27): t163: ch = TokenFactor t161, t65:1


Examining Available:
Height 12: SU(32): t161: ch = MOV64mi32<Mem:(store 8 into %ir.10, !tbaa !7)> t56, TargetConstant:i8<1>, t158, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<20>, t158:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [12]: SU(32): t161: ch = MOV64mi32<Mem:(store 8 into %ir.10, !tbaa !7)> t56, TargetConstant:i8<1>, t158, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<20>, t158:1


Examining Available:
Height 13: SU(33): t158: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t157

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [13]: SU(33): t158: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t157


Examining Available:
Height 13: SU(34): t157: ch = TokenFactor t154, t64:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [14]: SU(34): t157: ch = TokenFactor t154, t64:1


Examining Available:
Height 15: SU(35): t154: ch = MOV64mi32<Mem:(store 8 into %ir.8, !tbaa !18)> t56, TargetConstant:i8<1>, t151, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<16>, t151:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [15]: SU(35): t154: ch = MOV64mi32<Mem:(store 8 into %ir.8, !tbaa !18)> t56, TargetConstant:i8<1>, t151, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<16>, t151:1


Examining Available:
Height 16: SU(36): t151: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t150

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [16]: SU(36): t151: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t150


Examining Available:
Height 16: SU(37): t150: ch = TokenFactor t147, t64:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [17]: SU(37): t150: ch = TokenFactor t147, t64:1


Examining Available:
Height 18: SU(38): t147: ch = MOV32mr<Mem:(store 4 into %ir.5, !tbaa !17)> t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t77, t166

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [18]: SU(38): t147: ch = MOV32mr<Mem:(store 4 into %ir.5, !tbaa !17)> t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t77, t166


Examining Available:
Height 18: SU(39): t166: ch = TokenFactor t75:2, t140:1, t143:1

Height 19: SU(42): t77: i32,i32 = ADD32ri8_DB t75, TargetConstant:i32<4>

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [19]: SU(39): t166: ch = TokenFactor t75:2, t140:1, t143:1


Examining Available:
Height 19: SU(42): t77: i32,i32 = ADD32ri8_DB t75, TargetConstant:i32<4>

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [20]: SU(42): t77: i32,i32 = ADD32ri8_DB t75, TargetConstant:i32<4>


Examining Available:
Height 21: SU(40): t75: i32,i32,ch = AND32rm<Mem:(load 4 from %ir.5, !tbaa !17)> t74, t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t64:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [21]: SU(40): t75: i32,i32,ch = AND32rm<Mem:(load 4 from %ir.5, !tbaa !17)> t74, t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t64:1


Examining Available:
Height 22: SU(41): t74: i32 = MOV32ri TargetConstant:i32<-261>

Height 22: SU(43): t140: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t64:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [22]: SU(41): t74: i32 = MOV32ri TargetConstant:i32<-261>


Examining Available:
Height 22: SU(43): t140: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t64:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [23]: SU(43): t140: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t64:1


Examining Available:
Height 24: SU(44): t143: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.2, !tbaa !4)> t56, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t64:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [24]: SU(44): t143: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.2, !tbaa !4)> t56, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t64:1


Examining Available:
Height 25: SU(28): t65: i64,ch,glue = CopyFromReg t64:1, Register:i64 $rax, t64:2

    t60: ch,glue = CopyToReg t59:1, Register:i64 $rdi, t56

    t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1

    t62: ch,glue = CopyToReg t61, Register:i64 $rdx, t58, t61:1

    t63: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62, t62:1

    t64: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t63, t63:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [25]: SU(28): t65: i64,ch,glue = CopyFromReg t64:1, Register:i64 $rax, t64:2

    t60: ch,glue = CopyToReg t59:1, Register:i64 $rdi, t56

    t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1

    t62: ch,glue = CopyToReg t61, Register:i64 $rdx, t58, t61:1

    t63: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62, t62:1

    t64: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t63, t63:1


Examining Available:
Height 26: SU(29): t58: i64 = MOV32ri64 TargetConstant:i64<4>

Height 26: SU(30): t197: i64 = MOV32ri64 TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0

Height 26: SU(31): t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [26]: SU(29): t58: i64 = MOV32ri64 TargetConstant:i64<4>


Examining Available:
Height 26: SU(30): t197: i64 = MOV32ri64 TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0

Height 26: SU(31): t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [27]: SU(30): t197: i64 = MOV32ri64 TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0


Examining Available:
Height 26: SU(31): t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [28]: SU(31): t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1


Examining Available:
Height 29: SU(13): t56: i64,ch,glue = CopyFromReg t55:1, Register:i64 $rax, t55:2

    t50: ch,glue = CopyToReg t49:1, Register:i64 $rdi, t203

    t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

    t54: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52, t52:1

    t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t54, t54:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [29]: SU(13): t56: i64,ch,glue = CopyFromReg t55:1, Register:i64 $rax, t55:2

    t50: ch,glue = CopyToReg t49:1, Register:i64 $rdi, t203

    t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

    t54: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52, t52:1

    t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t54, t54:1


Examining Available:
Height 30: SU(14): t48: i32,ch = CopyFromReg t0, Register:i32 %0

Height 30: SU(16): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t177

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [30]: SU(14): t48: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 30: SU(16): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t177

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [31]: SU(16): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t177


Examining Available:
Height 31: SU(17): t177: ch = TokenFactor t175, t32:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [32]: SU(17): t177: ch = TokenFactor t175, t32:1


Examining Available:
Height 33: SU(22): t175: ch = MOV64mi32<Mem:(store 8 into %ir.1, !tbaa !7)> t168, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> + 16, Register:i16 $noreg, TargetConstant:i64<6>, t178

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [33]: SU(22): t175: ch = MOV64mi32<Mem:(store 8 into %ir.1, !tbaa !7)> t168, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> + 16, Register:i16 $noreg, TargetConstant:i64<6>, t178


Examining Available:
Height 33: SU(23): t178: ch = TokenFactor t168:1, t171:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [34]: SU(23): t178: ch = TokenFactor t168:1, t171:1


Examining Available:
Height 35: SU(25): t168: i64,ch = MOV64rm<Mem:(load 8 from %ir.0)> t171, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t30:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [35]: SU(25): t168: i64,ch = MOV64rm<Mem:(load 8 from %ir.0)> t171, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t30:1


Examining Available:
Height 36: SU(24): t171: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> 0, Register:i16 $noreg, t30:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [36]: SU(24): t171: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> 0, Register:i16 $noreg, t30:1


Examining Available:
Height 37: SU(18): t32: i64,ch,glue = CopyFromReg t30:1, Register:i64 $rax, t30:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t203

    t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1

    t26: ch,glue = CopyToReg t24, Register:i64 $rdx, t18, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26, t26:1

    t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [37]: SU(18): t32: i64,ch,glue = CopyFromReg t30:1, Register:i64 $rax, t30:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t203

    t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1

    t26: ch,glue = CopyToReg t24, Register:i64 $rdx, t18, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26, t26:1

    t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1


Examining Available:
Height 38: SU(19): t18: i64 = MOV32ri64 TargetConstant:i64<2>

Height 38: SU(20): t201: i64 = MOV32ri64 TargetGlobalAddress:i64<[3 x i8]* @.str> 0

Height 38: SU(15): t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Height 38: SU(21): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [38]: SU(19): t18: i64 = MOV32ri64 TargetConstant:i64<2>


Examining Available:
Height 38: SU(20): t201: i64 = MOV32ri64 TargetGlobalAddress:i64<[3 x i8]* @.str> 0

Height 38: SU(15): t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Height 38: SU(21): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [39]: SU(20): t201: i64 = MOV32ri64 TargetGlobalAddress:i64<[3 x i8]* @.str> 0


Examining Available:
Height 38: SU(15): t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

Height 38: SU(21): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [40]: SU(15): t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0


Examining Available:
Height 38: SU(21): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [41]: SU(21): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


Examining Available:
Height 10: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [42]: SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 43: SU(6): t12: f64 = MULSDrr nofpexcept t11, t9


*** Scheduling [43]: SU(6): t12: f64 = MULSDrr nofpexcept t11, t9


Examining Available:
Height 44: SU(12): t11: f64,ch = CopyFromReg t0, Register:f64 %2

Height 44: SU(7): t9: f64 = ADDSDrr nofpexcept t4, t8


*** Scheduling [44]: SU(12): t11: f64,ch = CopyFromReg t0, Register:f64 %2


Examining Available:
Height 44: SU(7): t9: f64 = ADDSDrr nofpexcept t4, t8


*** Scheduling [45]: SU(7): t9: f64 = ADDSDrr nofpexcept t4, t8


Examining Available:
Height 46: SU(8): t8: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t6, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

Height 46: SU(10): t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [46]: SU(8): t8: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t6, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 47: SU(9): t6: f64,ch = CopyFromReg t0, Register:f64 %14

Height 46: SU(10): t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [47]: SU(9): t6: f64,ch = CopyFromReg t0, Register:f64 %14


Examining Available:
Height 46: SU(10): t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0


*** Scheduling [48]: SU(10): t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0


Examining Available:
Height 49: SU(11): t2: f64,ch = CopyFromReg t0, Register:f64 %13


*** Scheduling [49]: SU(11): t2: f64,ch = CopyFromReg t0, Register:f64 %13

*** Final schedule ***
SU(11): t2: f64,ch = CopyFromReg t0, Register:f64 %13

SU(10): t4: f64,ch = ADDSDrm nofpexcept<Mem:(load 8 from constant-pool)> t2, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 1.000000e+00> 0, Register:i16 $noreg, t0

SU(9): t6: f64,ch = CopyFromReg t0, Register:f64 %14

SU(8): t8: f64,ch = MULSDrm nofpexcept<Mem:(load 8 from constant-pool)> t6, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 4.000000e+00> 0, Register:i16 $noreg, t0

SU(7): t9: f64 = ADDSDrr nofpexcept t4, t8

SU(12): t11: f64,ch = CopyFromReg t0, Register:f64 %2

SU(6): t12: f64 = MULSDrr nofpexcept t11, t9

SU(5): t14: f64,ch = DIVSDrm nofpexcept<Mem:(load 8 from constant-pool)> t12, Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstantPool:i32<double 3.000000e+00> 0, Register:i16 $noreg, t0

SU(21): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(15): t203: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::basic_ostream"* @_ZSt4cout> 0

SU(20): t201: i64 = MOV32ri64 TargetGlobalAddress:i64<[3 x i8]* @.str> 0

SU(19): t18: i64 = MOV32ri64 TargetConstant:i64<2>

SU(18): t32: i64,ch,glue = CopyFromReg t30:1, Register:i64 $rax, t30:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t203

    t24: ch,glue = CopyToReg t22, Register:i64 $rsi, t201, t22:1

    t26: ch,glue = CopyToReg t24, Register:i64 $rdx, t18, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t26, t26:1

    t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1

SU(24): t171: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)> Register:i64 $rip, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> 0, Register:i16 $noreg, t30:1

SU(25): t168: i64,ch = MOV64rm<Mem:(load 8 from %ir.0)> t171, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t30:1

SU(23): t178: ch = TokenFactor t168:1, t171:1

SU(22): t175: ch = MOV64mi32<Mem:(store 8 into %ir.1, !tbaa !7)> t168, TargetConstant:i8<1>, Register:i64 $noreg, TargetGlobalAddress:i32<%"class.std::basic_ostream"* @_ZSt4cout> + 16, Register:i16 $noreg, TargetConstant:i64<6>, t178

SU(17): t177: ch = TokenFactor t175, t32:1

SU(16): t49: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t177

SU(14): t48: i32,ch = CopyFromReg t0, Register:i32 %0

SU(13): t56: i64,ch,glue = CopyFromReg t55:1, Register:i64 $rax, t55:2

    t50: ch,glue = CopyToReg t49:1, Register:i64 $rdi, t203

    t52: ch,glue = CopyToReg t50, Register:i32 $esi, t48, t50:1

    t54: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i32)* @_ZNSolsEi> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t52, t52:1

    t55: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t54, t54:1

SU(31): t59: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t56:1

SU(30): t197: i64 = MOV32ri64 TargetGlobalAddress:i64<[5 x i8]* @.str.1> 0

SU(29): t58: i64 = MOV32ri64 TargetConstant:i64<4>

SU(28): t65: i64,ch,glue = CopyFromReg t64:1, Register:i64 $rax, t64:2

    t60: ch,glue = CopyToReg t59:1, Register:i64 $rdi, t56

    t61: ch,glue = CopyToReg t60, Register:i64 $rsi, t197, t60:1

    t62: ch,glue = CopyToReg t61, Register:i64 $rdx, t58, t61:1

    t63: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8*, i64)* @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l> 0, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t62, t62:1

    t64: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t63, t63:1

SU(44): t143: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.2, !tbaa !4)> t56, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t64:1

SU(43): t140: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t64:1

SU(41): t74: i32 = MOV32ri TargetConstant:i32<-261>

SU(40): t75: i32,i32,ch = AND32rm<Mem:(load 4 from %ir.5, !tbaa !17)> t74, t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t64:1

SU(42): t77: i32,i32 = ADD32ri8_DB t75, TargetConstant:i32<4>

SU(39): t166: ch = TokenFactor t75:2, t140:1, t143:1

SU(38): t147: ch = MOV32mr<Mem:(store 4 into %ir.5, !tbaa !17)> t56, TargetConstant:i8<1>, t140, TargetConstant:i32<24>, Register:i16 $noreg, t77, t166

SU(37): t150: ch = TokenFactor t147, t64:1

SU(36): t151: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t150

SU(35): t154: ch = MOV64mi32<Mem:(store 8 into %ir.8, !tbaa !18)> t56, TargetConstant:i8<1>, t151, TargetConstant:i32<8>, Register:i16 $noreg, TargetConstant:i64<16>, t151:1

SU(34): t157: ch = TokenFactor t154, t64:1

SU(33): t158: i64,ch = MOV64rm<Mem:(load 8 from %ir.3)> t143, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t157

SU(32): t161: ch = MOV64mi32<Mem:(store 8 into %ir.10, !tbaa !7)> t56, TargetConstant:i8<1>, t158, TargetConstant:i32<16>, Register:i16 $noreg, TargetConstant:i64<20>, t158:1

SU(27): t163: ch = TokenFactor t161, t65:1

SU(26): t89: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t163

SU(4): t96: i64,ch,glue = CopyFromReg t95:1, Register:i64 $rax, t95:2

    t90: ch,glue = CopyToReg t89:1, Register:i64 $rdi, t56

    t92: ch,glue = CopyToReg t90, Register:f64 $xmm0, t14, t90:1

    t94: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, double)* @_ZNSo9_M_insertIdEERSoT_> 0, Register:i64 $rdi, Register:f64 $xmm0, RegisterMask:Untyped, t92, t92:1

    t95: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t94, t94:1

SU(49): t98: ch = CopyToReg t0, Register:i64 %15, t96

SU(46): t131: i64,ch = MOV64rm<Mem:(dereferenceable load 8 from %ir.11, !tbaa !4)> t96, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t95:1

SU(45): t129: i64,ch = MOV64rm<Mem:(load 8 from %ir.12)> t131, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<-24>, Register:i16 $noreg, t95:1

SU(3): t121: i64,ch = MOV64rm<Mem:(load 8 from %ir.14, !tbaa !19)> t96, TargetConstant:i8<1>, t129, TargetConstant:i32<240>, Register:i16 $noreg, t95:1

SU(48): t108: ch = CopyToReg t0, Register:i64 %16, t121

SU(2): t193: i32 = TEST64rr t121, t121

SU(47): t114: ch = TokenFactor t98, t108, t96:1

SU(1): t195: ch = JCC_1 BasicBlock:ch<_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit 0x7fffc1df5b70>, TargetConstant:i8<5>, t217, t217:1

    t217: ch,glue = CopyToReg t114, Register:i32 $eflags, t193

SU(0): t117: ch = JMP_1 BasicBlock:ch<if.then.i64 0x7fffc1df5a98>, t195


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Creating constant: t3: i64 = Constant<56>
Creating new node: t4: i64 = add nuw t2, Constant:i64<56>
Creating constant: t5: i64 = Constant<0>
Creating new node: t6: i64 = undef
Creating new node: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
Creating constant: t8: i8 = Constant<0>
Creating new node: t10: i1 = setcc t7, Constant:i8<0>, seteq:ch
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
Creating new node: t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>
Initial selection DAG: %bb.8 'main:_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
  t5: i64 = Constant<0>
            t2: i64,ch = CopyFromReg t0, Register:i64 %16
          t4: i64 = add nuw t2, Constant:i64<56>
        t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
      t10: i1 = setcc t7, Constant:i8<0>, seteq:ch
    t12: ch = brcond t0, t10, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
  t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>



Combining: t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>

Combining: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>

Combining: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>

Combining: t10: i1 = setcc t7, Constant:i8<0>, seteq:ch

Combining: t9: ch = seteq

Combining: t8: i8 = Constant<0>

Combining: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64

Combining: t6: i64 = undef

Combining: t4: i64 = add nuw t2, Constant:i64<56>

Combining: t3: i64 = Constant<56>

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Combining: t1: i64 = Register %16

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.8 'main:_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
            t2: i64,ch = CopyFromReg t0, Register:i64 %16
          t4: i64 = add nuw t2, Constant:i64<56>
        t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
      t10: i1 = setcc t7, Constant:i8<0>, seteq:ch
    t12: ch = brcond t0, t10, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
  t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>


Legalizing node: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>

Legalizing node: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>

Legalizing node: t9: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t9: ch = seteq

Legalizing node: t8: i8 = Constant<0>
Analyzing result type: i8
Legal result type
Legally typed node: t8: i8 = Constant<0>

Legalizing node: t6: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = undef

Legalizing node: t3: i64 = Constant<56>
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = Constant<56>

Legalizing node: t1: i64 = Register %16
Ignoring node results
Legally typed node: t1: i64 = Register %16

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing node: t4: i64 = add nuw t2, Constant:i64<56>
Analyzing result type: i64
Legal result type
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Analyzing operand: t3: i64 = Constant<56>
Legal operand
Legally typed node: t4: i64 = add nuw t2, Constant:i64<56>

Legalizing node: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
Analyzing result type: i8
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t4: i64 = add nuw t2, Constant:i64<56>
Legal operand
Analyzing operand: t6: i64 = undef
Legal operand
Legally typed node: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64

Legalizing node: t10: i1 = setcc t7, Constant:i8<0>, seteq:ch
Analyzing result type: i1
Promote integer result: t10: i1 = setcc t7, Constant:i8<0>, seteq:ch

Creating new node: t15: i8 = setcc t7, Constant:i8<0>, seteq:ch
Legalizing node: t12: ch = brcond t0, t10, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t10: i1 = setcc t7, Constant:i8<0>, seteq:ch
Promote integer operand: t12: ch = brcond t0, t10, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>

Creating new node: t16: i8 = zero_extend t10
Legalizing node: t16: i8 = zero_extend t10
Analyzing result type: i8
Legal result type
Analyzing operand: t10: i1 = setcc t7, Constant:i8<0>, seteq:ch
Promote integer operand: t16: i8 = zero_extend t10

Creating constant: t17: i8 = Constant<1>
Creating new node: t18: i8 = and t15, Constant:i8<1>
Replacing: t16: i8 = zero_extend t10
     with: t18: i8 = and t15, Constant:i8<1>
Legalizing node: t17: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t17: i8 = Constant<1>

Legalizing node: t15: i8 = setcc t7, Constant:i8<0>, seteq:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
Legal operand
Analyzing operand: t8: i8 = Constant<0>
Legal operand
Analyzing operand: t9: ch = seteq
Legal operand
Legally typed node: t15: i8 = setcc t7, Constant:i8<0>, seteq:ch

Legalizing node: t18: i8 = and t15, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t15: i8 = setcc t7, Constant:i8<0>, seteq:ch
Legal operand
Analyzing operand: t17: i8 = Constant<1>
Legal operand
Legally typed node: t18: i8 = and t15, Constant:i8<1>

Legalizing node: t12: ch = brcond t0, t18, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t18: i8 = and t15, Constant:i8<1>
Legal operand
Analyzing operand: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>
Legal operand
Legally typed node: t12: ch = brcond t0, t18, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>

Legalizing node: t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = brcond t0, t18, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
Legal operand
Analyzing operand: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>
Legal operand
Legally typed node: t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.8 'main:_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
              t2: i64,ch = CopyFromReg t0, Register:i64 %16
            t4: i64 = add nuw t2, Constant:i64<56>
          t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
        t15: i8 = setcc t7, Constant:i8<0>, seteq:ch
      t18: i8 = and t15, Constant:i8<1>
    t12: ch = brcond t0, t18, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
  t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>



Combining: t18: i8 = and t15, Constant:i8<1>

Replacing.2 t18: i8 = and t15, Constant:i8<1>

With: t15: i8 = setcc t7, Constant:i8<0>, seteq:ch


Combining: t15: i8 = setcc t7, Constant:i8<0>, seteq:ch

Combining: t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>

Combining: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>

Combining: t12: ch = brcond t0, t15, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>

Combining: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>

Combining: t9: ch = seteq

Combining: t8: i8 = Constant<0>

Combining: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64

Combining: t6: i64 = undef

Combining: t4: i64 = add nuw t2, Constant:i64<56>

Combining: t3: i64 = Constant<56>

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Combining: t1: i64 = Register %16

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.8 'main:_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
            t2: i64,ch = CopyFromReg t0, Register:i64 %16
          t4: i64 = add nuw t2, Constant:i64<56>
        t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
      t15: i8 = setcc t7, Constant:i8<0>, seteq:ch
    t12: ch = brcond t0, t15, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
  t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>



Legalizing: t14: ch = br t12, BasicBlock:ch<if.then.i 0x7fffc1df5c48>
Legal node: nothing to do

Legalizing: t12: ch = brcond t0, t15, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
Trying custom legalization
Creating new node: t19: i32 = X86ISD::CMP t7, Constant:i8<0>
Creating constant: t20: i8 = TargetConstant<4>
Creating new node: t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19
Successfully custom legalized node
 ... replacing: t12: ch = brcond t0, t15, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>
     with:      t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19

Legalizing: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
Legalizing non-extending load operation

Legalizing: t4: i64 = add nuw t2, Constant:i64<56>
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Legalizing: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>
Legal node: nothing to do

Legalizing: t8: i8 = Constant<0>
Legal node: nothing to do

Legalizing: t6: i64 = undef
Legal node: nothing to do

Legalizing: t3: i64 = Constant<56>
Legal node: nothing to do

Legalizing: t1: i64 = Register %16

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19
Legal node: nothing to do

Legalizing: t20: i8 = TargetConstant<4>

Legalizing: t19: i32 = X86ISD::CMP t7, Constant:i8<0>
Legal node: nothing to do
Legalized selection DAG: %bb.8 'main:_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
            t2: i64,ch = CopyFromReg t0, Register:i64 %16
          t4: i64 = add nuw t2, Constant:i64<56>
        t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
      t19: i32 = X86ISD::CMP t7, Constant:i8<0>
    t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19
  t14: ch = br t21, BasicBlock:ch<if.then.i 0x7fffc1df5c48>



Legalizing: t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19
Legal node: nothing to do

Combining: t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19

Legalizing: t20: i8 = TargetConstant<4>

Combining: t20: i8 = TargetConstant<4>

Legalizing: t19: i32 = X86ISD::CMP t7, Constant:i8<0>
Legal node: nothing to do

Combining: t19: i32 = X86ISD::CMP t7, Constant:i8<0>

Legalizing: t14: ch = br t21, BasicBlock:ch<if.then.i 0x7fffc1df5c48>
Legal node: nothing to do

Combining: t14: ch = br t21, BasicBlock:ch<if.then.i 0x7fffc1df5c48>

Legalizing: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
Legalizing non-extending load operation

Combining: t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64

Legalizing: t4: i64 = add nuw t2, Constant:i64<56>
Legal node: nothing to do

Combining: t4: i64 = add nuw t2, Constant:i64<56>

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>
Legal node: nothing to do

Combining: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>

Legalizing: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>
Legal node: nothing to do

Combining: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>

Legalizing: t8: i8 = Constant<0>
Legal node: nothing to do

Combining: t8: i8 = Constant<0>

Legalizing: t6: i64 = undef
Legal node: nothing to do

Combining: t6: i64 = undef

Legalizing: t3: i64 = Constant<56>
Legal node: nothing to do

Combining: t3: i64 = Constant<56>

Legalizing: t1: i64 = Register %16

Combining: t1: i64 = Register %16

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.8 'main:_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
            t2: i64,ch = CopyFromReg t0, Register:i64 %16
          t4: i64 = add nuw t2, Constant:i64<56>
        t7: i8,ch = load<(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t0, t4, undef:i64
      t19: i32 = X86ISD::CMP t7, Constant:i8<0>
    t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19
  t14: ch = br t21, BasicBlock:ch<if.then.i 0x7fffc1df5c48>


===== Instruction selection begins: %bb.8 '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'

ISEL: Starting selection on root node: t14: ch = br t21, BasicBlock:ch<if.then.i 0x7fffc1df5c48>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t14: ch = JMP_1 BasicBlock:ch<if.then.i 0x7fffc1df5c48>, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t19
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t23: ch,glue = CopyToReg t0, Register:i32 $eflags, t19
  Morphed node: t21: ch = JCC_1 BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t23, t23:1
ISEL: Match complete!

ISEL: Starting selection on root node: t19: i32 = X86ISD::CMP t7, Constant:i8<0>
ISEL: Starting pattern match
  Initial Opcode index to 24481
  OpcodeSwitch from 24485 to 24984
  TypeSwitch[i8] from 24990 to 25328
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t2: i64,ch = CopyFromReg t0, Register:i64 %16
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t24: i8 = TargetConstant<1>
Creating constant: t26: i32 = TargetConstant<56>
Creating constant: t28: i8 = TargetConstant<0>
  Morphed node: t19: i32,ch = CMP8mi<Mem:(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i8<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %16

ISEL: Starting selection on root node: t20: i8 = TargetConstant<4>

ISEL: Starting selection on root node: t13: ch = BasicBlock<if.then.i 0x7fffc1df5c48>

ISEL: Starting selection on root node: t11: ch = BasicBlock<if.end.i 0x7fffc1df0fd0>

ISEL: Starting selection on root node: t1: i64 = Register %16

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.8 'main:_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t2: i64,ch = CopyFromReg t0, Register:i64 %16
    t19: i32,ch = CMP8mi<Mem:(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i8<0>, t0
  t23: ch,glue = CopyToReg t0, Register:i32 $eflags, t19
    t21: ch = JCC_1 BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t23, t23:1
  t14: ch = JMP_1 BasicBlock:ch<if.then.i 0x7fffc1df5c48>, t21


********** List Scheduling %bb.8 '_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit' **********
SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then.i 0x7fffc1df5c48>, t21

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t21: ch = JCC_1 BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t23, t23:1

    t23: ch,glue = CopyToReg t0, Register:i32 $eflags, t19

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t19: i32,ch = CMP8mi<Mem:(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i8<0>, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then.i 0x7fffc1df5c48>, t21


*** Scheduling [0]: SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then.i 0x7fffc1df5c48>, t21


Examining Available:
Height 1: SU(1): t21: ch = JCC_1 BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t23, t23:1

    t23: ch,glue = CopyToReg t0, Register:i32 $eflags, t19


*** Scheduling [1]: SU(1): t21: ch = JCC_1 BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t23, t23:1

    t23: ch,glue = CopyToReg t0, Register:i32 $eflags, t19


Examining Available:
Height 2: SU(2): t19: i32,ch = CMP8mi<Mem:(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i8<0>, t0


*** Scheduling [2]: SU(2): t19: i32,ch = CMP8mi<Mem:(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i8<0>, t0


Examining Available:
Height 3: SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16


*** Scheduling [3]: SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16

*** Final schedule ***
SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16

SU(2): t19: i32,ch = CMP8mi<Mem:(load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<56>, Register:i16 $noreg, TargetConstant:i8<0>, t0

SU(1): t21: ch = JCC_1 BasicBlock:ch<if.end.i 0x7fffc1df0fd0>, TargetConstant:i8<4>, t23, t23:1

    t23: ch,glue = CopyToReg t0, Register:i32 $eflags, t19

SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then.i 0x7fffc1df5c48>, t21


Total amount of phi nodes to update: 0
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Creating constant: t3: i64 = Constant<57>
Creating new node: t4: i64 = add nuw t2, Constant:i64<57>
Creating constant: t5: i64 = Constant<10>
Creating new node: t6: i64 = add nuw t4, Constant:i64<10>
Creating constant: t7: i64 = Constant<0>
Creating new node: t8: i64 = undef
Creating new node: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t6, undef:i64
Creating new node: t11: ch = CopyToReg t0, Register:i8 %17, t9
Creating new node: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Initial selection DAG: %bb.9 'main:if.then.i'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
  t7: i64 = Constant<0>
            t2: i64,ch = CopyFromReg t0, Register:i64 %16
          t4: i64 = add nuw t2, Constant:i64<57>
        t6: i64 = add nuw t4, Constant:i64<10>
      t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t6, undef:i64
    t11: ch = CopyToReg t0, Register:i8 %17, t9
  t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>



Combining: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>

Combining: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>

Combining: t11: ch = CopyToReg t0, Register:i8 %17, t9

Combining: t10: i8 = Register %17

Combining: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t6, undef:i64

Combining: t8: i64 = undef

Combining: t6: i64 = add nuw t4, Constant:i64<10>
Creating constant: t14: i64 = Constant<67>
Creating new node: t15: i64 = add t2, Constant:i64<67>
 ... into: t15: i64 = add t2, Constant:i64<67>

Combining: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64

Combining: t15: i64 = add t2, Constant:i64<67>

Combining: t14: i64 = Constant<67>

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Combining: t1: i64 = Register %16

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.9 'main:if.then.i'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
          t2: i64,ch = CopyFromReg t0, Register:i64 %16
        t15: i64 = add t2, Constant:i64<67>
      t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
    t11: ch = CopyToReg t0, Register:i8 %17, t9
  t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>


Legalizing node: t14: i64 = Constant<67>
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = Constant<67>

Legalizing node: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Analyzing result type: ch
Legal result type
Legally typed node: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>

Legalizing node: t10: i8 = Register %17
Ignoring node results
Legally typed node: t10: i8 = Register %17

Legalizing node: t8: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = undef

Legalizing node: t1: i64 = Register %16
Ignoring node results
Legally typed node: t1: i64 = Register %16

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing node: t15: i64 = add t2, Constant:i64<67>
Analyzing result type: i64
Legal result type
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Analyzing operand: t14: i64 = Constant<67>
Legal operand
Legally typed node: t15: i64 = add t2, Constant:i64<67>

Legalizing node: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
Analyzing result type: i8
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t15: i64 = add t2, Constant:i64<67>
Legal operand
Analyzing operand: t8: i64 = undef
Legal operand
Legally typed node: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64

Legalizing node: t11: ch = CopyToReg t0, Register:i8 %17, t9
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
Legal operand
Legally typed node: t11: ch = CopyToReg t0, Register:i8 %17, t9

Legalizing node: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = CopyToReg t0, Register:i8 %17, t9
Legal operand
Analyzing operand: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Legal operand
Legally typed node: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>

Legalizing node: t65535: ch = handlenode t13
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Legal operand
Legally typed node: t65535: ch = handlenode t13

Type-legalized selection DAG: %bb.9 'main:if.then.i'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
          t2: i64,ch = CopyFromReg t0, Register:i64 %16
        t15: i64 = add t2, Constant:i64<67>
      t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
    t11: ch = CopyToReg t0, Register:i8 %17, t9
  t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>



Legalizing: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Legal node: nothing to do

Legalizing: t11: ch = CopyToReg t0, Register:i8 %17, t9
Legal node: nothing to do

Legalizing: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
Legalizing non-extending load operation

Legalizing: t15: i64 = add t2, Constant:i64<67>
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Legalizing: t14: i64 = Constant<67>
Legal node: nothing to do

Legalizing: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Legal node: nothing to do

Legalizing: t10: i8 = Register %17

Legalizing: t8: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = Register %16

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.9 'main:if.then.i'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
          t2: i64,ch = CopyFromReg t0, Register:i64 %16
        t15: i64 = add t2, Constant:i64<67>
      t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
    t11: ch = CopyToReg t0, Register:i8 %17, t9
  t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>



Legalizing: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Legal node: nothing to do

Combining: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>

Legalizing: t11: ch = CopyToReg t0, Register:i8 %17, t9
Legal node: nothing to do

Combining: t11: ch = CopyToReg t0, Register:i8 %17, t9

Legalizing: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
Legalizing non-extending load operation

Combining: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64

Legalizing: t15: i64 = add t2, Constant:i64<67>
Legal node: nothing to do

Combining: t15: i64 = add t2, Constant:i64<67>

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing: t14: i64 = Constant<67>
Legal node: nothing to do

Combining: t14: i64 = Constant<67>

Legalizing: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
Legal node: nothing to do

Combining: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>

Legalizing: t10: i8 = Register %17

Combining: t10: i8 = Register %17

Legalizing: t8: i64 = undef
Legal node: nothing to do

Combining: t8: i64 = undef

Legalizing: t1: i64 = Register %16

Combining: t1: i64 = Register %16

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.9 'main:if.then.i'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
          t2: i64,ch = CopyFromReg t0, Register:i64 %16
        t15: i64 = add t2, Constant:i64<67>
      t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
    t11: ch = CopyToReg t0, Register:i8 %17, t9
  t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>


===== Instruction selection begins: %bb.9 'if.then.i'

ISEL: Starting selection on root node: t13: ch = br t11, BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t13: ch = JMP_1 BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = CopyToReg t0, Register:i8 %17, t9

ISEL: Starting selection on root node: t9: i8,ch = load<(load 1 from %ir.arrayidx.i, !tbaa !24)> t0, t15, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t2: i64,ch = CopyFromReg t0, Register:i64 %16
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t16: i8 = TargetConstant<1>
Creating constant: t18: i32 = TargetConstant<67>
  Morphed node: t9: i8,ch = MOV8rm<Mem:(load 1 from %ir.arrayidx.i, !tbaa !24)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<67>, Register:i16 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %16

ISEL: Starting selection on root node: t12: ch = BasicBlock<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>

ISEL: Starting selection on root node: t10: i8 = Register %17

ISEL: Starting selection on root node: t1: i64 = Register %16

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.9 'main:if.then.i'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t2: i64,ch = CopyFromReg t0, Register:i64 %16
      t9: i8,ch = MOV8rm<Mem:(load 1 from %ir.arrayidx.i, !tbaa !24)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<67>, Register:i16 $noreg, t0
    t11: ch = CopyToReg t0, Register:i8 %17, t9
  t13: ch = JMP_1 BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>, t11


********** List Scheduling %bb.9 'if.then.i' **********
SU(0): t13: ch = JMP_1 BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>, t11

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t11: ch = CopyToReg t0, Register:i8 %17, t9

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t9: i8,ch = MOV8rm<Mem:(load 1 from %ir.arrayidx.i, !tbaa !24)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<67>, Register:i16 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t13: ch = JMP_1 BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>, t11


*** Scheduling [0]: SU(0): t13: ch = JMP_1 BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>, t11


Examining Available:
Height 1: SU(1): t11: ch = CopyToReg t0, Register:i8 %17, t9


*** Scheduling [1]: SU(1): t11: ch = CopyToReg t0, Register:i8 %17, t9


Examining Available:
Height 2: SU(2): t9: i8,ch = MOV8rm<Mem:(load 1 from %ir.arrayidx.i, !tbaa !24)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<67>, Register:i16 $noreg, t0


*** Scheduling [2]: SU(2): t9: i8,ch = MOV8rm<Mem:(load 1 from %ir.arrayidx.i, !tbaa !24)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<67>, Register:i16 $noreg, t0


Examining Available:
Height 3: SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16


*** Scheduling [3]: SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16

*** Final schedule ***
SU(3): t2: i64,ch = CopyFromReg t0, Register:i64 %16

SU(2): t9: i8,ch = MOV8rm<Mem:(load 1 from %ir.arrayidx.i, !tbaa !24)> t2, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<67>, Register:i16 $noreg, t0

SU(1): t11: ch = CopyToReg t0, Register:i8 %17, t9

SU(0): t13: ch = JMP_1 BasicBlock:ch<_ZNKSt5ctypeIcE5widenEc.exit 0x7fffc1df10a8>, t11


Total amount of phi nodes to update: 1
Node 0 : (0x7fffc1df1180, 2147483665)
Creating new node: t3: i64,ch = CopyFromReg t0, Register:i64 %16
Creating constant: t4: i64 = TargetConstant<0>
Creating new node: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
Creating new node: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
Creating new node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Creating constant: t12: i64 = Constant<0>
Creating new node: t13: i64 = undef
Creating new node: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
Creating constant: t15: i64 = Constant<48>
Creating new node: t16: i64 = add nuw t14, Constant:i64<48>
Creating new node: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
Creating constant: t18: i8 = Constant<10>
Creating new node: t19: ch = TokenFactor t14:1, t17:1
Creating new node: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating constant: t21: i32 = Constant<10>
Creating new node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
Creating new node: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
Creating new node: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
Creating new node: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
Creating new node: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
Creating new node: t30: ch = CopyToReg t0, Register:i8 %18, t28
Creating new node: t31: ch = TokenFactor t30, t28:1
Initial selection DAG: %bb.10 'main:if.end.i'
SelectionDAG has 32 nodes:
  t0: ch = EntryToken
  t1: i64 = GlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0
  t3: i64,ch = CopyFromReg t0, Register:i64 %16
    t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
  t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t12: i64 = Constant<0>
  t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
    t16: i64 = add nuw t14, Constant:i64<48>
  t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
  t18: i8 = Constant<10>
      t19: ch = TokenFactor t14:1, t17:1
    t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
  t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
  t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
  t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
  t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
    t30: ch = CopyToReg t0, Register:i8 %18, t28
  t31: ch = TokenFactor t30, t28:1



Combining: t31: ch = TokenFactor t30, t28:1

Combining: t30: ch = CopyToReg t0, Register:i8 %18, t28

Combining: t29: i8 = Register %18

Combining: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1

Combining: t27: i8 = Register $al

Combining: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1

Combining: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1

Combining: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1

Combining: t23: i32 = Register $esi

Combining: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3

Combining: t21: i32 = Constant<10>

Combining: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t19: ch = TokenFactor t14:1, t17:1

Combining: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64

Combining: t16: i64 = add nuw t14, Constant:i64<48>

Combining: t15: i64 = Constant<48>

Combining: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64

Combining: t13: i64 = undef

Combining: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Combining: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1

Combining: t9: Untyped = RegisterMask

Combining: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0

Combining: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3

Combining: t6: i64 = Register $rdi

Combining: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t4: i64 = TargetConstant<0>

Combining: t3: i64,ch = CopyFromReg t0, Register:i64 %16

Combining: t2: i64 = Register %16

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.10 'main:if.end.i'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
  t3: i64,ch = CopyFromReg t0, Register:i64 %16
    t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
  t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
    t16: i64 = add nuw t14, Constant:i64<48>
  t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
      t19: ch = TokenFactor t14:1, t17:1
    t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
  t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
  t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
  t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
  t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
    t30: ch = CopyToReg t0, Register:i8 %18, t28
  t31: ch = TokenFactor t30, t28:1


Legalizing node: t29: i8 = Register %18
Ignoring node results
Legally typed node: t29: i8 = Register %18

Legalizing node: t27: i8 = Register $al
Ignoring node results
Legally typed node: t27: i8 = Register $al

Legalizing node: t23: i32 = Register $esi
Ignoring node results
Legally typed node: t23: i32 = Register $esi

Legalizing node: t21: i32 = Constant<10>
Analyzing result type: i32
Legal result type
Legally typed node: t21: i32 = Constant<10>

Legalizing node: t15: i64 = Constant<48>
Analyzing result type: i64
Legal result type
Legally typed node: t15: i64 = Constant<48>

Legalizing node: t13: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t13: i64 = undef

Legalizing node: t9: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t9: Untyped = RegisterMask

Legalizing node: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0

Legalizing node: t6: i64 = Register $rdi
Ignoring node results
Legally typed node: t6: i64 = Register $rdi

Legalizing node: t4: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t4: i64 = TargetConstant<0>

Legalizing node: t2: i64 = Register %16
Ignoring node results
Legally typed node: t2: i64 = Register %16

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: i64,ch = CopyFromReg t0, Register:i64 %16
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t3: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing node: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t3: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Legally typed node: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3

Legalizing node: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
Legal operand
Analyzing operand: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0
Legal operand
Analyzing operand: t9: Untyped = RegisterMask
Legal operand
Analyzing operand: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
Legal operand
Legally typed node: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1

Legalizing node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
Legal operand
Analyzing operand: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
Legal operand
Legally typed node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Legalizing node: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Legal operand
Analyzing operand: t3: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Analyzing operand: t13: i64 = undef
Legal operand
Legally typed node: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64

Legalizing node: t16: i64 = add nuw t14, Constant:i64<48>
Analyzing result type: i64
Legal result type
Analyzing operand: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
Legal operand
Analyzing operand: t15: i64 = Constant<48>
Legal operand
Legally typed node: t16: i64 = add nuw t14, Constant:i64<48>

Legalizing node: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
Legal operand
Analyzing operand: t16: i64 = add nuw t14, Constant:i64<48>
Legal operand
Analyzing operand: t13: i64 = undef
Legal operand
Legally typed node: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64

Legalizing node: t19: ch = TokenFactor t14:1, t17:1
Analyzing result type: ch
Legal result type
Analyzing operand: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
Legal operand
Analyzing operand: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
Legal operand
Legally typed node: t19: ch = TokenFactor t14:1, t17:1

Legalizing node: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t19: ch = TokenFactor t14:1, t17:1
Legal operand
Legally typed node: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t3: i64,ch = CopyFromReg t0, Register:i64 %16
Legal operand
Legally typed node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3

Legalizing node: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
Legal operand
Analyzing operand: t21: i32 = Constant<10>
Legal operand
Analyzing operand: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
Legal operand
Legally typed node: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1

Legalizing node: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
Legal operand
Analyzing operand: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
Legal operand
Analyzing operand: t9: Untyped = RegisterMask
Legal operand
Analyzing operand: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
Legal operand
Legally typed node: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1

Legalizing node: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
Legal operand
Analyzing operand: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
Legal operand
Legally typed node: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1

Legalizing node: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
Analyzing result type: i8
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
Legal operand
Analyzing operand: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
Legal operand
Legally typed node: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1

Legalizing node: t30: ch = CopyToReg t0, Register:i8 %18, t28
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
Legal operand
Legally typed node: t30: ch = CopyToReg t0, Register:i8 %18, t28

Legalizing node: t31: ch = TokenFactor t30, t28:1
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = CopyToReg t0, Register:i8 %18, t28
Legal operand
Analyzing operand: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
Legal operand
Legally typed node: t31: ch = TokenFactor t30, t28:1

Legalizing node: t65535: ch = handlenode t31
Analyzing result type: ch
Legal result type
Analyzing operand: t31: ch = TokenFactor t30, t28:1
Legal operand
Legally typed node: t65535: ch = handlenode t31

Type-legalized selection DAG: %bb.10 'main:if.end.i'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
  t3: i64,ch = CopyFromReg t0, Register:i64 %16
    t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
  t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
    t16: i64 = add nuw t14, Constant:i64<48>
  t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
      t19: ch = TokenFactor t14:1, t17:1
    t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
  t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
  t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
  t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
  t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
    t30: ch = CopyToReg t0, Register:i8 %18, t28
  t31: ch = TokenFactor t30, t28:1



Legalizing: t31: ch = TokenFactor t30, t28:1
Legal node: nothing to do

Legalizing: t30: ch = CopyToReg t0, Register:i8 %18, t28
Legal node: nothing to do

Legalizing: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
Legal node: nothing to do

Legalizing: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1

Legalizing: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
Legal node: nothing to do

Legalizing: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
Legal node: nothing to do

Legalizing: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
Legal node: nothing to do

Legalizing: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t19: ch = TokenFactor t14:1, t17:1
Legal node: nothing to do

Legalizing: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
Legalizing non-extending load operation

Legalizing: t16: i64 = add nuw t14, Constant:i64<48>
Legal node: nothing to do

Legalizing: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
Legalizing non-extending load operation

Legalizing: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Legalizing: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
Legal node: nothing to do

Legalizing: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
Legal node: nothing to do

Legalizing: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t3: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Legalizing: t29: i8 = Register %18

Legalizing: t27: i8 = Register $al

Legalizing: t23: i32 = Register $esi

Legalizing: t21: i32 = Constant<10>
Legal node: nothing to do

Legalizing: t15: i64 = Constant<48>
Legal node: nothing to do

Legalizing: t13: i64 = undef
Legal node: nothing to do

Legalizing: t9: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0
Legal node: nothing to do

Legalizing: t6: i64 = Register $rdi

Legalizing: t4: i64 = TargetConstant<0>

Legalizing: t2: i64 = Register %16

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.10 'main:if.end.i'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
  t3: i64,ch = CopyFromReg t0, Register:i64 %16
    t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
  t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
    t16: i64 = add nuw t14, Constant:i64<48>
  t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
      t19: ch = TokenFactor t14:1, t17:1
    t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
  t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
  t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
  t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
  t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
    t30: ch = CopyToReg t0, Register:i8 %18, t28
  t31: ch = TokenFactor t30, t28:1



Legalizing: t31: ch = TokenFactor t30, t28:1
Legal node: nothing to do

Combining: t31: ch = TokenFactor t30, t28:1

Legalizing: t30: ch = CopyToReg t0, Register:i8 %18, t28
Legal node: nothing to do

Combining: t30: ch = CopyToReg t0, Register:i8 %18, t28

Legalizing: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
Legal node: nothing to do

Combining: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1

Legalizing: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1

Combining: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1

Legalizing: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
Legal node: nothing to do

Combining: t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1

Legalizing: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
Legal node: nothing to do

Combining: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1

Legalizing: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
Legal node: nothing to do

Combining: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3

Legalizing: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t19: ch = TokenFactor t14:1, t17:1
Legal node: nothing to do

Combining: t19: ch = TokenFactor t14:1, t17:1

Legalizing: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
Legalizing non-extending load operation

Combining: t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64

Legalizing: t16: i64 = add nuw t14, Constant:i64<48>
Legal node: nothing to do

Combining: t16: i64 = add nuw t14, Constant:i64<48>

Legalizing: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
Legalizing non-extending load operation

Combining: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64

Legalizing: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Combining: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1

Legalizing: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
Legal node: nothing to do

Combining: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1

Legalizing: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
Legal node: nothing to do

Combining: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3

Legalizing: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t3: i64,ch = CopyFromReg t0, Register:i64 %16
Legal node: nothing to do

Combining: t3: i64,ch = CopyFromReg t0, Register:i64 %16

Legalizing: t29: i8 = Register %18

Combining: t29: i8 = Register %18

Legalizing: t27: i8 = Register $al

Combining: t27: i8 = Register $al

Legalizing: t23: i32 = Register $esi

Combining: t23: i32 = Register $esi

Legalizing: t21: i32 = Constant<10>
Legal node: nothing to do

Combining: t21: i32 = Constant<10>

Legalizing: t15: i64 = Constant<48>
Legal node: nothing to do

Combining: t15: i64 = Constant<48>

Legalizing: t13: i64 = undef
Legal node: nothing to do

Combining: t13: i64 = undef

Legalizing: t9: Untyped = RegisterMask
Legal node: nothing to do

Combining: t9: Untyped = RegisterMask

Legalizing: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0
Legal node: nothing to do

Combining: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0

Legalizing: t6: i64 = Register $rdi

Combining: t6: i64 = Register $rdi

Legalizing: t4: i64 = TargetConstant<0>

Combining: t4: i64 = TargetConstant<0>

Legalizing: t2: i64 = Register %16

Combining: t2: i64 = Register %16

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.10 'main:if.end.i'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
  t3: i64,ch = CopyFromReg t0, Register:i64 %16
    t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3
  t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
  t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
  t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
    t16: i64 = add nuw t14, Constant:i64<48>
  t17: i64,ch = load<(load 8 from %ir.vfn.i)> t11, t16, undef:i64
      t19: ch = TokenFactor t14:1, t17:1
    t20: ch,glue = callseq_start t19, TargetConstant:i64<0>, TargetConstant:i64<0>
  t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3
  t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1
  t25: ch,glue = X86ISD::CALL t24, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
  t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
  t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1
    t30: ch = CopyToReg t0, Register:i8 %18, t28
  t31: ch = TokenFactor t30, t28:1


===== Instruction selection begins: %bb.10 'if.end.i'
Creating new node: t32: ch = TokenFactor t14:1, t11

ISEL: Starting selection on root node: t31: ch = TokenFactor t30, t28:1

ISEL: Starting selection on root node: t30: ch = CopyToReg t0, Register:i8 %18, t28

ISEL: Starting selection on root node: t28: i8,ch,glue = CopyFromReg t26, Register:i8 $al, t26:1

ISEL: Starting selection on root node: t26: ch,glue = callseq_end t25, TargetConstant:i64<0>, TargetConstant:i64<0>, t25:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t26: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t25, t25:1
ISEL: Match complete!

ISEL: Starting selection on root node: t25: ch,glue = X86ISD::CALL t17:1, t17, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  TypeSwitch[i64] from 91306 to 91357
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
Creating constant: t33: i8 = TargetConstant<1>
Creating constant: t35: i32 = TargetConstant<48>
  Morphed node: t25: ch,glue = CALL64m<Mem:(load 8 from %ir.vfn.i)> t14, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24, t24:1
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch,glue = CopyToReg t22, Register:i32 $esi, Constant:i32<10>, t22:1

ISEL: Starting selection on root node: t22: ch,glue = CopyToReg t20, Register:i64 $rdi, t3

ISEL: Starting selection on root node: t20: ch,glue = callseq_start t32, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t37: i32 = TargetConstant<0>
  Morphed node: t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t32
ISEL: Match complete!

ISEL: Starting selection on root node: t32: ch = TokenFactor t14:1, t11

ISEL: Starting selection on root node: t14: i64,ch = load<(load 8 from %ir.18, !tbaa !4)> t11, t3, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 115472
  Match failed at index 115481
  Continuing at 115498
  Match failed at index 115501
  Continuing at 115518
  Match failed at index 115521
  Continuing at 115538
MatchAddress: X86ISelAddressMode 0x7fffc8b134b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Morphed node: t14: i64,ch = MOV64rm<Mem:(load 8 from %ir.18, !tbaa !4)> t3, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch,glue = callseq_end t10, TargetConstant:i64<0>, TargetConstant:i64<0>, t10:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch,glue = X86ISD::CALL t7, TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t10: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7, t7:1
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch,glue = CopyToReg t5, Register:i64 $rdi, t3

ISEL: Starting selection on root node: t5: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t5: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t3: i64,ch = CopyFromReg t0, Register:i64 %16

ISEL: Starting selection on root node: t29: i8 = Register %18

ISEL: Starting selection on root node: t27: i8 = Register $al

ISEL: Starting selection on root node: t23: i32 = Register $esi

ISEL: Starting selection on root node: t21: i32 = Constant<10>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  Skipped scope entry (due to false predicate) at index 123995, continuing at 124072
  Skipped scope entry (due to false predicate) at index 124073, continuing at 124110
  Skipped scope entry (due to false predicate) at index 124111, continuing at 124157
  TypeSwitch[i32] from 124159 to 124162
  Match failed at index 124166
  Continuing at 124177
Creating constant: t38: i32 = TargetConstant<10>
  Morphed node: t21: i32 = MOV32ri TargetConstant:i32<10>
ISEL: Match complete!

ISEL: Starting selection on root node: t9: Untyped = RegisterMask

ISEL: Starting selection on root node: t8: i64 = TargetGlobalAddress<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0

ISEL: Starting selection on root node: t6: i64 = Register $rdi

ISEL: Starting selection on root node: t4: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t2: i64 = Register %16

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.10 'main:if.end.i'
SelectionDAG has 31 nodes:
  t0: ch = EntryToken
  t3: i64,ch = CopyFromReg t0, Register:i64 %16
    t5: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t7: ch,glue = CopyToReg t5:1, Register:i64 $rdi, t3
  t10: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7, t7:1
  t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1
  t14: i64,ch = MOV64rm<Mem:(load 8 from %ir.18, !tbaa !4)> t3, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11:1
      t32: ch = TokenFactor t14:1, t11:1
    t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t32
  t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t3
    t21: i32 = MOV32ri TargetConstant:i32<10>
  t24: ch,glue = CopyToReg t22, Register:i32 $esi, t21, t22:1
  t25: ch,glue = CALL64m<Mem:(load 8 from %ir.vfn.i)> t14, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24, t24:1
  t26: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t25, t25:1
  t28: i8,ch,glue = CopyFromReg t26:1, Register:i8 $al, t26:2
    t30: ch = CopyToReg t0, Register:i8 %18, t28
  t31: ch = TokenFactor t30, t28:1


********** List Scheduling %bb.10 'if.end.i' **********
SU(0): t31: ch = TokenFactor t30, t28:1

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(9): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(1): t28: i8,ch,glue = CopyFromReg t26:1, Register:i8 $al, t26:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t3

    t24: ch,glue = CopyToReg t22, Register:i32 $esi, t21, t22:1

    t25: ch,glue = CALL64m<Mem:(load 8 from %ir.vfn.i)> t14, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24, t24:1

    t26: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t25, t25:1

  # preds left       : 4
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(8): Data Latency=1
    SU(2): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
    SU(3): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
    SU(9): Data Latency=1
SU(2): t21: i32 = MOV32ri TargetConstant:i32<10>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(1): Data Latency=1
SU(3): t3: i64,ch = CopyFromReg t0, Register:i64 %16

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(1): Data Latency=1
    SU(6): Data Latency=1
    SU(8): Data Latency=1
SU(4): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t32

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(5): Ord  Latency=0 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(5): t32: ch = TokenFactor t14:1, t11:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(8): Ord  Latency=1 Barrier
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=0 Barrier
SU(6): t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1

    t7: ch,glue = CopyToReg t5:1, Register:i64 $rdi, t3

    t10: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7, t7:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
    SU(3): Data Latency=1
  Successors:
    SU(5): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
SU(7): t5: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(8): t14: i64,ch = MOV64rm<Mem:(load 8 from %ir.18, !tbaa !4)> t3, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(3): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
SU(9): t30: ch = CopyToReg t0, Register:i8 %18, t28

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(1): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t31: ch = TokenFactor t30, t28:1


*** Scheduling [0]: SU(0): t31: ch = TokenFactor t30, t28:1


Examining Available:
Height 1: SU(9): t30: ch = CopyToReg t0, Register:i8 %18, t28


*** Scheduling [1]: SU(9): t30: ch = CopyToReg t0, Register:i8 %18, t28


Examining Available:
Height 2: SU(1): t28: i8,ch,glue = CopyFromReg t26:1, Register:i8 $al, t26:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t3

    t24: ch,glue = CopyToReg t22, Register:i32 $esi, t21, t22:1

    t25: ch,glue = CALL64m<Mem:(load 8 from %ir.vfn.i)> t14, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24, t24:1

    t26: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t25, t25:1


*** Scheduling [2]: SU(1): t28: i8,ch,glue = CopyFromReg t26:1, Register:i8 $al, t26:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t3

    t24: ch,glue = CopyToReg t22, Register:i32 $esi, t21, t22:1

    t25: ch,glue = CALL64m<Mem:(load 8 from %ir.vfn.i)> t14, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24, t24:1

    t26: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t25, t25:1


Examining Available:
Height 3: SU(2): t21: i32 = MOV32ri TargetConstant:i32<10>

Height 3: SU(4): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t32


*** Scheduling [3]: SU(2): t21: i32 = MOV32ri TargetConstant:i32<10>


Examining Available:
Height 3: SU(4): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t32


*** Scheduling [4]: SU(4): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t32


Examining Available:
Height 4: SU(5): t32: ch = TokenFactor t14:1, t11:1


*** Scheduling [5]: SU(5): t32: ch = TokenFactor t14:1, t11:1


Examining Available:
Height 6: SU(8): t14: i64,ch = MOV64rm<Mem:(load 8 from %ir.18, !tbaa !4)> t3, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11:1


*** Scheduling [6]: SU(8): t14: i64,ch = MOV64rm<Mem:(load 8 from %ir.18, !tbaa !4)> t3, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11:1


Examining Available:
Height 7: SU(6): t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1

    t7: ch,glue = CopyToReg t5:1, Register:i64 $rdi, t3

    t10: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7, t7:1


*** Scheduling [7]: SU(6): t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1

    t7: ch,glue = CopyToReg t5:1, Register:i64 $rdi, t3

    t10: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7, t7:1


Examining Available:
Height 8: SU(3): t3: i64,ch = CopyFromReg t0, Register:i64 %16

Height 8: SU(7): t5: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [8]: SU(3): t3: i64,ch = CopyFromReg t0, Register:i64 %16


Examining Available:
Height 8: SU(7): t5: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [9]: SU(7): t5: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(7): t5: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(3): t3: i64,ch = CopyFromReg t0, Register:i64 %16

SU(6): t11: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t10, t10:1

    t7: ch,glue = CopyToReg t5:1, Register:i64 $rdi, t3

    t10: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ctype"*)* @_ZNKSt5ctypeIcE13_M_widen_initEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t7, t7:1

SU(8): t14: i64,ch = MOV64rm<Mem:(load 8 from %ir.18, !tbaa !4)> t3, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i16 $noreg, t11:1

SU(5): t32: ch = TokenFactor t14:1, t11:1

SU(4): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t32

SU(2): t21: i32 = MOV32ri TargetConstant:i32<10>

SU(1): t28: i8,ch,glue = CopyFromReg t26:1, Register:i8 $al, t26:2

    t22: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t3

    t24: ch,glue = CopyToReg t22, Register:i32 $esi, t21, t22:1

    t25: ch,glue = CALL64m<Mem:(load 8 from %ir.vfn.i)> t14, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<48>, Register:i16 $noreg, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t24, t24:1

    t26: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t25, t25:1

SU(9): t30: ch = CopyToReg t0, Register:i8 %18, t28

SU(0): t31: ch = TokenFactor t30, t28:1


Total amount of phi nodes to update: 1
Node 0 : (0x7fffc1df1180, 2147483666)
Creating new node: t3: i64,ch = CopyFromReg t0, Register:i64 %15
Creating new node: t5: i8,ch = CopyFromReg t0, Register:i8 %19
Creating constant: t6: i64 = TargetConstant<0>
Creating new node: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t8: i32 = sign_extend t5
Creating new node: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
Creating new node: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
Creating new node: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
Creating new node: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
Creating new node: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
Creating new node: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
Creating new node: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
Creating new node: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
Creating new node: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
Creating new node: t27: i32,ch = CopyFromReg t0, Register:i32 %0
Creating constant: t28: i32 = Constant<1>
Creating constant: t29: i8 = Constant<1>
Creating new node: t30: i32 = shl nsw t27, Constant:i8<1>
Creating new node: t32: ch = CopyToReg t0, Register:i32 %20, t30
Creating constant: t33: i32 = Constant<65537>
Creating new node: t35: i1 = setcc t30, Constant:i32<65537>, setult:ch
Creating new node: t37: ch = TokenFactor t32, t25:1
Creating new node: t38: ch = brcond t37, t35, BasicBlock:ch<for.body 0x7fffc1df5388>
Creating new node: t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>
Initial selection DAG: %bb.11 'main:_ZNKSt5ctypeIcE5widenEc.exit'
SelectionDAG has 41 nodes:
  t0: ch = EntryToken
  t1: i64 = GlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0
    t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t3: i64,ch = CopyFromReg t0, Register:i64 %15
  t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
      t5: i8,ch = CopyFromReg t0, Register:i8 %19
    t8: i32 = sign_extend t5
  t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
  t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
  t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
  t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
  t19: i64 = GlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0
    t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
  t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
  t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
  t28: i32 = Constant<1>
    t27: i32,ch = CopyFromReg t0, Register:i32 %0
  t30: i32 = shl nsw t27, Constant:i8<1>
        t32: ch = CopyToReg t0, Register:i32 %20, t30
        t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
      t37: ch = TokenFactor t32, t25:1
      t35: i1 = setcc t30, Constant:i32<65537>, setult:ch
    t38: ch = brcond t37, t35, BasicBlock:ch<for.body 0x7fffc1df5388>
  t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>



Combining: t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>

Combining: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>

Combining: t38: ch = brcond t37, t35, BasicBlock:ch<for.body 0x7fffc1df5388>

Combining: t37: ch = TokenFactor t32, t25:1

Combining: t36: ch = BasicBlock<for.body 0x7fffc1df5388>

Combining: t35: i1 = setcc t30, Constant:i32<65537>, setult:ch

Combining: t34: ch = setult

Combining: t33: i32 = Constant<65537>

Combining: t32: ch = CopyToReg t0, Register:i32 %20, t30

Combining: t31: i32 = Register %20

Combining: t30: i32 = shl nsw t27, Constant:i8<1>

Combining: t29: i8 = Constant<1>

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t26: i32 = Register %0

Combining: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1

Combining: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1

Combining: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1

Combining: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0

Combining: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18

Combining: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1

Combining: t17: i64 = Register $rax

Combining: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1

Combining: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1

Combining: t14: Untyped = RegisterMask

Combining: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0

Combining: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

Combining: t11: i32 = Register $esi

Combining: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3

Combining: t9: i64 = Register $rdi

Combining: t8: i32 = sign_extend t5

Combining: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t6: i64 = TargetConstant<0>

Combining: t5: i8,ch = CopyFromReg t0, Register:i8 %19

Combining: t4: i8 = Register %19

Combining: t3: i64,ch = CopyFromReg t0, Register:i64 %15

Combining: t2: i64 = Register %15

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.11 'main:_ZNKSt5ctypeIcE5widenEc.exit'
SelectionDAG has 38 nodes:
  t0: ch = EntryToken
    t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t3: i64,ch = CopyFromReg t0, Register:i64 %15
  t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
      t5: i8,ch = CopyFromReg t0, Register:i8 %19
    t8: i32 = sign_extend t5
  t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
  t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
  t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
  t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
    t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
  t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
  t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
    t27: i32,ch = CopyFromReg t0, Register:i32 %0
  t30: i32 = shl nsw t27, Constant:i8<1>
        t32: ch = CopyToReg t0, Register:i32 %20, t30
        t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
      t37: ch = TokenFactor t32, t25:1
      t35: i1 = setcc t30, Constant:i32<65537>, setult:ch
    t38: ch = brcond t37, t35, BasicBlock:ch<for.body 0x7fffc1df5388>
  t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>


Legalizing node: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>
Analyzing result type: ch
Legal result type
Legally typed node: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>

Legalizing node: t36: ch = BasicBlock<for.body 0x7fffc1df5388>
Analyzing result type: ch
Legal result type
Legally typed node: t36: ch = BasicBlock<for.body 0x7fffc1df5388>

Legalizing node: t34: ch = setult
Analyzing result type: ch
Legal result type
Legally typed node: t34: ch = setult

Legalizing node: t33: i32 = Constant<65537>
Analyzing result type: i32
Legal result type
Legally typed node: t33: i32 = Constant<65537>

Legalizing node: t31: i32 = Register %20
Ignoring node results
Legally typed node: t31: i32 = Register %20

Legalizing node: t29: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t29: i8 = Constant<1>

Legalizing node: t26: i32 = Register %0
Ignoring node results
Legally typed node: t26: i32 = Register %0

Legalizing node: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0
Analyzing result type: i64
Legal result type
Legally typed node: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0

Legalizing node: t17: i64 = Register $rax
Ignoring node results
Legally typed node: t17: i64 = Register $rax

Legalizing node: t14: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t14: Untyped = RegisterMask

Legalizing node: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0
Analyzing result type: i64
Legal result type
Legally typed node: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0

Legalizing node: t11: i32 = Register $esi
Ignoring node results
Legally typed node: t11: i32 = Register $esi

Legalizing node: t9: i64 = Register $rdi
Ignoring node results
Legally typed node: t9: i64 = Register $rdi

Legalizing node: t6: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t6: i64 = TargetConstant<0>

Legalizing node: t4: i8 = Register %19
Ignoring node results
Legally typed node: t4: i8 = Register %19

Legalizing node: t2: i64 = Register %15
Ignoring node results
Legally typed node: t2: i64 = Register %15

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: i64,ch = CopyFromReg t0, Register:i64 %15
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t3: i64,ch = CopyFromReg t0, Register:i64 %15

Legalizing node: t5: i8,ch = CopyFromReg t0, Register:i8 %19
Analyzing result type: i8
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t5: i8,ch = CopyFromReg t0, Register:i8 %19

Legalizing node: t8: i32 = sign_extend t5
Analyzing result type: i32
Legal result type
Analyzing operand: t5: i8,ch = CopyFromReg t0, Register:i8 %19
Legal operand
Legally typed node: t8: i32 = sign_extend t5

Legalizing node: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t3: i64,ch = CopyFromReg t0, Register:i64 %15
Legal operand
Legally typed node: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3

Legalizing node: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
Legal operand
Analyzing operand: t8: i32 = sign_extend t5
Legal operand
Analyzing operand: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
Legal operand
Legally typed node: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

Legalizing node: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
Legal operand
Analyzing operand: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0
Legal operand
Analyzing operand: t14: Untyped = RegisterMask
Legal operand
Analyzing operand: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
Legal operand
Legally typed node: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1

Legalizing node: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
Legal operand
Analyzing operand: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
Legal operand
Legally typed node: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1

Legalizing node: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
Legal operand
Analyzing operand: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
Legal operand
Legally typed node: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1

Legalizing node: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
Legal operand
Legally typed node: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
Legal operand
Legally typed node: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18

Legalizing node: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
Legal operand
Analyzing operand: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0
Legal operand
Analyzing operand: t14: Untyped = RegisterMask
Legal operand
Analyzing operand: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
Legal operand
Legally typed node: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1

Legalizing node: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
Legal operand
Analyzing operand: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
Legal operand
Legally typed node: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1

Legalizing node: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
Legal operand
Analyzing operand: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
Legal operand
Legally typed node: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1

Legalizing node: t27: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t27: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t30: i32 = shl nsw t27, Constant:i8<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t27: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t29: i8 = Constant<1>
Legal operand
Legally typed node: t30: i32 = shl nsw t27, Constant:i8<1>

Legalizing node: t32: ch = CopyToReg t0, Register:i32 %20, t30
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t30: i32 = shl nsw t27, Constant:i8<1>
Legal operand
Legally typed node: t32: ch = CopyToReg t0, Register:i32 %20, t30

Legalizing node: t37: ch = TokenFactor t32, t25:1
Analyzing result type: ch
Legal result type
Analyzing operand: t32: ch = CopyToReg t0, Register:i32 %20, t30
Legal operand
Analyzing operand: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
Legal operand
Legally typed node: t37: ch = TokenFactor t32, t25:1

Legalizing node: t35: i1 = setcc t30, Constant:i32<65537>, setult:ch
Analyzing result type: i1
Promote integer result: t35: i1 = setcc t30, Constant:i32<65537>, setult:ch

Creating new node: t41: i8 = setcc t30, Constant:i32<65537>, setult:ch
Legalizing node: t38: ch = brcond t37, t35, BasicBlock:ch<for.body 0x7fffc1df5388>
Analyzing result type: ch
Legal result type
Analyzing operand: t37: ch = TokenFactor t32, t25:1
Legal operand
Analyzing operand: t35: i1 = setcc t30, Constant:i32<65537>, setult:ch
Promote integer operand: t38: ch = brcond t37, t35, BasicBlock:ch<for.body 0x7fffc1df5388>

Creating new node: t42: i8 = zero_extend t35
Legalizing node: t42: i8 = zero_extend t35
Analyzing result type: i8
Legal result type
Analyzing operand: t35: i1 = setcc t30, Constant:i32<65537>, setult:ch
Promote integer operand: t42: i8 = zero_extend t35

Creating new node: t43: i8 = and t41, Constant:i8<1>
Replacing: t42: i8 = zero_extend t35
     with: t43: i8 = and t41, Constant:i8<1>
Legalizing node: t41: i8 = setcc t30, Constant:i32<65537>, setult:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t30: i32 = shl nsw t27, Constant:i8<1>
Legal operand
Analyzing operand: t33: i32 = Constant<65537>
Legal operand
Analyzing operand: t34: ch = setult
Legal operand
Legally typed node: t41: i8 = setcc t30, Constant:i32<65537>, setult:ch

Legalizing node: t43: i8 = and t41, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t41: i8 = setcc t30, Constant:i32<65537>, setult:ch
Legal operand
Analyzing operand: t29: i8 = Constant<1>
Legal operand
Legally typed node: t43: i8 = and t41, Constant:i8<1>

Legalizing node: t38: ch = brcond t37, t43, BasicBlock:ch<for.body 0x7fffc1df5388>
Analyzing result type: ch
Legal result type
Analyzing operand: t37: ch = TokenFactor t32, t25:1
Legal operand
Analyzing operand: t43: i8 = and t41, Constant:i8<1>
Legal operand
Analyzing operand: t36: ch = BasicBlock<for.body 0x7fffc1df5388>
Legal operand
Legally typed node: t38: ch = brcond t37, t43, BasicBlock:ch<for.body 0x7fffc1df5388>

Legalizing node: t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>
Analyzing result type: ch
Legal result type
Analyzing operand: t38: ch = brcond t37, t43, BasicBlock:ch<for.body 0x7fffc1df5388>
Legal operand
Analyzing operand: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>
Legal operand
Legally typed node: t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>

Legalizing node: t65535: ch = handlenode t40
Analyzing result type: ch
Legal result type
Analyzing operand: t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>
Legal operand
Legally typed node: t65535: ch = handlenode t40

Type-legalized selection DAG: %bb.11 'main:_ZNKSt5ctypeIcE5widenEc.exit'
SelectionDAG has 39 nodes:
  t0: ch = EntryToken
    t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t3: i64,ch = CopyFromReg t0, Register:i64 %15
  t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
      t5: i8,ch = CopyFromReg t0, Register:i8 %19
    t8: i32 = sign_extend t5
  t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
  t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
  t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
  t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
    t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
  t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
  t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
    t27: i32,ch = CopyFromReg t0, Register:i32 %0
  t30: i32 = shl nsw t27, Constant:i8<1>
        t32: ch = CopyToReg t0, Register:i32 %20, t30
        t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
      t37: ch = TokenFactor t32, t25:1
        t41: i8 = setcc t30, Constant:i32<65537>, setult:ch
      t43: i8 = and t41, Constant:i8<1>
    t38: ch = brcond t37, t43, BasicBlock:ch<for.body 0x7fffc1df5388>
  t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>



Combining: t43: i8 = and t41, Constant:i8<1>

Replacing.2 t43: i8 = and t41, Constant:i8<1>

With: t41: i8 = setcc t30, Constant:i32<65537>, setult:ch


Combining: t41: i8 = setcc t30, Constant:i32<65537>, setult:ch

Combining: t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>

Combining: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>

Combining: t38: ch = brcond t37, t41, BasicBlock:ch<for.body 0x7fffc1df5388>

Combining: t37: ch = TokenFactor t32, t25:1

Combining: t36: ch = BasicBlock<for.body 0x7fffc1df5388>

Combining: t34: ch = setult

Combining: t33: i32 = Constant<65537>

Combining: t32: ch = CopyToReg t0, Register:i32 %20, t30

Combining: t31: i32 = Register %20

Combining: t30: i32 = shl nsw t27, Constant:i8<1>

Combining: t29: i8 = Constant<1>

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t26: i32 = Register %0

Combining: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1

Combining: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1

Combining: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1

Combining: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0

Combining: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18

Combining: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1

Combining: t17: i64 = Register $rax

Combining: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1

Combining: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1

Combining: t14: Untyped = RegisterMask

Combining: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0

Combining: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

Combining: t11: i32 = Register $esi

Combining: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3

Combining: t9: i64 = Register $rdi

Combining: t8: i32 = sign_extend t5

Combining: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t6: i64 = TargetConstant<0>

Combining: t5: i8,ch = CopyFromReg t0, Register:i8 %19

Combining: t4: i8 = Register %19

Combining: t3: i64,ch = CopyFromReg t0, Register:i64 %15

Combining: t2: i64 = Register %15

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.11 'main:_ZNKSt5ctypeIcE5widenEc.exit'
SelectionDAG has 38 nodes:
  t0: ch = EntryToken
    t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t3: i64,ch = CopyFromReg t0, Register:i64 %15
  t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
      t5: i8,ch = CopyFromReg t0, Register:i8 %19
    t8: i32 = sign_extend t5
  t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
  t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
  t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
  t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
    t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
  t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
  t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
    t27: i32,ch = CopyFromReg t0, Register:i32 %0
  t30: i32 = shl nsw t27, Constant:i8<1>
        t32: ch = CopyToReg t0, Register:i32 %20, t30
        t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
      t37: ch = TokenFactor t32, t25:1
      t41: i8 = setcc t30, Constant:i32<65537>, setult:ch
    t38: ch = brcond t37, t41, BasicBlock:ch<for.body 0x7fffc1df5388>
  t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>



Legalizing: t40: ch = br t38, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>
Legal node: nothing to do

Legalizing: t38: ch = brcond t37, t41, BasicBlock:ch<for.body 0x7fffc1df5388>
Trying custom legalization
Creating new node: t44: i32,i32 = X86ISD::SUB t30, Constant:i32<65537>
Creating constant: t45: i8 = TargetConstant<2>
Creating new node: t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1
Successfully custom legalized node
 ... replacing: t38: ch = brcond t37, t41, BasicBlock:ch<for.body 0x7fffc1df5388>
     with:      t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1

Legalizing: t37: ch = TokenFactor t32, t25:1
Legal node: nothing to do

Legalizing: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
Legal node: nothing to do

Legalizing: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1

Legalizing: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
Legal node: nothing to do

Legalizing: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
Legal node: nothing to do

Legalizing: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
Legal node: nothing to do

Legalizing: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1

Legalizing: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Legalizing: t32: ch = CopyToReg t0, Register:i32 %20, t30
Legal node: nothing to do

Legalizing: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
Legal node: nothing to do

Legalizing: t30: i32 = shl nsw t27, Constant:i8<1>
Legal node: nothing to do

Legalizing: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
Legal node: nothing to do

Legalizing: t8: i32 = sign_extend t5
Legal node: nothing to do

Legalizing: t27: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i8,ch = CopyFromReg t0, Register:i8 %19
Legal node: nothing to do

Legalizing: t3: i64,ch = CopyFromReg t0, Register:i64 %15
Legal node: nothing to do

Legalizing: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>
Legal node: nothing to do

Legalizing: t36: ch = BasicBlock<for.body 0x7fffc1df5388>
Legal node: nothing to do

Legalizing: t33: i32 = Constant<65537>
Legal node: nothing to do

Legalizing: t31: i32 = Register %20

Legalizing: t29: i8 = Constant<1>
Legal node: nothing to do

Legalizing: t26: i32 = Register %0

Legalizing: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0
Legal node: nothing to do

Legalizing: t17: i64 = Register $rax

Legalizing: t14: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0
Legal node: nothing to do

Legalizing: t11: i32 = Register $esi

Legalizing: t9: i64 = Register $rdi

Legalizing: t6: i64 = TargetConstant<0>

Legalizing: t4: i8 = Register %19

Legalizing: t2: i64 = Register %15

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1
Legal node: nothing to do

Legalizing: t45: i8 = TargetConstant<2>

Legalizing: t44: i32,i32 = X86ISD::SUB t30, Constant:i32<65537>
Legal node: nothing to do
Legalized selection DAG: %bb.11 'main:_ZNKSt5ctypeIcE5widenEc.exit'
SelectionDAG has 38 nodes:
  t0: ch = EntryToken
    t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t3: i64,ch = CopyFromReg t0, Register:i64 %15
  t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
    t27: i32,ch = CopyFromReg t0, Register:i32 %0
  t30: i32 = shl nsw t27, Constant:i8<1>
      t5: i8,ch = CopyFromReg t0, Register:i8 %19
    t8: i32 = sign_extend t5
  t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
  t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
  t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
  t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
    t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
  t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
  t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
        t32: ch = CopyToReg t0, Register:i32 %20, t30
        t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
      t37: ch = TokenFactor t32, t25:1
      t44: i32,i32 = X86ISD::SUB t30, Constant:i32<65537>
    t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1
  t40: ch = br t46, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>



Legalizing: t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1
Legal node: nothing to do

Combining: t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1

Legalizing: t45: i8 = TargetConstant<2>

Combining: t45: i8 = TargetConstant<2>

Legalizing: t44: i32,i32 = X86ISD::SUB t30, Constant:i32<65537>
Legal node: nothing to do

Combining: t44: i32,i32 = X86ISD::SUB t30, Constant:i32<65537>

Legalizing: t40: ch = br t46, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>
Legal node: nothing to do

Combining: t40: ch = br t46, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>

Legalizing: t37: ch = TokenFactor t32, t25:1
Legal node: nothing to do

Combining: t37: ch = TokenFactor t32, t25:1

Legalizing: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
Legal node: nothing to do

Combining: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1

Legalizing: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1

Combining: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1

Legalizing: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
Legal node: nothing to do

Combining: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1

Legalizing: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
Legal node: nothing to do

Combining: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18

Legalizing: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
Legal node: nothing to do

Combining: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1

Legalizing: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1

Combining: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1

Legalizing: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
Legal node: nothing to do

Combining: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1

Legalizing: t32: ch = CopyToReg t0, Register:i32 %20, t30
Legal node: nothing to do

Combining: t32: ch = CopyToReg t0, Register:i32 %20, t30

Legalizing: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
Legal node: nothing to do

Combining: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

Legalizing: t30: i32 = shl nsw t27, Constant:i8<1>
Legal node: nothing to do

Combining: t30: i32 = shl nsw t27, Constant:i8<1>

Legalizing: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
Legal node: nothing to do

Combining: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3

Legalizing: t8: i32 = sign_extend t5
Legal node: nothing to do

Combining: t8: i32 = sign_extend t5

Legalizing: t27: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t27: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: i8,ch = CopyFromReg t0, Register:i8 %19
Legal node: nothing to do

Combining: t5: i8,ch = CopyFromReg t0, Register:i8 %19

Legalizing: t3: i64,ch = CopyFromReg t0, Register:i64 %15
Legal node: nothing to do

Combining: t3: i64,ch = CopyFromReg t0, Register:i64 %15

Legalizing: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>
Legal node: nothing to do

Combining: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>

Legalizing: t36: ch = BasicBlock<for.body 0x7fffc1df5388>
Legal node: nothing to do

Combining: t36: ch = BasicBlock<for.body 0x7fffc1df5388>

Legalizing: t33: i32 = Constant<65537>
Legal node: nothing to do

Combining: t33: i32 = Constant<65537>

Legalizing: t31: i32 = Register %20

Combining: t31: i32 = Register %20

Legalizing: t29: i8 = Constant<1>
Legal node: nothing to do

Combining: t29: i8 = Constant<1>

Legalizing: t26: i32 = Register %0

Combining: t26: i32 = Register %0

Legalizing: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0
Legal node: nothing to do

Combining: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0

Legalizing: t17: i64 = Register $rax

Combining: t17: i64 = Register $rax

Legalizing: t14: Untyped = RegisterMask
Legal node: nothing to do

Combining: t14: Untyped = RegisterMask

Legalizing: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0
Legal node: nothing to do

Combining: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0

Legalizing: t11: i32 = Register $esi

Combining: t11: i32 = Register $esi

Legalizing: t9: i64 = Register $rdi

Combining: t9: i64 = Register $rdi

Legalizing: t6: i64 = TargetConstant<0>

Combining: t6: i64 = TargetConstant<0>

Legalizing: t4: i8 = Register %19

Combining: t4: i8 = Register %19

Legalizing: t2: i64 = Register %15

Combining: t2: i64 = Register %15

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.11 'main:_ZNKSt5ctypeIcE5widenEc.exit'
SelectionDAG has 38 nodes:
  t0: ch = EntryToken
    t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
    t3: i64,ch = CopyFromReg t0, Register:i64 %15
  t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3
    t27: i32,ch = CopyFromReg t0, Register:i32 %0
  t30: i32 = shl nsw t27, Constant:i8<1>
      t5: i8,ch = CopyFromReg t0, Register:i8 %19
    t8: i32 = sign_extend t5
  t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
  t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
  t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
  t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1
    t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
  t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18
  t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
  t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
        t32: ch = CopyToReg t0, Register:i32 %20, t30
        t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1
      t37: ch = TokenFactor t32, t25:1
      t44: i32,i32 = X86ISD::SUB t30, Constant:i32<65537>
    t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1
  t40: ch = br t46, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>


===== Instruction selection begins: %bb.11 '_ZNKSt5ctypeIcE5widenEc.exit'

ISEL: Starting selection on root node: t40: ch = br t46, BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>
ISEL: Starting pattern match
  Initial Opcode index to 129506
  Morphed node: t40: ch = JMP_1 BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>, t46
ISEL: Match complete!

ISEL: Starting selection on root node: t46: ch = X86ISD::BRCOND t37, BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t44:1
ISEL: Starting pattern match
  Initial Opcode index to 127121
Creating new node: t48: ch,glue = CopyToReg t37, Register:i32 $eflags, t44:1
  Morphed node: t46: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t48, t48:1
ISEL: Match complete!

ISEL: Starting selection on root node: t37: ch = TokenFactor t32, t25:1

ISEL: Starting selection on root node: t25: i64,ch,glue = CopyFromReg t24, Register:i64 $rax, t24:1

ISEL: Starting selection on root node: t24: ch,glue = callseq_end t23, TargetConstant:i64<0>, TargetConstant:i64<0>, t23:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch,glue = X86ISD::CALL t21, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch,glue = CopyToReg t20, Register:i64 $rdi, t18

ISEL: Starting selection on root node: t20: ch,glue = callseq_start t18:1, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t49: i32 = TargetConstant<0>
  Morphed node: t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t18:1
ISEL: Match complete!

ISEL: Starting selection on root node: t18: i64,ch,glue = CopyFromReg t16, Register:i64 $rax, t16:1

ISEL: Starting selection on root node: t16: ch,glue = callseq_end t15, TargetConstant:i64<0>, TargetConstant:i64<0>, t15:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t16: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t15, t15:1
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = X86ISD::CALL t12, TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t15: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12, t12:1
ISEL: Match complete!

ISEL: Starting selection on root node: t32: ch = CopyToReg t0, Register:i32 %20, t30

ISEL: Starting selection on root node: t44: i32,i32 = X86ISD::SUB t30, Constant:i32<65537>
ISEL: Starting pattern match
  Initial Opcode index to 89092
  Match failed at index 89099
  Continuing at 89202
  Match failed at index 89203
  Continuing at 89249
  Match failed at index 89250
  Continuing at 89313
  Continuing at 89314
  Match failed at index 89315
  Continuing at 89360
  Match failed at index 89379
  Continuing at 89392
  Match failed at index 89393
  Continuing at 89411
  Match failed at index 89412
  Continuing at 89430
  Match failed at index 89431
  Continuing at 89449
  TypeSwitch[i32] from 89453 to 89469
Creating constant: t50: i32 = TargetConstant<65537>
  Morphed node: t44: i32,i32 = SUB32ri t30, TargetConstant:i32<65537>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

ISEL: Starting selection on root node: t30: i32 = shl nsw t27, Constant:i8<1>
ISEL: Starting pattern match
  Initial Opcode index to 43060
  Match failed at index 43064
  Continuing at 43279
  TypeSwitch[i32] from 43281 to 43284
  Skipped scope entry (due to false predicate) at index 43286, continuing at 43302
MatchAddress: X86ISelAddressMode 0x7fffc8b133f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align1
  Match failed at index 43305
  Continuing at 43319
  Continuing at 43337
  Match failed at index 43344
  Continuing at 43487
  TypeSwitch[i32] from 43492 to 43517
  Morphed node: t30: i32,i32 = ADD32rr nsw t27, t27
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch,glue = CopyToReg t7, Register:i64 $rdi, t3

ISEL: Starting selection on root node: t8: i32 = sign_extend t5
ISEL: Starting pattern match
  Initial Opcode index to 128794
  TypeSwitch[i32] from 128801 to 128804
  Morphed node: t8: i32 = MOVSX32rr8 t5
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: i8,ch = CopyFromReg t0, Register:i8 %19

ISEL: Starting selection on root node: t3: i64,ch = CopyFromReg t0, Register:i64 %15

ISEL: Starting selection on root node: t45: i8 = TargetConstant<2>

ISEL: Starting selection on root node: t39: ch = BasicBlock<for.cond.cleanup 0x7fffc1df52b0>

ISEL: Starting selection on root node: t36: ch = BasicBlock<for.body 0x7fffc1df5388>

ISEL: Starting selection on root node: t31: i32 = Register %20

ISEL: Starting selection on root node: t26: i32 = Register %0

ISEL: Starting selection on root node: t22: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0

ISEL: Starting selection on root node: t17: i64 = Register $rax

ISEL: Starting selection on root node: t14: Untyped = RegisterMask

ISEL: Starting selection on root node: t13: i64 = TargetGlobalAddress<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0

ISEL: Starting selection on root node: t11: i32 = Register $esi

ISEL: Starting selection on root node: t9: i64 = Register $rdi

ISEL: Starting selection on root node: t6: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t4: i8 = Register %19

ISEL: Starting selection on root node: t2: i64 = Register %15

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.11 'main:_ZNKSt5ctypeIcE5widenEc.exit'
SelectionDAG has 41 nodes:
  t0: ch = EntryToken
  t27: i32,ch = CopyFromReg t0, Register:i32 %0
    t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
    t3: i64,ch = CopyFromReg t0, Register:i64 %15
  t10: ch,glue = CopyToReg t7:1, Register:i64 $rdi, t3
  t30: i32,i32 = ADD32rr nsw t27, t27
      t5: i8,ch = CopyFromReg t0, Register:i8 %19
    t8: i32 = MOVSX32rr8 t5
  t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1
  t15: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12, t12:1
  t16: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t15, t15:1
  t18: i64,ch,glue = CopyFromReg t16:1, Register:i64 $rax, t16:2
    t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t18:1
  t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18
  t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1
  t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1
      t32: ch = CopyToReg t0, Register:i32 %20, t30
      t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2
    t37: ch = TokenFactor t32, t25:1
    t44: i32,i32 = SUB32ri t30, TargetConstant:i32<65537>
  t48: ch,glue = CopyToReg t37, Register:i32 $eflags, t44:1
  t51: i32 = Register $noreg
    t46: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t48, t48:1
  t40: ch = JMP_1 BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>, t46


********** List Scheduling %bb.11 '_ZNKSt5ctypeIcE5widenEc.exit' **********
SU(0): t40: ch = JMP_1 BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>, t46

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t46: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t48, t48:1

    t48: ch,glue = CopyToReg t37, Register:i32 $eflags, t44:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=0 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t44: i32,i32 = SUB32ri t30, TargetConstant:i32<65537>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t30: i32,i32 = ADD32rr nsw t27, t27

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(13): Data Latency=1
SU(4): t27: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t37: ch = TokenFactor t32, t25:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(12): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(7): t18: i64,ch,glue = CopyFromReg t16:1, Register:i64 $rax, t16:2

    t10: ch,glue = CopyToReg t7:1, Register:i64 $rdi, t3

    t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

    t15: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12, t12:1

    t16: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t15, t15:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(10): Data Latency=1
  Successors:
    SU(6): Data Latency=1
    SU(12): Ord  Latency=1 Barrier
SU(8): t8: i32 = MOVSX32rr8 t5

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(9): Data Latency=1
  Successors:
    SU(7): Data Latency=1
SU(9): t5: i8,ch = CopyFromReg t0, Register:i8 %19

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(8): Data Latency=1
SU(10): t3: i64,ch = CopyFromReg t0, Register:i64 %15

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(7): Data Latency=1
SU(11): t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(12): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t18:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(13): t32: ch = CopyToReg t0, Register:i32 %20, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(5): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t40: ch = JMP_1 BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>, t46


*** Scheduling [0]: SU(0): t40: ch = JMP_1 BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>, t46


Examining Available:
Height 1: SU(1): t46: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t48, t48:1

    t48: ch,glue = CopyToReg t37, Register:i32 $eflags, t44:1


*** Scheduling [1]: SU(1): t46: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t48, t48:1

    t48: ch,glue = CopyToReg t37, Register:i32 $eflags, t44:1


Examining Available:
Height 1: SU(5): t37: ch = TokenFactor t32, t25:1

Height 2: SU(2): t44: i32,i32 = SUB32ri t30, TargetConstant:i32<65537>


*** Scheduling [2]: SU(5): t37: ch = TokenFactor t32, t25:1


Examining Available:
Height 2: SU(2): t44: i32,i32 = SUB32ri t30, TargetConstant:i32<65537>

Height 3: SU(13): t32: ch = CopyToReg t0, Register:i32 %20, t30

Height 3: SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1


*** Scheduling [3]: SU(2): t44: i32,i32 = SUB32ri t30, TargetConstant:i32<65537>


Examining Available:
Height 3: SU(13): t32: ch = CopyToReg t0, Register:i32 %20, t30

Height 3: SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1


*** Scheduling [4]: SU(13): t32: ch = CopyToReg t0, Register:i32 %20, t30


Examining Available:
Height 5: SU(3): t30: i32,i32 = ADD32rr nsw t27, t27

Height 3: SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1


*** Scheduling [5]: SU(3): t30: i32,i32 = ADD32rr nsw t27, t27


Examining Available:
Height 6: SU(4): t27: i32,ch = CopyFromReg t0, Register:i32 %0

Height 3: SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1


*** Scheduling [6]: SU(4): t27: i32,ch = CopyFromReg t0, Register:i32 %0


Examining Available:
Height 3: SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1


*** Scheduling [7]: SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1


Examining Available:
Height 8: SU(12): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t18:1


*** Scheduling [8]: SU(12): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t18:1


Examining Available:
Height 9: SU(7): t18: i64,ch,glue = CopyFromReg t16:1, Register:i64 $rax, t16:2

    t10: ch,glue = CopyToReg t7:1, Register:i64 $rdi, t3

    t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

    t15: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12, t12:1

    t16: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t15, t15:1


*** Scheduling [9]: SU(7): t18: i64,ch,glue = CopyFromReg t16:1, Register:i64 $rax, t16:2

    t10: ch,glue = CopyToReg t7:1, Register:i64 $rdi, t3

    t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

    t15: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12, t12:1

    t16: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t15, t15:1


Examining Available:
Height 10: SU(10): t3: i64,ch = CopyFromReg t0, Register:i64 %15

Height 10: SU(8): t8: i32 = MOVSX32rr8 t5

Height 10: SU(11): t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [10]: SU(10): t3: i64,ch = CopyFromReg t0, Register:i64 %15


Examining Available:
Height 10: SU(8): t8: i32 = MOVSX32rr8 t5

Height 10: SU(11): t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [11]: SU(8): t8: i32 = MOVSX32rr8 t5


Examining Available:
Height 12: SU(9): t5: i8,ch = CopyFromReg t0, Register:i8 %19

Height 10: SU(11): t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [12]: SU(9): t5: i8,ch = CopyFromReg t0, Register:i8 %19


Examining Available:
Height 10: SU(11): t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [13]: SU(11): t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(11): t7: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(9): t5: i8,ch = CopyFromReg t0, Register:i8 %19

SU(8): t8: i32 = MOVSX32rr8 t5

SU(10): t3: i64,ch = CopyFromReg t0, Register:i64 %15

SU(7): t18: i64,ch,glue = CopyFromReg t16:1, Register:i64 $rax, t16:2

    t10: ch,glue = CopyToReg t7:1, Register:i64 $rdi, t3

    t12: ch,glue = CopyToReg t10, Register:i32 $esi, t8, t10:1

    t15: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*, i8)* @_ZNSo3putEc> 0, Register:i64 $rdi, Register:i32 $esi, RegisterMask:Untyped, t12, t12:1

    t16: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t15, t15:1

SU(12): t20: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t18:1

SU(6): t25: i64,ch,glue = CopyFromReg t24:1, Register:i64 $rax, t24:2

    t21: ch,glue = CopyToReg t20:1, Register:i64 $rdi, t18

    t23: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<%"class.std::basic_ostream"* (%"class.std::basic_ostream"*)* @_ZNSo5flushEv> 0, Register:i64 $rdi, RegisterMask:Untyped, t21, t21:1

    t24: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t23, t23:1

SU(4): t27: i32,ch = CopyFromReg t0, Register:i32 %0

SU(3): t30: i32,i32 = ADD32rr nsw t27, t27

SU(13): t32: ch = CopyToReg t0, Register:i32 %20, t30

SU(2): t44: i32,i32 = SUB32ri t30, TargetConstant:i32<65537>

SU(5): t37: ch = TokenFactor t32, t25:1

SU(1): t46: ch = JCC_1 BasicBlock:ch<for.body 0x7fffc1df5388>, TargetConstant:i8<2>, t48, t48:1

    t48: ch,glue = CopyToReg t37, Register:i32 $eflags, t44:1

SU(0): t40: ch = JMP_1 BasicBlock:ch<for.cond.cleanup 0x7fffc1df52b0>, t46


Total amount of phi nodes to update: 1
Node 0 : (0x7fffc1df5460, 2147483668)
Creating constant: t1: i32 = Constant<0>
Creating constant: t2: i32 = TargetConstant<0>
Creating new node: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
Creating new node: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1
Initial selection DAG: %bb.1 'main:for.cond.cleanup'
SelectionDAG has 6 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
  t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1



Combining: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1

Combining: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>

Combining: t3: i32 = Register $eax

Combining: t2: i32 = TargetConstant<0>

Combining: t1: i32 = Constant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 'main:for.cond.cleanup'
SelectionDAG has 6 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
  t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1


Legalizing node: t3: i32 = Register $eax
Ignoring node results
Legally typed node: t3: i32 = Register $eax

Legalizing node: t2: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t2: i32 = TargetConstant<0>

Legalizing node: t1: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = Constant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<0>
Legal operand
Legally typed node: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>

Legalizing node: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1
Analyzing result type: ch
Legal result type
Analyzing operand: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
Legal operand
Analyzing operand: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
Legal operand
Legally typed node: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1

Legalizing node: t65535: ch = handlenode t5
Analyzing result type: ch
Legal result type
Analyzing operand: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1
Legal operand
Legally typed node: t65535: ch = handlenode t5

Type-legalized selection DAG: %bb.1 'main:for.cond.cleanup'
SelectionDAG has 6 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
  t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1



Legalizing: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1
Legal node: nothing to do

Legalizing: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
Legal node: nothing to do

Legalizing: t3: i32 = Register $eax

Legalizing: t2: i32 = TargetConstant<0>

Legalizing: t1: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.1 'main:for.cond.cleanup'
SelectionDAG has 6 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
  t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1



Legalizing: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1
Legal node: nothing to do

Combining: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1

Legalizing: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
Legal node: nothing to do

Combining: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>

Legalizing: t3: i32 = Register $eax

Combining: t3: i32 = Register $eax

Legalizing: t2: i32 = TargetConstant<0>

Combining: t2: i32 = TargetConstant<0>

Legalizing: t1: i32 = Constant<0>
Legal node: nothing to do

Combining: t1: i32 = Constant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 'main:for.cond.cleanup'
SelectionDAG has 6 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>
  t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1


===== Instruction selection begins: %bb.1 'for.cond.cleanup'

ISEL: Starting selection on root node: t5: ch = X86ISD::RET_FLAG t4, TargetConstant:i32<0>, Register:i32 $eax, t4:1
ISEL: Starting pattern match
  Initial Opcode index to 127064
  Morphed node: t5: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t4, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t4: ch,glue = CopyToReg t0, Register:i32 $eax, Constant:i32<0>

ISEL: Starting selection on root node: t3: i32 = Register $eax

ISEL: Starting selection on root node: t2: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t1: i32 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 123993
  TypeSwitch[i32] from 123997 to 124000
  Morphed node: t1: i32,i32 = MOV32r0
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 'main:for.cond.cleanup'
SelectionDAG has 6 nodes:
    t0: ch = EntryToken
  t4: ch,glue = CopyToReg t0, Register:i32 $eax, MOV32r0:i32,i32
  t5: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t4, t4:1


********** List Scheduling %bb.1 'for.cond.cleanup' **********
SU(0): t5: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t4, t4:1

    t4: ch,glue = CopyToReg t0, Register:i32 $eax, MOV32r0:i32,i32

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t1: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t5: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t4, t4:1

    t4: ch,glue = CopyToReg t0, Register:i32 $eax, MOV32r0:i32,i32


*** Scheduling [0]: SU(0): t5: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t4, t4:1

    t4: ch,glue = CopyToReg t0, Register:i32 $eax, MOV32r0:i32,i32


Examining Available:
Height 1: SU(1): t1: i32,i32 = MOV32r0


*** Scheduling [1]: SU(1): t1: i32,i32 = MOV32r0

*** Final schedule ***
SU(1): t1: i32,i32 = MOV32r0

SU(0): t5: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t4, t4:1

    t4: ch,glue = CopyToReg t0, Register:i32 $eax, MOV32r0:i32,i32


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = TargetConstant<0>
Creating new node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
Creating new node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Initial selection DAG: %bb.7 'main:if.then.i64'
SelectionDAG has 8 nodes:
  t1: i64 = GlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0
      t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1



Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped

Combining: t5: Untyped = RegisterMask

Combining: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t2: i64 = TargetConstant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.7 'main:if.then.i64'
SelectionDAG has 7 nodes:
      t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1


Legalizing node: t5: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t5: Untyped = RegisterMask

Legalizing node: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0
Analyzing result type: i64
Legal result type
Legally typed node: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0

Legalizing node: t2: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t2: i64 = TargetConstant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0
Legal operand
Analyzing operand: t5: Untyped = RegisterMask
Legal operand
Legally typed node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped

Legalizing node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
Legal operand
Analyzing operand: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
Legal operand
Legally typed node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing node: t65535: ch = handlenode t7
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
Legal operand
Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: %bb.7 'main:if.then.i64'
SelectionDAG has 7 nodes:
      t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1



Legalizing: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
Legal node: nothing to do

Legalizing: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0
Legal node: nothing to do

Legalizing: t2: i64 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.7 'main:if.then.i64'
SelectionDAG has 7 nodes:
      t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1



Legalizing: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Combining: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1

Legalizing: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
Legal node: nothing to do

Combining: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped

Legalizing: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t5: Untyped = RegisterMask
Legal node: nothing to do

Combining: t5: Untyped = RegisterMask

Legalizing: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0
Legal node: nothing to do

Combining: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0

Legalizing: t2: i64 = TargetConstant<0>

Combining: t2: i64 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.7 'main:if.then.i64'
SelectionDAG has 7 nodes:
      t0: ch = EntryToken
    t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
  t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1


===== Instruction selection begins: %bb.7 'if.then.i64'

ISEL: Starting selection on root node: t7: ch,glue = callseq_end t6, TargetConstant:i64<0>, TargetConstant:i64<0>, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = X86ISD::CALL t3, TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped, t3
ISEL: Match complete!

ISEL: Starting selection on root node: t3: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
Creating constant: t8: i32 = TargetConstant<0>
  Morphed node: t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t5: Untyped = RegisterMask

ISEL: Starting selection on root node: t4: i64 = TargetGlobalAddress<void ()* @_ZSt16__throw_bad_castv> 0

ISEL: Starting selection on root node: t2: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.7 'main:if.then.i64'
SelectionDAG has 8 nodes:
      t0: ch = EntryToken
    t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped, t3:1
  t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1


********** List Scheduling %bb.7 'if.then.i64' **********
SU(0): t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped, t3:1

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped, t3:1


*** Scheduling [0]: SU(0): t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped, t3:1


Examining Available:
Height 1: SU(1): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(1): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(1): t3: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(0): t7: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t6, t6:1

    t6: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void ()* @_ZSt16__throw_bad_castv> 0, RegisterMask:Untyped, t3:1


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %21:gr32 = MOV32ri 2
  JMP_1 %bb.2

bb.1.for.cond.cleanup:
; predecessors: %bb.11

  %77:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %77:gr32
  RET 0, $eax

bb.2.for.body:
; predecessors: %bb.0, %bb.11
  successors: %bb.3(0x40000000), %bb.6(0x40000000); %bb.3(50.00%), %bb.6(50.00%)

  %0:gr32 = PHI %21:gr32, %bb.0, %20:gr32, %bb.11
  %23:gr32 = OR32ri8 %0:gr32(tied-def 0), 1, implicit-def dead $eflags
  %24:gr32 = SHR32ri %23:gr32(tied-def 0), 31, implicit-def dead $eflags
  %25:gr32 = ADD32rr %23:gr32(tied-def 0), killed %24:gr32, implicit-def dead $eflags
  %1:gr32 = AND32ri8 %25:gr32(tied-def 0), -2, implicit-def dead $eflags
  %26:fr64 = CVTSI2SDrr %1:gr32
  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %2:fr64 = nofpexcept DIVSDrr %27:fr64(tied-def 0), killed %26:fr64, implicit $mxcsr
  %22:fr64 = FsFLD0SD
  %28:fr64 = nofpexcept ADDSDrr %2:fr64(tied-def 0), %22:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %28:fr64
  $xmm1 = COPY %29:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:fr64 = COPY $xmm0
  %3:fr64 = COPY %30:fr64
  %31:gr32 = SUB32ri8 %0:gr32(tied-def 0), 3, implicit-def $eflags
  JCC_1 %bb.6, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.body.i.preheader:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %34:fr64 = FsFLD0SD
  %33:gr32 = MOV32ri 2
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)

bb.4.for.body.i:
; predecessors: %bb.3, %bb.4
  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

  %4:fr64 = PHI %32:fr64, %bb.3, %11:fr64, %bb.4
  %5:gr32 = PHI %33:gr32, %bb.3, %10:gr32, %bb.4
  %6:fr64 = PHI %3:fr64, %bb.3, %9:fr64, %bb.4
  %7:fr64 = PHI %34:fr64, %bb.3, %8:fr64, %bb.4
  %35:fr64 = CVTSI2SDrr %5:gr32
  %36:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %35:fr64, implicit $mxcsr
  %37:fr64 = FsFLD0SD
  %38:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %39:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %38:fr64
  $xmm1 = COPY %39:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:fr64 = COPY $xmm0
  %8:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  %41:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), %4:fr64, implicit $mxcsr
  %42:fr64 = nofpexcept ADDSDrr %41:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %42:fr64
  $xmm1 = COPY %39:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %43:fr64 = COPY $xmm0
  %9:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  %10:gr32 = nuw nsw ADD32ri8 %5:gr32(tied-def 0), 2, implicit-def dead $eflags
  %11:fr64 = nofpexcept ADDSDrm %4:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %44:gr32 = SUB32rr %10:gr32(tied-def 0), %1:gr32, implicit-def $eflags
  JCC_1 %bb.4, 12, implicit $eflags
  JMP_1 %bb.5

bb.5.for.end.loopexit.i:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %12:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), %8:fr64, implicit $mxcsr

bb.6._Z7simpsonPFddEddi.exit:
; predecessors: %bb.2, %bb.5
  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

  %13:fr64 = PHI %22:fr64, %bb.2, %12:fr64, %bb.5
  %14:fr64 = PHI %3:fr64, %bb.2, %9:fr64, %bb.5
  %45:fr64 = nofpexcept ADDSDrm %13:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %46:fr64 = nofpexcept MULSDrm %14:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %47:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), killed %46:fr64, implicit $mxcsr
  %48:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
  %49:fr64 = nofpexcept DIVSDrm %48:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr64 = MOV32ri64 @_ZSt4cout
  %51:gr64 = MOV32ri64 @.str
  %52:gr64 = MOV32ri64 2
  $rdi = COPY %50:gr64
  $rsi = COPY %51:gr64
  $rdx = COPY %52:gr64
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %53:gr64 = COPY $rax
  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
  %55:gr64 = MOV64rm killed %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
  MOV64mi32 killed %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %50:gr64
  $esi = COPY %0:gr32
  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %56:gr64 = COPY $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr64 = MOV32ri64 4
  $rdi = COPY %56:gr64
  $rsi = COPY %57:gr64
  $rdx = COPY %58:gr64
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %59:gr64 = COPY $rax
  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  %62:gr32 = MOV32ri -261
  %63:gr32 = AND32rm %62:gr32(tied-def 0), %56:gr64, 1, %61:gr64_nosp, 24, $noreg, implicit-def dead $eflags :: (load 4 from %ir.5, !tbaa !17)
  %64:gr32 = ADD32ri8_DB %63:gr32(tied-def 0), 4, implicit-def dead $eflags
  MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, killed %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 %56:gr64, 1, killed %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
  %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 %56:gr64, 1, killed %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %56:gr64
  $xmm0 = COPY %49:fr64
  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %67:gr64 = COPY $rax
  %15:gr64 = COPY %67:gr64
  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
  %69:gr64_nosp = MOV64rm killed %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
  %16:gr64 = MOV64rm %67:gr64, 1, killed %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
  JCC_1 %bb.8, 5, implicit $eflags
  JMP_1 %bb.7

bb.7.if.then.i64:
; predecessors: %bb.6

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
; predecessors: %bb.6
  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
  JCC_1 %bb.10, 4, implicit $eflags
  JMP_1 %bb.9

bb.9.if.then.i:
; predecessors: %bb.8
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %17:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
  JMP_1 %bb.11

bb.10.if.end.i:
; predecessors: %bb.8
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %16:gr64
  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:gr32 = MOV32ri 10
  $rdi = COPY %16:gr64
  $esi = COPY %71:gr32
  CALL64m killed %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %72:gr8 = COPY $al
  %18:gr8 = COPY %72:gr8

bb.11._ZNKSt5ctypeIcE5widenEc.exit:
; predecessors: %bb.9, %bb.10
  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

  %19:gr8 = PHI %17:gr8, %bb.9, %18:gr8, %bb.10
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr32 = MOVSX32rr8 %19:gr8
  $rdi = COPY %15:gr64
  $esi = COPY %73:gr32
  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %74:gr64 = COPY $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %74:gr64
  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %75:gr64 = COPY $rax
  %20:gr32 = nsw ADD32rr %0:gr32(tied-def 0), %0:gr32, implicit-def dead $eflags
  %76:gr32 = SUB32ri %20:gr32(tied-def 0), 65537, implicit-def $eflags
  JCC_1 %bb.2, 2, implicit $eflags
  JMP_1 %bb.1

# End machine code for function main.

***** Machine Function before Domain Reassignment *****
# Machine code for function main: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %21:gr32 = MOV32ri 2
  JMP_1 %bb.2

bb.1.for.cond.cleanup:
; predecessors: %bb.11

  %77:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %77:gr32
  RET 0, $eax

bb.2.for.body:
; predecessors: %bb.0, %bb.11
  successors: %bb.3(0x40000000), %bb.6(0x40000000); %bb.3(50.00%), %bb.6(50.00%)

  %0:gr32 = PHI %21:gr32, %bb.0, %20:gr32, %bb.11
  %23:gr32 = OR32ri8 %0:gr32(tied-def 0), 1, implicit-def dead $eflags
  %24:gr32 = SHR32ri %23:gr32(tied-def 0), 31, implicit-def dead $eflags
  %25:gr32 = ADD32rr %23:gr32(tied-def 0), killed %24:gr32, implicit-def dead $eflags
  %1:gr32 = AND32ri8 %25:gr32(tied-def 0), -2, implicit-def dead $eflags
  %26:fr64 = CVTSI2SDrr %1:gr32
  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %2:fr64 = nofpexcept DIVSDrr %27:fr64(tied-def 0), killed %26:fr64, implicit $mxcsr
  %22:fr64 = FsFLD0SD
  %28:fr64 = nofpexcept ADDSDrr %2:fr64(tied-def 0), %22:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %28:fr64
  $xmm1 = COPY %29:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:fr64 = COPY $xmm0
  %3:fr64 = COPY %30:fr64
  %31:gr32 = SUB32ri8 %0:gr32(tied-def 0), 3, implicit-def $eflags
  JCC_1 %bb.6, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.body.i.preheader:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %34:fr64 = FsFLD0SD
  %33:gr32 = MOV32ri 2
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)

bb.4.for.body.i:
; predecessors: %bb.3, %bb.4
  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

  %4:fr64 = PHI %32:fr64, %bb.3, %11:fr64, %bb.4
  %5:gr32 = PHI %33:gr32, %bb.3, %10:gr32, %bb.4
  %6:fr64 = PHI %3:fr64, %bb.3, %9:fr64, %bb.4
  %7:fr64 = PHI %34:fr64, %bb.3, %8:fr64, %bb.4
  %35:fr64 = CVTSI2SDrr %5:gr32
  %36:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %35:fr64, implicit $mxcsr
  %37:fr64 = FsFLD0SD
  %38:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %39:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  $xmm0 = COPY %38:fr64
  $xmm1 = COPY %39:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:fr64 = COPY $xmm0
  %8:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  %41:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), %4:fr64, implicit $mxcsr
  %42:fr64 = nofpexcept ADDSDrr %41:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %42:fr64
  $xmm1 = COPY %39:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %43:fr64 = COPY $xmm0
  %9:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  %10:gr32 = nuw nsw ADD32ri8 %5:gr32(tied-def 0), 2, implicit-def dead $eflags
  %11:fr64 = nofpexcept ADDSDrm %4:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %44:gr32 = SUB32rr %10:gr32(tied-def 0), %1:gr32, implicit-def $eflags
  JCC_1 %bb.4, 12, implicit $eflags
  JMP_1 %bb.5

bb.5.for.end.loopexit.i:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %12:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), %8:fr64, implicit $mxcsr

bb.6._Z7simpsonPFddEddi.exit:
; predecessors: %bb.2, %bb.5
  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

  %13:fr64 = PHI %22:fr64, %bb.2, %12:fr64, %bb.5
  %14:fr64 = PHI %3:fr64, %bb.2, %9:fr64, %bb.5
  %45:fr64 = nofpexcept ADDSDrm %13:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %46:fr64 = nofpexcept MULSDrm %14:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %47:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), killed %46:fr64, implicit $mxcsr
  %48:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
  %49:fr64 = nofpexcept DIVSDrm %48:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr64 = MOV32ri64 @_ZSt4cout
  %51:gr64 = MOV32ri64 @.str
  %52:gr64 = MOV32ri64 2
  $rdi = COPY %50:gr64
  $rsi = COPY %51:gr64
  $rdx = COPY %52:gr64
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %53:gr64 = COPY $rax
  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
  %55:gr64 = MOV64rm killed %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
  MOV64mi32 killed %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %50:gr64
  $esi = COPY %0:gr32
  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %56:gr64 = COPY $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr64 = MOV32ri64 4
  $rdi = COPY %56:gr64
  $rsi = COPY %57:gr64
  $rdx = COPY %58:gr64
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %59:gr64 = COPY $rax
  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  %62:gr32 = MOV32ri -261
  %63:gr32 = AND32rm %62:gr32(tied-def 0), %56:gr64, 1, %61:gr64_nosp, 24, $noreg, implicit-def dead $eflags :: (load 4 from %ir.5, !tbaa !17)
  %64:gr32 = ADD32ri8_DB %63:gr32(tied-def 0), 4, implicit-def dead $eflags
  MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, killed %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 %56:gr64, 1, killed %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
  %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 %56:gr64, 1, killed %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %56:gr64
  $xmm0 = COPY %49:fr64
  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %67:gr64 = COPY $rax
  %15:gr64 = COPY %67:gr64
  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
  %69:gr64_nosp = MOV64rm killed %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
  %16:gr64 = MOV64rm %67:gr64, 1, killed %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
  JCC_1 %bb.8, 5, implicit $eflags
  JMP_1 %bb.7

bb.7.if.then.i64:
; predecessors: %bb.6

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
; predecessors: %bb.6
  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
  JCC_1 %bb.10, 4, implicit $eflags
  JMP_1 %bb.9

bb.9.if.then.i:
; predecessors: %bb.8
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %17:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
  JMP_1 %bb.11

bb.10.if.end.i:
; predecessors: %bb.8
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %16:gr64
  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:gr32 = MOV32ri 10
  $rdi = COPY %16:gr64
  $esi = COPY %71:gr32
  CALL64m killed %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %72:gr8 = COPY $al
  %18:gr8 = COPY %72:gr8

bb.11._ZNKSt5ctypeIcE5widenEc.exit:
; predecessors: %bb.9, %bb.10
  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

  %19:gr8 = PHI %17:gr8, %bb.9, %18:gr8, %bb.10
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr32 = MOVSX32rr8 %19:gr8
  $rdi = COPY %15:gr64
  $esi = COPY %73:gr32
  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %74:gr64 = COPY $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %74:gr64
  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %75:gr64 = COPY $rax
  %20:gr32 = nsw ADD32rr %0:gr32(tied-def 0), %0:gr32, implicit-def dead $eflags
  %76:gr32 = SUB32ri %20:gr32(tied-def 0), 65537, implicit-def $eflags
  JCC_1 %bb.2, 2, implicit $eflags
  JMP_1 %bb.1

# End machine code for function main.

# Machine code for function main: IsSSA, TracksLiveness
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

16B	  %21:gr32 = MOV32ri 2
32B	  JMP_1 %bb.2

48B	bb.1.for.cond.cleanup:
	; predecessors: %bb.11

64B	  %77:gr32 = MOV32r0 implicit-def dead $eflags
80B	  $eax = COPY %77:gr32
96B	  RET 0, $eax

112B	bb.2.for.body:
	; predecessors: %bb.0, %bb.11
	  successors: %bb.3(0x40000000), %bb.6(0x40000000); %bb.3(50.00%), %bb.6(50.00%)

128B	  %0:gr32 = PHI %21:gr32, %bb.0, %20:gr32, %bb.11
144B	  %23:gr32 = OR32ri8 %0:gr32(tied-def 0), 1, implicit-def dead $eflags
160B	  %24:gr32 = SHR32ri %23:gr32(tied-def 0), 31, implicit-def dead $eflags
176B	  %25:gr32 = ADD32rr %23:gr32(tied-def 0), killed %24:gr32, implicit-def dead $eflags
192B	  %1:gr32 = AND32ri8 %25:gr32(tied-def 0), -2, implicit-def dead $eflags
208B	  %26:fr64 = CVTSI2SDrr %1:gr32
224B	  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
240B	  %2:fr64 = nofpexcept DIVSDrr %27:fr64(tied-def 0), killed %26:fr64, implicit $mxcsr
256B	  %22:fr64 = FsFLD0SD
272B	  %28:fr64 = nofpexcept ADDSDrr %2:fr64(tied-def 0), %22:fr64, implicit $mxcsr
288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
304B	  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
320B	  $xmm0 = COPY %28:fr64
336B	  $xmm1 = COPY %29:fr64
352B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  %30:fr64 = COPY $xmm0
400B	  %3:fr64 = COPY %30:fr64
416B	  %31:gr32 = SUB32ri8 %0:gr32(tied-def 0), 3, implicit-def $eflags
432B	  JCC_1 %bb.6, 12, implicit $eflags
448B	  JMP_1 %bb.3

464B	bb.3.for.body.i.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

480B	  %34:fr64 = FsFLD0SD
496B	  %33:gr32 = MOV32ri 2
512B	  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)

528B	bb.4.for.body.i:
	; predecessors: %bb.3, %bb.4
	  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

544B	  %4:fr64 = PHI %32:fr64, %bb.3, %11:fr64, %bb.4
560B	  %5:gr32 = PHI %33:gr32, %bb.3, %10:gr32, %bb.4
576B	  %6:fr64 = PHI %3:fr64, %bb.3, %9:fr64, %bb.4
592B	  %7:fr64 = PHI %34:fr64, %bb.3, %8:fr64, %bb.4
608B	  %35:fr64 = CVTSI2SDrr %5:gr32
624B	  %36:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %35:fr64, implicit $mxcsr
640B	  %37:fr64 = FsFLD0SD
656B	  %38:fr64 = nofpexcept ADDSDrr %36:fr64(tied-def 0), %37:fr64, implicit $mxcsr
672B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
688B	  %39:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
704B	  $xmm0 = COPY %38:fr64
720B	  $xmm1 = COPY %39:fr64
736B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
752B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
768B	  %40:fr64 = COPY $xmm0
784B	  %8:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %40:fr64, implicit $mxcsr
800B	  %41:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), %4:fr64, implicit $mxcsr
816B	  %42:fr64 = nofpexcept ADDSDrr %41:fr64(tied-def 0), %37:fr64, implicit $mxcsr
832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
848B	  $xmm0 = COPY %42:fr64
864B	  $xmm1 = COPY %39:fr64
880B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
912B	  %43:fr64 = COPY $xmm0
928B	  %9:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %43:fr64, implicit $mxcsr
944B	  %10:gr32 = nuw nsw ADD32ri8 %5:gr32(tied-def 0), 2, implicit-def dead $eflags
960B	  %11:fr64 = nofpexcept ADDSDrm %4:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
976B	  %44:gr32 = SUB32rr %10:gr32(tied-def 0), %1:gr32, implicit-def $eflags
992B	  JCC_1 %bb.4, 12, implicit $eflags
1008B	  JMP_1 %bb.5

1024B	bb.5.for.end.loopexit.i:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1040B	  %12:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), %8:fr64, implicit $mxcsr

1056B	bb.6._Z7simpsonPFddEddi.exit:
	; predecessors: %bb.2, %bb.5
	  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

1072B	  %13:fr64 = PHI %22:fr64, %bb.2, %12:fr64, %bb.5
1088B	  %14:fr64 = PHI %3:fr64, %bb.2, %9:fr64, %bb.5
1104B	  %45:fr64 = nofpexcept ADDSDrm %13:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1120B	  %46:fr64 = nofpexcept MULSDrm %14:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1136B	  %47:fr64 = nofpexcept ADDSDrr %45:fr64(tied-def 0), killed %46:fr64, implicit $mxcsr
1152B	  %48:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
1168B	  %49:fr64 = nofpexcept DIVSDrm %48:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1184B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1200B	  %50:gr64 = MOV32ri64 @_ZSt4cout
1216B	  %51:gr64 = MOV32ri64 @.str
1232B	  %52:gr64 = MOV32ri64 2
1248B	  $rdi = COPY %50:gr64
1264B	  $rsi = COPY %51:gr64
1280B	  $rdx = COPY %52:gr64
1296B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1312B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1328B	  %53:gr64 = COPY $rax
1344B	  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
1360B	  %55:gr64 = MOV64rm killed %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
1376B	  MOV64mi32 killed %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
1392B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1408B	  $rdi = COPY %50:gr64
1424B	  $esi = COPY %0:gr32
1440B	  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1456B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1472B	  %56:gr64 = COPY $rax
1488B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1504B	  %57:gr64 = MOV32ri64 @.str.1
1520B	  %58:gr64 = MOV32ri64 4
1536B	  $rdi = COPY %56:gr64
1552B	  $rsi = COPY %57:gr64
1568B	  $rdx = COPY %58:gr64
1584B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1600B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1616B	  %59:gr64 = COPY $rax
1632B	  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
1648B	  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
1664B	  %62:gr32 = MOV32ri -261
1680B	  %63:gr32 = AND32rm %62:gr32(tied-def 0), %56:gr64, 1, %61:gr64_nosp, 24, $noreg, implicit-def dead $eflags :: (load 4 from %ir.5, !tbaa !17)
1696B	  %64:gr32 = ADD32ri8_DB %63:gr32(tied-def 0), 4, implicit-def dead $eflags
1712B	  MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, killed %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
1728B	  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
1744B	  MOV64mi32 %56:gr64, 1, killed %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
1760B	  %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
1776B	  MOV64mi32 %56:gr64, 1, killed %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
1792B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1808B	  $rdi = COPY %56:gr64
1824B	  $xmm0 = COPY %49:fr64
1840B	  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
1856B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1872B	  %67:gr64 = COPY $rax
1888B	  %15:gr64 = COPY %67:gr64
1904B	  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
1920B	  %69:gr64_nosp = MOV64rm killed %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
1936B	  %16:gr64 = MOV64rm %67:gr64, 1, killed %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
1952B	  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
1968B	  JCC_1 %bb.8, 5, implicit $eflags
1984B	  JMP_1 %bb.7

2000B	bb.7.if.then.i64:
	; predecessors: %bb.6

2016B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2032B	  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
2048B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2064B	bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
	; predecessors: %bb.6
	  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

2080B	  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
2096B	  JCC_1 %bb.10, 4, implicit $eflags
2112B	  JMP_1 %bb.9

2128B	bb.9.if.then.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2144B	  %17:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
2160B	  JMP_1 %bb.11

2176B	bb.10.if.end.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2192B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2208B	  $rdi = COPY %16:gr64
2224B	  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
2240B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
2272B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2288B	  %71:gr32 = MOV32ri 10
2304B	  $rdi = COPY %16:gr64
2320B	  $esi = COPY %71:gr32
2336B	  CALL64m killed %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
2352B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2368B	  %72:gr8 = COPY $al
2384B	  %18:gr8 = COPY %72:gr8

2400B	bb.11._ZNKSt5ctypeIcE5widenEc.exit:
	; predecessors: %bb.9, %bb.10
	  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

2416B	  %19:gr8 = PHI %17:gr8, %bb.9, %18:gr8, %bb.10
2432B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2448B	  %73:gr32 = MOVSX32rr8 %19:gr8
2464B	  $rdi = COPY %15:gr64
2480B	  $esi = COPY %73:gr32
2496B	  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2512B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2528B	  %74:gr64 = COPY $rax
2544B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2560B	  $rdi = COPY %74:gr64
2576B	  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2608B	  %75:gr64 = COPY $rax
2624B	  %20:gr32 = nsw ADD32rr %0:gr32(tied-def 0), %0:gr32, implicit-def dead $eflags
2640B	  %76:gr32 = SUB32ri %20:gr32(tied-def 0), 65537, implicit-def $eflags
2656B	  JCC_1 %bb.2, 2, implicit $eflags
2672B	  JMP_1 %bb.1

# End machine code for function main.

********** Stack Coloring **********
********** Function: main
DeadMachineInstructionElim: DELETING: %75:gr64 = COPY $rax
DeadMachineInstructionElim: DELETING: %59:gr64 = COPY $rax
DeadMachineInstructionElim: DELETING: %53:gr64 = COPY $rax
********** EARLY IF-CONVERSION **********
********** Function: main
Machine InstCombiner: main
Combining MBB entry
Combining MBB for.cond.cleanup
Combining MBB for.body
Combining MBB for.body.i.preheader
Combining MBB for.body.i
Combining MBB for.end.loopexit.i
Combining MBB _Z7simpsonPFddEddi.exit
Combining MBB if.then.i64
Combining MBB _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
Combining MBB if.then.i
Combining MBB if.end.i
Combining MBB _ZNKSt5ctypeIcE5widenEc.exit
********** X86 cmov Conversion : main**********

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB2[for.body]
 - 2: BB3[for.body.i.preheader]
 - 3: BB4[for.body.i]
 - 4: BB5[for.end.loopexit.i]
 - 5: BB6[_Z7simpsonPFddEddi.exit]
 - 6: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - 7: BB9[if.then.i]
 - 8: BB10[if.end.i]
 - 9: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - 10: BB1[for.cond.cleanup]
 - 11: BB7[if.then.i64]
loop-detection
 - loop = BB2[for.body]
 - loop = BB4[for.body.i]
 - loop = BB2[for.body]: member = BB3[for.body.i.preheader]
 - loop = BB2[for.body]: member = BB5[for.end.loopexit.i]
 - loop = BB2[for.body]: member = BB6[_Z7simpsonPFddEddi.exit]
 - loop = BB2[for.body]: member = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - loop = BB2[for.body]: member = BB9[if.then.i]
 - loop = BB2[for.body]: member = BB10[if.end.i]
 - loop = BB2[for.body]: member = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB5[for.end.loopexit.i]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB4[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB5[for.end.loopexit.i]
compute-loop-scale: BB4[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [ local  ] weight = 1073741824, succ = BB3[for.body.i.preheader]
  => [ local  ] weight = 1073741824, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB3[for.body.i.preheader]
  => assign 8000000000000000 (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB3[for.body.i.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[for.body.i]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.body.i]
 - node: BB4[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB5[for.end.loopexit.i]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB5[for.end.loopexit.i]
 - node: BB5[for.end.loopexit.i]
  => [ local  ] weight = 2147483648, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB6[_Z7simpsonPFddEddi.exit]
  => [  exit  ] weight = 2048, succ = BB7[if.then.i64]
  => [ local  ] weight = 2147481600, succ = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => assign 0000100000000000 (0000000000000000) [exit] to BB7[if.then.i64]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => [ local  ] weight = 805306368, succ = BB10[if.end.i]
  => [ local  ] weight = 1342177280, succ = BB9[if.then.i]
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to BB9[if.then.i]
  => assign 5ffffa0000000000 (0000000000000000) to BB10[if.end.i]
 - node: BB9[if.then.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB10[if.end.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB1[for.cond.cleanup]
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to BB2[for.body]
  => assign 07ffff8000000000 (0000000000000000) [exit] to BB1[for.cond.cleanup]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
 - node: BB3[for.body.i.preheader]
 - node: BB4[for.body.i]
 - node: BB5[for.end.loopexit.i]
 - node: BB6[_Z7simpsonPFddEddi.exit]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - node: BB9[if.then.i]
 - node: BB10[if.end.i]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 17592186044416, succ = BB7[if.then.i64]
  => [ local  ] weight = 576460202547609600, succ = BB1[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to BB1[for.cond.cleanup]
  => assign 0001fffc00000000 (0000000000000000) to BB7[if.then.i64]
 - node: BB1[for.cond.cleanup]
  => mass:  fffe0003ffffffff
 - node: BB7[if.then.i64]
  => mass:  0001fffc00000000
unwrap-loop-package: BB2[for.body]*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - BB2[for.body]: 1.0 => 31.99905398
 - BB3[for.body.i.preheader]: 0.5 => 15.99952699
 - BB4[for.body.i]: 32.0 => 1023.969727
 - BB5[for.end.loopexit.i]: 0.5 => 15.99952699
 - BB6[_Z7simpsonPFddEddi.exit]: 1.0 => 31.99905398
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: 0.9999990463 => 31.99902347
 - BB9[if.then.i]: 0.624999404 => 19.99938967
 - BB10[if.end.i]: 0.3749996424 => 11.9996338
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: 0.9999990463 => 31.99902347
unwrap-loop-package: BB4[for.body.i]*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - BB4[for.body.i]: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - BB0[entry]: float = 1.0, scaled = 262152.0002, int = 262152
 - BB2[for.body]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB3[for.body.i.preheader]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB4[for.body.i]: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - BB5[for.end.loopexit.i]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB9[if.then.i]: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - BB10[if.end.i]: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB1[for.cond.cleanup]: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - BB7[if.then.i64]: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 262152
 - BB1[for.cond.cleanup]: float = 0.99997, int = 262144
 - BB2[for.body]: float = 31.999, int = 8388616
 - BB3[for.body.i.preheader]: float = 16.0, int = 4194308
 - BB4[for.body.i]: float = 511.98, int = 134217856
 - BB5[for.end.loopexit.i]: float = 16.0, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.999, int = 8388616
 - BB7[if.then.i64]: float = 0.000030517, int = 8
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.999, int = 8388608
 - BB9[if.then.i]: float = 19.999, int = 5242880
 - BB10[if.end.i]: float = 12.0, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.999, int = 8388608

******** Pre-regalloc Machine LICM: main ********
Entering %bb.2
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
 from %bb.2 to %bb.0
Won't hoist cheap instr with loop PHI use: %22:fr64 = FsFLD0SD
Hoisting %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 from %bb.2 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Entering %bb.3
Won't hoist cheap instr with loop PHI use: %34:fr64 = FsFLD0SD
Won't hoist cheap instr with loop PHI use: %33:gr32 = MOV32ri 2
Hoisting %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
 from %bb.3 to %bb.0
Entering %bb.4
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %37:fr64 = FsFLD0SD
 from %bb.4 to %bb.0
Hoisting %39:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 from %bb.4 to %bb.0
CSEing %39:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 with %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
 from %bb.4 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Entering %bb.5
Exiting %bb.5
Exiting %bb.4
Exiting %bb.3
Entering %bb.6
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %79:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
 from %bb.6 to %bb.0
CSEing %79:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
 with %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
Hoisting %80:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 from %bb.6 to %bb.0
CSEing %80:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
 with %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
Hoisting %81:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
 from %bb.6 to %bb.0
CSEing %81:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
 with %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
Hoisting %50:gr64 = MOV32ri64 @_ZSt4cout
 from %bb.6 to %bb.0
Hoisting %51:gr64 = MOV32ri64 @.str
 from %bb.6 to %bb.0
Hoisting %52:gr64 = MOV32ri64 2
 from %bb.6 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %57:gr64 = MOV32ri64 @.str.1
 from %bb.6 to %bb.0
Hoisting %58:gr64 = MOV32ri64 4
 from %bb.6 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %62:gr32 = MOV32ri -261
 from %bb.6 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Entering %bb.8
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Entering %bb.10
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %71:gr32 = MOV32ri 10
 from %bb.10 to %bb.0
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Exiting %bb.10
Entering %bb.11
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Entering %bb.9
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Exiting %bb.9

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB2[for.body]
 - 2: BB3[for.body.i.preheader]
 - 3: BB4[for.body.i]
 - 4: BB5[for.end.loopexit.i]
 - 5: BB6[_Z7simpsonPFddEddi.exit]
 - 6: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - 7: BB9[if.then.i]
 - 8: BB10[if.end.i]
 - 9: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - 10: BB1[for.cond.cleanup]
 - 11: BB7[if.then.i64]
loop-detection
 - loop = BB2[for.body]
 - loop = BB4[for.body.i]
 - loop = BB2[for.body]: member = BB3[for.body.i.preheader]
 - loop = BB2[for.body]: member = BB5[for.end.loopexit.i]
 - loop = BB2[for.body]: member = BB6[_Z7simpsonPFddEddi.exit]
 - loop = BB2[for.body]: member = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - loop = BB2[for.body]: member = BB9[if.then.i]
 - loop = BB2[for.body]: member = BB10[if.end.i]
 - loop = BB2[for.body]: member = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB5[for.end.loopexit.i]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB4[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB5[for.end.loopexit.i]
compute-loop-scale: BB4[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [ local  ] weight = 1073741824, succ = BB3[for.body.i.preheader]
  => [ local  ] weight = 1073741824, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB3[for.body.i.preheader]
  => assign 8000000000000000 (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB3[for.body.i.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[for.body.i]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.body.i]
 - node: BB4[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB5[for.end.loopexit.i]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB5[for.end.loopexit.i]
 - node: BB5[for.end.loopexit.i]
  => [ local  ] weight = 2147483648, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB6[_Z7simpsonPFddEddi.exit]
  => [  exit  ] weight = 2048, succ = BB7[if.then.i64]
  => [ local  ] weight = 2147481600, succ = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => assign 0000100000000000 (0000000000000000) [exit] to BB7[if.then.i64]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => [ local  ] weight = 805306368, succ = BB10[if.end.i]
  => [ local  ] weight = 1342177280, succ = BB9[if.then.i]
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to BB9[if.then.i]
  => assign 5ffffa0000000000 (0000000000000000) to BB10[if.end.i]
 - node: BB9[if.then.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB10[if.end.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB1[for.cond.cleanup]
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to BB2[for.body]
  => assign 07ffff8000000000 (0000000000000000) [exit] to BB1[for.cond.cleanup]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
 - node: BB3[for.body.i.preheader]
 - node: BB4[for.body.i]
 - node: BB5[for.end.loopexit.i]
 - node: BB6[_Z7simpsonPFddEddi.exit]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - node: BB9[if.then.i]
 - node: BB10[if.end.i]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 17592186044416, succ = BB7[if.then.i64]
  => [ local  ] weight = 576460202547609600, succ = BB1[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to BB1[for.cond.cleanup]
  => assign 0001fffc00000000 (0000000000000000) to BB7[if.then.i64]
 - node: BB1[for.cond.cleanup]
  => mass:  fffe0003ffffffff
 - node: BB7[if.then.i64]
  => mass:  0001fffc00000000
unwrap-loop-package: BB2[for.body]*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - BB2[for.body]: 1.0 => 31.99905398
 - BB3[for.body.i.preheader]: 0.5 => 15.99952699
 - BB4[for.body.i]: 32.0 => 1023.969727
 - BB5[for.end.loopexit.i]: 0.5 => 15.99952699
 - BB6[_Z7simpsonPFddEddi.exit]: 1.0 => 31.99905398
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: 0.9999990463 => 31.99902347
 - BB9[if.then.i]: 0.624999404 => 19.99938967
 - BB10[if.end.i]: 0.3749996424 => 11.9996338
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: 0.9999990463 => 31.99902347
unwrap-loop-package: BB4[for.body.i]*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - BB4[for.body.i]: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - BB0[entry]: float = 1.0, scaled = 262152.0002, int = 262152
 - BB2[for.body]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB3[for.body.i.preheader]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB4[for.body.i]: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - BB5[for.end.loopexit.i]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB9[if.then.i]: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - BB10[if.end.i]: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB1[for.cond.cleanup]: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - BB7[if.then.i64]: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 262152
 - BB1[for.cond.cleanup]: float = 0.99997, int = 262144
 - BB2[for.body]: float = 31.999, int = 8388616
 - BB3[for.body.i.preheader]: float = 16.0, int = 4194308
 - BB4[for.body.i]: float = 511.98, int = 134217856
 - BB5[for.end.loopexit.i]: float = 16.0, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.999, int = 8388616
 - BB7[if.then.i64]: float = 0.000030517, int = 8
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.999, int = 8388608
 - BB9[if.then.i]: float = 19.999, int = 5242880
 - BB10[if.end.i]: float = 12.0, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.999, int = 8388608

Entering: entry
Entering: for.body
Examining: %22:fr64 = FsFLD0SD
*** Found a common subexpression: %37:fr64 = FsFLD0SD
Entering: _Z7simpsonPFddEddi.exit
Entering: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
Entering: if.then.i
Exiting: if.then.i
Entering: _ZNKSt5ctypeIcE5widenEc.exit
Entering: for.cond.cleanup
Exiting: for.cond.cleanup
Exiting: _ZNKSt5ctypeIcE5widenEc.exit
Entering: if.end.i
Exiting: if.end.i
Exiting: _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
Entering: if.then.i64
Exiting: if.then.i64
Exiting: _Z7simpsonPFddEddi.exit
Entering: for.body.i.preheader
Examining: %34:fr64 = FsFLD0SD
*** Found a common subexpression: %37:fr64 = FsFLD0SD
*** Not profitable, avoid CSE!
Examining: %33:gr32 = MOV32ri 2
*** Found a common subexpression: %21:gr32 = MOV32ri 2
*** Not profitable, avoid CSE!
Entering: for.body.i
Entering: for.end.loopexit.i
Exiting: for.end.loopexit.i
Exiting: for.body.i
Exiting: for.body.i.preheader
Exiting: for.body
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.1
Last visited node: %bb.9
Found a new trivial root: %bb.7
Last visited node: %bb.7
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.1
3: %bb.11
4: %bb.10
5: %bb.8
6: %bb.6
7: %bb.5
8: %bb.4
9: %bb.3
10: %bb.2
11: %bb.0
12: %bb.9
13: %bb.7
Found roots: %bb.1 %bb.7 
******** Machine Sinking ********
Sink instr %15:gr64 = COPY %67:gr64
	into block bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
; predecessors: %bb.6
  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
  JCC_1 %bb.10, 4, implicit $eflags
  JMP_1 %bb.9
Sink instr %15:gr64 = COPY %67:gr64
	into block bb.11._ZNKSt5ctypeIcE5widenEc.exit:
; predecessors: %bb.9, %bb.10
  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

  %19:gr8 = PHI %17:gr8, %bb.9, %18:gr8, %bb.10
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr32 = MOVSX32rr8 %19:gr8
  $rdi = COPY %15:gr64
  $esi = COPY %73:gr32
  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %74:gr64 = COPY $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %74:gr64
  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %20:gr32 = nsw ADD32rr %0:gr32(tied-def 0), %0:gr32, implicit-def dead $eflags
  %76:gr32 = SUB32ri %20:gr32(tied-def 0), 65537, implicit-def $eflags
  JCC_1 %bb.2, 2, implicit $eflags
  JMP_1 %bb.1
Sinking along critical edge.
********** PEEPHOLE OPTIMIZER **********
********** Function: main
Encountered load fold barrier on CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
Attempting to optimize compare: %31:gr32 = SUB32ri8 %0:gr32(tied-def 0), 3, implicit-def $eflags
Optimize recurrence chain from %6:fr64 = PHI %3:fr64, %bb.3, %9:fr64, %bb.4
	Inst: %9:fr64 = nofpexcept ADDSDrr %6:fr64(tied-def 0), %43:fr64, implicit $mxcsr
Optimize recurrence chain from %7:fr64 = PHI %34:fr64, %bb.3, %8:fr64, %bb.4
	Inst: %8:fr64 = nofpexcept ADDSDrr %7:fr64(tied-def 0), %40:fr64, implicit $mxcsr
Encountered load fold barrier on CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
Encountered load fold barrier on CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
Attempting to optimize compare: %44:gr32 = SUB32rr %10:gr32(tied-def 0), %1:gr32, implicit-def $eflags
Encountered load fold barrier on CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Encountered load fold barrier on MOV64mi32 killed %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
Encountered load fold barrier on CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Encountered load fold barrier on CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Encountered load fold barrier on MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, killed %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
Encountered load fold barrier on MOV64mi32 %56:gr64, 1, killed %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
Encountered load fold barrier on MOV64mi32 %56:gr64, 1, killed %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
Encountered load fold barrier on CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
Encountered load fold barrier on CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on CALL64m killed %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
Encountered load fold barrier on CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Encountered load fold barrier on CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
Attempting to optimize compare: %76:gr32 = SUB32ri %20:gr32(tied-def 0), 65537, implicit-def $eflags
**** Analysing main
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : main **********
********** X86 EFLAGS copy lowering : main **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: main
%37 live-out before critical edge %bb.2 -> %bb.6: %13:fr64 = PHI %37:fr64, %bb.2, %12:fr64, %bb.5
%3 live-out before critical edge %bb.2 -> %bb.6: %14:fr64 = PHI %3:fr64, %bb.2, %9:fr64, %bb.5
Splitting critical edge: %bb.2 -- %bb.12 -- %bb.6
Removing terminator kill: JCC_1 %bb.6, 12, implicit killed $eflags
Updating terminators on %bb.2
Restored terminator kill: JCC_1 %bb.3, 13, implicit killed $eflags
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
	%23:gr32 = OR32ri8 %0:gr32(tied-def 0), 1, implicit-def dead $eflags
		prepend:	%23:gr32 = COPY %0:gr32
		rewrite to:	%23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
	%24:gr32 = SHR32ri %23:gr32(tied-def 0), 31, implicit-def dead $eflags
		prepend:	%24:gr32 = COPY %23:gr32
		rewrite to:	%24:gr32 = SHR32ri %24:gr32(tied-def 0), 31, implicit-def dead $eflags
	%25:gr32 = ADD32rr killed %23:gr32(tied-def 0), killed %24:gr32, implicit-def dead $eflags
2addr: COMMUTING  : %25:gr32 = ADD32rr killed %23:gr32(tied-def 0), killed %24:gr32, implicit-def dead $eflags
2addr: COMMUTED TO: %25:gr32 = ADD32rr killed %24:gr32(tied-def 0), killed %23:gr32, implicit-def dead $eflags
		prepend:	%25:gr32 = COPY %24:gr32
		rewrite to:	%25:gr32 = ADD32rr %25:gr32(tied-def 0), killed %23:gr32, implicit-def dead $eflags
	%1:gr32 = AND32ri8 killed %25:gr32(tied-def 0), -2, implicit-def dead $eflags
		prepend:	%1:gr32 = COPY %25:gr32
		rewrite to:	%1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
	%2:fr64 = nofpexcept DIVSDrr %27:fr64(tied-def 0), killed %26:fr64, implicit $mxcsr
		prepend:	%2:fr64 = COPY %27:fr64
		rewrite to:	%2:fr64 = nofpexcept DIVSDrr %2:fr64(tied-def 0), killed %26:fr64, implicit $mxcsr
	%28:fr64 = nofpexcept ADDSDrr %2:fr64(tied-def 0), %37:fr64, implicit $mxcsr
		prepend:	%28:fr64 = COPY %2:fr64
		rewrite to:	%28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
	%36:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %35:fr64, implicit $mxcsr
2addr: COMMUTING  : %36:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), killed %35:fr64, implicit $mxcsr
2addr: COMMUTED TO: %36:fr64 = nofpexcept MULSDrr killed %35:fr64(tied-def 0), %2:fr64, implicit $mxcsr
		prepend:	%36:fr64 = COPY %35:fr64
		rewrite to:	%36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %2:fr64, implicit $mxcsr
	%38:fr64 = nofpexcept ADDSDrr killed %36:fr64(tied-def 0), %37:fr64, implicit $mxcsr
		prepend:	%38:fr64 = COPY %36:fr64
		rewrite to:	%38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
	%8:fr64 = nofpexcept ADDSDrr killed %7:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
		prepend:	%8:fr64 = COPY %7:fr64
		rewrite to:	%8:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
	%41:fr64 = nofpexcept MULSDrr %2:fr64(tied-def 0), %4:fr64, implicit $mxcsr
		prepend:	%41:fr64 = COPY %2:fr64
		rewrite to:	%41:fr64 = nofpexcept MULSDrr %41:fr64(tied-def 0), %4:fr64, implicit $mxcsr
	%42:fr64 = nofpexcept ADDSDrr killed %41:fr64(tied-def 0), %37:fr64, implicit $mxcsr
		prepend:	%42:fr64 = COPY %41:fr64
		rewrite to:	%42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
	%9:fr64 = nofpexcept ADDSDrr killed %6:fr64(tied-def 0), killed %43:fr64, implicit $mxcsr
		prepend:	%9:fr64 = COPY %6:fr64
		rewrite to:	%9:fr64 = nofpexcept ADDSDrr %9:fr64(tied-def 0), killed %43:fr64, implicit $mxcsr
	%10:gr32 = nuw nsw ADD32ri8 killed %5:gr32(tied-def 0), 2, implicit-def dead $eflags
		prepend:	%10:gr32 = COPY %5:gr32
		rewrite to:	%10:gr32 = nuw nsw ADD32ri8 %10:gr32(tied-def 0), 2, implicit-def dead $eflags
	%11:fr64 = ADDSDrr killed %4:fr64(tied-def 0), %78:fr64, implicit $mxcsr
		prepend:	%11:fr64 = COPY %4:fr64
		rewrite to:	%11:fr64 = ADDSDrr %11:fr64(tied-def 0), %78:fr64, implicit $mxcsr
	%12:fr64 = nofpexcept ADDSDrr killed %8:fr64(tied-def 0), %8:fr64, implicit $mxcsr
		prepend:	%12:fr64 = COPY %8:fr64
		rewrite to:	%12:fr64 = nofpexcept ADDSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
	%45:fr64 = ADDSDrr killed %13:fr64(tied-def 0), %27:fr64, implicit $mxcsr
		prepend:	%45:fr64 = COPY %13:fr64
		rewrite to:	%45:fr64 = ADDSDrr %45:fr64(tied-def 0), %27:fr64, implicit $mxcsr
	%46:fr64 = MULSDrr killed %14:fr64(tied-def 0), %29:fr64, implicit $mxcsr
		prepend:	%46:fr64 = COPY %14:fr64
		rewrite to:	%46:fr64 = MULSDrr %46:fr64(tied-def 0), %29:fr64, implicit $mxcsr
	%47:fr64 = nofpexcept ADDSDrr killed %45:fr64(tied-def 0), killed %46:fr64, implicit $mxcsr
2addr: COMMUTING  : %47:fr64 = nofpexcept ADDSDrr killed %45:fr64(tied-def 0), killed %46:fr64, implicit $mxcsr
2addr: COMMUTED TO: %47:fr64 = nofpexcept ADDSDrr killed %46:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
		prepend:	%47:fr64 = COPY %46:fr64
		rewrite to:	%47:fr64 = nofpexcept ADDSDrr %47:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
	%48:fr64 = nofpexcept MULSDrr killed %2:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
		prepend:	%48:fr64 = COPY %2:fr64
		rewrite to:	%48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
	%49:fr64 = DIVSDrr killed %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr
		prepend:	%49:fr64 = COPY %48:fr64
		rewrite to:	%49:fr64 = DIVSDrr %49:fr64(tied-def 0), %32:fr64, implicit $mxcsr
	%63:gr32 = AND32rm %62:gr32(tied-def 0), %56:gr64, 1, %61:gr64_nosp, 24, $noreg, implicit-def dead $eflags :: (load 4 from %ir.5, !tbaa !17)
2addr:   UNFOLDING: %63:gr32 = AND32rm %62:gr32(tied-def 0), %56:gr64, 1, %61:gr64_nosp, 24, $noreg, implicit-def dead $eflags :: (load 4 from %ir.5, !tbaa !17)
2addr:    NEW LOAD: %90:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
2addr:    NEW INST: %63:gr32 = AND32rr %62:gr32(tied-def 0), killed %90:gr32, implicit-def dead $eflags
2addr: COMMUTING  : %63:gr32 = AND32rr %62:gr32(tied-def 0), killed %90:gr32, implicit-def dead $eflags
2addr: COMMUTED TO: %63:gr32 = AND32rr killed %90:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
		prepend:	%63:gr32 = COPY %90:gr32
		rewrite to:	%63:gr32 = AND32rr %63:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
	%64:gr32 = ADD32ri8_DB killed %63:gr32(tied-def 0), 4, implicit-def dead $eflags
		prepend:	%64:gr32 = COPY %63:gr32
		rewrite to:	%64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
	%20:gr32 = nsw ADD32rr killed %0:gr32(tied-def 0), %0:gr32, implicit-def dead $eflags
		prepend:	%20:gr32 = COPY %0:gr32
		rewrite to:	%20:gr32 = nsw ADD32rr %20:gr32(tied-def 0), %20:gr32, implicit-def dead $eflags
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

16B	  %21:gr32 = MOV32ri 2
32B	  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
64B	  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
80B	  %37:fr64 = FsFLD0SD
96B	  %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
112B	  %50:gr64 = MOV32ri64 @_ZSt4cout
128B	  %51:gr64 = MOV32ri64 @.str
144B	  %52:gr64 = MOV32ri64 2
160B	  %57:gr64 = MOV32ri64 @.str.1
176B	  %58:gr64 = MOV32ri64 4
192B	  %62:gr32 = MOV32ri -261
208B	  %71:gr32 = MOV32ri 10
224B	  %82:gr32 = COPY killed %21:gr32
240B	  JMP_1 %bb.2

256B	bb.1.for.cond.cleanup:
	; predecessors: %bb.11

272B	  %77:gr32 = MOV32r0 implicit-def dead $eflags
288B	  $eax = COPY killed %77:gr32
304B	  RET 0, killed $eax

320B	bb.2.for.body:
	; predecessors: %bb.0, %bb.11
	  successors: %bb.3(0x40000000), %bb.12(0x40000000); %bb.3(50.00%), %bb.12(50.00%)

336B	  %0:gr32 = COPY killed %82:gr32
352B	  %23:gr32 = COPY %0:gr32
368B	  %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
384B	  %24:gr32 = COPY %23:gr32
400B	  %24:gr32 = SHR32ri %24:gr32(tied-def 0), 31, implicit-def dead $eflags
416B	  %25:gr32 = COPY killed %24:gr32
432B	  %25:gr32 = ADD32rr %25:gr32(tied-def 0), killed %23:gr32, implicit-def dead $eflags
448B	  %1:gr32 = COPY killed %25:gr32
464B	  %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
480B	  %26:fr64 = CVTSI2SDrr %1:gr32
496B	  %2:fr64 = COPY %27:fr64
512B	  %2:fr64 = nofpexcept DIVSDrr %2:fr64(tied-def 0), killed %26:fr64, implicit $mxcsr
528B	  %28:fr64 = COPY %2:fr64
544B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $xmm0 = COPY killed %28:fr64
592B	  $xmm1 = COPY %29:fr64
608B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
624B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
640B	  %30:fr64 = COPY killed $xmm0
656B	  %3:fr64 = COPY killed %30:fr64
672B	  CMP32ri8 %0:gr32, 3, implicit-def $eflags
688B	  JCC_1 %bb.3, 13, implicit killed $eflags

704B	bb.12:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

720B	  %87:fr64 = COPY %37:fr64
736B	  %88:fr64 = COPY killed %3:fr64
752B	  JMP_1 %bb.6

768B	bb.3.for.body.i.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

784B	  %34:fr64 = FsFLD0SD
800B	  %33:gr32 = MOV32ri 2
816B	  %83:fr64 = COPY %32:fr64
832B	  %84:gr32 = COPY killed %33:gr32
848B	  %85:fr64 = COPY killed %3:fr64
864B	  %86:fr64 = COPY killed %34:fr64

880B	bb.4.for.body.i:
	; predecessors: %bb.3, %bb.4
	  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

896B	  %7:fr64 = COPY killed %86:fr64
912B	  %6:fr64 = COPY killed %85:fr64
928B	  %5:gr32 = COPY killed %84:gr32
944B	  %4:fr64 = COPY killed %83:fr64
960B	  %35:fr64 = CVTSI2SDrr %5:gr32
976B	  %36:fr64 = COPY killed %35:fr64
992B	  %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %2:fr64, implicit $mxcsr
1008B	  %38:fr64 = COPY killed %36:fr64
1024B	  %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1040B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1056B	  $xmm0 = COPY killed %38:fr64
1072B	  $xmm1 = COPY %29:fr64
1088B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1104B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1120B	  %40:fr64 = COPY killed $xmm0
1136B	  %8:fr64 = COPY killed %7:fr64
1152B	  %8:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
1168B	  %41:fr64 = COPY %2:fr64
1184B	  %41:fr64 = nofpexcept MULSDrr %41:fr64(tied-def 0), %4:fr64, implicit $mxcsr
1200B	  %42:fr64 = COPY killed %41:fr64
1216B	  %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1232B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1248B	  $xmm0 = COPY killed %42:fr64
1264B	  $xmm1 = COPY %29:fr64
1280B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1312B	  %43:fr64 = COPY killed $xmm0
1328B	  %9:fr64 = COPY killed %6:fr64
1344B	  %9:fr64 = nofpexcept ADDSDrr %9:fr64(tied-def 0), killed %43:fr64, implicit $mxcsr
1360B	  %10:gr32 = COPY killed %5:gr32
1376B	  %10:gr32 = nuw nsw ADD32ri8 %10:gr32(tied-def 0), 2, implicit-def dead $eflags
1392B	  %11:fr64 = COPY killed %4:fr64
1408B	  %11:fr64 = ADDSDrr %11:fr64(tied-def 0), %78:fr64, implicit $mxcsr
1424B	  CMP32rr %10:gr32, %1:gr32, implicit-def $eflags
1440B	  %83:fr64 = COPY killed %11:fr64
1456B	  %84:gr32 = COPY killed %10:gr32
1472B	  %85:fr64 = COPY %9:fr64
1488B	  %86:fr64 = COPY %8:fr64
1504B	  JCC_1 %bb.4, 12, implicit killed $eflags
1520B	  JMP_1 %bb.5

1536B	bb.5.for.end.loopexit.i:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1552B	  %12:fr64 = COPY killed %8:fr64
1568B	  %12:fr64 = nofpexcept ADDSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
1584B	  %87:fr64 = COPY killed %12:fr64
1600B	  %88:fr64 = COPY killed %9:fr64

1616B	bb.6._Z7simpsonPFddEddi.exit:
	; predecessors: %bb.5, %bb.12
	  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

1632B	  %14:fr64 = COPY killed %88:fr64
1648B	  %13:fr64 = COPY killed %87:fr64
1664B	  %45:fr64 = COPY killed %13:fr64
1680B	  %45:fr64 = ADDSDrr %45:fr64(tied-def 0), %27:fr64, implicit $mxcsr
1696B	  %46:fr64 = COPY killed %14:fr64
1712B	  %46:fr64 = MULSDrr %46:fr64(tied-def 0), %29:fr64, implicit $mxcsr
1728B	  %47:fr64 = COPY killed %46:fr64
1744B	  %47:fr64 = nofpexcept ADDSDrr %47:fr64(tied-def 0), killed %45:fr64, implicit $mxcsr
1760B	  %48:fr64 = COPY killed %2:fr64
1776B	  %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), killed %47:fr64, implicit $mxcsr
1792B	  %49:fr64 = COPY killed %48:fr64
1808B	  %49:fr64 = DIVSDrr %49:fr64(tied-def 0), %32:fr64, implicit $mxcsr
1824B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1840B	  $rdi = COPY %50:gr64
1856B	  $rsi = COPY %51:gr64
1872B	  $rdx = COPY %52:gr64
1888B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
1904B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1920B	  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
1936B	  %55:gr64 = MOV64rm killed %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
1952B	  MOV64mi32 killed %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
1968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1984B	  $rdi = COPY %50:gr64
2000B	  $esi = COPY %0:gr32
2016B	  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %56:gr64 = COPY killed $rax
2064B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2080B	  $rdi = COPY %56:gr64
2096B	  $rsi = COPY %57:gr64
2112B	  $rdx = COPY %58:gr64
2128B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
2144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
2176B	  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2192B	  %90:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
2208B	  %63:gr32 = COPY killed %90:gr32
2224B	  %63:gr32 = AND32rr %63:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
2240B	  %64:gr32 = COPY killed %63:gr32
2256B	  %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
2272B	  MOV32mr %56:gr64, 1, killed %61:gr64_nosp, 24, $noreg, killed %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
2288B	  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2304B	  MOV64mi32 %56:gr64, 1, killed %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
2320B	  %66:gr64_nosp = MOV64rm killed %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2336B	  MOV64mi32 %56:gr64, 1, killed %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
2352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2368B	  $rdi = COPY killed %56:gr64
2384B	  $xmm0 = COPY killed %49:fr64
2400B	  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  %67:gr64 = COPY killed $rax
2448B	  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
2464B	  %69:gr64_nosp = MOV64rm killed %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
2480B	  %16:gr64 = MOV64rm %67:gr64, 1, killed %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
2496B	  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
2512B	  JCC_1 %bb.8, 5, implicit killed $eflags
2528B	  JMP_1 %bb.7

2544B	bb.7.if.then.i64:
	; predecessors: %bb.6

2560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2576B	  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2608B	bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
	; predecessors: %bb.6
	  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

2624B	  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
2640B	  JCC_1 %bb.10, 4, implicit killed $eflags
2656B	  JMP_1 %bb.9

2672B	bb.9.if.then.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2688B	  %17:gr8 = MOV8rm killed %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
2704B	  %89:gr8 = COPY killed %17:gr8
2720B	  JMP_1 %bb.11

2736B	bb.10.if.end.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2768B	  $rdi = COPY %16:gr64
2784B	  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
2800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2816B	  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
2832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2848B	  $rdi = COPY killed %16:gr64
2864B	  $esi = COPY %71:gr32
2880B	  CALL64m killed %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %72:gr8 = COPY killed $al
2928B	  %18:gr8 = COPY killed %72:gr8
2944B	  %89:gr8 = COPY killed %18:gr8

2960B	bb.11._ZNKSt5ctypeIcE5widenEc.exit:
	; predecessors: %bb.9, %bb.10
	  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

2976B	  %19:gr8 = COPY killed %89:gr8
2992B	  %15:gr64 = COPY killed %67:gr64
3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  %73:gr32 = MOVSX32rr8 killed %19:gr8
3040B	  $rdi = COPY killed %15:gr64
3056B	  $esi = COPY killed %73:gr32
3072B	  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3104B	  %74:gr64 = COPY killed $rax
3120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3136B	  $rdi = COPY killed %74:gr64
3152B	  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  %20:gr32 = COPY killed %0:gr32
3200B	  %20:gr32 = nsw ADD32rr %20:gr32(tied-def 0), %20:gr32, implicit-def dead $eflags
3216B	  CMP32ri %20:gr32, 65537, implicit-def $eflags
3232B	  %82:gr32 = COPY killed %20:gr32
3248B	  JCC_1 %bb.2, 2, implicit killed $eflags
3264B	  JMP_1 %bb.1

# End machine code for function main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%0 [336r,2544B:0)[2608B,3184r:0)  0@336r weight:0.000000e+00
%1 [448r,464r:0)[464r,704B:1)[768B,1536B:1)  0@448r 1@464r weight:0.000000e+00
%2 [496r,512r:0)[512r,1760r:1)  0@496r 1@512r weight:0.000000e+00
%3 [656r,736r:0)[768B,848r:0)  0@656r weight:0.000000e+00
%4 [944r,1392r:0)  0@944r weight:0.000000e+00
%5 [928r,1360r:0)  0@928r weight:0.000000e+00
%6 [912r,1328r:0)  0@912r weight:0.000000e+00
%7 [896r,1136r:0)  0@896r weight:0.000000e+00
%8 [1136r,1152r:0)[1152r,1552r:1)  0@1136r 1@1152r weight:0.000000e+00
%9 [1328r,1344r:0)[1344r,1600r:1)  0@1328r 1@1344r weight:0.000000e+00
%10 [1360r,1376r:0)[1376r,1456r:1)  0@1360r 1@1376r weight:0.000000e+00
%11 [1392r,1408r:0)[1408r,1440r:1)  0@1392r 1@1408r weight:0.000000e+00
%12 [1552r,1568r:0)[1568r,1584r:1)  0@1552r 1@1568r weight:0.000000e+00
%13 [1648r,1664r:0)  0@1648r weight:0.000000e+00
%14 [1632r,1696r:0)  0@1632r weight:0.000000e+00
%15 [2992r,3040r:0)  0@2992r weight:0.000000e+00
%16 [2480r,2544B:0)[2608B,2688r:0)[2736B,2848r:0)  0@2480r weight:0.000000e+00
%17 [2688r,2704r:0)  0@2688r weight:0.000000e+00
%18 [2928r,2944r:0)  0@2928r weight:0.000000e+00
%19 [2976r,3024r:0)  0@2976r weight:0.000000e+00
%20 [3184r,3200r:0)[3200r,3232r:1)  0@3184r 1@3200r weight:0.000000e+00
%21 [16r,224r:0)  0@16r weight:0.000000e+00
%23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:0.000000e+00
%24 [384r,400r:0)[400r,416r:1)  0@384r 1@400r weight:0.000000e+00
%25 [416r,432r:0)[432r,448r:1)  0@416r 1@432r weight:0.000000e+00
%26 [480r,512r:0)  0@480r weight:0.000000e+00
%27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:0.000000e+00
%28 [528r,544r:0)[544r,576r:1)  0@528r 1@544r weight:0.000000e+00
%29 [48r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@48r weight:0.000000e+00
%30 [640r,656r:0)  0@640r weight:0.000000e+00
%32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:0.000000e+00
%33 [800r,832r:0)  0@800r weight:0.000000e+00
%34 [784r,864r:0)  0@784r weight:0.000000e+00
%35 [960r,976r:0)  0@960r weight:0.000000e+00
%36 [976r,992r:0)[992r,1008r:1)  0@976r 1@992r weight:0.000000e+00
%37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:0.000000e+00
%38 [1008r,1024r:0)[1024r,1056r:1)  0@1008r 1@1024r weight:0.000000e+00
%40 [1120r,1152r:0)  0@1120r weight:0.000000e+00
%41 [1168r,1184r:0)[1184r,1200r:1)  0@1168r 1@1184r weight:0.000000e+00
%42 [1200r,1216r:0)[1216r,1248r:1)  0@1200r 1@1216r weight:0.000000e+00
%43 [1312r,1344r:0)  0@1312r weight:0.000000e+00
%45 [1664r,1680r:0)[1680r,1744r:1)  0@1664r 1@1680r weight:0.000000e+00
%46 [1696r,1712r:0)[1712r,1728r:1)  0@1696r 1@1712r weight:0.000000e+00
%47 [1728r,1744r:0)[1744r,1776r:1)  0@1728r 1@1744r weight:0.000000e+00
%48 [1760r,1776r:0)[1776r,1792r:1)  0@1760r 1@1776r weight:0.000000e+00
%49 [1792r,1808r:0)[1808r,2384r:1)  0@1792r 1@1808r weight:0.000000e+00
%50 [112r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@112r weight:0.000000e+00
%51 [128r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@128r weight:0.000000e+00
%52 [144r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@144r weight:0.000000e+00
%54 [1920r,1936r:0)  0@1920r weight:0.000000e+00
%55 [1936r,1952r:0)  0@1936r weight:0.000000e+00
%56 [2048r,2368r:0)  0@2048r weight:0.000000e+00
%57 [160r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@160r weight:0.000000e+00
%58 [176r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@176r weight:0.000000e+00
%60 [2160r,2320r:0)  0@2160r weight:0.000000e+00
%61 [2176r,2272r:0)  0@2176r weight:0.000000e+00
%62 [192r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@192r weight:0.000000e+00
%63 [2208r,2224r:0)[2224r,2240r:1)  0@2208r 1@2224r weight:0.000000e+00
%64 [2240r,2256r:0)[2256r,2272r:1)  0@2240r 1@2256r weight:0.000000e+00
%65 [2288r,2304r:0)  0@2288r weight:0.000000e+00
%66 [2320r,2336r:0)  0@2320r weight:0.000000e+00
%67 [2432r,2544B:0)[2608B,2992r:0)  0@2432r weight:0.000000e+00
%68 [2448r,2464r:0)  0@2448r weight:0.000000e+00
%69 [2464r,2480r:0)  0@2464r weight:0.000000e+00
%70 [2816r,2880r:0)  0@2816r weight:0.000000e+00
%71 [208r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@208r weight:0.000000e+00
%72 [2912r,2928r:0)  0@2912r weight:0.000000e+00
%73 [3024r,3056r:0)  0@3024r weight:0.000000e+00
%74 [3104r,3136r:0)  0@3104r weight:0.000000e+00
%77 [272r,288r:0)  0@272r weight:0.000000e+00
%78 [96r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@96r weight:0.000000e+00
%82 [224r,256B:0)[320B,336r:2)[3232r,3280B:1)  0@224r 1@3232r 2@320B-phi weight:0.000000e+00
%83 [816r,880B:0)[880B,944r:2)[1440r,1536B:1)  0@816r 1@1440r 2@880B-phi weight:0.000000e+00
%84 [832r,880B:0)[880B,928r:2)[1456r,1536B:1)  0@832r 1@1456r 2@880B-phi weight:0.000000e+00
%85 [848r,880B:0)[880B,912r:2)[1472r,1536B:1)  0@848r 1@1472r 2@880B-phi weight:0.000000e+00
%86 [864r,880B:0)[880B,896r:2)[1488r,1536B:1)  0@864r 1@1488r 2@880B-phi weight:0.000000e+00
%87 [720r,768B:0)[1584r,1616B:1)[1616B,1648r:2)  0@720r 1@1584r 2@1616B-phi weight:0.000000e+00
%88 [736r,768B:0)[1600r,1616B:1)[1616B,1632r:2)  0@736r 1@1600r 2@1616B-phi weight:0.000000e+00
%89 [2704r,2736B:0)[2944r,2960B:1)[2960B,2976r:2)  0@2704r 1@2944r 2@2960B-phi weight:0.000000e+00
%90 [2192r,2208r:0)  0@2192r weight:0.000000e+00
RegMasks: 608r 1088r 1280r 1888r 2016r 2128r 2400r 2576r 2784r 2880r 3072r 3152r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

16B	  %21:gr32 = MOV32ri 2
32B	  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
64B	  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
80B	  %37:fr64 = FsFLD0SD
96B	  %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
112B	  %50:gr64 = MOV32ri64 @_ZSt4cout
128B	  %51:gr64 = MOV32ri64 @.str
144B	  %52:gr64 = MOV32ri64 2
160B	  %57:gr64 = MOV32ri64 @.str.1
176B	  %58:gr64 = MOV32ri64 4
192B	  %62:gr32 = MOV32ri -261
208B	  %71:gr32 = MOV32ri 10
224B	  %82:gr32 = COPY %21:gr32
240B	  JMP_1 %bb.2

256B	bb.1.for.cond.cleanup:
	; predecessors: %bb.11

272B	  %77:gr32 = MOV32r0 implicit-def dead $eflags
288B	  $eax = COPY %77:gr32
304B	  RET 0, killed $eax

320B	bb.2.for.body:
	; predecessors: %bb.0, %bb.11
	  successors: %bb.3(0x40000000), %bb.12(0x40000000); %bb.3(50.00%), %bb.12(50.00%)

336B	  %0:gr32 = COPY %82:gr32
352B	  %23:gr32 = COPY %0:gr32
368B	  %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
384B	  %24:gr32 = COPY %23:gr32
400B	  %24:gr32 = SHR32ri %24:gr32(tied-def 0), 31, implicit-def dead $eflags
416B	  %25:gr32 = COPY %24:gr32
432B	  %25:gr32 = ADD32rr %25:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
448B	  %1:gr32 = COPY %25:gr32
464B	  %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
480B	  %26:fr64 = CVTSI2SDrr %1:gr32
496B	  %2:fr64 = COPY %27:fr64
512B	  %2:fr64 = nofpexcept DIVSDrr %2:fr64(tied-def 0), %26:fr64, implicit $mxcsr
528B	  %28:fr64 = COPY %2:fr64
544B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $xmm0 = COPY %28:fr64
592B	  $xmm1 = COPY %29:fr64
608B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
624B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
640B	  %30:fr64 = COPY killed $xmm0
656B	  %3:fr64 = COPY %30:fr64
672B	  CMP32ri8 %0:gr32, 3, implicit-def $eflags
688B	  JCC_1 %bb.3, 13, implicit killed $eflags

704B	bb.12:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

720B	  %87:fr64 = COPY %37:fr64
736B	  %88:fr64 = COPY %3:fr64
752B	  JMP_1 %bb.6

768B	bb.3.for.body.i.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

784B	  %34:fr64 = FsFLD0SD
800B	  %33:gr32 = MOV32ri 2
816B	  %83:fr64 = COPY %32:fr64
832B	  %84:gr32 = COPY %33:gr32
848B	  %85:fr64 = COPY %3:fr64
864B	  %86:fr64 = COPY %34:fr64

880B	bb.4.for.body.i:
	; predecessors: %bb.3, %bb.4
	  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

896B	  %7:fr64 = COPY %86:fr64
912B	  %6:fr64 = COPY %85:fr64
928B	  %5:gr32 = COPY %84:gr32
944B	  %4:fr64 = COPY %83:fr64
960B	  %35:fr64 = CVTSI2SDrr %5:gr32
976B	  %36:fr64 = COPY %35:fr64
992B	  %36:fr64 = nofpexcept MULSDrr %36:fr64(tied-def 0), %2:fr64, implicit $mxcsr
1008B	  %38:fr64 = COPY %36:fr64
1024B	  %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1040B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1056B	  $xmm0 = COPY %38:fr64
1072B	  $xmm1 = COPY %29:fr64
1088B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1104B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1120B	  %40:fr64 = COPY killed $xmm0
1136B	  %8:fr64 = COPY %7:fr64
1152B	  %8:fr64 = nofpexcept ADDSDrr %8:fr64(tied-def 0), %40:fr64, implicit $mxcsr
1168B	  %41:fr64 = COPY %2:fr64
1184B	  %41:fr64 = nofpexcept MULSDrr %41:fr64(tied-def 0), %4:fr64, implicit $mxcsr
1200B	  %42:fr64 = COPY %41:fr64
1216B	  %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1232B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1248B	  $xmm0 = COPY %42:fr64
1264B	  $xmm1 = COPY %29:fr64
1280B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1312B	  %43:fr64 = COPY killed $xmm0
1328B	  %9:fr64 = COPY %6:fr64
1344B	  %9:fr64 = nofpexcept ADDSDrr %9:fr64(tied-def 0), %43:fr64, implicit $mxcsr
1360B	  %10:gr32 = COPY %5:gr32
1376B	  %10:gr32 = nuw nsw ADD32ri8 %10:gr32(tied-def 0), 2, implicit-def dead $eflags
1392B	  %11:fr64 = COPY %4:fr64
1408B	  %11:fr64 = ADDSDrr %11:fr64(tied-def 0), %78:fr64, implicit $mxcsr
1424B	  CMP32rr %10:gr32, %1:gr32, implicit-def $eflags
1440B	  %83:fr64 = COPY %11:fr64
1456B	  %84:gr32 = COPY %10:gr32
1472B	  %85:fr64 = COPY %9:fr64
1488B	  %86:fr64 = COPY %8:fr64
1504B	  JCC_1 %bb.4, 12, implicit killed $eflags
1520B	  JMP_1 %bb.5

1536B	bb.5.for.end.loopexit.i:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1552B	  %12:fr64 = COPY %8:fr64
1568B	  %12:fr64 = nofpexcept ADDSDrr %12:fr64(tied-def 0), %12:fr64, implicit $mxcsr
1584B	  %87:fr64 = COPY %12:fr64
1600B	  %88:fr64 = COPY %9:fr64

1616B	bb.6._Z7simpsonPFddEddi.exit:
	; predecessors: %bb.5, %bb.12
	  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

1632B	  %14:fr64 = COPY %88:fr64
1648B	  %13:fr64 = COPY %87:fr64
1664B	  %45:fr64 = COPY %13:fr64
1680B	  %45:fr64 = ADDSDrr %45:fr64(tied-def 0), %27:fr64, implicit $mxcsr
1696B	  %46:fr64 = COPY %14:fr64
1712B	  %46:fr64 = MULSDrr %46:fr64(tied-def 0), %29:fr64, implicit $mxcsr
1728B	  %47:fr64 = COPY %46:fr64
1744B	  %47:fr64 = nofpexcept ADDSDrr %47:fr64(tied-def 0), %45:fr64, implicit $mxcsr
1760B	  %48:fr64 = COPY %2:fr64
1776B	  %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %47:fr64, implicit $mxcsr
1792B	  %49:fr64 = COPY %48:fr64
1808B	  %49:fr64 = DIVSDrr %49:fr64(tied-def 0), %32:fr64, implicit $mxcsr
1824B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1840B	  $rdi = COPY %50:gr64
1856B	  $rsi = COPY %51:gr64
1872B	  $rdx = COPY %52:gr64
1888B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
1904B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1920B	  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
1936B	  %55:gr64 = MOV64rm %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
1952B	  MOV64mi32 %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
1968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1984B	  $rdi = COPY %50:gr64
2000B	  $esi = COPY %0:gr32
2016B	  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %56:gr64 = COPY killed $rax
2064B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2080B	  $rdi = COPY %56:gr64
2096B	  $rsi = COPY %57:gr64
2112B	  $rdx = COPY %58:gr64
2128B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
2144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
2176B	  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2192B	  %90:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
2208B	  %63:gr32 = COPY %90:gr32
2224B	  %63:gr32 = AND32rr %63:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
2240B	  %64:gr32 = COPY %63:gr32
2256B	  %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
2272B	  MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
2288B	  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2304B	  MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
2320B	  %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2336B	  MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
2352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2368B	  $rdi = COPY %56:gr64
2384B	  $xmm0 = COPY %49:fr64
2400B	  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  %67:gr64 = COPY killed $rax
2448B	  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
2464B	  %69:gr64_nosp = MOV64rm %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
2480B	  %16:gr64 = MOV64rm %67:gr64, 1, %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
2496B	  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
2512B	  JCC_1 %bb.8, 5, implicit killed $eflags
2528B	  JMP_1 %bb.7

2544B	bb.7.if.then.i64:
	; predecessors: %bb.6

2560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2576B	  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2608B	bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
	; predecessors: %bb.6
	  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

2624B	  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
2640B	  JCC_1 %bb.10, 4, implicit killed $eflags
2656B	  JMP_1 %bb.9

2672B	bb.9.if.then.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2688B	  %17:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
2704B	  %89:gr8 = COPY %17:gr8
2720B	  JMP_1 %bb.11

2736B	bb.10.if.end.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2768B	  $rdi = COPY %16:gr64
2784B	  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
2800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2816B	  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
2832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2848B	  $rdi = COPY %16:gr64
2864B	  $esi = COPY %71:gr32
2880B	  CALL64m %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %72:gr8 = COPY killed $al
2928B	  %18:gr8 = COPY %72:gr8
2944B	  %89:gr8 = COPY %18:gr8

2960B	bb.11._ZNKSt5ctypeIcE5widenEc.exit:
	; predecessors: %bb.9, %bb.10
	  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

2976B	  %19:gr8 = COPY %89:gr8
2992B	  %15:gr64 = COPY %67:gr64
3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  %73:gr32 = MOVSX32rr8 %19:gr8
3040B	  $rdi = COPY %15:gr64
3056B	  $esi = COPY %73:gr32
3072B	  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3104B	  %74:gr64 = COPY killed $rax
3120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3136B	  $rdi = COPY %74:gr64
3152B	  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3184B	  %20:gr32 = COPY %0:gr32
3200B	  %20:gr32 = nsw ADD32rr %20:gr32(tied-def 0), %20:gr32, implicit-def dead $eflags
3216B	  CMP32ri %20:gr32, 65537, implicit-def $eflags
3232B	  %82:gr32 = COPY %20:gr32
3248B	  JCC_1 %bb.2, 2, implicit killed $eflags
3264B	  JMP_1 %bb.1

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
for.body.i:
1056B	$xmm0 = COPY %38:fr64
	Considering merging %38 with $xmm0
	Can only merge into reserved registers.
1072B	$xmm1 = COPY %29:fr64
	Considering merging %29 with $xmm1
	Can only merge into reserved registers.
1120B	%40:fr64 = COPY killed $xmm0
	Considering merging %40 with $xmm0
	Can only merge into reserved registers.
1248B	$xmm0 = COPY %42:fr64
	Considering merging %42 with $xmm0
	Can only merge into reserved registers.
1264B	$xmm1 = COPY %29:fr64
	Considering merging %29 with $xmm1
	Can only merge into reserved registers.
1312B	%43:fr64 = COPY killed $xmm0
	Considering merging %43 with $xmm0
	Can only merge into reserved registers.
1472B	%85:fr64 = COPY %9:fr64
	Considering merging to FR64 with %9 in %85
		RHS = %9 [1328r,1344r:0)[1344r,1600r:1)  0@1328r 1@1344r weight:0.000000e+00
		LHS = %85 [848r,880B:0)[880B,912r:2)[1472r,1536B:1)  0@848r 1@1472r 2@880B-phi weight:0.000000e+00
		merge %85:1@1472r into %9:1@1344r --> @1344r
		erased:	1472r	%85:fr64 = COPY %9:fr64
		updated: 1328B	%85:fr64 = COPY %6:fr64
		updated: 1344B	%85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %43:fr64, implicit $mxcsr
		updated: 1600B	%88:fr64 = COPY %85:fr64
	Success: %9 -> %85
	Result = %85 [848r,880B:0)[880B,912r:2)[1328r,1344r:3)[1344r,1600r:1)  0@848r 1@1344r 2@880B-phi 3@1328r weight:0.000000e+00
1488B	%86:fr64 = COPY %8:fr64
	Considering merging to FR64 with %8 in %86
		RHS = %8 [1136r,1152r:0)[1152r,1552r:1)  0@1136r 1@1152r weight:0.000000e+00
		LHS = %86 [864r,880B:0)[880B,896r:2)[1488r,1536B:1)  0@864r 1@1488r 2@880B-phi weight:0.000000e+00
		merge %86:1@1488r into %8:1@1152r --> @1152r
		erased:	1488r	%86:fr64 = COPY %8:fr64
		updated: 1136B	%86:fr64 = COPY %7:fr64
		updated: 1152B	%86:fr64 = nofpexcept ADDSDrr %86:fr64(tied-def 0), %40:fr64, implicit $mxcsr
		updated: 1552B	%12:fr64 = COPY %86:fr64
	Success: %8 -> %86
	Result = %86 [864r,880B:0)[880B,896r:2)[1136r,1152r:3)[1152r,1552r:1)  0@864r 1@1152r 2@880B-phi 3@1136r weight:0.000000e+00
896B	%7:fr64 = COPY %86:fr64
	Considering merging to FR64 with %7 in %86
		RHS = %7 [896r,1136r:0)  0@896r weight:0.000000e+00
		LHS = %86 [864r,880B:0)[880B,896r:2)[1136r,1152r:3)[1152r,1552r:1)  0@864r 1@1152r 2@880B-phi 3@1136r weight:0.000000e+00
		merge %7:0@896r into %86:2@880B --> @880B
		merge %86:3@1136r into %7:0@896r --> @880B
		erased:	1136r	%86:fr64 = COPY %7:fr64
		erased:	896r	%7:fr64 = COPY %86:fr64
	Success: %7 -> %86
	Result = %86 [864r,880B:0)[880B,1152r:2)[1152r,1552r:1)  0@864r 1@1152r 2@880B-phi weight:0.000000e+00
912B	%6:fr64 = COPY %85:fr64
	Considering merging to FR64 with %6 in %85
		RHS = %6 [912r,1328r:0)  0@912r weight:0.000000e+00
		LHS = %85 [848r,880B:0)[880B,912r:2)[1328r,1344r:3)[1344r,1600r:1)  0@848r 1@1344r 2@880B-phi 3@1328r weight:0.000000e+00
		merge %6:0@912r into %85:2@880B --> @880B
		merge %85:3@1328r into %6:0@912r --> @880B
		erased:	1328r	%85:fr64 = COPY %6:fr64
		erased:	912r	%6:fr64 = COPY %85:fr64
	Success: %6 -> %85
	Result = %85 [848r,880B:0)[880B,1344r:2)[1344r,1600r:1)  0@848r 1@1344r 2@880B-phi weight:0.000000e+00
928B	%5:gr32 = COPY %84:gr32
	Considering merging to GR32 with %5 in %84
		RHS = %5 [928r,1360r:0)  0@928r weight:0.000000e+00
		LHS = %84 [832r,880B:0)[880B,928r:2)[1456r,1536B:1)  0@832r 1@1456r 2@880B-phi weight:0.000000e+00
		merge %5:0@928r into %84:2@880B --> @880B
		erased:	928r	%5:gr32 = COPY %84:gr32
		updated: 960B	%35:fr64 = CVTSI2SDrr %84:gr32
		updated: 1360B	%10:gr32 = COPY %84:gr32
	Success: %5 -> %84
	Result = %84 [832r,880B:0)[880B,1360r:2)[1456r,1536B:1)  0@832r 1@1456r 2@880B-phi weight:0.000000e+00
944B	%4:fr64 = COPY %83:fr64
	Considering merging to FR64 with %4 in %83
		RHS = %4 [944r,1392r:0)  0@944r weight:0.000000e+00
		LHS = %83 [816r,880B:0)[880B,944r:2)[1440r,1536B:1)  0@816r 1@1440r 2@880B-phi weight:0.000000e+00
		merge %4:0@944r into %83:2@880B --> @880B
		erased:	944r	%4:fr64 = COPY %83:fr64
		updated: 1184B	%41:fr64 = nofpexcept MULSDrr %41:fr64(tied-def 0), %83:fr64, implicit $mxcsr
		updated: 1392B	%11:fr64 = COPY %83:fr64
	Success: %4 -> %83
	Result = %83 [816r,880B:0)[880B,1392r:2)[1440r,1536B:1)  0@816r 1@1440r 2@880B-phi weight:0.000000e+00
976B	%36:fr64 = COPY %35:fr64
	Considering merging to FR64 with %35 in %36
		RHS = %35 [960r,976r:0)  0@960r weight:0.000000e+00
		LHS = %36 [976r,992r:0)[992r,1008r:1)  0@976r 1@992r weight:0.000000e+00
		merge %36:0@976r into %35:0@960r --> @960r
		erased:	976r	%36:fr64 = COPY %35:fr64
		updated: 960B	%36:fr64 = CVTSI2SDrr %84:gr32
	Success: %35 -> %36
	Result = %36 [960r,992r:0)[992r,1008r:1)  0@960r 1@992r weight:0.000000e+00
1008B	%38:fr64 = COPY %36:fr64
	Considering merging to FR64 with %36 in %38
		RHS = %36 [960r,992r:0)[992r,1008r:1)  0@960r 1@992r weight:0.000000e+00
		LHS = %38 [1008r,1024r:0)[1024r,1056r:1)  0@1008r 1@1024r weight:0.000000e+00
		merge %38:0@1008r into %36:1@992r --> @992r
		erased:	1008r	%38:fr64 = COPY %36:fr64
		updated: 960B	%38:fr64 = CVTSI2SDrr %84:gr32
		updated: 992B	%38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %2:fr64, implicit $mxcsr
	Success: %36 -> %38
	Result = %38 [960r,992r:2)[992r,1024r:0)[1024r,1056r:1)  0@992r 1@1024r 2@960r weight:0.000000e+00
1168B	%41:fr64 = COPY %2:fr64
	Considering merging to FR64 with %2 in %41
		RHS = %2 [496r,512r:0)[512r,1760r:1)  0@496r 1@512r weight:0.000000e+00
		LHS = %41 [1168r,1184r:0)[1184r,1200r:1)  0@1168r 1@1184r weight:0.000000e+00
		merge %41:0@1168r into %2:1@512r --> @512r
		interference at %41:1@1184r
	Interference!
1200B	%42:fr64 = COPY %41:fr64
	Considering merging to FR64 with %41 in %42
		RHS = %41 [1168r,1184r:0)[1184r,1200r:1)  0@1168r 1@1184r weight:0.000000e+00
		LHS = %42 [1200r,1216r:0)[1216r,1248r:1)  0@1200r 1@1216r weight:0.000000e+00
		merge %42:0@1200r into %41:1@1184r --> @1184r
		erased:	1200r	%42:fr64 = COPY %41:fr64
		updated: 1168B	%42:fr64 = COPY %2:fr64
		updated: 1184B	%42:fr64 = nofpexcept MULSDrr %42:fr64(tied-def 0), %83:fr64, implicit $mxcsr
	Success: %41 -> %42
	Result = %42 [1168r,1184r:2)[1184r,1216r:0)[1216r,1248r:1)  0@1184r 1@1216r 2@1168r weight:0.000000e+00
1360B	%10:gr32 = COPY %84:gr32
	Considering merging to GR32 with %10 in %84
		RHS = %10 [1360r,1376r:0)[1376r,1456r:1)  0@1360r 1@1376r weight:0.000000e+00
		LHS = %84 [832r,880B:0)[880B,1360r:2)[1456r,1536B:1)  0@832r 1@1456r 2@880B-phi weight:0.000000e+00
		merge %84:1@1456r into %10:1@1376r --> @1376r
		merge %10:0@1360r into %84:2@880B --> @880B
		erased:	1456r	%84:gr32 = COPY %10:gr32
		erased:	1360r	%10:gr32 = COPY %84:gr32
		updated: 1376B	%84:gr32 = nuw nsw ADD32ri8 %84:gr32(tied-def 0), 2, implicit-def dead $eflags
		updated: 1424B	CMP32rr %84:gr32, %1:gr32, implicit-def $eflags
	Success: %10 -> %84
	Result = %84 [832r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@832r 1@1376r 2@880B-phi weight:0.000000e+00
1392B	%11:fr64 = COPY %83:fr64
	Considering merging to FR64 with %11 in %83
		RHS = %11 [1392r,1408r:0)[1408r,1440r:1)  0@1392r 1@1408r weight:0.000000e+00
		LHS = %83 [816r,880B:0)[880B,1392r:2)[1440r,1536B:1)  0@816r 1@1440r 2@880B-phi weight:0.000000e+00
		merge %83:1@1440r into %11:1@1408r --> @1408r
		merge %11:0@1392r into %83:2@880B --> @880B
		erased:	1440r	%83:fr64 = COPY %11:fr64
		erased:	1392r	%11:fr64 = COPY %83:fr64
		updated: 1408B	%83:fr64 = ADDSDrr %83:fr64(tied-def 0), %78:fr64, implicit $mxcsr
	Success: %11 -> %83
	Result = %83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:0.000000e+00
for.body:
336B	%0:gr32 = COPY %82:gr32
	Considering merging to GR32 with %0 in %82
		RHS = %0 [336r,2544B:0)[2608B,3184r:0)  0@336r weight:0.000000e+00
		LHS = %82 [224r,256B:0)[320B,336r:2)[3232r,3280B:1)  0@224r 1@3232r 2@320B-phi weight:0.000000e+00
		merge %0:0@336r into %82:2@320B --> @320B
		erased:	336r	%0:gr32 = COPY %82:gr32
		updated: 672B	CMP32ri8 %82:gr32, 3, implicit-def $eflags
		updated: 2000B	$esi = COPY %82:gr32
		updated: 352B	%23:gr32 = COPY %82:gr32
		updated: 3184B	%20:gr32 = COPY %82:gr32
	Success: %0 -> %82
	Result = %82 [224r,256B:0)[320B,2544B:2)[2608B,3184r:2)[3232r,3280B:1)  0@224r 1@3232r 2@320B-phi weight:0.000000e+00
496B	%2:fr64 = COPY %27:fr64
	Considering merging to FR64 with %2 in %27
		RHS = %2 [496r,512r:0)[512r,1760r:1)  0@496r 1@512r weight:0.000000e+00
		LHS = %27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:0.000000e+00
		merge %2:0@496r into %27:0@32r --> @32r
		interference at %2:1@512r
	Interference!
576B	$xmm0 = COPY %28:fr64
	Considering merging %28 with $xmm0
	Can only merge into reserved registers.
592B	$xmm1 = COPY %29:fr64
	Considering merging %29 with $xmm1
	Can only merge into reserved registers.
640B	%30:fr64 = COPY killed $xmm0
	Considering merging %30 with $xmm0
	Can only merge into reserved registers.
_Z7simpsonPFddEddi.exit:
1840B	$rdi = COPY %50:gr64
	Considering merging %50 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 @_ZSt4cout
Shrink: %50 [112r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@112r weight:0.000000e+00
 live-in at 1616B
 live-in at 704B
 live-in at 320B
 live-in at 2960B
 live-in at 2736B
 live-in at 2608B
 live-in at 2672B
 live-in at 1536B
 live-in at 880B
 live-in at 768B
Shrunk: %50 [112r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@112r weight:0.000000e+00
1856B	$rsi = COPY %51:gr64
	Considering merging %51 with $rsi
	Can only merge into reserved registers.
Remat: $rsi = MOV32ri64 @.str
Shrink: %51 [128r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@128r weight:0.000000e+00
All defs dead: 128r	dead %51:gr64 = MOV32ri64 @.str
Shrunk: %51 [128r,128d:0)  0@128r weight:0.000000e+00
Deleting dead def 128r	dead %51:gr64 = MOV32ri64 @.str
1872B	$rdx = COPY %52:gr64
	Considering merging %52 with $rdx
	Can only merge into reserved registers.
Remat: $rdx = MOV32ri64 2
Shrink: %52 [144r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@144r weight:0.000000e+00
All defs dead: 144r	dead %52:gr64 = MOV32ri64 2
Shrunk: %52 [144r,144d:0)  0@144r weight:0.000000e+00
Deleting dead def 144r	dead %52:gr64 = MOV32ri64 2
1984B	$rdi = COPY %50:gr64
	Considering merging %50 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 @_ZSt4cout
Shrink: %50 [112r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@112r weight:0.000000e+00
All defs dead: 112r	dead %50:gr64 = MOV32ri64 @_ZSt4cout
Shrunk: %50 [112r,112d:0)  0@112r weight:0.000000e+00
Deleting dead def 112r	dead %50:gr64 = MOV32ri64 @_ZSt4cout
2000B	$esi = COPY %82:gr32
	Considering merging %82 with $esi
	Can only merge into reserved registers.
2048B	%56:gr64 = COPY killed $rax
	Considering merging %56 with $rax
	Can only merge into reserved registers.
2080B	$rdi = COPY %56:gr64
	Considering merging %56 with $rdi
	Can only merge into reserved registers.
2096B	$rsi = COPY %57:gr64
	Considering merging %57 with $rsi
	Can only merge into reserved registers.
Remat: $rsi = MOV32ri64 @.str.1
Shrink: %57 [160r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@160r weight:0.000000e+00
All defs dead: 160r	dead %57:gr64 = MOV32ri64 @.str.1
Shrunk: %57 [160r,160d:0)  0@160r weight:0.000000e+00
Deleting dead def 160r	dead %57:gr64 = MOV32ri64 @.str.1
2112B	$rdx = COPY %58:gr64
	Considering merging %58 with $rdx
	Can only merge into reserved registers.
Remat: $rdx = MOV32ri64 4
Shrink: %58 [176r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@176r weight:0.000000e+00
All defs dead: 176r	dead %58:gr64 = MOV32ri64 4
Shrunk: %58 [176r,176d:0)  0@176r weight:0.000000e+00
Deleting dead def 176r	dead %58:gr64 = MOV32ri64 4
2368B	$rdi = COPY %56:gr64
	Considering merging %56 with $rdi
	Can only merge into reserved registers.
2384B	$xmm0 = COPY %49:fr64
	Considering merging %49 with $xmm0
	Can only merge into reserved registers.
2432B	%67:gr64 = COPY killed $rax
	Considering merging %67 with $rax
	Can only merge into reserved registers.
_ZNKSt5ctypeIcE5widenEc.exit:
3040B	$rdi = COPY %15:gr64
	Considering merging %15 with $rdi
	Can only merge into reserved registers.
3056B	$esi = COPY %73:gr32
	Considering merging %73 with $esi
	Can only merge into reserved registers.
3104B	%74:gr64 = COPY killed $rax
	Considering merging %74 with $rax
	Can only merge into reserved registers.
3136B	$rdi = COPY %74:gr64
	Considering merging %74 with $rdi
	Can only merge into reserved registers.
_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
for.body.i.preheader:
816B	%83:fr64 = COPY %32:fr64
	Considering merging to FR64 with %32 in %83
		RHS = %32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:0.000000e+00
		LHS = %83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:0.000000e+00
		merge %83:0@816r into %32:0@64r --> @64r
		interference at %83:1@1408r
	Interference!
848B	%85:fr64 = COPY %3:fr64
	Considering merging to FR64 with %3 in %85
		RHS = %3 [656r,736r:0)[768B,848r:0)  0@656r weight:0.000000e+00
		LHS = %85 [848r,880B:0)[880B,1344r:2)[1344r,1600r:1)  0@848r 1@1344r 2@880B-phi weight:0.000000e+00
		merge %85:0@848r into %3:0@656r --> @656r
		erased:	848r	%85:fr64 = COPY %3:fr64
		updated: 656B	%85:fr64 = COPY %30:fr64
		updated: 736B	%88:fr64 = COPY %85:fr64
	Success: %3 -> %85
	Result = %85 [656r,736r:0)[768B,880B:0)[880B,1344r:2)[1344r,1600r:1)  0@656r 1@1344r 2@880B-phi weight:0.000000e+00
for.end.loopexit.i:
1600B	%88:fr64 = COPY %85:fr64
	Considering merging to FR64 with %88 in %85
		RHS = %88 [736r,768B:0)[1600r,1616B:1)[1616B,1632r:2)  0@736r 1@1600r 2@1616B-phi weight:0.000000e+00
		LHS = %85 [656r,736r:0)[768B,880B:0)[880B,1344r:2)[1344r,1600r:1)  0@656r 1@1344r 2@880B-phi weight:0.000000e+00
		merge %88:0@736r into %85:0@656r --> @656r
		merge %88:1@1600r into %85:1@1344r --> @1344r
		erased:	736r	%88:fr64 = COPY %85:fr64
		erased:	1600r	%88:fr64 = COPY %85:fr64
		updated: 1632B	%14:fr64 = COPY %85:fr64
	Success: %88 -> %85
	Result = %85 [656r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1632r:3)  0@656r 1@1344r 2@880B-phi 3@1616B-phi weight:0.000000e+00
if.then.i:
if.end.i:
2768B	$rdi = COPY %16:gr64
	Considering merging %16 with $rdi
	Can only merge into reserved registers.
2848B	$rdi = COPY %16:gr64
	Considering merging %16 with $rdi
	Can only merge into reserved registers.
2864B	$esi = COPY %71:gr32
	Considering merging %71 with $esi
	Can only merge into reserved registers.
Remat: $esi = MOV32ri 10
Shrink: %71 [208r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@208r weight:0.000000e+00
All defs dead: 208r	dead %71:gr32 = MOV32ri 10
Shrunk: %71 [208r,208d:0)  0@208r weight:0.000000e+00
Deleting dead def 208r	dead %71:gr32 = MOV32ri 10
2912B	%72:gr8 = COPY killed $al
	Considering merging %72 with $al
	Can only merge into reserved registers.
:
720B	%87:fr64 = COPY %37:fr64
	Considering merging to FR64 with %37 in %87
		RHS = %37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:0.000000e+00
		LHS = %87 [720r,768B:0)[1584r,1616B:1)[1616B,1648r:2)  0@720r 1@1584r 2@1616B-phi weight:0.000000e+00
		merge %87:0@720r into %37:0@80r --> @80r
		interference at %87:1@1584r
		updated: 720B	%87:fr64 = FsFLD0SD
		updated: 1584B	%87:fr64 = COPY %12:fr64
		updated: 1648B	%13:fr64 = COPY %87:fr64
Remat: %87:fr64 = FsFLD0SD
Shrink: %37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:0.000000e+00
 live-in at 880B
 live-in at 768B
 live-in at 320B
 live-in at 2960B
 live-in at 2736B
 live-in at 2608B
 live-in at 1616B
 live-in at 704B
 live-in at 1536B
 live-in at 2672B
Shrunk: %37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:0.000000e+00
352B	%23:gr32 = COPY %82:gr32
	Considering merging to GR32 with %23 in %82
		RHS = %23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:0.000000e+00
		LHS = %82 [224r,256B:0)[320B,2544B:2)[2608B,3184r:2)[3232r,3280B:1)  0@224r 1@3232r 2@320B-phi weight:0.000000e+00
		merge %23:0@352r into %82:2@320B --> @320B
		interference at %23:1@368r
	Interference!
384B	%24:gr32 = COPY %23:gr32
	Considering merging to GR32 with %23 in %24
		RHS = %23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:0.000000e+00
		LHS = %24 [384r,400r:0)[400r,416r:1)  0@384r 1@400r weight:0.000000e+00
		merge %24:0@384r into %23:1@368r --> @368r
		interference at %24:1@400r
	Interference!
416B	%25:gr32 = COPY %24:gr32
	Considering merging to GR32 with %24 in %25
		RHS = %24 [384r,400r:0)[400r,416r:1)  0@384r 1@400r weight:0.000000e+00
		LHS = %25 [416r,432r:0)[432r,448r:1)  0@416r 1@432r weight:0.000000e+00
		merge %25:0@416r into %24:1@400r --> @400r
		erased:	416r	%25:gr32 = COPY %24:gr32
		updated: 384B	%25:gr32 = COPY %23:gr32
		updated: 400B	%25:gr32 = SHR32ri %25:gr32(tied-def 0), 31, implicit-def dead $eflags
	Success: %24 -> %25
	Result = %25 [384r,400r:2)[400r,432r:0)[432r,448r:1)  0@400r 1@432r 2@384r weight:0.000000e+00
448B	%1:gr32 = COPY %25:gr32
	Considering merging to GR32 with %25 in %1
		RHS = %25 [384r,400r:2)[400r,432r:0)[432r,448r:1)  0@400r 1@432r 2@384r weight:0.000000e+00
		LHS = %1 [448r,464r:0)[464r,704B:1)[768B,1536B:1)  0@448r 1@464r weight:0.000000e+00
		merge %1:0@448r into %25:1@432r --> @432r
		erased:	448r	%1:gr32 = COPY %25:gr32
		updated: 400B	%1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
		updated: 384B	%1:gr32 = COPY %23:gr32
		updated: 432B	%1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
	Success: %25 -> %1
	Result = %1 [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r weight:0.000000e+00
528B	%28:fr64 = COPY %2:fr64
	Considering merging to FR64 with %2 in %28
		RHS = %2 [496r,512r:0)[512r,1760r:1)  0@496r 1@512r weight:0.000000e+00
		LHS = %28 [528r,544r:0)[544r,576r:1)  0@528r 1@544r weight:0.000000e+00
		merge %28:0@528r into %2:1@512r --> @512r
		interference at %28:1@544r
	Interference!
656B	%85:fr64 = COPY %30:fr64
	Considering merging to FR64 with %30 in %85
		RHS = %30 [640r,656r:0)  0@640r weight:0.000000e+00
		LHS = %85 [656r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1632r:3)  0@656r 1@1344r 2@880B-phi 3@1616B-phi weight:0.000000e+00
		merge %85:0@656r into %30:0@640r --> @640r
		erased:	656r	%85:fr64 = COPY %30:fr64
		updated: 640B	%85:fr64 = COPY killed $xmm0
	Success: %30 -> %85
	Result = %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1632r:3)  0@640r 1@1344r 2@880B-phi 3@1616B-phi weight:0.000000e+00
1632B	%14:fr64 = COPY %85:fr64
	Considering merging to FR64 with %14 in %85
		RHS = %14 [1632r,1696r:0)  0@1632r weight:0.000000e+00
		LHS = %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1632r:3)  0@640r 1@1344r 2@880B-phi 3@1616B-phi weight:0.000000e+00
		merge %14:0@1632r into %85:3@1616B --> @1616B
		erased:	1632r	%14:fr64 = COPY %85:fr64
		updated: 1696B	%46:fr64 = COPY %85:fr64
	Success: %14 -> %85
	Result = %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1696r:3)  0@640r 1@1344r 2@880B-phi 3@1616B-phi weight:0.000000e+00
1648B	%13:fr64 = COPY %87:fr64
	Considering merging to FR64 with %13 in %87
		RHS = %13 [1648r,1664r:0)  0@1648r weight:0.000000e+00
		LHS = %87 [720r,768B:0)[1584r,1616B:1)[1616B,1648r:2)  0@720r 1@1584r 2@1616B-phi weight:0.000000e+00
		merge %13:0@1648r into %87:2@1616B --> @1616B
		erased:	1648r	%13:fr64 = COPY %87:fr64
		updated: 1664B	%45:fr64 = COPY %87:fr64
	Success: %13 -> %87
	Result = %87 [720r,768B:0)[1584r,1616B:1)[1616B,1664r:2)  0@720r 1@1584r 2@1616B-phi weight:0.000000e+00
1664B	%45:fr64 = COPY %87:fr64
	Considering merging to FR64 with %45 in %87
		RHS = %45 [1664r,1680r:0)[1680r,1744r:1)  0@1664r 1@1680r weight:0.000000e+00
		LHS = %87 [720r,768B:0)[1584r,1616B:1)[1616B,1664r:2)  0@720r 1@1584r 2@1616B-phi weight:0.000000e+00
		merge %45:0@1664r into %87:2@1616B --> @1616B
		erased:	1664r	%45:fr64 = COPY %87:fr64
		updated: 1680B	%87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
		updated: 1744B	%47:fr64 = nofpexcept ADDSDrr %47:fr64(tied-def 0), %87:fr64, implicit $mxcsr
	Success: %45 -> %87
	Result = %87 [720r,768B:0)[1584r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1584r 2@1616B-phi 3@1680r weight:0.000000e+00
1696B	%46:fr64 = COPY %85:fr64
	Considering merging to FR64 with %46 in %85
		RHS = %46 [1696r,1712r:0)[1712r,1728r:1)  0@1696r 1@1712r weight:0.000000e+00
		LHS = %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1696r:3)  0@640r 1@1344r 2@880B-phi 3@1616B-phi weight:0.000000e+00
		merge %46:0@1696r into %85:3@1616B --> @1616B
		erased:	1696r	%46:fr64 = COPY %85:fr64
		updated: 1712B	%85:fr64 = MULSDrr %85:fr64(tied-def 0), %29:fr64, implicit $mxcsr
		updated: 1728B	%47:fr64 = COPY %85:fr64
	Success: %46 -> %85
	Result = %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1728r:4)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r weight:0.000000e+00
1728B	%47:fr64 = COPY %85:fr64
	Considering merging to FR64 with %47 in %85
		RHS = %47 [1728r,1744r:0)[1744r,1776r:1)  0@1728r 1@1744r weight:0.000000e+00
		LHS = %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1728r:4)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r weight:0.000000e+00
		merge %47:0@1728r into %85:4@1712r --> @1712r
		erased:	1728r	%47:fr64 = COPY %85:fr64
		updated: 1744B	%85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
		updated: 1776B	%48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %85:fr64, implicit $mxcsr
	Success: %47 -> %85
	Result = %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1744r:4)[1744r,1776r:5)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r 5@1744r weight:0.000000e+00
1760B	%48:fr64 = COPY %2:fr64
	Considering merging to FR64 with %2 in %48
		RHS = %2 [496r,512r:0)[512r,1760r:1)  0@496r 1@512r weight:0.000000e+00
		LHS = %48 [1760r,1776r:0)[1776r,1792r:1)  0@1760r 1@1776r weight:0.000000e+00
		merge %48:0@1760r into %2:1@512r --> @512r
		erased:	1760r	%48:fr64 = COPY %2:fr64
		updated: 496B	%48:fr64 = COPY %27:fr64
		updated: 512B	%48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
		updated: 528B	%28:fr64 = COPY %48:fr64
		updated: 992B	%38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %48:fr64, implicit $mxcsr
		updated: 1168B	%42:fr64 = COPY %48:fr64
	Success: %2 -> %48
	Result = %48 [496r,512r:2)[512r,1776r:0)[1776r,1792r:1)  0@512r 1@1776r 2@496r weight:0.000000e+00
1792B	%49:fr64 = COPY %48:fr64
	Considering merging to FR64 with %49 in %48
		RHS = %49 [1792r,1808r:0)[1808r,2384r:1)  0@1792r 1@1808r weight:0.000000e+00
		LHS = %48 [496r,512r:2)[512r,1776r:0)[1776r,1792r:1)  0@512r 1@1776r 2@496r weight:0.000000e+00
		merge %49:0@1792r into %48:1@1776r --> @1776r
		erased:	1792r	%49:fr64 = COPY %48:fr64
		updated: 1808B	%48:fr64 = DIVSDrr %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr
		updated: 2384B	$xmm0 = COPY %48:fr64
	Success: %49 -> %48
	Result = %48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:0.000000e+00
2208B	%63:gr32 = COPY %90:gr32
	Considering merging to GR32 with %90 in %63
		RHS = %90 [2192r,2208r:0)  0@2192r weight:0.000000e+00
		LHS = %63 [2208r,2224r:0)[2224r,2240r:1)  0@2208r 1@2224r weight:0.000000e+00
		merge %63:0@2208r into %90:0@2192r --> @2192r
		erased:	2208r	%63:gr32 = COPY %90:gr32
		updated: 2192B	%63:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
	Success: %90 -> %63
	Result = %63 [2192r,2224r:0)[2224r,2240r:1)  0@2192r 1@2224r weight:0.000000e+00
2240B	%64:gr32 = COPY %63:gr32
	Considering merging to GR32 with %63 in %64
		RHS = %63 [2192r,2224r:0)[2224r,2240r:1)  0@2192r 1@2224r weight:0.000000e+00
		LHS = %64 [2240r,2256r:0)[2256r,2272r:1)  0@2240r 1@2256r weight:0.000000e+00
		merge %64:0@2240r into %63:1@2224r --> @2224r
		erased:	2240r	%64:gr32 = COPY %63:gr32
		updated: 2192B	%64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
		updated: 2224B	%64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
	Success: %63 -> %64
	Result = %64 [2192r,2224r:2)[2224r,2256r:0)[2256r,2272r:1)  0@2224r 1@2256r 2@2192r weight:0.000000e+00
2976B	%19:gr8 = COPY %89:gr8
	Considering merging to GR8 with %19 in %89
		RHS = %19 [2976r,3024r:0)  0@2976r weight:0.000000e+00
		LHS = %89 [2704r,2736B:0)[2944r,2960B:1)[2960B,2976r:2)  0@2704r 1@2944r 2@2960B-phi weight:0.000000e+00
		merge %19:0@2976r into %89:2@2960B --> @2960B
		erased:	2976r	%19:gr8 = COPY %89:gr8
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
		updated: 3024B	%73:gr32 = MOVSX32rr8 %89:gr8
	Success: %19 -> %89
	Result = %89 [2704r,2736B:0)[2944r,2960B:1)[2960B,3024r:2)  0@2704r 1@2944r 2@2960B-phi weight:0.000000e+00
2992B	%15:gr64 = COPY %67:gr64
	Considering merging to GR64 with %15 in %67
		RHS = %15 [2992r,3040r:0)  0@2992r weight:0.000000e+00
		LHS = %67 [2432r,2544B:0)[2608B,2992r:0)  0@2432r weight:0.000000e+00
		merge %15:0@2992r into %67:0@2432r --> @2432r
		erased:	2992r	%15:gr64 = COPY %67:gr64
		updated: 3040B	$rdi = COPY %67:gr64
	Success: %15 -> %67
	Result = %67 [2432r,2544B:0)[2608B,3040r:0)  0@2432r weight:0.000000e+00
3184B	%20:gr32 = COPY %82:gr32
	Considering merging to GR32 with %20 in %82
		RHS = %20 [3184r,3200r:0)[3200r,3232r:1)  0@3184r 1@3200r weight:0.000000e+00
		LHS = %82 [224r,256B:0)[320B,2544B:2)[2608B,3184r:2)[3232r,3280B:1)  0@224r 1@3232r 2@320B-phi weight:0.000000e+00
		merge %82:1@3232r into %20:1@3200r --> @3200r
		merge %20:0@3184r into %82:2@320B --> @320B
		erased:	3232r	%82:gr32 = COPY %20:gr32
		erased:	3184r	%20:gr32 = COPY %82:gr32
		updated: 3200B	%82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
		updated: 3216B	CMP32ri %82:gr32, 65537, implicit-def $eflags
	Success: %20 -> %82
	Result = %82 [224r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@224r 1@3200r 2@320B-phi weight:0.000000e+00
832B	%84:gr32 = COPY %33:gr32
	Considering merging to GR32 with %33 in %84
		RHS = %33 [800r,832r:0)  0@800r weight:0.000000e+00
		LHS = %84 [832r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@832r 1@1376r 2@880B-phi weight:0.000000e+00
		merge %84:0@832r into %33:0@800r --> @800r
		erased:	832r	%84:gr32 = COPY %33:gr32
		updated: 800B	%84:gr32 = MOV32ri 2
	Success: %33 -> %84
	Result = %84 [800r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@800r 1@1376r 2@880B-phi weight:0.000000e+00
864B	%86:fr64 = COPY %34:fr64
	Considering merging to FR64 with %34 in %86
		RHS = %34 [784r,864r:0)  0@784r weight:0.000000e+00
		LHS = %86 [864r,880B:0)[880B,1152r:2)[1152r,1552r:1)  0@864r 1@1152r 2@880B-phi weight:0.000000e+00
		merge %86:0@864r into %34:0@784r --> @784r
		erased:	864r	%86:fr64 = COPY %34:fr64
		updated: 784B	%86:fr64 = FsFLD0SD
	Success: %34 -> %86
	Result = %86 [784r,880B:0)[880B,1152r:2)[1152r,1552r:1)  0@784r 1@1152r 2@880B-phi weight:0.000000e+00
1552B	%12:fr64 = COPY %86:fr64
	Considering merging to FR64 with %12 in %86
		RHS = %12 [1552r,1568r:0)[1568r,1584r:1)  0@1552r 1@1568r weight:0.000000e+00
		LHS = %86 [784r,880B:0)[880B,1152r:2)[1152r,1552r:1)  0@784r 1@1152r 2@880B-phi weight:0.000000e+00
		merge %12:0@1552r into %86:1@1152r --> @1152r
		erased:	1552r	%12:fr64 = COPY %86:fr64
		updated: 1568B	%86:fr64 = nofpexcept ADDSDrr %86:fr64(tied-def 0), %86:fr64, implicit $mxcsr
		updated: 1584B	%87:fr64 = COPY %86:fr64
	Success: %12 -> %86
	Result = %86 [784r,880B:0)[880B,1152r:2)[1152r,1568r:1)[1568r,1584r:3)  0@784r 1@1152r 2@880B-phi 3@1568r weight:0.000000e+00
1584B	%87:fr64 = COPY %86:fr64
	Considering merging to FR64 with %86 in %87
		RHS = %86 [784r,880B:0)[880B,1152r:2)[1152r,1568r:1)[1568r,1584r:3)  0@784r 1@1152r 2@880B-phi 3@1568r weight:0.000000e+00
		LHS = %87 [720r,768B:0)[1584r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1584r 2@1616B-phi 3@1680r weight:0.000000e+00
		merge %87:1@1584r into %86:3@1568r --> @1568r
		erased:	1584r	%87:fr64 = COPY %86:fr64
		updated: 1568B	%87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %87:fr64, implicit $mxcsr
		updated: 784B	%87:fr64 = FsFLD0SD
		updated: 1152B	%87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
	Success: %86 -> %87
	Result = %87 [720r,768B:0)[784r,880B:4)[880B,1152r:6)[1152r,1568r:5)[1568r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1568r 2@1616B-phi 3@1680r 4@784r 5@1152r 6@880B-phi weight:0.000000e+00
2704B	%89:gr8 = COPY %17:gr8
	Considering merging to GR8 with %17 in %89
		RHS = %17 [2688r,2704r:0)  0@2688r weight:0.000000e+00
		LHS = %89 [2704r,2736B:0)[2944r,2960B:1)[2960B,3024r:2)  0@2704r 1@2944r 2@2960B-phi weight:0.000000e+00
		merge %89:0@2704r into %17:0@2688r --> @2688r
		erased:	2704r	%89:gr8 = COPY %17:gr8
		updated: 2688B	%89:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
	Success: %17 -> %89
	Result = %89 [2688r,2736B:0)[2944r,2960B:1)[2960B,3024r:2)  0@2688r 1@2944r 2@2960B-phi weight:0.000000e+00
2928B	%18:gr8 = COPY %72:gr8
	Considering merging to GR8 with %72 in %18
		RHS = %72 [2912r,2928r:0)  0@2912r weight:0.000000e+00
		LHS = %18 [2928r,2944r:0)  0@2928r weight:0.000000e+00
		merge %18:0@2928r into %72:0@2912r --> @2912r
		erased:	2928r	%18:gr8 = COPY %72:gr8
		updated: 2912B	%18:gr8 = COPY killed $al
	Success: %72 -> %18
	Result = %18 [2912r,2944r:0)  0@2912r weight:0.000000e+00
2944B	%89:gr8 = COPY %18:gr8
	Considering merging to GR8 with %18 in %89
		RHS = %18 [2912r,2944r:0)  0@2912r weight:0.000000e+00
		LHS = %89 [2688r,2736B:0)[2944r,2960B:1)[2960B,3024r:2)  0@2688r 1@2944r 2@2960B-phi weight:0.000000e+00
		merge %89:1@2944r into %18:0@2912r --> @2912r
		erased:	2944r	%89:gr8 = COPY %18:gr8
		updated: 2912B	%89:gr8 = COPY killed $al
	Success: %18 -> %89
	Result = %89 [2688r,2736B:0)[2912r,2960B:1)[2960B,3024r:2)  0@2688r 1@2912r 2@2960B-phi weight:0.000000e+00
entry:
for.cond.cleanup:
288B	$eax = COPY %77:gr32
	Considering merging %77 with $eax
	Can only merge into reserved registers.
Remat: $eax = MOV32r0 implicit-def dead $eflags
Shrink: %77 [272r,288r:0)  0@272r weight:0.000000e+00
All defs dead: 272r	dead %77:gr32 = MOV32r0 implicit-def dead $eflags
Shrunk: %77 [272r,272d:0)  0@272r weight:0.000000e+00
Deleting dead def 272r	dead %77:gr32 = MOV32r0 implicit-def dead $eflags
if.then.i64:
224B	%82:gr32 = COPY %21:gr32
	Considering merging to GR32 with %21 in %82
		RHS = %21 [16r,224r:0)  0@16r weight:0.000000e+00
		LHS = %82 [224r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@224r 1@3200r 2@320B-phi weight:0.000000e+00
		merge %82:0@224r into %21:0@16r --> @16r
		erased:	224r	%82:gr32 = COPY %21:gr32
		updated: 16B	%82:gr32 = MOV32ri 2
	Success: %21 -> %82
	Result = %82 [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi weight:0.000000e+00
1168B	%42:fr64 = COPY %48:fr64
	Considering merging to FR64 with %42 in %48
		RHS = %42 [1168r,1184r:2)[1184r,1216r:0)[1216r,1248r:1)  0@1184r 1@1216r 2@1168r weight:0.000000e+00
		LHS = %48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:0.000000e+00
		interference at %42:0@1184r
	Interference!
496B	%48:fr64 = COPY %27:fr64
	Considering merging to FR64 with %27 in %48
		RHS = %27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:0.000000e+00
		LHS = %48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:0.000000e+00
		interference at %48:0@512r
	Interference!
2080B	$rdi = COPY %56:gr64
	Considering merging %56 with $rdi
	Can only merge into reserved registers.
2368B	$rdi = COPY %56:gr64
	Considering merging %56 with $rdi
	Can only merge into reserved registers.
3040B	$rdi = COPY %67:gr64
	Considering merging %67 with $rdi
	Can only merge into reserved registers.
3136B	$rdi = COPY %74:gr64
	Considering merging %74 with $rdi
	Can only merge into reserved registers.
816B	%83:fr64 = COPY %32:fr64
	Considering merging to FR64 with %32 in %83
		RHS = %32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:0.000000e+00
		LHS = %83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:0.000000e+00
		merge %83:0@816r into %32:0@64r --> @64r
		interference at %83:1@1408r
	Interference!
352B	%23:gr32 = COPY %82:gr32
	Considering merging to GR32 with %23 in %82
		RHS = %23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:0.000000e+00
		LHS = %82 [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi weight:0.000000e+00
		merge %23:0@352r into %82:2@320B --> @320B
		interference at %23:1@368r
	Interference!
384B	%1:gr32 = COPY %23:gr32
	Considering merging to GR32 with %23 in %1
		RHS = %23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:0.000000e+00
		LHS = %1 [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r weight:0.000000e+00
		interference at %1:2@400r
	Interference!
528B	%28:fr64 = COPY %48:fr64
	Considering merging to FR64 with %28 in %48
		RHS = %28 [528r,544r:0)[544r,576r:1)  0@528r 1@544r weight:0.000000e+00
		LHS = %48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:0.000000e+00
		merge %28:0@528r into %48:0@512r --> @512r
		interference at %28:1@544r
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
%1 [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r weight:0.000000e+00
%16 [2480r,2544B:0)[2608B,2688r:0)[2736B,2848r:0)  0@2480r weight:0.000000e+00
%23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:0.000000e+00
%26 [480r,512r:0)  0@480r weight:0.000000e+00
%27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:0.000000e+00
%28 [528r,544r:0)[544r,576r:1)  0@528r 1@544r weight:0.000000e+00
%29 [48r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@48r weight:0.000000e+00
%32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:0.000000e+00
%37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:0.000000e+00
%38 [960r,992r:2)[992r,1024r:0)[1024r,1056r:1)  0@992r 1@1024r 2@960r weight:0.000000e+00
%40 [1120r,1152r:0)  0@1120r weight:0.000000e+00
%42 [1168r,1184r:2)[1184r,1216r:0)[1216r,1248r:1)  0@1184r 1@1216r 2@1168r weight:0.000000e+00
%43 [1312r,1344r:0)  0@1312r weight:0.000000e+00
%48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:0.000000e+00
%54 [1920r,1936r:0)  0@1920r weight:0.000000e+00
%55 [1936r,1952r:0)  0@1936r weight:0.000000e+00
%56 [2048r,2368r:0)  0@2048r weight:0.000000e+00
%60 [2160r,2320r:0)  0@2160r weight:0.000000e+00
%61 [2176r,2272r:0)  0@2176r weight:0.000000e+00
%62 [192r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@192r weight:0.000000e+00
%64 [2192r,2224r:2)[2224r,2256r:0)[2256r,2272r:1)  0@2224r 1@2256r 2@2192r weight:0.000000e+00
%65 [2288r,2304r:0)  0@2288r weight:0.000000e+00
%66 [2320r,2336r:0)  0@2320r weight:0.000000e+00
%67 [2432r,2544B:0)[2608B,3040r:0)  0@2432r weight:0.000000e+00
%68 [2448r,2464r:0)  0@2448r weight:0.000000e+00
%69 [2464r,2480r:0)  0@2464r weight:0.000000e+00
%70 [2816r,2880r:0)  0@2816r weight:0.000000e+00
%73 [3024r,3056r:0)  0@3024r weight:0.000000e+00
%74 [3104r,3136r:0)  0@3104r weight:0.000000e+00
%78 [96r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@96r weight:0.000000e+00
%82 [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi weight:0.000000e+00
%83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:0.000000e+00
%84 [800r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@800r 1@1376r 2@880B-phi weight:0.000000e+00
%85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1744r:4)[1744r,1776r:5)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r 5@1744r weight:0.000000e+00
%87 [720r,768B:0)[784r,880B:4)[880B,1152r:6)[1152r,1568r:5)[1568r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1568r 2@1616B-phi 3@1680r 4@784r 5@1152r 6@880B-phi weight:0.000000e+00
%89 [2688r,2736B:0)[2912r,2960B:1)[2960B,3024r:2)  0@2688r 1@2912r 2@2960B-phi weight:0.000000e+00
RegMasks: 608r 1088r 1280r 1888r 2016r 2128r 2400r 2576r 2784r 2880r 3072r 3152r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

16B	  %82:gr32 = MOV32ri 2
32B	  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
64B	  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
80B	  %37:fr64 = FsFLD0SD
96B	  %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
192B	  %62:gr32 = MOV32ri -261
240B	  JMP_1 %bb.2

256B	bb.1.for.cond.cleanup:
	; predecessors: %bb.11

288B	  $eax = MOV32r0 implicit-def dead $eflags
304B	  RET 0, killed $eax

320B	bb.2.for.body:
	; predecessors: %bb.0, %bb.11
	  successors: %bb.3(0x40000000), %bb.12(0x40000000); %bb.3(50.00%), %bb.12(50.00%)

352B	  %23:gr32 = COPY %82:gr32
368B	  %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
384B	  %1:gr32 = COPY %23:gr32
400B	  %1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
432B	  %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
464B	  %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
480B	  %26:fr64 = CVTSI2SDrr %1:gr32
496B	  %48:fr64 = COPY %27:fr64
512B	  %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
528B	  %28:fr64 = COPY %48:fr64
544B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $xmm0 = COPY %28:fr64
592B	  $xmm1 = COPY %29:fr64
608B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
624B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
640B	  %85:fr64 = COPY killed $xmm0
672B	  CMP32ri8 %82:gr32, 3, implicit-def $eflags
688B	  JCC_1 %bb.3, 13, implicit killed $eflags

704B	bb.12:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

720B	  %87:fr64 = FsFLD0SD
752B	  JMP_1 %bb.6

768B	bb.3.for.body.i.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

784B	  %87:fr64 = FsFLD0SD
800B	  %84:gr32 = MOV32ri 2
816B	  %83:fr64 = COPY %32:fr64

880B	bb.4.for.body.i:
	; predecessors: %bb.3, %bb.4
	  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

960B	  %38:fr64 = CVTSI2SDrr %84:gr32
992B	  %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %48:fr64, implicit $mxcsr
1024B	  %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1040B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1056B	  $xmm0 = COPY %38:fr64
1072B	  $xmm1 = COPY %29:fr64
1088B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1104B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1120B	  %40:fr64 = COPY killed $xmm0
1152B	  %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
1168B	  %42:fr64 = COPY %48:fr64
1184B	  %42:fr64 = nofpexcept MULSDrr %42:fr64(tied-def 0), %83:fr64, implicit $mxcsr
1216B	  %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1232B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1248B	  $xmm0 = COPY %42:fr64
1264B	  $xmm1 = COPY %29:fr64
1280B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1312B	  %43:fr64 = COPY killed $xmm0
1344B	  %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %43:fr64, implicit $mxcsr
1376B	  %84:gr32 = nuw nsw ADD32ri8 %84:gr32(tied-def 0), 2, implicit-def dead $eflags
1408B	  %83:fr64 = ADDSDrr %83:fr64(tied-def 0), %78:fr64, implicit $mxcsr
1424B	  CMP32rr %84:gr32, %1:gr32, implicit-def $eflags
1504B	  JCC_1 %bb.4, 12, implicit killed $eflags
1520B	  JMP_1 %bb.5

1536B	bb.5.for.end.loopexit.i:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1568B	  %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %87:fr64, implicit $mxcsr

1616B	bb.6._Z7simpsonPFddEddi.exit:
	; predecessors: %bb.5, %bb.12
	  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

1680B	  %87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
1712B	  %85:fr64 = MULSDrr %85:fr64(tied-def 0), %29:fr64, implicit $mxcsr
1744B	  %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
1776B	  %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %85:fr64, implicit $mxcsr
1808B	  %48:fr64 = DIVSDrr %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr
1824B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1840B	  $rdi = MOV32ri64 @_ZSt4cout
1856B	  $rsi = MOV32ri64 @.str
1872B	  $rdx = MOV32ri64 2
1888B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
1904B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1920B	  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
1936B	  %55:gr64 = MOV64rm %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
1952B	  MOV64mi32 %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
1968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1984B	  $rdi = MOV32ri64 @_ZSt4cout
2000B	  $esi = COPY %82:gr32
2016B	  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %56:gr64 = COPY killed $rax
2064B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2080B	  $rdi = COPY %56:gr64
2096B	  $rsi = MOV32ri64 @.str.1
2112B	  $rdx = MOV32ri64 4
2128B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
2144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
2176B	  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2192B	  %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
2224B	  %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
2256B	  %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
2272B	  MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
2288B	  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2304B	  MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
2320B	  %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2336B	  MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
2352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2368B	  $rdi = COPY %56:gr64
2384B	  $xmm0 = COPY %48:fr64
2400B	  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  %67:gr64 = COPY killed $rax
2448B	  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
2464B	  %69:gr64_nosp = MOV64rm %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
2480B	  %16:gr64 = MOV64rm %67:gr64, 1, %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
2496B	  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
2512B	  JCC_1 %bb.8, 5, implicit killed $eflags
2528B	  JMP_1 %bb.7

2544B	bb.7.if.then.i64:
	; predecessors: %bb.6

2560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2576B	  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2608B	bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
	; predecessors: %bb.6
	  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

2624B	  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
2640B	  JCC_1 %bb.10, 4, implicit killed $eflags
2656B	  JMP_1 %bb.9

2672B	bb.9.if.then.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2688B	  %89:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
2720B	  JMP_1 %bb.11

2736B	bb.10.if.end.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2768B	  $rdi = COPY %16:gr64
2784B	  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
2800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2816B	  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
2832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2848B	  $rdi = COPY %16:gr64
2864B	  $esi = MOV32ri 10
2880B	  CALL64m %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %89:gr8 = COPY killed $al

2960B	bb.11._ZNKSt5ctypeIcE5widenEc.exit:
	; predecessors: %bb.9, %bb.10
	  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  %73:gr32 = MOVSX32rr8 %89:gr8
3040B	  $rdi = COPY %67:gr64
3056B	  $esi = COPY %73:gr32
3072B	  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3104B	  %74:gr64 = COPY killed $rax
3120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3136B	  $rdi = COPY %74:gr64
3152B	  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3200B	  %82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
3216B	  CMP32ri %82:gr32, 65537, implicit-def $eflags
3248B	  JCC_1 %bb.2, 2, implicit killed $eflags
3264B	  JMP_1 %bb.1

# End machine code for function main.

Before MISched:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %82:gr32 = MOV32ri 2
  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %37:fr64 = FsFLD0SD
  %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %62:gr32 = MOV32ri -261
  JMP_1 %bb.2

bb.1.for.cond.cleanup:
; predecessors: %bb.11

  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, killed $eax

bb.2.for.body:
; predecessors: %bb.0, %bb.11
  successors: %bb.3(0x40000000), %bb.12(0x40000000); %bb.3(50.00%), %bb.12(50.00%)

  %23:gr32 = COPY %82:gr32
  %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
  %1:gr32 = COPY %23:gr32
  %1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
  %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
  %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
  %26:fr64 = CVTSI2SDrr %1:gr32
  %48:fr64 = COPY %27:fr64
  %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
  %28:fr64 = COPY %48:fr64
  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %28:fr64
  $xmm1 = COPY %29:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %85:fr64 = COPY killed $xmm0
  CMP32ri8 %82:gr32, 3, implicit-def $eflags
  JCC_1 %bb.3, 13, implicit killed $eflags

bb.12:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %87:fr64 = FsFLD0SD
  JMP_1 %bb.6

bb.3.for.body.i.preheader:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %87:fr64 = FsFLD0SD
  %84:gr32 = MOV32ri 2
  %83:fr64 = COPY %32:fr64

bb.4.for.body.i:
; predecessors: %bb.3, %bb.4
  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

  %38:fr64 = CVTSI2SDrr %84:gr32
  %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %48:fr64, implicit $mxcsr
  %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %38:fr64
  $xmm1 = COPY %29:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:fr64 = COPY killed $xmm0
  %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  %42:fr64 = COPY %48:fr64
  %42:fr64 = nofpexcept MULSDrr %42:fr64(tied-def 0), %83:fr64, implicit $mxcsr
  %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $xmm0 = COPY %42:fr64
  $xmm1 = COPY %29:fr64
  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %43:fr64 = COPY killed $xmm0
  %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  %84:gr32 = nuw nsw ADD32ri8 %84:gr32(tied-def 0), 2, implicit-def dead $eflags
  %83:fr64 = ADDSDrr %83:fr64(tied-def 0), %78:fr64, implicit $mxcsr
  CMP32rr %84:gr32, %1:gr32, implicit-def $eflags
  JCC_1 %bb.4, 12, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.end.loopexit.i:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %87:fr64, implicit $mxcsr

bb.6._Z7simpsonPFddEddi.exit:
; predecessors: %bb.5, %bb.12
  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

  %87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
  %85:fr64 = MULSDrr %85:fr64(tied-def 0), %29:fr64, implicit $mxcsr
  %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
  %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %85:fr64, implicit $mxcsr
  %48:fr64 = DIVSDrr %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @_ZSt4cout
  $rsi = MOV32ri64 @.str
  $rdx = MOV32ri64 2
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
  %55:gr64 = MOV64rm %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
  MOV64mi32 %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @_ZSt4cout
  $esi = COPY %82:gr32
  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %56:gr64 = COPY killed $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %56:gr64
  $rsi = MOV32ri64 @.str.1
  $rdx = MOV32ri64 4
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
  %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
  %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
  MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
  %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %56:gr64
  $xmm0 = COPY %48:fr64
  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %67:gr64 = COPY killed $rax
  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
  %69:gr64_nosp = MOV64rm %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
  %16:gr64 = MOV64rm %67:gr64, 1, %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
  JCC_1 %bb.8, 5, implicit killed $eflags
  JMP_1 %bb.7

bb.7.if.then.i64:
; predecessors: %bb.6

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
; predecessors: %bb.6
  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
  JCC_1 %bb.10, 4, implicit killed $eflags
  JMP_1 %bb.9

bb.9.if.then.i:
; predecessors: %bb.8
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %89:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
  JMP_1 %bb.11

bb.10.if.end.i:
; predecessors: %bb.8
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %16:gr64
  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %16:gr64
  $esi = MOV32ri 10
  CALL64m %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr8 = COPY killed $al

bb.11._ZNKSt5ctypeIcE5widenEc.exit:
; predecessors: %bb.9, %bb.10
  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %73:gr32 = MOVSX32rr8 %89:gr8
  $rdi = COPY %67:gr64
  $esi = COPY %73:gr32
  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %74:gr64 = COPY killed $rax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %74:gr64
  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
  CMP32ri %82:gr32, 65537, implicit-def $eflags
  JCC_1 %bb.2, 2, implicit killed $eflags
  JMP_1 %bb.1

# End machine code for function main.

********** MI Scheduling **********
main:%bb.0 entry
  From: %82:gr32 = MOV32ri 2
    To: JMP_1 %bb.2
 RegionInstrs: 7
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   %82:gr32 = MOV32ri 2
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
SU(2):   %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
SU(3):   %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
SU(4):   %37:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(5):   %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 6
  Depth              : 0
  Height             : 5
  Successors:
    ExitSU: Ord  Latency=5 Artificial
  Single Issue       : false;
SU(6):   %62:gr32 = MOV32ri -261
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
ExitSU:   JMP_1 %bb.2
  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=5 Artificial
    SU(3): Ord  Latency=5 Artificial
    SU(2): Ord  Latency=5 Artificial
    SU(1): Ord  Latency=5 Artificial
Critical Path(GS-RR ): 5
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 4 0 5 3 2 1 
  Cand SU(6) ORDER                              
Pick Bot ORDER     
Scheduling SU(6) %62:gr32 = MOV32ri -261
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 4 0 5 3 2 
  Cand SU(1) ORDER                              
  Cand SU(4) ORDER                              
  Cand SU(5) ORDER                              
Pick Bot ORDER     
Scheduling SU(5) %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(5) 5c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 4 0 2 3 
  Cand SU(1) ORDER                              
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %37:fr64 = FsFLD0SD
  Ready @0c
BotQ.A @0c
  Retired: 3
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 0 2 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 0 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 5
  Executed: 1c
  Critical: 1c, 3 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 6
  Executed: 2c
  Critical: 2c, 4 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %82:gr32 = MOV32ri 2
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 7
  Executed: 2c
  Critical: 2c, 4 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   %82:gr32 = MOV32ri 2
SU(1):   %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
SU(2):   %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
SU(3):   %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
SU(4):   %37:fr64 = FsFLD0SD
SU(5):   %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
SU(6):   %62:gr32 = MOV32ri -261

********** MI Scheduling **********
main:%bb.2 for.body
  From: %85:fr64 = COPY killed $xmm0
    To: JCC_1 %bb.3, 13, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  CMP32ri8 - JCC_1
SU(0):   %85:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    SU(1): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   CMP32ri8 %82:gr32, 3, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.3, 13, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri8 %82:gr32, 3, implicit-def $eflags
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %85:fr64 = COPY killed $xmm0
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %85:fr64 = COPY killed $xmm0
SU(1):   CMP32ri8 %82:gr32, 3, implicit-def $eflags

********** MI Scheduling **********
main:%bb.2 for.body
  From: $xmm0 = COPY %28:fr64
    To: CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $xmm0 = COPY %28:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $xmm1 = COPY %29:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $xmm1 = COPY %29:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $xmm0 = COPY %28:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   $xmm0 = COPY %28:fr64
SU(1):   $xmm1 = COPY %29:fr64

********** MI Scheduling **********
main:%bb.2 for.body
  From: %23:gr32 = COPY %82:gr32
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 11
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: FR32=4
FR32X=4
GR16=6
Live In: %37 %27 %82 
Live Out: %28 %37 %48 %27 %1 %82 
Live Thru: FR32=2
FR32X=2
GR16=2
  LiveReg: %28
  LiveReg: %37
  UpdateRegP: SU(10) %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
              to 
  LiveReg: %48
  UpdateRegP: SU(9) %28:fr64 = COPY %48:fr64
              to FR32 -1    FR32X -1
  LiveReg: %27
  UpdateRegP: SU(7) %48:fr64 = COPY %27:fr64
              to FR32 -1    FR32X -1
  LiveReg: %1
  UpdateRegP: SU(6) %26:fr64 = CVTSI2SDrr %1:gr32
              to FR32 -1    FR32X -1
  LiveReg: %82
  UpdateRegP: SU(0) %23:gr32 = COPY %82:gr32
              to GR16 -2
Top Pressure:
FR32=2
FR32X=2
GR16=2
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
Excess PSets: 
SU(0):   %23:gr32 = COPY %82:gr32
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 32
  Successors:
    SU(1): Data Latency=0 Reg=%23
    SU(1): Out  Latency=0
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 32
  Predecessors:
    SU(0): Data Latency=0 Reg=%23
    SU(0): Out  Latency=0
  Successors:
    SU(4): Data Latency=1 Reg=%23
    SU(2): Data Latency=1 Reg=%23
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %1:gr32 = COPY %23:gr32
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 31
  Predecessors:
    SU(1): Data Latency=1 Reg=%23
  Successors:
    SU(3): Data Latency=0 Reg=%1
    SU(3): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 31
  Predecessors:
    SU(2): Data Latency=0 Reg=%1
    SU(2): Out  Latency=0
  Successors:
    SU(4): Data Latency=1 Reg=%1
    SU(4): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 30
  Predecessors:
    SU(3): Data Latency=1 Reg=%1
    SU(3): Out  Latency=0
    SU(1): Data Latency=1 Reg=%23
  Successors:
    SU(5): Data Latency=1 Reg=%1
    SU(5): Out  Latency=0
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(5):   %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 29
  Predecessors:
    SU(4): Data Latency=1 Reg=%1
    SU(4): Out  Latency=0
  Successors:
    SU(6): Data Latency=1 Reg=%1
  Pressure Diff      : 
  Single Issue       : false;
SU(6):   %26:fr64 = CVTSI2SDrr %1:gr32
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 4
  Height             : 28
  Predecessors:
    SU(5): Data Latency=1 Reg=%1
  Successors:
    SU(8): Data Latency=4 Reg=%26
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(7):   %48:fr64 = COPY %27:fr64
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 24
  Successors:
    SU(8): Data Latency=0 Reg=%48
    SU(8): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(8):   %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 22
  Depth              : 8
  Height             : 24
  Predecessors:
    SU(6): Data Latency=4 Reg=%26
    SU(7): Out  Latency=0
    SU(7): Data Latency=0 Reg=%48
  Successors:
    SU(9): Data Latency=22 Reg=%48
  Pressure Diff      : FR32 1    FR32X 1
  Single Issue       : false;
SU(9):   %28:fr64 = COPY %48:fr64
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 30
  Height             : 2
  Predecessors:
    SU(8): Data Latency=22 Reg=%48
  Successors:
    SU(10): Data Latency=0 Reg=%28
    SU(10): Out  Latency=0
  Pressure Diff      : FR32 -1    FR32X -1
  Single Issue       : false;
SU(10):   %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 30
  Height             : 2
  Predecessors:
    SU(9): Data Latency=0 Reg=%28
    SU(9): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Pressure Diff      : 
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 32
  Height             : 0
  Predecessors:
    SU(10): Ord  Latency=2 Artificial
Critical Path(GS-RR ): 32
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 10 
Scheduling SU(10) %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %28
  UpdateRegP: SU(10) %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(10) 30c
  BotQ.A BotLatency SU(10) 2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 9 
Scheduling SU(9) %28:fr64 = COPY %48:fr64
Bottom Pressure:
FR32=3
FR32X=3
GR16=4
  Ready @2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
Bottom Pressure:
FR32=4
FR32X=4
GR16=4
  LiveReg: %48
  UpdateRegP: SU(8) %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
              to 
  LiveReg: %26
  UpdateRegP: SU(8) %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
              to FR32 -1    FR32X -1
  Ready @24c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(8) 24c
BotQ.A @0c
  Retired: 2
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 24c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 7 
  Cand SU(6) ORDER                              
  Cand SU(7) ORDER                              
Pick Bot ORDER     
Scheduling SU(7) %48:fr64 = COPY %27:fr64
Bottom Pressure:
FR32=3
FR32X=3
GR16=4
  Ready @24c
BotQ.A @0c
  Retired: 2
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 24c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) %26:fr64 = CVTSI2SDrr %1:gr32
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  Ready @28c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(6) 28c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 28c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  LiveReg: %1
  UpdateRegP: SU(5) %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
              to GR16 -2
  Ready @29c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(5) 29c
BotQ.A @1c
  Retired: 5
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 29c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=6
  LiveReg: %1
  UpdateRegP: SU(4) %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
              to 
  LiveReg: %23
  UpdateRegP: SU(2) %1:gr32 = COPY %23:gr32
              to GR16 -2
  UpdateRegP: SU(4) %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @30c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(4) 30c
BotQ.A @1c
  Retired: 6
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 30c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=6
  LiveReg: %1
  UpdateRegP: SU(3) %1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
              to GR16 -2
  Ready @31c
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 31c
BotQ.A @1c
  Retired: 7
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 31c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %1:gr32 = COPY %23:gr32
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  Ready @31c
BotQ.A @1c
  Retired: 7
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 31c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
Bottom Pressure:
FR32=2
FR32X=2
GR16=4
  LiveReg: %23
  UpdateRegP: SU(1) %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
              to GR16 -2
  Ready @32c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 32c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 32c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %23:gr32 = COPY %82:gr32
Bottom Pressure:
FR32=2
FR32X=2
GR16=2
  Ready @32c
BotQ.A @2c
  Retired: 8
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 32c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.2 ***
SU(0):   %23:gr32 = COPY %82:gr32
SU(1):   %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
SU(2):   %1:gr32 = COPY %23:gr32
SU(3):   %1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
SU(4):   %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
SU(5):   %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
SU(6):   %26:fr64 = CVTSI2SDrr %1:gr32
SU(7):   %48:fr64 = COPY %27:fr64
SU(8):   %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
SU(9):   %28:fr64 = COPY %48:fr64
SU(10):   %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr

********** MI Scheduling **********
main:%bb.3 for.body.i.preheader
  From: %87:fr64 = FsFLD0SD
    To: End RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %87:fr64 = FsFLD0SD
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(1):   %84:gr32 = MOV32ri 2
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0
  Single Issue       : false;
SU(2):   %83:fr64 = COPY %32:fr64
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Single Issue       : false;
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %83:fr64 = COPY %32:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %84:gr32 = MOV32ri 2
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %87:fr64 = FsFLD0SD
  Ready @0c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.3 ***
SU(0):   %87:fr64 = FsFLD0SD
SU(1):   %84:gr32 = MOV32ri 2
SU(2):   %83:fr64 = COPY %32:fr64

********** MI Scheduling **********
main:%bb.4 for.body.i
  From: %43:fr64 = COPY killed $xmm0
    To: JCC_1 %bb.4, 12, implicit killed $eflags
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(4) - ExitSU /  CMP32rr - JCC_1
  Bind SU(3) - SU(4)
  Bind SU(1) - SU(4)
SU(0):   %43:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=0 Reg=%43
  Single Issue       : false;
SU(1):   %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 2
  Predecessors:
    SU(0): Data Latency=0 Reg=%43
  Successors:
    ExitSU: Ord  Latency=2 Artificial
    SU(4): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   %84:gr32 = nuw nsw ADD32ri8 %84:gr32(tied-def 0), 2, implicit-def dead $eflags
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(4): Data Latency=1 Reg=%84
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(3):   %83:fr64 = ADDSDrr %83:fr64(tied-def 0), %78:fr64, implicit $mxcsr
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 2
  Successors:
    ExitSU: Ord  Latency=2 Artificial
    SU(4): Ord  Latency=0 Artificial
  Single Issue       : false;
SU(4):   CMP32rr %84:gr32, %1:gr32, implicit-def $eflags
  # preds left       : 4
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Data Latency=1 Reg=%84
    SU(2): Out  Latency=0
    SU(3): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.4, 12, implicit killed $eflags
  # preds left       : 3
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Artificial
    SU(3): Ord  Latency=2 Artificial
    SU(1): Ord  Latency=2 Artificial
    SU(4): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 2
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) CMP32rr %84:gr32, %1:gr32, implicit-def $eflags
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A TopLatency SU(4) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 3 1 
  Cand SU(2) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %83:fr64 = ADDSDrr %83:fr64(tied-def 0), %78:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 2c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %84:gr32 = nuw nsw ADD32ri8 %84:gr32(tied-def 0), 2, implicit-def dead $eflags
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %43:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %43:fr64 = COPY killed $xmm0
  Ready @2c
BotQ.A @1c
  Retired: 4
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %43:fr64 = COPY killed $xmm0
SU(1):   %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %43:fr64, implicit $mxcsr
SU(2):   %84:gr32 = nuw nsw ADD32ri8 %84:gr32(tied-def 0), 2, implicit-def dead $eflags
SU(3):   %83:fr64 = ADDSDrr %83:fr64(tied-def 0), %78:fr64, implicit $mxcsr
SU(4):   CMP32rr %84:gr32, %1:gr32, implicit-def $eflags

********** MI Scheduling **********
main:%bb.4 for.body.i
  From: $xmm0 = COPY %42:fr64
    To: CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $xmm0 = COPY %42:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $xmm1 = COPY %29:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $xmm1 = COPY %29:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $xmm0 = COPY %42:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   $xmm0 = COPY %42:fr64
SU(1):   $xmm1 = COPY %29:fr64

********** MI Scheduling **********
main:%bb.4 for.body.i
  From: %40:fr64 = COPY killed $xmm0
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %40:fr64 = COPY killed $xmm0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=0 Reg=%40
  Single Issue       : false;
SU(1):   %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 2
  Predecessors:
    SU(0): Data Latency=0 Reg=%40
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Single Issue       : false;
SU(2):   %42:fr64 = COPY %48:fr64
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 7
  Successors:
    SU(3): Data Latency=0 Reg=%42
    SU(3): Out  Latency=0
  Single Issue       : false;
SU(3):   %42:fr64 = nofpexcept MULSDrr %42:fr64(tied-def 0), %83:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 7
  Predecessors:
    SU(2): Data Latency=0 Reg=%42
    SU(2): Out  Latency=0
  Successors:
    SU(4): Data Latency=5 Reg=%42
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(3): Data Latency=5 Reg=%42
    SU(3): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=2 Artificial
    SU(1): Ord  Latency=2 Artificial
Critical Path(GS-RR ): 7
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 1 
  Cand SU(4) ORDER                              
Pick Bot ORDER     
Scheduling SU(4) %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(4) 5c
  BotQ.A BotLatency SU(4) 2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 3 
  Cand SU(1) ORDER                              
  Cand SU(3) ORDER                              
Pick Bot ORDER     
Scheduling SU(3) %42:fr64 = nofpexcept MULSDrr %42:fr64(tied-def 0), %83:fr64, implicit $mxcsr
  Ready @7c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 7c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 2 
  Cand SU(1) ORDER                              
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) %42:fr64 = COPY %48:fr64
  Ready @7c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %40:fr64 = COPY killed $xmm0
  Ready @2c
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %40:fr64 = COPY killed $xmm0
SU(1):   %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
SU(2):   %42:fr64 = COPY %48:fr64
SU(3):   %42:fr64 = nofpexcept MULSDrr %42:fr64(tied-def 0), %83:fr64, implicit $mxcsr
SU(4):   %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr

********** MI Scheduling **********
main:%bb.4 for.body.i
  From: $xmm0 = COPY %38:fr64
    To: CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $xmm0 = COPY %38:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $xmm1 = COPY %29:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $xmm1 = COPY %29:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $xmm0 = COPY %38:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   $xmm0 = COPY %38:fr64
SU(1):   $xmm1 = COPY %29:fr64

********** MI Scheduling **********
main:%bb.4 for.body.i
  From: %38:fr64 = CVTSI2SDrr %84:gr32
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %38:fr64 = CVTSI2SDrr %84:gr32
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 11
  Successors:
    SU(1): Data Latency=4 Reg=%38
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %48:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 4
  Height             : 7
  Predecessors:
    SU(0): Data Latency=4 Reg=%38
    SU(0): Out  Latency=0
  Successors:
    SU(2): Data Latency=5 Reg=%38
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 9
  Height             : 2
  Predecessors:
    SU(1): Data Latency=5 Reg=%38
    SU(1): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 11
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=2 Artificial
Critical Path(GS-RR ): 11
Cyclic Critical Path: 0c
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
  Ready @2c
  SBPort1 +1x12u
  *** Critical resource SBPort1: 1c
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(2) 9c
  BotQ.A BotLatency SU(2) 2c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 2c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %48:fr64, implicit $mxcsr
  Ready @7c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 7c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort1
  ExpectedLatency: 7c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %38:fr64 = CVTSI2SDrr %84:gr32
  Ready @11c
  SBPort1 +1x12u
  SBPort5 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort15 +2x6u
  SBPort015 +2x4u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(0) 11c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 2c
  Critical: 2c, 2 SBPort1
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.4 ***
SU(0):   %38:fr64 = CVTSI2SDrr %84:gr32
SU(1):   %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %48:fr64, implicit $mxcsr
SU(2):   %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: %67:gr64 = COPY killed $rax
    To: JCC_1 %bb.8, 5, implicit killed $eflags
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(4) - ExitSU /  TEST64rr - JCC_1
SU(0):   %67:gr64 = COPY killed $rax
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 15
  Successors:
    SU(3): Data Latency=0 Reg=%67
    SU(1): Data Latency=0 Reg=%67
  Single Issue       : false;
SU(1):   %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 15
  Predecessors:
    SU(0): Data Latency=0 Reg=%67
  Successors:
    SU(2): Data Latency=5 Reg=%68
  Single Issue       : false;
SU(2):   %69:gr64_nosp = MOV64rm %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 5
  Height             : 10
  Predecessors:
    SU(1): Data Latency=5 Reg=%68
  Successors:
    SU(3): Data Latency=5 Reg=%69
  Single Issue       : false;
SU(3):   %16:gr64 = MOV64rm %67:gr64, 1, %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 5
  Depth              : 10
  Height             : 5
  Predecessors:
    SU(2): Data Latency=5 Reg=%69
    SU(0): Data Latency=0 Reg=%67
  Successors:
    SU(4): Data Latency=5 Reg=%16
  Single Issue       : false;
SU(4):   TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
  # preds left       : 1
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 15
  Height             : 0
  Predecessors:
    SU(3): Data Latency=5 Reg=%16
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.8, 5, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 15
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=0 Artificial
    SU(4): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 15
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A TopLatency SU(4) 15c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %16:gr64 = MOV64rm %67:gr64, 1, %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
  Ready @5c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 5c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 1 SBPort23
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %69:gr64_nosp = MOV64rm %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
  Ready @10c
  SBPort23 +1x6u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 10c
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 2 SBPort23
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
  Ready @15c
  SBPort23 +1x6u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 15c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 3 SBPort23
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %67:gr64 = COPY killed $rax
  Ready @15c
BotQ.A @1c
  Retired: 4
  Executed: 1c
  Critical: 1c, 3 SBPort23
  ExpectedLatency: 15c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %67:gr64 = COPY killed $rax
SU(1):   %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
SU(2):   %69:gr64_nosp = MOV64rm %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
SU(3):   %16:gr64 = MOV64rm %67:gr64, 1, %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
SU(4):   TEST64rr %16:gr64, %16:gr64, implicit-def $eflags

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: $rdi = COPY %56:gr64
    To: CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %56:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $xmm0 = COPY %48:fr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 0
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $xmm0 = COPY %48:fr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %56:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   $rdi = COPY %56:gr64
SU(1):   $xmm0 = COPY %48:fr64

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 10
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=1 OnlyTopDown=0 OnlyBottomUp=1
Max Pressure: GR16=10
Live In: %56 %62 
Live Out: %56 %62 
Live Thru: GR16=4
  LiveReg: %56
  UpdateRegP: SU(0) %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
              to GR16 -2
  UpdateRegP: SU(2) %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
              to 
  UpdateRegP: SU(5) MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
              to GR16 4
  UpdateRegP: SU(7) MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
              to GR16 2
  UpdateRegP: SU(9) MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
              to GR16 2
  LiveReg: %62
  UpdateRegP: SU(3) %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
              to 
Top Pressure:
GR16=4
Bottom Pressure:
GR16=4
Excess PSets: 
SU(0):   %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
  # preds left       : 0
  # succs left       : 6
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 29
  Successors:
    SU(8): Data Latency=5 Reg=%60
    SU(6): Data Latency=5 Reg=%60
    SU(1): Data Latency=5 Reg=%60
    SU(9): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
  Pressure Diff      : GR16 -2
  Single Issue       : false;
SU(1):   %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 5
  Depth              : 5
  Height             : 24
  Predecessors:
    SU(0): Data Latency=5 Reg=%60
  Successors:
    SU(5): Data Latency=5 Reg=%61
    SU(2): Data Latency=5 Reg=%61
    SU(9): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(2):   %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
  # preds left       : 1
  # succs left       : 5
  # rdefs left       : 0
  Latency            : 5
  Depth              : 10
  Height             : 19
  Predecessors:
    SU(1): Data Latency=5 Reg=%61
  Successors:
    SU(3): Data Latency=5 Reg=%64
    SU(3): Out  Latency=0
    SU(9): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(3):   %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 15
  Height             : 14
  Predecessors:
    SU(2): Data Latency=5 Reg=%64
    SU(2): Out  Latency=0
  Successors:
    SU(4): Data Latency=1 Reg=%64
    SU(4): Out  Latency=0
  Pressure Diff      : 
  Single Issue       : false;
SU(4):   %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 16
  Height             : 13
  Predecessors:
    SU(3): Data Latency=1 Reg=%64
    SU(3): Out  Latency=0
  Successors:
    SU(5): Data Latency=1 Reg=%64
  Pressure Diff      : 
  Single Issue       : false;
SU(5):   MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
  # preds left       : 5
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 17
  Height             : 12
  Predecessors:
    SU(4): Data Latency=1 Reg=%64
    SU(2): Ord  Latency=0 Memory
    SU(1): Data Latency=5 Reg=%61
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(9): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(8): Ord  Latency=1 Memory
    SU(6): Ord  Latency=1 Memory
  Pressure Diff      : GR16 4
  Single Issue       : false;
SU(6):   %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 5
  Depth              : 18
  Height             : 11
  Predecessors:
    SU(5): Ord  Latency=1 Memory
    SU(0): Data Latency=5 Reg=%60
  Successors:
    SU(7): Data Latency=5 Reg=%65
    SU(9): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(7):   MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
  # preds left       : 6
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 23
  Height             : 6
  Predecessors:
    SU(6): Data Latency=5 Reg=%65
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Successors:
    SU(9): Ord  Latency=0 Memory
    SU(8): Ord  Latency=1 Memory
  Pressure Diff      : GR16 2
  Single Issue       : false;
SU(8):   %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 24
  Height             : 5
  Predecessors:
    SU(7): Ord  Latency=1 Memory
    SU(5): Ord  Latency=1 Memory
    SU(0): Data Latency=5 Reg=%60
  Successors:
    SU(9): Data Latency=5 Reg=%66
    SU(9): Ord  Latency=0 Memory
  Pressure Diff      : 
  Single Issue       : false;
SU(9):   MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
  # preds left       : 8
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 29
  Height             : 0
  Predecessors:
    SU(8): Data Latency=5 Reg=%66
    SU(8): Ord  Latency=0 Memory
    SU(7): Ord  Latency=0 Memory
    SU(6): Ord  Latency=0 Memory
    SU(5): Ord  Latency=0 Memory
    SU(2): Ord  Latency=0 Memory
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Pressure Diff      : GR16 2
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 29
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 9 
Scheduling SU(9) MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
Bottom Pressure:
GR16=6
  LiveReg: %66
  UpdateRegP: SU(9) MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
              to 
  Ready @0c
  SBPort4 +1x12u
  *** Critical resource SBPort4: 1c
  SBPort23 +1x6u
  SBPortAny +2x2u
  BotQ.A TopLatency SU(9) 29c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 8 
Scheduling SU(8) %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
Bottom Pressure:
GR16=6
  LiveReg: %60
  UpdateRegP: SU(1) %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
              to GR16 -2
  UpdateRegP: SU(6) %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
              to GR16 -2
  UpdateRegP: SU(8) %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
              to GR16 -2
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(8) 5c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort4
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 7 
Scheduling SU(7) MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
Bottom Pressure:
GR16=8
  LiveReg: %65
  UpdateRegP: SU(7) MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
              to 
  Ready @6c
  SBPort4 +1x12u
  SBPort23 +1x6u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(7) 6c
BotQ.A @0c
  Retired: 3
  Executed: 2c
  Critical: 2c, 2 SBPort4
  ExpectedLatency: 6c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 6 
Scheduling SU(6) %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
Bottom Pressure:
GR16=6
  Ready @11c
  SBPort23 +1x6u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(6) 11c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 2c
  Critical: 2c, 2 SBPort4
  ExpectedLatency: 11c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 5 
Scheduling SU(5) MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
Bottom Pressure:
GR16=10
  LiveReg: %61
  UpdateRegP: SU(2) %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
              to GR16 -2
  UpdateRegP: SU(5) MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
              to GR16 2
  LiveReg: %64
  UpdateRegP: SU(5) MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
              to 
  Ready @12c
  SBPort4 +1x12u
  SBPort23 +1x6u
  SBPortAny +2x2u
  BotQ.A BotLatency SU(5) 12c
BotQ.A @1c
  Retired: 5
  Executed: 3c
  Critical: 3c, 3 SBPort4
  ExpectedLatency: 12c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
Bottom Pressure:
GR16=10
  LiveReg: %64
  UpdateRegP: SU(4) %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
              to GR16 -2
  Ready @13c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(4) 13c
BotQ.A @1c
  Retired: 6
  Executed: 3c
  Critical: 3c, 3 SBPort4
  ExpectedLatency: 13c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
Bottom Pressure:
GR16=10
  LiveReg: %64
  UpdateRegP: SU(3) %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
              to GR16 -2
  Ready @14c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 14c
BotQ.A @1c
  Retired: 7
  Executed: 3c
  Critical: 3c, 3 SBPort4
  ExpectedLatency: 14c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
Bottom Pressure:
GR16=8
  Ready @19c
  SBPort23 +1x6u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 19c
  *** Max MOps 4 at cycle 1
Cycle: 2 BotQ.A
BotQ.A @2c
  Retired: 8
  Executed: 3c
  Critical: 3c, 3 SBPort4
  ExpectedLatency: 19c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
Bottom Pressure:
GR16=6
  Ready @24c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 3c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 24c
BotQ.A @2c
  Retired: 9
  Executed: 3c
  Critical: 3c, 7 SBPort23
  ExpectedLatency: 24c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
Bottom Pressure:
GR16=4
  Ready @29c
  SBPort23 +1x6u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(0) 29c
BotQ.A @2c
  Retired: 10
  Executed: 4c
  Critical: 4c, 8 SBPort23
  ExpectedLatency: 29c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
SU(1):   %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
SU(2):   %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
SU(3):   %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
SU(4):   %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
SU(5):   MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
SU(6):   %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
SU(7):   MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
SU(8):   %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
SU(9):   MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: $rdi = COPY %56:gr64
    To: CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %56:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str.1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 4
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
  Cand SU(0) PHYS-REG                           
Pick Bot PHYS-REG  
Scheduling SU(0) $rdi = COPY %56:gr64
handleMove 2080B -> 2120B: $rdi = COPY %56:gr64
     DIL:	[1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
        -->	[1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
     DIH:	[1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
        -->	[1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
     HDI:	[1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
        -->	[1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
     %56:	[2048r,2368r:0)  0@2048r
        -->	[2048r,2368r:0)  0@2048r
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 4
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) $rsi = MOV32ri64 @.str.1
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(1):   $rsi = MOV32ri64 @.str.1
SU(2):   $rdx = MOV32ri64 4
SU(0):   $rdi = COPY %56:gr64

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: $rdi = MOV32ri64 @_ZSt4cout
    To: CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @_ZSt4cout
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $esi = COPY %82:gr32
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $esi = COPY %82:gr32
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @_ZSt4cout
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   $rdi = MOV32ri64 @_ZSt4cout
SU(1):   $esi = COPY %82:gr32

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 10
  Successors:
    SU(1): Data Latency=5 Reg=%54
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(1):   %55:gr64 = MOV64rm %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 5
  Height             : 5
  Predecessors:
    SU(0): Data Latency=5 Reg=%54
  Successors:
    SU(2): Data Latency=5 Reg=%55
    SU(2): Ord  Latency=0 Memory
  Single Issue       : false;
SU(2):   MOV64mi32 %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 0
  Predecessors:
    SU(1): Data Latency=5 Reg=%55
    SU(1): Ord  Latency=0 Memory
    SU(0): Ord  Latency=0 Memory
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
Critical Path(GS-RR ): 10
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) MOV64mi32 %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
  Ready @0c
  SBPort4 +1x12u
  *** Critical resource SBPort4: 1c
  SBPort23 +1x6u
  SBPortAny +2x2u
  BotQ.A TopLatency SU(2) 10c
BotQ.A @0c
  Retired: 1
  Executed: 1c
  Critical: 1c, 1 SBPort4
  ExpectedLatency: 0c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) %55:gr64 = MOV64rm %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
  Ready @5c
  SBPort23 +1x6u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 5c
BotQ.A @0c
  Retired: 2
  Executed: 1c
  Critical: 1c, 1 SBPort4
  ExpectedLatency: 5c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
  Ready @10c
  SBPort23 +1x6u
  *** Critical resource SBPort23: 1c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(0) 10c
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort23
  ExpectedLatency: 10c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
SU(1):   %55:gr64 = MOV64rm %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
SU(2):   MOV64mi32 %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: $rdi = MOV32ri64 @_ZSt4cout
    To: CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = MOV32ri64 @_ZSt4cout
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @.str
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 2
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @.str
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @_ZSt4cout
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   $rdi = MOV32ri64 @_ZSt4cout
SU(1):   $rsi = MOV32ri64 @.str
SU(2):   $rdx = MOV32ri64 2

********** MI Scheduling **********
main:%bb.6 _Z7simpsonPFddEddi.exit
  From: %87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
    To: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
 RegionInstrs: 5
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 0
  Height             : 32
  Successors:
    SU(2): Data Latency=3 Reg=%87
  Single Issue       : false;
SU(1):   %85:fr64 = MULSDrr %85:fr64(tied-def 0), %29:fr64, implicit $mxcsr
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 0
  Height             : 34
  Successors:
    SU(2): Data Latency=5 Reg=%85
    SU(2): Out  Latency=0
  Single Issue       : false;
SU(2):   %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 3
  Depth              : 5
  Height             : 29
  Predecessors:
    SU(1): Data Latency=5 Reg=%85
    SU(1): Out  Latency=0
    SU(0): Data Latency=3 Reg=%87
  Successors:
    SU(3): Data Latency=3 Reg=%85
  Single Issue       : false;
SU(3):   %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %85:fr64, implicit $mxcsr
  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 5
  Depth              : 8
  Height             : 26
  Predecessors:
    SU(2): Data Latency=3 Reg=%85
  Successors:
    SU(4): Data Latency=5 Reg=%48
    SU(4): Out  Latency=0
  Single Issue       : false;
SU(4):   %48:fr64 = DIVSDrr %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 22
  Depth              : 13
  Height             : 21
  Predecessors:
    SU(3): Data Latency=5 Reg=%48
    SU(3): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=21 Artificial
  Single Issue       : false;
ExitSU:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 34
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=21 Artificial
Critical Path(GS-RR ): 34
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 4 
Scheduling SU(4) %48:fr64 = DIVSDrr %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr
  Ready @21c
  SBFPDivider +22x12u
  *** Critical resource SBFPDivider: 22c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A TopLatency SU(4) 13c
  BotQ.A BotLatency SU(4) 21c
BotQ.A @0c
  Retired: 1
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 21c
  - Resource limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 3 
Scheduling SU(3) %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %85:fr64, implicit $mxcsr
  Ready @26c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(3) 26c
BotQ.A @0c
  Retired: 2
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 26c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 
Scheduling SU(2) %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
  Ready @29c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 29c
BotQ.A @0c
  Retired: 3
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 29c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) %85:fr64 = MULSDrr %85:fr64(tied-def 0), %29:fr64, implicit $mxcsr
  Ready @34c
  SBPort0 +1x12u
  SBPort01 +1x6u
  SBPort05 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 34c
  *** Max MOps 4 at cycle 0
Cycle: 1 BotQ.A
BotQ.A @1c
  Retired: 4
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 34c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
  Ready @32c
  SBPort1 +1x12u
  SBPort01 +1x6u
  SBPort15 +1x6u
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @1c
  Retired: 5
  Executed: 22c
  Critical: 22c, 22 SBFPDivider
  ExpectedLatency: 34c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.6 ***
SU(0):   %87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
SU(1):   %85:fr64 = MULSDrr %85:fr64(tied-def 0), %29:fr64, implicit $mxcsr
SU(2):   %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
SU(3):   %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %85:fr64, implicit $mxcsr
SU(4):   %48:fr64 = DIVSDrr %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr

********** MI Scheduling **********
main:%bb.10 if.end.i
  From: $rdi = COPY %16:gr64
    To: CALL64m %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   $rdi = COPY %16:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(1):   $esi = MOV32ri 10
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   CALL64m %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $esi = MOV32ri 10
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = COPY %16:gr64
  Ready @0c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.10 ***
SU(0):   $rdi = COPY %16:gr64
SU(1):   $esi = MOV32ri 10

********** MI Scheduling **********
main:%bb.11 _ZNKSt5ctypeIcE5widenEc.exit
  From: %82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
    To: JCC_1 %bb.2, 2, implicit killed $eflags
 RegionInstrs: 2
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Macro fuse: SU(1) - ExitSU /  CMP32ri - JCC_1
SU(0):   %82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(1): Data Latency=1 Reg=%82
    SU(1): Out  Latency=0
  Single Issue       : false;
SU(1):   CMP32ri %82:gr32, 65537, implicit-def $eflags
  # preds left       : 2
  # succs left       : 1
  # weak succs left  : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%82
    SU(0): Out  Latency=0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
    ExitSU: Ord  Latency=0 Cluster
  Single Issue       : false;
ExitSU:   JCC_1 %bb.2, 2, implicit killed $eflags
  # preds left       : 1
  # succs left       : 0
  # weak preds left  : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Cluster
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 
Scheduling SU(1) CMP32ri %82:gr32, 65537, implicit-def $eflags
  Ready @0c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A TopLatency SU(1) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.11 ***
SU(0):   %82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
SU(1):   CMP32ri %82:gr32, 65537, implicit-def $eflags

********** MI Scheduling **********
main:%bb.11 _ZNKSt5ctypeIcE5widenEc.exit
  From: %73:gr32 = MOVSX32rr8 %89:gr8
    To: CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
SU(0):   %73:gr32 = MOVSX32rr8 %89:gr8
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(2): Data Latency=1 Reg=%73
  Single Issue       : false;
SU(1):   $rdi = COPY %67:gr64
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
SU(2):   $esi = COPY %73:gr32
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Data Latency=1 Reg=%73
  Successors:
    ExitSU: Ord  Latency=0 Artificial
  Single Issue       : false;
ExitSU:   CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=0 Artificial
    SU(1): Ord  Latency=0 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $esi = COPY %73:gr32
  Ready @0c
  BotQ.A TopLatency SU(2) 1c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 1 0 
  Cand SU(1) ORDER                              
Pick Bot PHYS-REG  
Scheduling SU(1) $rdi = COPY %67:gr64
  Ready @0c
BotQ.A @0c
  Retired: 0
  Executed: 0c
  Critical: 0c, 0 MOps
  ExpectedLatency: 0c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) %73:gr32 = MOVSX32rr8 %89:gr8
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(0) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.11 ***
SU(0):   %73:gr32 = MOVSX32rr8 %89:gr8
SU(1):   $rdi = COPY %67:gr64
SU(2):   $esi = COPY %73:gr32

********** INTERVALS **********
DIL [1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
DIH [1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
HDI [1840r,1888r:1)[1984r,2016r:0)[2120r,2128r:7)[2368r,2400r:6)[2768r,2784r:5)[2848r,2880r:4)[3040r,3072r:3)[3136r,3152r:2)  0@1984r 1@1840r 2@3136r 3@3040r 4@2848r 5@2768r 6@2368r 7@2120r
%1 [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r weight:0.000000e+00
%16 [2480r,2544B:0)[2608B,2688r:0)[2736B,2848r:0)  0@2480r weight:0.000000e+00
%23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:0.000000e+00
%26 [480r,512r:0)  0@480r weight:0.000000e+00
%27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:0.000000e+00
%28 [528r,544r:0)[544r,576r:1)  0@528r 1@544r weight:0.000000e+00
%29 [48r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@48r weight:0.000000e+00
%32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:0.000000e+00
%37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:0.000000e+00
%38 [960r,992r:2)[992r,1024r:0)[1024r,1056r:1)  0@992r 1@1024r 2@960r weight:0.000000e+00
%40 [1120r,1152r:0)  0@1120r weight:0.000000e+00
%42 [1168r,1184r:2)[1184r,1216r:0)[1216r,1248r:1)  0@1184r 1@1216r 2@1168r weight:0.000000e+00
%43 [1312r,1344r:0)  0@1312r weight:0.000000e+00
%48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:0.000000e+00
%54 [1920r,1936r:0)  0@1920r weight:0.000000e+00
%55 [1936r,1952r:0)  0@1936r weight:0.000000e+00
%56 [2048r,2368r:0)  0@2048r weight:0.000000e+00
%60 [2160r,2320r:0)  0@2160r weight:0.000000e+00
%61 [2176r,2272r:0)  0@2176r weight:0.000000e+00
%62 [192r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@192r weight:0.000000e+00
%64 [2192r,2224r:2)[2224r,2256r:0)[2256r,2272r:1)  0@2224r 1@2256r 2@2192r weight:0.000000e+00
%65 [2288r,2304r:0)  0@2288r weight:0.000000e+00
%66 [2320r,2336r:0)  0@2320r weight:0.000000e+00
%67 [2432r,2544B:0)[2608B,3040r:0)  0@2432r weight:0.000000e+00
%68 [2448r,2464r:0)  0@2448r weight:0.000000e+00
%69 [2464r,2480r:0)  0@2464r weight:0.000000e+00
%70 [2816r,2880r:0)  0@2816r weight:0.000000e+00
%73 [3024r,3056r:0)  0@3024r weight:0.000000e+00
%74 [3104r,3136r:0)  0@3104r weight:0.000000e+00
%78 [96r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@96r weight:0.000000e+00
%82 [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi weight:0.000000e+00
%83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:0.000000e+00
%84 [800r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@800r 1@1376r 2@880B-phi weight:0.000000e+00
%85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1744r:4)[1744r,1776r:5)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r 5@1744r weight:0.000000e+00
%87 [720r,768B:0)[784r,880B:4)[880B,1152r:6)[1152r,1568r:5)[1568r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1568r 2@1616B-phi 3@1680r 4@784r 5@1152r 6@880B-phi weight:0.000000e+00
%89 [2688r,2736B:0)[2912r,2960B:1)[2960B,3024r:2)  0@2688r 1@2912r 2@2960B-phi weight:0.000000e+00
RegMasks: 608r 1088r 1280r 1888r 2016r 2128r 2400r 2576r 2784r 2880r 3072r 3152r
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: 4.000000e+00, align=8
  cp#2: 3.000000e+00, align=8
  cp#3: 2.000000e+00, align=8

0B	bb.0.entry:
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

16B	  %82:gr32 = MOV32ri 2
32B	  %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
48B	  %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
64B	  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
80B	  %37:fr64 = FsFLD0SD
96B	  %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
192B	  %62:gr32 = MOV32ri -261
240B	  JMP_1 %bb.2

256B	bb.1.for.cond.cleanup:
	; predecessors: %bb.11

288B	  $eax = MOV32r0 implicit-def dead $eflags
304B	  RET 0, killed $eax

320B	bb.2.for.body:
	; predecessors: %bb.0, %bb.11
	  successors: %bb.3(0x40000000), %bb.12(0x40000000); %bb.3(50.00%), %bb.12(50.00%)

352B	  %23:gr32 = COPY %82:gr32
368B	  %23:gr32 = OR32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
384B	  %1:gr32 = COPY %23:gr32
400B	  %1:gr32 = SHR32ri %1:gr32(tied-def 0), 31, implicit-def dead $eflags
432B	  %1:gr32 = ADD32rr %1:gr32(tied-def 0), %23:gr32, implicit-def dead $eflags
464B	  %1:gr32 = AND32ri8 %1:gr32(tied-def 0), -2, implicit-def dead $eflags
480B	  %26:fr64 = CVTSI2SDrr %1:gr32
496B	  %48:fr64 = COPY %27:fr64
512B	  %48:fr64 = nofpexcept DIVSDrr %48:fr64(tied-def 0), %26:fr64, implicit $mxcsr
528B	  %28:fr64 = COPY %48:fr64
544B	  %28:fr64 = nofpexcept ADDSDrr %28:fr64(tied-def 0), %37:fr64, implicit $mxcsr
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $xmm0 = COPY %28:fr64
592B	  $xmm1 = COPY %29:fr64
608B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
624B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
640B	  %85:fr64 = COPY killed $xmm0
672B	  CMP32ri8 %82:gr32, 3, implicit-def $eflags
688B	  JCC_1 %bb.3, 13, implicit killed $eflags

704B	bb.12:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

720B	  %87:fr64 = FsFLD0SD
752B	  JMP_1 %bb.6

768B	bb.3.for.body.i.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

784B	  %87:fr64 = FsFLD0SD
800B	  %84:gr32 = MOV32ri 2
816B	  %83:fr64 = COPY %32:fr64

880B	bb.4.for.body.i:
	; predecessors: %bb.3, %bb.4
	  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)

960B	  %38:fr64 = CVTSI2SDrr %84:gr32
992B	  %38:fr64 = nofpexcept MULSDrr %38:fr64(tied-def 0), %48:fr64, implicit $mxcsr
1024B	  %38:fr64 = nofpexcept ADDSDrr %38:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1040B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1056B	  $xmm0 = COPY %38:fr64
1072B	  $xmm1 = COPY %29:fr64
1088B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1104B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1120B	  %40:fr64 = COPY killed $xmm0
1152B	  %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
1168B	  %42:fr64 = COPY %48:fr64
1184B	  %42:fr64 = nofpexcept MULSDrr %42:fr64(tied-def 0), %83:fr64, implicit $mxcsr
1216B	  %42:fr64 = nofpexcept ADDSDrr %42:fr64(tied-def 0), %37:fr64, implicit $mxcsr
1232B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1248B	  $xmm0 = COPY %42:fr64
1264B	  $xmm1 = COPY %29:fr64
1280B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $xmm0, implicit killed $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1312B	  %43:fr64 = COPY killed $xmm0
1344B	  %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %43:fr64, implicit $mxcsr
1376B	  %84:gr32 = nuw nsw ADD32ri8 %84:gr32(tied-def 0), 2, implicit-def dead $eflags
1408B	  %83:fr64 = ADDSDrr %83:fr64(tied-def 0), %78:fr64, implicit $mxcsr
1424B	  CMP32rr %84:gr32, %1:gr32, implicit-def $eflags
1504B	  JCC_1 %bb.4, 12, implicit killed $eflags
1520B	  JMP_1 %bb.5

1536B	bb.5.for.end.loopexit.i:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

1568B	  %87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %87:fr64, implicit $mxcsr

1616B	bb.6._Z7simpsonPFddEddi.exit:
	; predecessors: %bb.5, %bb.12
	  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)

1680B	  %87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
1712B	  %85:fr64 = MULSDrr %85:fr64(tied-def 0), %29:fr64, implicit $mxcsr
1744B	  %85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
1776B	  %48:fr64 = nofpexcept MULSDrr %48:fr64(tied-def 0), %85:fr64, implicit $mxcsr
1808B	  %48:fr64 = DIVSDrr %48:fr64(tied-def 0), %32:fr64, implicit $mxcsr
1824B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1840B	  $rdi = MOV32ri64 @_ZSt4cout
1856B	  $rsi = MOV32ri64 @.str
1872B	  $rdx = MOV32ri64 2
1888B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
1904B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1920B	  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
1936B	  %55:gr64 = MOV64rm %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
1952B	  MOV64mi32 %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
1968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1984B	  $rdi = MOV32ri64 @_ZSt4cout
2000B	  $esi = COPY %82:gr32
2016B	  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %56:gr64 = COPY killed $rax
2064B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2096B	  $rsi = MOV32ri64 @.str.1
2112B	  $rdx = MOV32ri64 4
2120B	  $rdi = COPY %56:gr64
2128B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
2144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
2176B	  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2192B	  %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
2224B	  %64:gr32 = AND32rr %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
2256B	  %64:gr32 = ADD32ri8_DB %64:gr32(tied-def 0), 4, implicit-def dead $eflags
2272B	  MOV32mr %56:gr64, 1, %61:gr64_nosp, 24, $noreg, %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
2288B	  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2304B	  MOV64mi32 %56:gr64, 1, %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
2320B	  %66:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2336B	  MOV64mi32 %56:gr64, 1, %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
2352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2368B	  $rdi = COPY %56:gr64
2384B	  $xmm0 = COPY %48:fr64
2400B	  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  %67:gr64 = COPY killed $rax
2448B	  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
2464B	  %69:gr64_nosp = MOV64rm %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
2480B	  %16:gr64 = MOV64rm %67:gr64, 1, %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
2496B	  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
2512B	  JCC_1 %bb.8, 5, implicit killed $eflags
2528B	  JMP_1 %bb.7

2544B	bb.7.if.then.i64:
	; predecessors: %bb.6

2560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2576B	  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

2608B	bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
	; predecessors: %bb.6
	  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)

2624B	  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
2640B	  JCC_1 %bb.10, 4, implicit killed $eflags
2656B	  JMP_1 %bb.9

2672B	bb.9.if.then.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2688B	  %89:gr8 = MOV8rm %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
2720B	  JMP_1 %bb.11

2736B	bb.10.if.end.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

2752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2768B	  $rdi = COPY %16:gr64
2784B	  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
2800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2816B	  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
2832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2848B	  $rdi = COPY %16:gr64
2864B	  $esi = MOV32ri 10
2880B	  CALL64m %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %89:gr8 = COPY killed $al

2960B	bb.11._ZNKSt5ctypeIcE5widenEc.exit:
	; predecessors: %bb.9, %bb.10
	  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)

3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  %73:gr32 = MOVSX32rr8 %89:gr8
3040B	  $rdi = COPY %67:gr64
3056B	  $esi = COPY %73:gr32
3072B	  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3104B	  %74:gr64 = COPY killed $rax
3120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3136B	  $rdi = COPY %74:gr64
3152B	  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3200B	  %82:gr32 = nsw ADD32rr %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
3216B	  CMP32ri %82:gr32, 65537, implicit-def $eflags
3248B	  JCC_1 %bb.2, 2, implicit killed $eflags
3264B	  JMP_1 %bb.1

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB2[for.body]
 - 2: BB12
 - 3: BB3[for.body.i.preheader]
 - 4: BB4[for.body.i]
 - 5: BB5[for.end.loopexit.i]
 - 6: BB6[_Z7simpsonPFddEddi.exit]
 - 7: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - 8: BB9[if.then.i]
 - 9: BB10[if.end.i]
 - 10: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - 11: BB1[for.cond.cleanup]
 - 12: BB7[if.then.i64]
loop-detection
 - loop = BB2[for.body]
 - loop = BB4[for.body.i]
 - loop = BB2[for.body]: member = BB12
 - loop = BB2[for.body]: member = BB3[for.body.i.preheader]
 - loop = BB2[for.body]: member = BB5[for.end.loopexit.i]
 - loop = BB2[for.body]: member = BB6[_Z7simpsonPFddEddi.exit]
 - loop = BB2[for.body]: member = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - loop = BB2[for.body]: member = BB9[if.then.i]
 - loop = BB2[for.body]: member = BB10[if.end.i]
 - loop = BB2[for.body]: member = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB5[for.end.loopexit.i]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB4[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB5[for.end.loopexit.i]
compute-loop-scale: BB4[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [ local  ] weight = 1073741824, succ = BB3[for.body.i.preheader]
  => [ local  ] weight = 1073741824, succ = BB12
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB12
  => assign 8000000000000000 (0000000000000000) to BB3[for.body.i.preheader]
 - node: BB12
  => [ local  ] weight = 2147483648, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB3[for.body.i.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[for.body.i]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[for.body.i]
 - node: BB4[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB5[for.end.loopexit.i]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB5[for.end.loopexit.i]
 - node: BB5[for.end.loopexit.i]
  => [ local  ] weight = 2147483648, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB6[_Z7simpsonPFddEddi.exit]
  => [  exit  ] weight = 2048, succ = BB7[if.then.i64]
  => [ local  ] weight = 2147481600, succ = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => assign 0000100000000000 (0000000000000000) [exit] to BB7[if.then.i64]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => [ local  ] weight = 805306368, succ = BB10[if.end.i]
  => [ local  ] weight = 1342177280, succ = BB9[if.then.i]
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to BB9[if.then.i]
  => assign 5ffffa0000000000 (0000000000000000) to BB10[if.end.i]
 - node: BB9[if.then.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB10[if.end.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB1[for.cond.cleanup]
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to BB2[for.body]
  => assign 07ffff8000000000 (0000000000000000) [exit] to BB1[for.cond.cleanup]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
 - node: BB12
 - node: BB3[for.body.i.preheader]
 - node: BB4[for.body.i]
 - node: BB5[for.end.loopexit.i]
 - node: BB6[_Z7simpsonPFddEddi.exit]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - node: BB9[if.then.i]
 - node: BB10[if.end.i]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 17592186044416, succ = BB7[if.then.i64]
  => [ local  ] weight = 576460202547609600, succ = BB1[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to BB1[for.cond.cleanup]
  => assign 0001fffc00000000 (0000000000000000) to BB7[if.then.i64]
 - node: BB1[for.cond.cleanup]
  => mass:  fffe0003ffffffff
 - node: BB7[if.then.i64]
  => mass:  0001fffc00000000
unwrap-loop-package: BB2[for.body]*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - BB2[for.body]: 1.0 => 31.99905398
 - BB12: 0.5 => 15.99952699
 - BB3[for.body.i.preheader]: 0.5 => 15.99952699
 - BB4[for.body.i]: 32.0 => 1023.969727
 - BB5[for.end.loopexit.i]: 0.5 => 15.99952699
 - BB6[_Z7simpsonPFddEddi.exit]: 1.0 => 31.99905398
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: 0.9999990463 => 31.99902347
 - BB9[if.then.i]: 0.624999404 => 19.99938967
 - BB10[if.end.i]: 0.3749996424 => 11.9996338
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: 0.9999990463 => 31.99902347
unwrap-loop-package: BB4[for.body.i]*: mass = 8000000000000000, scale = 1023.969727
  => combined-scale = 511.9848637
 - BB4[for.body.i]: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - BB0[entry]: float = 1.0, scaled = 262152.0002, int = 262152
 - BB2[for.body]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB12: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB3[for.body.i.preheader]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB4[for.body.i]: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - BB5[for.end.loopexit.i]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB9[if.then.i]: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - BB10[if.end.i]: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB1[for.cond.cleanup]: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - BB7[if.then.i64]: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 262152
 - BB1[for.cond.cleanup]: float = 0.99997, int = 262144
 - BB2[for.body]: float = 31.999, int = 8388616
 - BB12: float = 16.0, int = 4194308
 - BB3[for.body.i.preheader]: float = 16.0, int = 4194308
 - BB4[for.body.i]: float = 511.98, int = 134217856
 - BB5[for.end.loopexit.i]: float = 16.0, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.999, int = 8388616
 - BB7[if.then.i64]: float = 0.000030517, int = 8
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.999, int = 8388608
 - BB9[if.then.i]: float = 19.999, int = 5242880
 - BB10[if.end.i]: float = 12.0, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.999, int = 8388608

********** BASIC REGISTER ALLOCATION **********
********** Function: main
********** Compute Spill Weights **********
********** Function: main
VirtReg:40-> 0(group: FR64)
hints: $xmm0
0 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:43-> 1(group: FR64)
hints: $xmm0
1 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:54-> 2(group: GR64)
2 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:68-> 3(group: GR64)
3 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:69-> 4(group: GR64_NOSP)
4 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:55-> 5(group: GR64)
5 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:64-> 6(group: GR32)
6 can be allocatable among $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:65-> 7(group: GR64_NOSP)
7 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:66-> 8(group: GR64_NOSP)
8 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:42-> 9(group: FR64)
hints: $xmm0
9 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:38-> 10(group: FR64)
hints: $xmm0
10 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:84-> 11(group: GR32)
11 can be allocatable among $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:83-> 12(group: FR64)
12 can be allocatable among 
VirtReg:87-> 13(group: FR64)
13 can be allocatable among 
VirtReg:85-> 14(group: FR64)
hints: $xmm0
14 can be allocatable among 
VirtReg:48-> 15(group: FR64)
hints: $xmm0
15 can be allocatable among 
VirtReg:1-> 16(group: GR32)
16 can be allocatable among $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:56-> 17(group: GR64)
hints: $rdi $rax
17 can be allocatable among $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:23-> 18(group: GR32)
18 can be allocatable among $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:16-> 19(group: GR64)
hints: $rdi
19 can be allocatable among $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:28-> 20(group: FR64)
hints: $xmm0
20 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:60-> 21(group: GR64)
21 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:67-> 22(group: GR64)
hints: $rax $rdi
22 can be allocatable among $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:61-> 23(group: GR64_NOSP)
23 can be allocatable among $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:29-> 24(group: FR64)
hints: $xmm1
24 can be allocatable among 
VirtReg:37-> 25(group: FR64)
25 can be allocatable among 
VirtReg:73-> 26(group: GR32)
hints: $esi
26 can be allocatable among $esi $eax $ecx $edx $r8d $r9d $r10d $r11d $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:74-> 27(group: GR64)
hints: $rax $rdi
27 can be allocatable among $rax $rdi $rcx $rdx $rsi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:26-> 28(group: FR64)
28 can be allocatable among $xmm0 $xmm1 $xmm2 $xmm3 $xmm4 $xmm5 $xmm6 $xmm7 $xmm8 $xmm9 $xmm10 $xmm11 $xmm12 $xmm13 $xmm14 $xmm15 
VirtReg:89-> 29(group: GR8)
AllocationOrder(GR8) = [ $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b ]
hints: $al
29 can be allocatable among $al $cl $dl $sil $dil $r8b $r9b $r10b $r11b $bl $bpl $r14b $r15b $r12b $r13b 
VirtReg:82-> 30(group: GR32)
hints: $esi
30 can be allocatable among $ebx $ebp $r14d $r15d $r12d $r13d 
VirtReg:78-> 31(group: FR64)
31 can be allocatable among 
VirtReg:70-> 32(group: GR64)
32 can be allocatable among $rax $rcx $rdx $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 $rbp 
VirtReg:27-> 33(group: FR64)
33 can be allocatable among 
VirtReg:32-> 34(group: FR64)
34 can be allocatable among 
VirtReg:62-> 35(group: GR32)
35 can be allocatable among $ebx $ebp $r14d $r15d $r12d $r13d 
test!!! regcount = 36

selectOrSplit FR64:%40 [1120r,1152r:0)  0@1120r weight:INF w=INF
hints: $xmm0
assigning %40 to $xmm0: XMM0 [1120r,1152r:0)  0@1120r

selectOrSplit FR64:%43 [1312r,1344r:0)  0@1312r weight:INF w=INF
hints: $xmm0
assigning %43 to $xmm0: XMM0 [1312r,1344r:0)  0@1312r

selectOrSplit GR64:%54 [1920r,1936r:0)  0@1920r weight:INF w=INF
assigning %54 to $rax: AH [1920r,1936r:0)  0@1920r AL [1920r,1936r:0)  0@1920r HAX [1920r,1936r:0)  0@1920r

selectOrSplit GR64:%68 [2448r,2464r:0)  0@2448r weight:INF w=INF
assigning %68 to $rax: AH [2448r,2464r:0)  0@2448r AL [2448r,2464r:0)  0@2448r HAX [2448r,2464r:0)  0@2448r

selectOrSplit GR64_NOSP:%69 [2464r,2480r:0)  0@2464r weight:INF w=INF
assigning %69 to $rax: AH [2464r,2480r:0)  0@2464r AL [2464r,2480r:0)  0@2464r HAX [2464r,2480r:0)  0@2464r

selectOrSplit GR64:%55 [1936r,1952r:0)  0@1936r weight:INF w=INF
assigning %55 to $rax: AH [1936r,1952r:0)  0@1936r AL [1936r,1952r:0)  0@1936r HAX [1936r,1952r:0)  0@1936r

selectOrSplit GR32:%64 [2192r,2224r:2)[2224r,2256r:0)[2256r,2272r:1)  0@2224r 1@2256r 2@2192r weight:INF w=INF
assigning %64 to $eax: AH [2192r,2224r:2)[2224r,2256r:0)[2256r,2272r:1)  0@2224r 1@2256r 2@2192r AL [2192r,2224r:2)[2224r,2256r:0)[2256r,2272r:1)  0@2224r 1@2256r 2@2192r HAX [2192r,2224r:2)[2224r,2256r:0)[2256r,2272r:1)  0@2224r 1@2256r 2@2192r

selectOrSplit GR64_NOSP:%65 [2288r,2304r:0)  0@2288r weight:INF w=INF
assigning %65 to $rax: AH [2288r,2304r:0)  0@2288r AL [2288r,2304r:0)  0@2288r HAX [2288r,2304r:0)  0@2288r

selectOrSplit GR64_NOSP:%66 [2320r,2336r:0)  0@2320r weight:INF w=INF
assigning %66 to $rax: AH [2320r,2336r:0)  0@2320r AL [2320r,2336r:0)  0@2320r HAX [2320r,2336r:0)  0@2320r

selectOrSplit FR64:%42 [1168r,1184r:2)[1184r,1216r:0)[1216r,1248r:1)  0@1184r 1@1216r 2@1168r weight:6.463809e+00 w=6.463809e+00
hints: $xmm0
assigning %42 to $xmm0: XMM0 [1168r,1184r:2)[1184r,1216r:0)[1216r,1248r:1)  0@1184r 1@1216r 2@1168r

selectOrSplit FR64:%38 [960r,992r:2)[992r,1024r:0)[1024r,1056r:1)  0@992r 1@1024r 2@960r weight:6.255299e+00 w=6.255299e+00
hints: $xmm0
assigning %38 to $xmm0: XMM0 [960r,992r:2)[992r,1024r:0)[1024r,1056r:1)  0@992r 1@1024r 2@960r

selectOrSplit GR32:%84 [800r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@800r 1@1376r 2@880B-phi weight:3.625995e+00 w=3.625995e+00
assigning %84 to $ebx: BH [800r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@800r 1@1376r 2@880B-phi BL [800r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@800r 1@1376r 2@880B-phi HBX [800r,880B:0)[880B,1376r:2)[1376r,1536B:1)  0@800r 1@1376r 2@880B-phi

selectOrSplit FR64:%83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:3.252140e+00 w=3.252140e+00
83-> 38, 40, 42, 43, 
spilling: %83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:3.252140e+00
Inline spilling FR64:%83 [816r,880B:0)[880B,1408r:2)[1408r,1536B:1)  0@816r 1@1408r 2@880B-phi weight:3.252140e+00
From original %83
Merged spilled regs: SS#0 [816r,1536B:0)  0@x weight:0.000000e+00
spillAroundUses %83
	reload:   1384r	%91:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
	rewrite: 1408r	%91:fr64 = ADDSDrr %91:fr64(tied-def 0), %78:fr64, implicit $mxcsr

	spill:   1416r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %91:fr64 :: (store 8 into %stack.0)
	folded:   816r	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, %32:fr64 :: (store 8 into %stack.0)
	folded:   1184r	%42:fr64 = nofpexcept MULSDrm %42:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
queuing new interval: %91 [1384r,1408r:1)[1408r,1416r:0)  0@1408r 1@1384r weight:INF

selectOrSplit FR64:%91 [1384r,1408r:1)[1408r,1416r:0)  0@1408r 1@1384r weight:INF w=INF
assigning %91 to $xmm0: XMM0 [1384r,1408r:1)[1408r,1416r:0)  0@1408r 1@1384r

selectOrSplit FR64:%87 [720r,768B:0)[784r,880B:4)[880B,1152r:6)[1152r,1568r:5)[1568r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1568r 2@1616B-phi 3@1680r 4@784r 5@1152r 6@880B-phi weight:2.298652e+00 w=2.298652e+00
87-> 38, 40, 42, 43, 91, 
spilling: %87 [720r,768B:0)[784r,880B:4)[880B,1152r:6)[1152r,1568r:5)[1568r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1568r 2@1616B-phi 3@1680r 4@784r 5@1152r 6@880B-phi weight:2.298652e+00
Inline spilling FR64:%87 [720r,768B:0)[784r,880B:4)[880B,1152r:6)[1152r,1568r:5)[1568r,1616B:1)[1616B,1680r:2)[1680r,1744r:3)  0@720r 1@1568r 2@1616B-phi 3@1680r 4@784r 5@1152r 6@880B-phi weight:2.298652e+00
From original %87
	cannot remat for 1152e	%87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
	cannot remat for 1568e	%87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %87:fr64, implicit $mxcsr
	cannot remat for 1680e	%87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
	cannot remat for 1680e	%87:fr64 = ADDSDrr %87:fr64(tied-def 0), %27:fr64, implicit $mxcsr
	cannot remat for 1744e	%85:fr64 = nofpexcept ADDSDrr %85:fr64(tied-def 0), %87:fr64, implicit $mxcsr
	cannot remat for 1568e	%87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %87:fr64, implicit $mxcsr
	cannot remat for 1152e	%87:fr64 = nofpexcept ADDSDrr %87:fr64(tied-def 0), %40:fr64, implicit $mxcsr
Merged spilled regs: SS#1 [720r,768B:0)[784r,1744r:0)  0@x weight:0.000000e+00
spillAroundUses %87
	reload:   1128r	%92:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
	rewrite: 1152r	%92:fr64 = nofpexcept ADDSDrr %92:fr64(tied-def 0), %40:fr64, implicit $mxcsr

	spill:   1160r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %92:fr64 :: (store 8 into %stack.1)
	rewrite: 784r	%93:fr64 = FsFLD0SD

	spill:   792r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %93:fr64 :: (store 8 into %stack.1)
	reload:   1544r	%94:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
	rewrite: 1568r	%94:fr64 = nofpexcept ADDSDrr %94:fr64(tied-def 0), killed %94:fr64, implicit $mxcsr

	spill:   1576r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %94:fr64 :: (store 8 into %stack.1)
	reload:   1624r	%95:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
	rewrite: 1680r	%95:fr64 = ADDSDrr %95:fr64(tied-def 0), %27:fr64, implicit $mxcsr

	spill:   1688r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %95:fr64 :: (store 8 into %stack.1)
	rewrite: 720r	%96:fr64 = FsFLD0SD

	spill:   728r	MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %96:fr64 :: (store 8 into %stack.1)
	folded:   1744r	%85:fr64 = nofpexcept ADDSDrm %85:fr64(tied-def 0), %stack.1, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
queuing new interval: %92 [1128r,1152r:1)[1152r,1160r:0)  0@1152r 1@1128r weight:INF
queuing new interval: %93 [784r,792r:0)  0@784r weight:INF
queuing new interval: %94 [1544r,1568r:1)[1568r,1576r:0)  0@1568r 1@1544r weight:INF
queuing new interval: %95 [1624r,1680r:1)[1680r,1688r:0)  0@1680r 1@1624r weight:INF
queuing new interval: %96 [720r,728r:0)  0@720r weight:INF

selectOrSplit FR64:%92 [1128r,1152r:1)[1152r,1160r:0)  0@1152r 1@1128r weight:INF w=INF
92-> 40, 
assigning %92 to $xmm1: XMM1 [1128r,1152r:1)[1152r,1160r:0)  0@1152r 1@1128r

selectOrSplit FR64:%93 [784r,792r:0)  0@784r weight:INF w=INF
assigning %93 to $xmm0: XMM0 [784r,792r:0)  0@784r

selectOrSplit FR64:%94 [1544r,1568r:1)[1568r,1576r:0)  0@1568r 1@1544r weight:INF w=INF
assigning %94 to $xmm0: XMM0 [1544r,1568r:1)[1568r,1576r:0)  0@1568r 1@1544r

selectOrSplit FR64:%95 [1624r,1680r:1)[1680r,1688r:0)  0@1680r 1@1624r weight:INF w=INF
assigning %95 to $xmm0: XMM0 [1624r,1680r:1)[1680r,1688r:0)  0@1680r 1@1624r

selectOrSplit FR64:%96 [720r,728r:0)  0@720r weight:INF w=INF
assigning %96 to $xmm0: XMM0 [720r,728r:0)  0@720r

selectOrSplit FR64:%85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1744r:4)[1744r,1776r:5)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r 5@1744r weight:2.146187e+00 w=2.146187e+00
hints: $xmm0
85-> 96, 93, 38, 40, 42, 43, 91, 94, 95, 
85-> 92, 
spilling: %85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1744r:4)[1744r,1776r:5)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r 5@1744r weight:2.146187e+00
Inline spilling FR64:%85 [640r,880B:0)[880B,1344r:2)[1344r,1616B:1)[1616B,1712r:3)[1712r,1744r:4)[1744r,1776r:5)  0@640r 1@1344r 2@880B-phi 3@1616B-phi 4@1712r 5@1744r weight:2.146187e+00
From original %85
Merged spilled regs: SS#2 [640r,1776r:0)  0@x weight:0.000000e+00
spillAroundUses %85
	reload:   1720r	%97:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
	rewrite: 1744r	%97:fr64 = nofpexcept ADDSDrm %97:fr64(tied-def 0), %stack.1, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)

	spill:   1752r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %97:fr64 :: (store 8 into %stack.2)
	reload:   1692r	%98:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
	rewrite: 1712r	%98:fr64 = MULSDrr %98:fr64(tied-def 0), %29:fr64, implicit $mxcsr

	spill:   1716r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %98:fr64 :: (store 8 into %stack.2)
	folded:   640r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.2)
	reload:   1320r	%99:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
	rewrite: 1344r	%99:fr64 = nofpexcept ADDSDrr %99:fr64(tied-def 0), %43:fr64, implicit $mxcsr

	spill:   1352r	MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %99:fr64 :: (store 8 into %stack.2)
	folded:   1776r	%48:fr64 = nofpexcept MULSDrm %48:fr64(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
queuing new interval: %97 [1720r,1744r:1)[1744r,1752r:0)  0@1744r 1@1720r weight:INF
queuing new interval: %98 [1692r,1712r:1)[1712r,1716r:0)  0@1712r 1@1692r weight:INF
queuing new interval: %99 [1320r,1344r:1)[1344r,1352r:0)  0@1344r 1@1320r weight:INF

selectOrSplit FR64:%97 [1720r,1744r:1)[1744r,1752r:0)  0@1744r 1@1720r weight:INF w=INF
assigning %97 to $xmm0: XMM0 [1720r,1744r:1)[1744r,1752r:0)  0@1744r 1@1720r

selectOrSplit FR64:%99 [1320r,1344r:1)[1344r,1352r:0)  0@1344r 1@1320r weight:INF w=INF
99-> 43, 
assigning %99 to $xmm1: XMM1 [1320r,1344r:1)[1344r,1352r:0)  0@1344r 1@1320r

selectOrSplit FR64:%98 [1692r,1712r:1)[1712r,1716r:0)  0@1712r 1@1692r weight:INF w=INF
assigning %98 to $xmm0: XMM0 [1692r,1712r:1)[1712r,1716r:0)  0@1712r 1@1692r

selectOrSplit FR64:%48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:5.791437e-01 w=5.791437e-01
hints: $xmm0
48-> 96, 93, 38, 40, 42, 43, 91, 94, 95, 98, 97, 
48-> 92, 99, 
spilling: %48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:5.791437e-01
Inline spilling FR64:%48 [496r,512r:2)[512r,1776r:0)[1776r,1808r:1)[1808r,2384r:3)  0@512r 1@1776r 2@496r 3@1808r weight:5.791437e-01
From original %48
Merged spilled regs: SS#3 [496r,2384r:0)  0@x weight:0.000000e+00
spillAroundUses %48
	reload:   1756r	%100:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	rewrite: 1776r	%100:fr64 = nofpexcept MULSDrm %100:fr64(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)

	spill:   1784r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %100:fr64 :: (store 8 into %stack.3)
	reload:   1788r	%101:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	rewrite: 1808r	%101:fr64 = DIVSDrr %101:fr64(tied-def 0), %32:fr64, implicit $mxcsr

	spill:   1816r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %101:fr64 :: (store 8 into %stack.3)
	reload:   504r	%102:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	rewrite: 512r	%102:fr64 = nofpexcept DIVSDrr %102:fr64(tied-def 0), %26:fr64, implicit $mxcsr

	spill:   520r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %102:fr64 :: (store 8 into %stack.3)
	folded:   496r	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, %27:fr64 :: (store 8 into %stack.3)
	folded:   528r	%28:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	folded:   992r	%38:fr64 = nofpexcept MULSDrm %38:fr64(tied-def 0), %stack.3, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
	folded:   1168r	%42:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
	folded:   2384r	$xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
queuing new interval: %100 [1756r,1776r:1)[1776r,1784r:0)  0@1776r 1@1756r weight:INF
queuing new interval: %101 [1788r,1808r:1)[1808r,1816r:0)  0@1808r 1@1788r weight:INF
queuing new interval: %102 [504r,512r:1)[512r,520r:0)  0@512r 1@504r weight:INF

selectOrSplit FR64:%100 [1756r,1776r:1)[1776r,1784r:0)  0@1776r 1@1756r weight:INF w=INF
assigning %100 to $xmm0: XMM0 [1756r,1776r:1)[1776r,1784r:0)  0@1776r 1@1756r

selectOrSplit FR64:%101 [1788r,1808r:1)[1808r,1816r:0)  0@1808r 1@1788r weight:INF w=INF
assigning %101 to $xmm0: XMM0 [1788r,1808r:1)[1808r,1816r:0)  0@1808r 1@1788r

selectOrSplit FR64:%102 [504r,512r:1)[512r,520r:0)  0@512r 1@504r weight:INF w=INF
assigning %102 to $xmm0: XMM0 [504r,512r:1)[512r,520r:0)  0@512r 1@504r

selectOrSplit GR32:%1 [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r weight:5.219765e-01 w=5.219765e-01
1-> 84, 
1-> 84, 
1-> 84, 
assigning %1 to $ebp: BPL [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r BPH [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r HBP [384r,400r:3)[400r,432r:2)[432r,464r:0)[464r,704B:1)[768B,1536B:1)  0@432r 1@464r 2@400r 3@384r

selectOrSplit GR64:%56 [2048r,2368r:0)  0@2048r weight:3.591005e-01 w=3.591005e-01
hints: $rdi $rax
56-> 64, 65, 66, 
56-> 64, 65, 66, 
56-> 64, 65, 66, 
assigning %56 to $rbx: BH [2048r,2368r:0)  0@2048r BL [2048r,2368r:0)  0@2048r HBX [2048r,2368r:0)  0@2048r

selectOrSplit GR32:%23 [352r,368r:0)[368r,432r:1)  0@352r 1@368r weight:3.366567e-01 w=3.366567e-01
hints: $ebp
23-> 1, 
23-> 1, 
23-> 1, 
assigning %23 to $eax: AH [352r,368r:0)[368r,432r:1)  0@352r 1@368r AL [352r,368r:0)[368r,432r:1)  0@352r 1@368r HAX [352r,368r:0)[368r,432r:1)  0@352r 1@368r

selectOrSplit GR64:%16 [2480r,2544B:0)[2608B,2688r:0)[2736B,2848r:0)  0@2480r weight:3.315402e-01 w=3.315402e-01
hints: $rdi
assigning %16 to $rbx: BH [2480r,2544B:0)[2608B,2688r:0)[2736B,2848r:0)  0@2480r BL [2480r,2544B:0)[2608B,2688r:0)[2736B,2848r:0)  0@2480r HBX [2480r,2544B:0)[2608B,2688r:0)[2736B,2848r:0)  0@2480r

selectOrSplit FR64:%28 [528r,544r:0)[544r,576r:1)  0@528r 1@544r weight:2.885629e-01 w=2.885629e-01
hints: $xmm0
assigning %28 to $xmm0: XMM0 [528r,544r:0)[544r,576r:1)  0@528r 1@544r

selectOrSplit GR64:%60 [2160r,2320r:0)  0@2160r weight:2.285647e-01 w=2.285647e-01
60-> 64, 65, 
60-> 64, 65, 
60-> 64, 65, 
assigning %60 to $rcx: CH [2160r,2320r:0)  0@2160r CL [2160r,2320r:0)  0@2160r HCX [2160r,2320r:0)  0@2160r

selectOrSplit GR64:%67 [2432r,2544B:0)[2608B,3040r:0)  0@2432r weight:2.054176e-01 w=2.054176e-01
hints: $rax $rdi
67-> 68, 69, 
67-> 68, 69, 
67-> 68, 69, 
67-> 16, 
67-> 16, 
67-> 16, 
assigning %67 to $r14: R14B [2432r,2544B:0)[2608B,3040r:0)  0@2432r R14BH [2432r,2544B:0)[2608B,3040r:0)  0@2432r R14WH [2432r,2544B:0)[2608B,3040r:0)  0@2432r

selectOrSplit GR64_NOSP:%61 [2176r,2272r:0)  0@2176r weight:1.935427e-01 w=1.935427e-01
61-> 64, 
61-> 64, 
61-> 64, 
61-> 60, 
61-> 60, 
61-> 60, 
assigning %61 to $rdx: DH [2176r,2272r:0)  0@2176r DL [2176r,2272r:0)  0@2176r HDX [2176r,2272r:0)  0@2176r

selectOrSplit FR64:%29 [48r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@48r weight:1.570328e-01 w=1.570328e-01
hints: $xmm1
29-> 92, 99, 
29-> 102, 28, 96, 93, 38, 40, 42, 43, 91, 94, 95, 98, 97, 100, 101, 
spilling: %29 [48r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@48r weight:1.570328e-01
Inline spilling FR64:%29 [48r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@48r weight:1.570328e-01
From original %29
	remat:  584r	%103:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
	        592e	$xmm1 = COPY killed %103:fr64

	remat:  1064r	%104:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
	        1072e	$xmm1 = COPY killed %104:fr64

	remat:  1256r	%105:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
	        1264e	$xmm1 = COPY killed %105:fr64

	folded:   1712r	%98:fr64 = MULSDrm %98:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
All defs dead: dead %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 48r	dead %29:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.
queuing new interval: %103 [584r,592r:0)  0@584r weight:INF
queuing new interval: %104 [1064r,1072r:0)  0@1064r weight:INF
queuing new interval: %105 [1256r,1264r:0)  0@1256r weight:INF

selectOrSplit FR64:%103 [584r,592r:0)  0@584r weight:INF w=INF
hints: $xmm1
assigning %103 to $xmm1: XMM1 [584r,592r:0)  0@584r

selectOrSplit FR64:%104 [1064r,1072r:0)  0@1064r weight:INF w=INF
hints: $xmm1
assigning %104 to $xmm1: XMM1 [1064r,1072r:0)  0@1064r

selectOrSplit FR64:%105 [1256r,1264r:0)  0@1256r weight:INF w=INF
hints: $xmm1
assigning %105 to $xmm1: XMM1 [1256r,1264r:0)  0@1256r

selectOrSplit FR64:%37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:1.523010e-01 w=1.523010e-01
37-> 102, 28, 96, 93, 38, 40, 42, 43, 91, 94, 95, 98, 97, 100, 101, 
37-> 103, 104, 92, 105, 99, 
spilling: %37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:1.523010e-01
Inline spilling FR64:%37 [80r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@80r weight:1.523010e-01
From original %37
	folded:   544r	%28:fr64 = nofpexcept ADDSDrm %28:fr64(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
	folded:   1024r	%38:fr64 = nofpexcept ADDSDrm %38:fr64(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
	folded:   1216r	%42:fr64 = nofpexcept ADDSDrm %42:fr64(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
All defs dead: dead %37:fr64 = FsFLD0SD
Remat created 1 dead defs.
Deleting dead def 80r	dead %37:fr64 = FsFLD0SD
0 registers to spill after remat.

selectOrSplit GR32:%73 [3024r,3056r:0)  0@3024r weight:1.496250e-01 w=1.496250e-01
hints: $esi
assigning %73 to $esi: SIL [3024r,3056r:0)  0@3024r SIH [3024r,3056r:0)  0@3024r HSI [3024r,3056r:0)  0@3024r

selectOrSplit GR64:%74 [3104r,3136r:0)  0@3104r weight:1.496250e-01 w=1.496250e-01
hints: $rax $rdi
assigning %74 to $rax: AH [3104r,3136r:0)  0@3104r AL [3104r,3136r:0)  0@3104r HAX [3104r,3136r:0)  0@3104r

selectOrSplit FR64:%26 [480r,512r:0)  0@480r weight:1.481438e-01 w=1.481438e-01
26-> 102, 
assigning %26 to $xmm1: XMM1 [480r,512r:0)  0@480r

selectOrSplit GR8:%89 [2688r,2736B:0)[2912r,2960B:1)[2960B,3024r:2)  0@2688r 1@2912r 2@2960B-phi weight:1.158388e-01 w=1.158388e-01
hints: $al
assigning %89 to $al: AL [2688r,2736B:0)[2912r,2960B:1)[2960B,3024r:2)  0@2688r 1@2912r 2@2960B-phi

selectOrSplit GR32:%82 [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi weight:9.173747e-02 w=9.173747e-02
hints: $esi $eax
82-> 73, 
82-> 73, 
82-> 73, 
82-> 23, 54, 55, 64, 65, 66, 68, 69, 74, 
82-> 23, 54, 55, 64, 65, 66, 68, 69, 89, 74, 
82-> 23, 54, 55, 64, 65, 66, 68, 69, 74, 
82-> 60, 
82-> 60, 
82-> 60, 
82-> 61, 
82-> 61, 
82-> 61, 
82-> 84, 56, 16, 
82-> 84, 56, 16, 
82-> 84, 56, 16, 
82-> 1, 
82-> 1, 
82-> 1, 
82-> 67, 
82-> 67, 
82-> 67, 
assigning %82 to $r15d: R15B [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi R15BH [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi R15WH [16r,256B:0)[320B,2544B:2)[2608B,3200r:2)[3200r,3280B:1)  0@16r 1@3200r 2@320B-phi

selectOrSplit FR64:%78 [96r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@96r weight:7.425953e-02 w=7.425953e-02
78-> 102, 28, 96, 93, 38, 40, 42, 43, 91, 94, 95, 98, 97, 100, 101, 
78-> 26, 103, 104, 92, 105, 99, 
spilling: %78 [96r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@96r weight:7.425953e-02
Inline spilling FR64:%78 [96r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@96r weight:7.425953e-02
From original %78
	folded:   1408r	%91:fr64 = ADDSDrm %91:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
All defs dead: dead %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 96r	dead %78:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.

selectOrSplit GR64:%70 [2816r,2880r:0)  0@2816r weight:5.172256e-02 w=5.172256e-02
assigning %70 to $rax: AH [2816r,2880r:0)  0@2816r AL [2816r,2880r:0)  0@2816r HAX [2816r,2880r:0)  0@2816r

selectOrSplit FR64:%27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:9.330314e-03 w=9.330314e-03
27-> 102, 28, 96, 93, 38, 40, 42, 43, 91, 94, 95, 98, 97, 100, 101, 
27-> 26, 103, 104, 92, 105, 99, 
spilling: %27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:9.330314e-03
Inline spilling FR64:%27 [32r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@32r weight:9.330314e-03
From original %27
	folded:   1680r	%95:fr64 = ADDSDrm %95:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	remat:  488r	%109:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
	        496e	MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %109:fr64 :: (store 8 into %stack.3)

All defs dead: dead %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 32r	dead %27:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.
queuing new interval: %109 [488r,496r:0)  0@488r weight:INF

selectOrSplit FR64:%109 [488r,496r:0)  0@488r weight:INF w=INF
assigning %109 to $xmm0: XMM0 [488r,496r:0)  0@488r

selectOrSplit FR64:%32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:7.098188e-03 w=7.098188e-03
32-> 109, 102, 28, 96, 93, 38, 40, 42, 43, 91, 94, 95, 98, 97, 100, 101, 
32-> 26, 103, 104, 92, 105, 99, 
spilling: %32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:7.098188e-03
Inline spilling FR64:%32 [64r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@64r weight:7.098188e-03
From original %32
	folded:   1808r	%101:fr64 = DIVSDrm %101:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
	remat:  808r	%111:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
	        816e	MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %111:fr64 :: (store 8 into %stack.0)

All defs dead: dead %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
Remat created 1 dead defs.
Deleting dead def 64r	dead %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
0 registers to spill after remat.
queuing new interval: %111 [808r,816r:0)  0@808r weight:INF

selectOrSplit FR64:%111 [808r,816r:0)  0@808r weight:INF w=INF
assigning %111 to $xmm0: XMM0 [808r,816r:0)  0@808r

selectOrSplit GR32:%62 [192r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@192r weight:4.913498e-03 w=4.913498e-03
62-> 23, 54, 55, 64, 65, 66, 68, 69, 70, 74, 
62-> 23, 54, 55, 64, 65, 66, 68, 69, 89, 70, 74, 
62-> 23, 54, 55, 64, 65, 66, 68, 69, 70, 74, 
62-> 60, 
62-> 60, 
62-> 60, 
62-> 61, 
62-> 61, 
62-> 61, 
62-> 73, 
62-> 73, 
62-> 73, 
62-> 84, 56, 16, 
62-> 84, 56, 16, 
62-> 84, 56, 16, 
62-> 1, 
62-> 1, 
62-> 1, 
62-> 67, 
62-> 67, 
62-> 67, 
62-> 82, 
62-> 82, 
62-> 82, 
assigning %62 to $r12d: R12B [192r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@192r R12BH [192r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@192r R12WH [192r,256B:0)[320B,2544B:0)[2608B,3280B:0)  0@192r

For Slot0 and VN1:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot0 and VN0:
Equal spills in BB: 3 
Orders size is 1
BB3,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN5:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN4:
Equal spills in BB: 3 
Orders size is 1
BB3,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN1:
Equal spills in BB: 5 
Orders size is 1
BB5,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN3:
Equal spills in BB: 6 
Orders size is 1
BB6,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot1 and VN0:
Equal spills in BB: 12 
Orders size is 1
BB12,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN5:
Equal spills in BB: 6 
Orders size is 1
BB6,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN4:
Equal spills in BB: 6 
Orders size is 1
BB6,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN0:
Equal spills in BB: 2 
Orders size is 1
BB2,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot2 and VN1:
Equal spills in BB: 4 
Orders size is 1
BB4,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN1:
Equal spills in BB: 6 
Orders size is 1
BB6,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN3:
Equal spills in BB: 6 
Orders size is 1
BB6,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN0:
Equal spills in BB: 2 
Orders size is 1
BB2,
Finally inserted spills in BB: 
Finally removed spills in BB: 

For Slot3 and VN2:
Equal spills in BB: 2 
Orders size is 1
BB2,
Finally inserted spills in BB: 
Finally removed spills in BB: 
Post alloc VirtRegMap:
********** REGISTER MAP **********
[%1 -> $ebp] GR32
[%16 -> $rbx] GR64
[%23 -> $eax] GR32
[%26 -> $xmm1] FR64
[%28 -> $xmm0] FR64
[%38 -> $xmm0] FR64
[%40 -> $xmm0] FR64
[%42 -> $xmm0] FR64
[%43 -> $xmm0] FR64
[%54 -> $rax] GR64
[%55 -> $rax] GR64
[%56 -> $rbx] GR64
[%60 -> $rcx] GR64
[%61 -> $rdx] GR64_NOSP
[%62 -> $r12d] GR32
[%64 -> $eax] GR32
[%65 -> $rax] GR64_NOSP
[%66 -> $rax] GR64_NOSP
[%67 -> $r14] GR64
[%68 -> $rax] GR64
[%69 -> $rax] GR64_NOSP
[%70 -> $rax] GR64
[%73 -> $esi] GR32
[%74 -> $rax] GR64
[%82 -> $r15d] GR32
[%84 -> $ebx] GR32
[%89 -> $al] GR8
[%91 -> $xmm0] FR64
[%92 -> $xmm1] FR64
[%93 -> $xmm0] FR64
[%94 -> $xmm0] FR64
[%95 -> $xmm0] FR64
[%96 -> $xmm0] FR64
[%97 -> $xmm0] FR64
[%98 -> $xmm0] FR64
[%99 -> $xmm1] FR64
[%100 -> $xmm0] FR64
[%101 -> $xmm0] FR64
[%102 -> $xmm0] FR64
[%103 -> $xmm1] FR64
[%104 -> $xmm1] FR64
[%105 -> $xmm1] FR64
[%109 -> $xmm0] FR64
[%111 -> $xmm0] FR64
[%48 -> fi#3] FR64
[%83 -> fi#0] FR64
[%85 -> fi#2] FR64
[%87 -> fi#1] FR64


********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********
[%1 -> $ebp] GR32
[%16 -> $rbx] GR64
[%23 -> $eax] GR32
[%26 -> $xmm1] FR64
[%28 -> $xmm0] FR64
[%38 -> $xmm0] FR64
[%40 -> $xmm0] FR64
[%42 -> $xmm0] FR64
[%43 -> $xmm0] FR64
[%54 -> $rax] GR64
[%55 -> $rax] GR64
[%56 -> $rbx] GR64
[%60 -> $rcx] GR64
[%61 -> $rdx] GR64_NOSP
[%62 -> $r12d] GR32
[%64 -> $eax] GR32
[%65 -> $rax] GR64_NOSP
[%66 -> $rax] GR64_NOSP
[%67 -> $r14] GR64
[%68 -> $rax] GR64
[%69 -> $rax] GR64_NOSP
[%70 -> $rax] GR64
[%73 -> $esi] GR32
[%74 -> $rax] GR64
[%82 -> $r15d] GR32
[%84 -> $ebx] GR32
[%89 -> $al] GR8
[%91 -> $xmm0] FR64
[%92 -> $xmm1] FR64
[%93 -> $xmm0] FR64
[%94 -> $xmm0] FR64
[%95 -> $xmm0] FR64
[%96 -> $xmm0] FR64
[%97 -> $xmm0] FR64
[%98 -> $xmm0] FR64
[%99 -> $xmm1] FR64
[%100 -> $xmm0] FR64
[%101 -> $xmm0] FR64
[%102 -> $xmm0] FR64
[%103 -> $xmm1] FR64
[%104 -> $xmm1] FR64
[%105 -> $xmm1] FR64
[%109 -> $xmm0] FR64
[%111 -> $xmm0] FR64
[%48 -> fi#3] FR64
[%83 -> fi#0] FR64
[%85 -> fi#2] FR64
[%87 -> fi#1] FR64

0B	bb.0.entry:
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

16B	  %82:gr32 = MOV32ri 2
192B	  %62:gr32 = MOV32ri -261
240B	  JMP_1 %bb.2
> renamable $r15d = MOV32ri 2
> renamable $r12d = MOV32ri -261
> JMP_1 %bb.2
256B	bb.1.for.cond.cleanup:
	; predecessors: %bb.11

288B	  $eax = MOV32r0 implicit-def dead $eflags
304B	  RET 0, $eax
> $eax = MOV32r0 implicit-def dead $eflags
> RET 0, $eax
320B	bb.2.for.body:
	; predecessors: %bb.0, %bb.11
	  successors: %bb.3(0x40000000), %bb.12(0x40000000); %bb.3(50.00%), %bb.12(50.00%)
	  liveins: $r12d, $r15d
352B	  %23:gr32 = COPY %82:gr32
368B	  %23:gr32 = OR32ri8 killed %23:gr32(tied-def 0), 1, implicit-def dead $eflags
384B	  %1:gr32 = COPY %23:gr32
400B	  %1:gr32 = SHR32ri killed %1:gr32(tied-def 0), 31, implicit-def dead $eflags
432B	  %1:gr32 = ADD32rr killed %1:gr32(tied-def 0), killed %23:gr32, implicit-def dead $eflags
464B	  %1:gr32 = AND32ri8 killed %1:gr32(tied-def 0), -2, implicit-def dead $eflags
480B	  %26:fr64 = CVTSI2SDrr %1:gr32
488B	  %109:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
496B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %109:fr64 :: (store 8 into %stack.3)
504B	  %102:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
512B	  %102:fr64 = nofpexcept DIVSDrr killed %102:fr64(tied-def 0), killed %26:fr64, implicit $mxcsr
520B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %102:fr64 :: (store 8 into %stack.3)
528B	  %28:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
544B	  %28:fr64 = nofpexcept ADDSDrm killed %28:fr64(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $xmm0 = COPY killed %28:fr64
584B	  %103:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
592B	  $xmm1 = COPY killed %103:fr64
608B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
624B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
640B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.2)
672B	  CMP32ri8 %82:gr32, 3, implicit-def $eflags
688B	  JCC_1 %bb.3, 13, implicit killed $eflags
> renamable $eax = COPY renamable $r15d
> renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
> renamable $ebp = COPY renamable $eax
> renamable $ebp = SHR32ri killed renamable $ebp(tied-def 0), 31, implicit-def dead $eflags
> renamable $ebp = ADD32rr killed renamable $ebp(tied-def 0), killed renamable $eax, implicit-def dead $eflags
> renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
> renamable $xmm1 = CVTSI2SDrr renamable $ebp
> renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept DIVSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
> $xmm1 = COPY killed renamable $xmm1
Identity copy: $xmm1 = COPY killed renamable $xmm1
  deleted.
> CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, $xmm0 :: (store 8 into %stack.2)
> CMP32ri8 renamable $r15d, 3, implicit-def $eflags
> JCC_1 %bb.3, 13, implicit killed $eflags
704B	bb.12:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $r12d, $r15d
720B	  %96:fr64 = FsFLD0SD
728B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %96:fr64 :: (store 8 into %stack.1)
752B	  JMP_1 %bb.6
> renamable $xmm0 = FsFLD0SD
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
> JMP_1 %bb.6
768B	bb.3.for.body.i.preheader:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)
	  liveins: $ebp, $r12d, $r15d
784B	  %93:fr64 = FsFLD0SD
792B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %93:fr64 :: (store 8 into %stack.1)
800B	  %84:gr32 = MOV32ri 2
808B	  %111:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
816B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %111:fr64 :: (store 8 into %stack.0)
> renamable $xmm0 = FsFLD0SD
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
> renamable $ebx = MOV32ri 2
> renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
880B	bb.4.for.body.i:
	; predecessors: %bb.3, %bb.4
	  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)
	  liveins: $ebp, $ebx, $r12d, $r15d
960B	  %38:fr64 = CVTSI2SDrr %84:gr32
992B	  %38:fr64 = nofpexcept MULSDrm killed %38:fr64(tied-def 0), %stack.3, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
1024B	  %38:fr64 = nofpexcept ADDSDrm killed %38:fr64(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
1040B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1056B	  $xmm0 = COPY killed %38:fr64
1064B	  %104:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
1072B	  $xmm1 = COPY killed %104:fr64
1088B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1104B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1120B	  %40:fr64 = COPY $xmm0
1128B	  %92:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
1152B	  %92:fr64 = nofpexcept ADDSDrr killed %92:fr64(tied-def 0), killed %40:fr64, implicit $mxcsr
1160B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %92:fr64 :: (store 8 into %stack.1)
1168B	  %42:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
1184B	  %42:fr64 = nofpexcept MULSDrm killed %42:fr64(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
1216B	  %42:fr64 = nofpexcept ADDSDrm killed %42:fr64(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
1232B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1248B	  $xmm0 = COPY killed %42:fr64
1256B	  %105:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
1264B	  $xmm1 = COPY killed %105:fr64
1280B	  CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1312B	  %43:fr64 = COPY $xmm0
1320B	  %99:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
1344B	  %99:fr64 = nofpexcept ADDSDrr killed %99:fr64(tied-def 0), killed %43:fr64, implicit $mxcsr
1352B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %99:fr64 :: (store 8 into %stack.2)
1376B	  %84:gr32 = nuw nsw ADD32ri8 killed %84:gr32(tied-def 0), 2, implicit-def dead $eflags
1384B	  %91:fr64 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
1408B	  %91:fr64 = ADDSDrm killed %91:fr64(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1416B	  MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed %91:fr64 :: (store 8 into %stack.0)
1424B	  CMP32rr %84:gr32, %1:gr32, implicit-def $eflags
1504B	  JCC_1 %bb.4, 12, implicit killed $eflags
1520B	  JMP_1 %bb.5
> renamable $xmm0 = CVTSI2SDrr renamable $ebx
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), %stack.3, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
> $xmm1 = COPY killed renamable $xmm1
Identity copy: $xmm1 = COPY killed renamable $xmm1
  deleted.
> CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $xmm0 = COPY $xmm0
Identity copy: renamable $xmm0 = COPY $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
> renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm1 :: (store 8 into %stack.1)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), %stack.0, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $xmm0 = COPY killed renamable $xmm0
Identity copy: $xmm0 = COPY killed renamable $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
> $xmm1 = COPY killed renamable $xmm1
Identity copy: $xmm1 = COPY killed renamable $xmm1
  deleted.
> CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $xmm0 = COPY $xmm0
Identity copy: renamable $xmm0 = COPY $xmm0
  deleted.
> renamable $xmm1 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
> renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed renamable $xmm1 :: (store 8 into %stack.2)
> renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
> renamable $xmm0 = MOVSDrm_alt %stack.0, 1, $noreg, 0, $noreg :: (load 8 from %stack.0)
> renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.0, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.0)
> CMP32rr renamable $ebx, renamable $ebp, implicit-def $eflags
> JCC_1 %bb.4, 12, implicit killed $eflags
> JMP_1 %bb.5
1536B	bb.5.for.end.loopexit.i:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)
	  liveins: $r12d, $r15d
1544B	  %94:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
1568B	  %94:fr64 = nofpexcept ADDSDrr killed %94:fr64(tied-def 0), %94:fr64, implicit $mxcsr
1576B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %94:fr64 :: (store 8 into %stack.1)
> renamable $xmm0 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
> renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
1616B	bb.6._Z7simpsonPFddEddi.exit:
	; predecessors: %bb.5, %bb.12
	  successors: %bb.7(0x00000800), %bb.8(0x7ffff800); %bb.7(0.00%), %bb.8(100.00%)
	  liveins: $r12d, $r15d
1624B	  %95:fr64 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
1680B	  %95:fr64 = ADDSDrm killed %95:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1688B	  MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed %95:fr64 :: (store 8 into %stack.1)
1692B	  %98:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
1712B	  %98:fr64 = MULSDrm killed %98:fr64(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1716B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %98:fr64 :: (store 8 into %stack.2)
1720B	  %97:fr64 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
1744B	  %97:fr64 = nofpexcept ADDSDrm killed %97:fr64(tied-def 0), %stack.1, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
1752B	  MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed %97:fr64 :: (store 8 into %stack.2)
1756B	  %100:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
1776B	  %100:fr64 = nofpexcept MULSDrm killed %100:fr64(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
1784B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %100:fr64 :: (store 8 into %stack.3)
1788B	  %101:fr64 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
1808B	  %101:fr64 = DIVSDrm killed %101:fr64(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
1816B	  MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed %101:fr64 :: (store 8 into %stack.3)
1824B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1840B	  $rdi = MOV32ri64 @_ZSt4cout
1856B	  $rsi = MOV32ri64 @.str
1872B	  $rdx = MOV32ri64 2
1888B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
1904B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1920B	  %54:gr64 = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
1936B	  %55:gr64 = MOV64rm killed %54:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
1952B	  MOV64mi32 killed %55:gr64, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
1968B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1984B	  $rdi = MOV32ri64 @_ZSt4cout
2000B	  $esi = COPY %82:gr32
2016B	  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2032B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2048B	  %56:gr64 = COPY $rax
2064B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2096B	  $rsi = MOV32ri64 @.str.1
2112B	  $rdx = MOV32ri64 4
2120B	  $rdi = COPY %56:gr64
2128B	  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
2144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2160B	  %60:gr64 = MOV64rm %56:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
2176B	  %61:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2192B	  %64:gr32 = MOV32rm %56:gr64, 1, %61:gr64_nosp, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
2224B	  %64:gr32 = AND32rr killed %64:gr32(tied-def 0), %62:gr32, implicit-def dead $eflags
2256B	  %64:gr32 = ADD32ri8_DB killed %64:gr32(tied-def 0), 4, implicit-def dead $eflags
2272B	  MOV32mr %56:gr64, 1, killed %61:gr64_nosp, 24, $noreg, killed %64:gr32 :: (store 4 into %ir.5, !tbaa !17)
2288B	  %65:gr64_nosp = MOV64rm %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2304B	  MOV64mi32 %56:gr64, 1, killed %65:gr64_nosp, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
2320B	  %66:gr64_nosp = MOV64rm killed %60:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
2336B	  MOV64mi32 %56:gr64, 1, killed %66:gr64_nosp, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
2352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2368B	  $rdi = COPY killed %56:gr64
2384B	  $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
2400B	  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
2416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  %67:gr64 = COPY $rax
2448B	  %68:gr64 = MOV64rm %67:gr64, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
2464B	  %69:gr64_nosp = MOV64rm killed %68:gr64, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
2480B	  %16:gr64 = MOV64rm %67:gr64, 1, killed %69:gr64_nosp, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
2496B	  TEST64rr %16:gr64, %16:gr64, implicit-def $eflags
2512B	  JCC_1 %bb.8, 5, implicit killed $eflags
2528B	  JMP_1 %bb.7
> renamable $xmm0 = MOVSDrm_alt %stack.1, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
> renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.1, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
> renamable $xmm0 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
> renamable $xmm0 = MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.2)
> renamable $xmm0 = MOVSDrm_alt %stack.2, 1, $noreg, 0, $noreg :: (load 8 from %stack.2)
> renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), %stack.1, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
> MOVSDmr %stack.2, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.2)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), %stack.2, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> renamable $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> renamable $xmm0 = DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
> MOVSDmr %stack.3, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 @_ZSt4cout
> $rsi = MOV32ri64 @.str
> $rdx = MOV32ri64 2
> CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
> renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
> MOV64mi32 killed renamable $rax, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 @_ZSt4cout
> $esi = COPY renamable $r15d
> CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rbx = COPY $rax
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rsi = MOV32ri64 @.str.1
> $rdx = MOV32ri64 4
> $rdi = COPY renamable $rbx
> CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rcx = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
> renamable $rdx = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
> renamable $eax = MOV32rm renamable $rbx, 1, renamable $rdx, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
> renamable $eax = AND32rr killed renamable $eax(tied-def 0), renamable $r12d, implicit-def dead $eflags
> renamable $eax = ADD32ri8_DB killed renamable $eax(tied-def 0), 4, implicit-def dead $eflags
> MOV32mr renamable $rbx, 1, killed renamable $rdx, 24, $noreg, killed renamable $eax :: (store 4 into %ir.5, !tbaa !17)
> renamable $rax = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
> MOV64mi32 renamable $rbx, 1, killed renamable $rax, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
> renamable $rax = MOV64rm killed renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
> MOV64mi32 renamable $rbx, 1, killed renamable $rax, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY killed renamable $rbx
> $xmm0 = MOVSDrm_alt %stack.3, 1, $noreg, 0, $noreg :: (load 8 from %stack.3)
> CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r14 = COPY $rax
> renamable $rax = MOV64rm renamable $r14, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
> renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
> renamable $rbx = MOV64rm renamable $r14, 1, killed renamable $rax, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
> TEST64rr renamable $rbx, renamable $rbx, implicit-def $eflags
> JCC_1 %bb.8, 5, implicit killed $eflags
> JMP_1 %bb.7
2544B	bb.7.if.then.i64:
	; predecessors: %bb.6

2560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2576B	  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
2592B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2608B	bb.8._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
	; predecessors: %bb.6
	  successors: %bb.10(0x30000000), %bb.9(0x50000000); %bb.10(37.50%), %bb.9(62.50%)
	  liveins: $rbx, $r14, $r12d, $r15d
2624B	  CMP8mi %16:gr64, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
2640B	  JCC_1 %bb.10, 4, implicit killed $eflags
2656B	  JMP_1 %bb.9
> CMP8mi renamable $rbx, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
> JCC_1 %bb.10, 4, implicit killed $eflags
> JMP_1 %bb.9
2672B	bb.9.if.then.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)
	  liveins: $rbx, $r14, $r12d, $r15d
2688B	  %89:gr8 = MOV8rm killed %16:gr64, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
2720B	  JMP_1 %bb.11
> renamable $al = MOV8rm killed renamable $rbx, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
> JMP_1 %bb.11
2736B	bb.10.if.end.i:
	; predecessors: %bb.8
	  successors: %bb.11(0x80000000); %bb.11(100.00%)
	  liveins: $rbx, $r14, $r12d, $r15d
2752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2768B	  $rdi = COPY %16:gr64
2784B	  CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
2800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2816B	  %70:gr64 = MOV64rm %16:gr64, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
2832B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2848B	  $rdi = COPY killed %16:gr64
2864B	  $esi = MOV32ri 10
2880B	  CALL64m killed %70:gr64, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
2896B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2912B	  %89:gr8 = COPY $al
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY renamable $rbx
> CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY killed renamable $rbx
> $esi = MOV32ri 10
> CALL64m killed renamable $rax, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $al = COPY $al
Identity copy: renamable $al = COPY $al
  deleted.
2960B	bb.11._ZNKSt5ctypeIcE5widenEc.exit:
	; predecessors: %bb.9, %bb.10
	  successors: %bb.2(0x7c000000), %bb.1(0x04000000); %bb.2(96.88%), %bb.1(3.12%)
	  liveins: $al, $r14, $r12d, $r15d
3008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3024B	  %73:gr32 = MOVSX32rr8 killed %89:gr8
3040B	  $rdi = COPY killed %67:gr64
3056B	  $esi = COPY killed %73:gr32
3072B	  CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
3088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3104B	  %74:gr64 = COPY $rax
3120B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3136B	  $rdi = COPY killed %74:gr64
3152B	  CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
3168B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3200B	  %82:gr32 = nsw ADD32rr killed %82:gr32(tied-def 0), %82:gr32, implicit-def dead $eflags
3216B	  CMP32ri %82:gr32, 65537, implicit-def $eflags
3248B	  JCC_1 %bb.2, 2, implicit killed $eflags
3264B	  JMP_1 %bb.1
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $esi = MOVSX32rr8 killed renamable $al
> $rdi = COPY killed renamable $r14
> $esi = COPY killed renamable $esi
Identity copy: $esi = COPY killed renamable $esi
  deleted.
> CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $rax = COPY $rax
Identity copy: renamable $rax = COPY $rax
  deleted.
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = COPY killed renamable $rax
> CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $r15d = nsw ADD32rr killed renamable $r15d(tied-def 0), renamable $r15d, implicit-def dead $eflags
> CMP32ri renamable $r15d, 65537, implicit-def $eflags
> JCC_1 %bb.2, 2, implicit killed $eflags
> JMP_1 %bb.1
********** Stack Slot Coloring **********
********** Function: main
Spill slot intervals:
SS#0 [816r,1536B:0)  0@x weight:1.551954e+03
SS#1 [720r,768B:0)[784r,1744r:0)  0@x weight:1.183965e+03
SS#2 [640r,1776r:0)  0@x weight:1.215964e+03
SS#3 [496r,2384r:0)  0@x weight:1.311961e+03

Color spill slot intervals:
Assigning fi#0 to fi#0
Assigning fi#3 to fi#1
Assigning fi#2 to fi#2
Assigning fi#1 to fi#3

Spill slots after coloring:
SS#0 [816r,1536B:0)  0@x weight:1.551954e+03
SS#1 [720r,768B:0)[784r,1744r:0)  0@x weight:1.311961e+03
SS#2 [640r,1776r:0)  0@x weight:1.215964e+03
SS#3 [496r,2384r:0)  0@x weight:1.183965e+03

MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: BackwardCopyPropagateBlock for.cond.cleanup
MCP: ForwardCopyPropagateBlock for.cond.cleanup
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: Copy is a deletion candidate:   renamable $eax = COPY renamable $r15d
MCP: Copy is used - not dead:   renamable $eax = COPY renamable $r15d
MCP: Copy is used - not dead:   renamable $eax = COPY renamable $r15d
MCP: Copy is used - not dead:   renamable $eax = COPY renamable $r15d
MCP: Copy is a deletion candidate:   renamable $ebp = COPY renamable $eax
MCP: Copy is used - not dead:   renamable $ebp = COPY renamable $eax
MCP: Copy is used - not dead:   renamable $ebp = COPY renamable $eax
MCP: Copy is used - not dead:   renamable $ebp = COPY renamable $eax
MCP: BackwardCopyPropagateBlock 
MCP: ForwardCopyPropagateBlock 
MCP: BackwardCopyPropagateBlock for.body.i.preheader
MCP: ForwardCopyPropagateBlock for.body.i.preheader
MCP: BackwardCopyPropagateBlock for.body.i
MCP: ForwardCopyPropagateBlock for.body.i
MCP: BackwardCopyPropagateBlock for.end.loopexit.i
MCP: ForwardCopyPropagateBlock for.end.loopexit.i
MCP: BackwardCopyPropagateBlock _Z7simpsonPFddEddi.exit
MCP: ForwardCopyPropagateBlock _Z7simpsonPFddEddi.exit
MCP: Copy is a deletion candidate:   $esi = COPY renamable $r15d
MCP: Copy is used - not dead:   $esi = COPY renamable $r15d
MCP: Copy is used - not dead:   $esi = COPY renamable $r15d
MCP: Copy is used - not dead:   $esi = COPY renamable $r15d
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: Replacing $rbx
     with $rax
     in $rdi = COPY renamable $rbx
     from renamable $rbx = COPY $rax
MCP: After replacement: $rdi = COPY $rax

MCP: Copy is a deletion candidate:   $rdi = COPY $rax
MCP: Copy is used - not dead:   $rdi = COPY $rax
MCP: Copy is used - not dead:   $rdi = COPY $rax
MCP: Copy is used - not dead:   $rdi = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is a deletion candidate:   renamable $r14 = COPY $rax
MCP: Replacing $r14
     with $rax
     in renamable $rax = MOV64rm renamable $r14, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
     from renamable $r14 = COPY $rax
MCP: After replacement: renamable $rax = MOV64rm $rax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)

MCP: Copy is used - not dead:   renamable $r14 = COPY $rax
MCP: Copy is used - not dead:   renamable $r14 = COPY $rax
MCP: Copy is used - not dead:   renamable $r14 = COPY $rax
MCP: BackwardCopyPropagateBlock if.then.i64
MCP: ForwardCopyPropagateBlock if.then.i64
MCP: BackwardCopyPropagateBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
MCP: ForwardCopyPropagateBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
MCP: BackwardCopyPropagateBlock if.then.i
MCP: ForwardCopyPropagateBlock if.then.i
MCP: BackwardCopyPropagateBlock if.end.i
MCP: ForwardCopyPropagateBlock if.end.i
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: BackwardCopyPropagateBlock _ZNKSt5ctypeIcE5widenEc.exit
MCP: ForwardCopyPropagateBlock _ZNKSt5ctypeIcE5widenEc.exit
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $r14
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $rax
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rax
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rax
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rax
******** Post-regalloc Machine LICM: main ********
***** X86 Load Value Injection (LVI) Load Hardening : main *****

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB2[for.body]
 - 2: BB12
 - 3: BB3[for.body.i.preheader]
 - 4: BB4[for.body.i]
 - 5: BB5[for.end.loopexit.i]
 - 6: BB6[_Z7simpsonPFddEddi.exit]
 - 7: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - 8: BB9[if.then.i]
 - 9: BB10[if.end.i]
 - 10: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - 11: BB1[for.cond.cleanup]
 - 12: BB7[if.then.i64]
loop-detection
 - loop = BB2[for.body]
 - loop = BB4[for.body.i]
 - loop = BB2[for.body]: member = BB12
 - loop = BB2[for.body]: member = BB3[for.body.i.preheader]
 - loop = BB2[for.body]: member = BB5[for.end.loopexit.i]
 - loop = BB2[for.body]: member = BB6[_Z7simpsonPFddEddi.exit]
 - loop = BB2[for.body]: member = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - loop = BB2[for.body]: member = BB9[if.then.i]
 - loop = BB2[for.body]: member = BB10[if.end.i]
 - loop = BB2[for.body]: member = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB5[for.end.loopexit.i]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB4[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB5[for.end.loopexit.i]
compute-loop-scale: BB4[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB4[for.body.i]*
 - node: BB4[for.body.i]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [ local  ] weight = 1073741824, succ = BB3[for.body.i.preheader]
  => [ local  ] weight = 1073741824, succ = BB12
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB12
  => assign 8000000000000000 (0000000000000000) to BB3[for.body.i.preheader]
 - node: BB12
  => [ local  ] weight = 2147483648, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB3[for.body.i.preheader]
  => [ local  ] weight = 2147483648, succ = BB4[for.body.i]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[for.body.i]
 - node: BB4[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB5[for.end.loopexit.i]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB5[for.end.loopexit.i]
 - node: BB5[for.end.loopexit.i]
  => [ local  ] weight = 2147483648, succ = BB6[_Z7simpsonPFddEddi.exit]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB6[_Z7simpsonPFddEddi.exit]
 - node: BB6[_Z7simpsonPFddEddi.exit]
  => [  exit  ] weight = 2048, succ = BB7[if.then.i64]
  => [ local  ] weight = 2147481600, succ = BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => assign 0000100000000000 (0000000000000000) [exit] to BB7[if.then.i64]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => [ local  ] weight = 805306368, succ = BB10[if.end.i]
  => [ local  ] weight = 1342177280, succ = BB9[if.then.i]
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to BB9[if.then.i]
  => assign 5ffffa0000000000 (0000000000000000) to BB10[if.end.i]
 - node: BB9[if.then.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB10[if.end.i]
  => [ local  ] weight = 2147483648, succ = BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to BB11[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB1[for.cond.cleanup]
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to BB2[for.body]
  => assign 07ffff8000000000 (0000000000000000) [exit] to BB1[for.cond.cleanup]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
 - node: BB12
 - node: BB3[for.body.i.preheader]
 - node: BB4[for.body.i]
 - node: BB5[for.end.loopexit.i]
 - node: BB6[_Z7simpsonPFddEddi.exit]
 - node: BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - node: BB9[if.then.i]
 - node: BB10[if.end.i]
 - node: BB11[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 17592186044416, succ = BB7[if.then.i64]
  => [ local  ] weight = 576460202547609600, succ = BB1[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to BB1[for.cond.cleanup]
  => assign 0001fffc00000000 (0000000000000000) to BB7[if.then.i64]
 - node: BB1[for.cond.cleanup]
  => mass:  fffe0003ffffffff
 - node: BB7[if.then.i64]
  => mass:  0001fffc00000000
unwrap-loop-package: BB2[for.body]*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - BB2[for.body]: 1.0 => 31.99905398
 - BB12: 0.5 => 15.99952699
 - BB3[for.body.i.preheader]: 0.5 => 15.99952699
 - BB4[for.body.i]: 32.0 => 1023.969727
 - BB5[for.end.loopexit.i]: 0.5 => 15.99952699
 - BB6[_Z7simpsonPFddEddi.exit]: 1.0 => 31.99905398
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: 0.9999990463 => 31.99902347
 - BB9[if.then.i]: 0.624999404 => 19.99938967
 - BB10[if.end.i]: 0.3749996424 => 11.9996338
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: 0.9999990463 => 31.99902347
unwrap-loop-package: BB4[for.body.i]*: mass = 8000000000000000, scale = 1023.969727
  => combined-scale = 511.9848637
 - BB4[for.body.i]: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - BB0[entry]: float = 1.0, scaled = 262152.0002, int = 262152
 - BB2[for.body]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB12: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB3[for.body.i.preheader]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB4[for.body.i]: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - BB5[for.end.loopexit.i]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB9[if.then.i]: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - BB10[if.end.i]: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB1[for.cond.cleanup]: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - BB7[if.then.i64]: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 262152
 - BB1[for.cond.cleanup]: float = 0.99997, int = 262144
 - BB2[for.body]: float = 31.999, int = 8388616
 - BB12: float = 16.0, int = 4194308
 - BB3[for.body.i.preheader]: float = 16.0, int = 4194308
 - BB4[for.body.i]: float = 511.98, int = 134217856
 - BB5[for.end.loopexit.i]: float = 16.0, int = 4194308
 - BB6[_Z7simpsonPFddEddi.exit]: float = 31.999, int = 8388616
 - BB7[if.then.i64]: float = 0.000030517, int = 8
 - BB8[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.999, int = 8388608
 - BB9[if.then.i]: float = 19.999, int = 5242880
 - BB10[if.end.i]: float = 12.0, int = 3145728
 - BB11[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.999, int = 8388608

		Looking for trivial roots
Found a new trivial root: %bb.1
Last visited node: %bb.9
Found a new trivial root: %bb.7
Last visited node: %bb.7
		Looking for non-trivial roots
Total: 13, Num: 14
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.1
3: %bb.11
4: %bb.10
5: %bb.8
6: %bb.6
7: %bb.12
8: %bb.2
9: %bb.0
10: %bb.5
11: %bb.4
12: %bb.3
13: %bb.9
14: %bb.7
Found roots: %bb.1 %bb.7 
**** Analysing main
Look into: 0 entry
Use or define CSR(1) or FI(0): renamable $r15d = MOV32ri 2

No Shrink wrap candidate found
alloc FI(0) at SP[-56]
alloc FI(2) at SP[-64]
alloc FI(3) at SP[-72]
alloc FI(1) at SP[-80]

TryTailMergeBlocks: %bb.1, %bb.7
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.0, %bb.11
  with successor %bb.2
  which has fall-through from %bb.1
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.5, %bb.12
  with successor %bb.6
  which has fall-through from %bb.5
Looking for common tails of at least 3 instructions
Common tail length of %bb.12 and %bb.5 is 1

Splitting %bb.5, size 1
Using common tail in %bb.13 for %bb.12, 

TryTailMergeBlocks: %bb.9, %bb.10
  with successor %bb.11
  which has fall-through from %bb.10
Looking for common tails of at least 3 instructions

Merging into block: bb.7._Z7simpsonPFddEddi.exit:
; predecessors: %bb.6, %bb.3
  successors: %bb.8(0x80000000); %bb.8(100.00%)
  liveins: $r12d, $r15d, $xmm0
  MOVSDmr $rsp, 1, $noreg, 8, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
From MBB: bb.8._Z7simpsonPFddEddi.exit:
; predecessors: %bb.7
  successors: %bb.9(0x00000800), %bb.10(0x7ffff800); %bb.9(0.00%), %bb.10(100.00%)
  liveins: $r12d, $r15d
  renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
  renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  MOVSDmr $rsp, 1, $noreg, 8, $noreg, killed renamable $xmm0 :: (store 8 into %stack.3)
  renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
  renamable $xmm0 = MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  MOVSDmr $rsp, 1, $noreg, 16, $noreg, killed renamable $xmm0 :: (store 8 into %stack.2)
  renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
  renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 8, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
  MOVSDmr $rsp, 1, $noreg, 16, $noreg, killed renamable $xmm0 :: (store 8 into %stack.2)
  renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
  renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 16, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
  MOVSDmr $rsp, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
  renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
  renamable $xmm0 = DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  MOVSDmr $rsp, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store 8 into %stack.1)
  $rdi = MOV32ri64 @_ZSt4cout
  $rsi = MOV32ri64 @.str
  $rdx = MOV32ri64 2
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
  renamable $rax = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
  renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
  MOV64mi32 killed renamable $rax, 1, $noreg, @_ZSt4cout + 16, $noreg, 6 :: (store 8 into %ir.1, !tbaa !7)
  $rdi = MOV32ri64 @_ZSt4cout
  $esi = COPY renamable $r15d
  CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  renamable $rbx = COPY $rax
  $rsi = MOV32ri64 @.str.1
  $rdx = MOV32ri64 4
  $rdi = COPY $rax
  CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
  renamable $rcx = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
  renamable $rdx = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  renamable $eax = MOV32rm renamable $rbx, 1, renamable $rdx, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
  renamable $eax = AND32rr killed renamable $eax(tied-def 0), renamable $r12d, implicit-def dead $eflags
  renamable $eax = ADD32ri8_DB killed renamable $eax(tied-def 0), 4, implicit-def dead $eflags
  MOV32mr renamable $rbx, 1, killed renamable $rdx, 24, $noreg, killed renamable $eax :: (store 4 into %ir.5, !tbaa !17)
  renamable $rax = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 renamable $rbx, 1, killed renamable $rax, 8, $noreg, 16 :: (store 8 into %ir.8, !tbaa !18)
  renamable $rax = MOV64rm killed renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
  MOV64mi32 renamable $rbx, 1, killed renamable $rax, 16, $noreg, 20 :: (store 8 into %ir.10, !tbaa !7)
  $rdi = COPY killed renamable $rbx
  $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
  CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  renamable $r14 = COPY $rax
  renamable $rax = MOV64rm $rax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
  renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
  renamable $rbx = MOV64rm renamable $r14, 1, killed renamable $rax, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
  TEST64rr renamable $rbx, renamable $rbx, implicit-def $eflags
  JCC_1 %bb.10, 5, implicit killed $eflags

Removing MBB: bb.8._Z7simpsonPFddEddi.exit:
  liveins: $r12d, $r15d

Moving MBB: bb.9.if.then.i64:
; predecessors: %bb.7

  CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
To make fallthrough to: bb.10._ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit:
; predecessors: %bb.7
  successors: %bb.12(0x30000000), %bb.11(0x50000000); %bb.12(37.50%), %bb.11(62.50%)
  liveins: $rbx, $r14, $r12d, $r15d
  CMP8mi renamable $rbx, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
  JCC_1 %bb.12, 4, implicit killed $eflags
  JMP_1 %bb.11


TryTailMergeBlocks: %bb.1, %bb.9
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.0, %bb.13
  with successor %bb.2
  which has fall-through from %bb.0
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.6, %bb.3
  with successor %bb.7
  which has fall-through from %bb.6
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.11, %bb.12
  with successor %bb.13
  which has fall-through from %bb.12
Looking for common tails of at least 3 instructions

Removing MBB: bb.2:
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $r12d, $r15d, $xmm0

TryTailMergeBlocks: %bb.11, %bb.12
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.0, %bb.10
  with successor %bb.1
  which has fall-through from %bb.0
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.5, %bb.1
  with successor %bb.6
  which has fall-through from %bb.5
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.8, %bb.9
  with successor %bb.10
  which has fall-through from %bb.9
Looking for common tails of at least 3 instructions

*** Tail-duplicating %bb.7

*** Tail-duplicating %bb.11
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: Copy is a deletion candidate:   renamable $eax = COPY renamable $r15d
MCP: Copy is used - not dead:   renamable $eax = COPY renamable $r15d
MCP: Copy is used - not dead:   renamable $eax = COPY renamable $r15d
MCP: Copy is used - not dead:   renamable $eax = COPY renamable $r15d
MCP: Copy is a deletion candidate:   renamable $ebp = COPY renamable $eax
MCP: Copy is used - not dead:   renamable $ebp = COPY renamable $eax
MCP: Copy is used - not dead:   renamable $ebp = COPY renamable $eax
MCP: Copy is used - not dead:   renamable $ebp = COPY renamable $eax
MCP: BackwardCopyPropagateBlock for.body.i.preheader
MCP: ForwardCopyPropagateBlock for.body.i.preheader
MCP: BackwardCopyPropagateBlock for.body.i
MCP: ForwardCopyPropagateBlock for.body.i
MCP: BackwardCopyPropagateBlock for.end.loopexit.i
MCP: ForwardCopyPropagateBlock for.end.loopexit.i
MCP: BackwardCopyPropagateBlock _Z7simpsonPFddEddi.exit
MCP: ForwardCopyPropagateBlock _Z7simpsonPFddEddi.exit
MCP: Copy is a deletion candidate:   $esi = COPY renamable $r15d
MCP: Copy is used - not dead:   $esi = COPY renamable $r15d
MCP: Copy is used - not dead:   $esi = COPY renamable $r15d
MCP: Copy is used - not dead:   $esi = COPY renamable $r15d
MCP: Copy is a deletion candidate:   renamable $rbx = COPY $rax
MCP: Copy is a deletion candidate:   $rdi = COPY $rax
MCP: Copy is used - not dead:   $rdi = COPY $rax
MCP: Copy is used - not dead:   $rdi = COPY $rax
MCP: Copy is used - not dead:   $rdi = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is used - not dead:   renamable $rbx = COPY $rax
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is a deletion candidate:   renamable $r14 = COPY $rax
MCP: Copy is used - not dead:   renamable $r14 = COPY $rax
MCP: Copy is used - not dead:   renamable $r14 = COPY $rax
MCP: Copy is used - not dead:   renamable $r14 = COPY $rax
MCP: BackwardCopyPropagateBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
MCP: ForwardCopyPropagateBlock _ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit
MCP: BackwardCopyPropagateBlock if.then.i
MCP: ForwardCopyPropagateBlock if.then.i
MCP: BackwardCopyPropagateBlock if.end.i
MCP: ForwardCopyPropagateBlock if.end.i
MCP: Copy is a deletion candidate:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY renamable $rbx
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rbx
MCP: BackwardCopyPropagateBlock _ZNKSt5ctypeIcE5widenEc.exit
MCP: ForwardCopyPropagateBlock _ZNKSt5ctypeIcE5widenEc.exit
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $r14
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $r14
MCP: Copy is a deletion candidate:   $rdi = COPY killed renamable $rax
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rax
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rax
MCP: Copy is used - not dead:   $rdi = COPY killed renamable $rax
MCP: BackwardCopyPropagateBlock for.cond.cleanup
MCP: ForwardCopyPropagateBlock for.cond.cleanup
MCP: BackwardCopyPropagateBlock if.then.i64
MCP: ForwardCopyPropagateBlock if.then.i64
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
real copy:   renamable $eax = COPY renamable $r15d
replaced by: $eax = MOV32rr $r15d
real copy:   renamable $ebp = COPY renamable $eax
replaced by: $ebp = MOV32rr $eax
real copy:   $esi = COPY renamable $r15d
replaced by: $esi = MOV32rr $r15d
real copy:   renamable $rbx = COPY $rax
replaced by: $rbx = MOV64rr $rax
real copy:   $rdi = COPY $rax
replaced by: $rdi = MOV64rr $rax
real copy:   $rdi = COPY killed renamable $rbx
replaced by: $rdi = MOV64rr killed $rbx
real copy:   renamable $r14 = COPY $rax
replaced by: $r14 = MOV64rr $rax
real copy:   $rdi = COPY renamable $rbx
replaced by: $rdi = MOV64rr $rbx
real copy:   $rdi = COPY killed renamable $rbx
replaced by: $rdi = MOV64rr killed $rbx
real copy:   $rdi = COPY killed renamable $r14
replaced by: $rdi = MOV64rr killed $r14
real copy:   $rdi = COPY killed renamable $rax
replaced by: $rdi = MOV64rr killed $rax

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body]
 - 2: BB2[for.body.i.preheader]
 - 3: BB3[for.body.i]
 - 4: BB4[for.end.loopexit.i]
 - 5: BB5[_Z7simpsonPFddEddi.exit]
 - 6: BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - 7: BB7[if.then.i]
 - 8: BB8[if.end.i]
 - 9: BB9[_ZNKSt5ctypeIcE5widenEc.exit]
 - 10: BB10[for.cond.cleanup]
 - 11: BB11[if.then.i64]
loop-detection
 - loop = BB1[for.body]
 - loop = BB3[for.body.i]
 - loop = BB1[for.body]: member = BB2[for.body.i.preheader]
 - loop = BB1[for.body]: member = BB4[for.end.loopexit.i]
 - loop = BB1[for.body]: member = BB5[_Z7simpsonPFddEddi.exit]
 - loop = BB1[for.body]: member = BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - loop = BB1[for.body]: member = BB7[if.then.i]
 - loop = BB1[for.body]: member = BB8[if.end.i]
 - loop = BB1[for.body]: member = BB9[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-loop: BB3[for.body.i]*
 - node: BB3[for.body.i]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB4[for.end.loopexit.i]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[for.body.i]
  => assign 0800000000000000 (0000000000000000) [exit] to BB4[for.end.loopexit.i]
compute-loop-scale: BB3[for.body.i]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[for.body.i]*
 - node: BB3[for.body.i]
compute-mass-in-loop: BB1[for.body]*
 - node: BB1[for.body]
  => [ local  ] weight = 1073741824, succ = BB2[for.body.i.preheader]
  => [ local  ] weight = 1073741824, succ = BB5[_Z7simpsonPFddEddi.exit]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB2[for.body.i.preheader]
  => assign 8000000000000000 (0000000000000000) to BB5[_Z7simpsonPFddEddi.exit]
 - node: BB2[for.body.i.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[for.body.i]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB3[for.body.i]
 - node: BB3[for.body.i]
  => [ local  ] weight = 576460752303423488, succ = BB4[for.end.loopexit.i]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB4[for.end.loopexit.i]
 - node: BB4[for.end.loopexit.i]
  => [ local  ] weight = 2147483648, succ = BB5[_Z7simpsonPFddEddi.exit]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB5[_Z7simpsonPFddEddi.exit]
 - node: BB5[_Z7simpsonPFddEddi.exit]
  => [  exit  ] weight = 2048, succ = BB11[if.then.i64]
  => [ local  ] weight = 2147481600, succ = BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => mass:  ffffffffffffffff
  => assign ffffefffffffffff (0000100000000000) to BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => assign 0000100000000000 (0000000000000000) [exit] to BB11[if.then.i64]
 - node: BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
  => [ local  ] weight = 805306368, succ = BB8[if.end.i]
  => [ local  ] weight = 1342177280, succ = BB7[if.then.i]
  => mass:  ffffefffffffffff
  => assign 9ffff5ffffffffff (5ffffa0000000000) to BB7[if.then.i]
  => assign 5ffffa0000000000 (0000000000000000) to BB8[if.end.i]
 - node: BB7[if.then.i]
  => [ local  ] weight = 2147483648, succ = BB9[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  9ffff5ffffffffff
  => assign 9ffff5ffffffffff (0000000000000000) to BB9[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB8[if.end.i]
  => [ local  ] weight = 2147483648, succ = BB9[_ZNKSt5ctypeIcE5widenEc.exit]
  => mass:  5ffffa0000000000
  => assign 5ffffa0000000000 (0000000000000000) to BB9[_ZNKSt5ctypeIcE5widenEc.exit]
 - node: BB9[_ZNKSt5ctypeIcE5widenEc.exit]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB10[for.cond.cleanup]
  => mass:  ffffefffffffffff
  => assign f7fff07fffffffff (07ffff8000000000) [back] to BB1[for.body]
  => assign 07ffff8000000000 (0000000000000000) [exit] to BB10[for.cond.cleanup]
compute-loop-scale: BB1[for.body]*
 - exit-mass = 08000f8000000000 (ffffffffffffffff - f7fff07fffffffff)
 - scale = 31.99905398
packaging-loop: BB1[for.body]*
 - node: BB1[for.body]
 - node: BB2[for.body.i.preheader]
 - node: BB3[for.body.i]
 - node: BB4[for.end.loopexit.i]
 - node: BB5[_Z7simpsonPFddEddi.exit]
 - node: BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]
 - node: BB7[if.then.i]
 - node: BB8[if.end.i]
 - node: BB9[_ZNKSt5ctypeIcE5widenEc.exit]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 2147483648, succ = BB1[for.body]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[for.body]
 - node: BB1[for.body]
  => [ local  ] weight = 17592186044416, succ = BB11[if.then.i64]
  => [ local  ] weight = 576460202547609600, succ = BB10[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign fffe0003ffffffff (0001fffc00000000) to BB10[for.cond.cleanup]
  => assign 0001fffc00000000 (0000000000000000) to BB11[if.then.i64]
 - node: BB10[for.cond.cleanup]
  => mass:  fffe0003ffffffff
 - node: BB11[if.then.i64]
  => mass:  0001fffc00000000
unwrap-loop-package: BB1[for.body]*: mass = ffffffffffffffff, scale = 31.99905398
  => combined-scale = 31.99905398
 - BB1[for.body]: 1.0 => 31.99905398
 - BB2[for.body.i.preheader]: 0.5 => 15.99952699
 - BB3[for.body.i]: 32.0 => 1023.969727
 - BB4[for.end.loopexit.i]: 0.5 => 15.99952699
 - BB5[_Z7simpsonPFddEddi.exit]: 1.0 => 31.99905398
 - BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: 0.9999990463 => 31.99902347
 - BB7[if.then.i]: 0.624999404 => 19.99938967
 - BB8[if.end.i]: 0.3749996424 => 11.9996338
 - BB9[_ZNKSt5ctypeIcE5widenEc.exit]: 0.9999990463 => 31.99902347
unwrap-loop-package: BB3[for.body.i]*: mass = 7fffffffffffffff, scale = 1023.969727
  => combined-scale = 511.9848637
 - BB3[for.body.i]: 1.0 => 511.9848637
float-to-int: min = 0.0000305166468, max = 511.9848637, factor = 262152.0002
 - BB0[entry]: float = 1.0, scaled = 262152.0002, int = 262152
 - BB1[for.body]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB2[for.body.i.preheader]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB3[for.body.i]: float = 511.9848637, scaled = 134217856.1, int = 134217856
 - BB4[for.end.loopexit.i]: float = 15.99952699, scaled = 4194308.004, int = 4194308
 - BB5[_Z7simpsonPFddEddi.exit]: float = 31.99905398, scaled = 8388616.008, int = 8388616
 - BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB7[if.then.i]: float = 19.99938967, scaled = 5242880.005, int = 5242880
 - BB8[if.end.i]: float = 11.9996338, scaled = 3145728.003, int = 3145728
 - BB9[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.99902347, scaled = 8388608.008, int = 8388608
 - BB10[for.cond.cleanup]: float = 0.9999694834, scaled = 262144.0002, int = 262144
 - BB11[if.then.i64]: float = 0.0000305166468, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 262152
 - BB1[for.body]: float = 31.999, int = 8388616
 - BB2[for.body.i.preheader]: float = 16.0, int = 4194308
 - BB3[for.body.i]: float = 511.98, int = 134217856
 - BB4[for.end.loopexit.i]: float = 16.0, int = 4194308
 - BB5[_Z7simpsonPFddEddi.exit]: float = 31.999, int = 8388616
 - BB6[_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit]: float = 31.999, int = 8388608
 - BB7[if.then.i]: float = 19.999, int = 5242880
 - BB8[if.end.i]: float = 12.0, int = 3145728
 - BB9[_ZNKSt5ctypeIcE5widenEc.exit]: float = 31.999, int = 8388608
 - BB10[for.cond.cleanup]: float = 0.99997, int = 262144
 - BB11[if.then.i64]: float = 0.000030517, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.10
Last visited node: %bb.7
Found a new trivial root: %bb.11
Last visited node: %bb.11
		Looking for non-trivial roots
Total: 12, Num: 13
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.10
3: %bb.9
4: %bb.8
5: %bb.6
6: %bb.5
7: %bb.1
8: %bb.0
9: %bb.4
10: %bb.3
11: %bb.2
12: %bb.7
13: %bb.11
Found roots: %bb.10 %bb.11 
Pre-computing triangle chains.
Finding best loop top for: %bb.3 ('for.body.i')
    final top unchanged
Finding best loop exit for: %bb.3 ('for.body.i')
    exiting: %bb.3 ('for.body.i') -> %bb.4 ('for.end.loopexit.i') [L:1] (15.99952699)
    No other candidate exit blocks, using loop header
Selecting best successor for: %bb.3 ('for.body.i')
Finished forming chain for header block %bb.3 ('for.body.i')
          ... %bb.3 ('for.body.i')
Finding best loop top for: %bb.1 ('for.body')
   old top pred: %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit'), has 2 successors, 31.99902347 freq
    final top: %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit')
Finding best loop top for: %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit')
   old top pred: %bb.7 ('if.then.i'), has 1 successors, 19.99938967 freq
   old top pred: %bb.8 ('if.end.i'), has 1 successors, 11.9996338 freq
    final top: %bb.8 ('if.end.i')
Finding best loop top for: %bb.8 ('if.end.i')
   old top pred: %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'), has 2 successors, 31.99902347 freq
    final top unchanged
Selecting best successor for: %bb.8 ('if.end.i')
Merging from %bb.8 ('if.end.i') to %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit')
Selecting best successor for: %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit')
Merging from %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit') to %bb.1 ('for.body')
Selecting best successor for: %bb.1 ('for.body')
    Candidate: %bb.2 ('for.body.i.preheader'), probability: 0x40000000 / 0x80000000 = 50.00%
    Setting it as best candidate
    Not a candidate: %bb.5 ('_Z7simpsonPFddEddi.exit') -> 0x40000000 / 0x80000000 = 50.00% (prob) (non-cold CFG conflict)
    Selected: %bb.2 ('for.body.i.preheader')
Merging from %bb.1 ('for.body') to %bb.2 ('for.body.i.preheader')
Selecting best successor for: %bb.2 ('for.body.i.preheader')
    Candidate: %bb.3 ('for.body.i'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.3 ('for.body.i')
Merging from %bb.2 ('for.body.i.preheader') to %bb.3 ('for.body.i')
Selecting best successor for: %bb.3 ('for.body.i')
    Candidate: %bb.4 ('for.end.loopexit.i'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.4 ('for.end.loopexit.i')
Merging from %bb.3 ('for.body.i') to %bb.4 ('for.end.loopexit.i')
Selecting best successor for: %bb.4 ('for.end.loopexit.i')
    Candidate: %bb.5 ('_Z7simpsonPFddEddi.exit'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.5 ('_Z7simpsonPFddEddi.exit')
Merging from %bb.4 ('for.end.loopexit.i') to %bb.5 ('_Z7simpsonPFddEddi.exit')
Selecting best successor for: %bb.5 ('_Z7simpsonPFddEddi.exit')
    Candidate: %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit')
Merging from %bb.5 ('_Z7simpsonPFddEddi.exit') to %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit')
Selecting best successor for: %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit')
    Candidate: %bb.7 ('if.then.i'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.7 ('if.then.i')
Merging from %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit') to %bb.7 ('if.then.i')
Selecting best successor for: %bb.7 ('if.then.i')
Finished forming chain for header block %bb.8 ('if.end.i')
          ... %bb.8 ('if.end.i')
          ... %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit')
          ... %bb.1 ('for.body')
          ... %bb.2 ('for.body.i.preheader')
          ... %bb.3 ('for.body.i')
          ... %bb.4 ('for.end.loopexit.i')
          ... %bb.5 ('_Z7simpsonPFddEddi.exit')
          ... %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit')
          ... %bb.7 ('if.then.i')
    %bb.1 ('for.body') -> Mid chain!
Selecting best successor for: %bb.0 ('entry')
    %bb.8 ('if.end.i') -> 11.9996338 (freq)
Merging from %bb.0 ('entry') to %bb.8 ('if.end.i')
Selecting best successor for: %bb.7 ('if.then.i')
    %bb.10 ('for.cond.cleanup') -> 0.9999694834 (freq)
    %bb.11 ('if.then.i64') -> 0.00003051664683 (freq)
Merging from %bb.7 ('if.then.i') to %bb.10 ('for.cond.cleanup')
Selecting best successor for: %bb.10 ('for.cond.cleanup')
    %bb.11 ('if.then.i64') -> 0.00003051664683 (freq)
Merging from %bb.10 ('for.cond.cleanup') to %bb.11 ('if.then.i64')
Selecting best successor for: %bb.11 ('if.then.i64')
Finished forming chain for header block %bb.0 ('entry')
[MBP] Function: main
Placing chain %bb.0 ('entry')
          ... %bb.8 ('if.end.i')
Updating terminators on %bb.0
          ... %bb.9 ('_ZNKSt5ctypeIcE5widenEc.exit')
Updating terminators on %bb.8
          ... %bb.1 ('for.body')
Updating terminators on %bb.9
          ... %bb.2 ('for.body.i.preheader')
Updating terminators on %bb.1
          ... %bb.3 ('for.body.i')
Updating terminators on %bb.2
          ... %bb.4 ('for.end.loopexit.i')
Updating terminators on %bb.3
          ... %bb.5 ('_Z7simpsonPFddEddi.exit')
Updating terminators on %bb.4
          ... %bb.6 ('_ZSt13__check_facetISt5ctypeIcEERKT_PS3_.exit')
Updating terminators on %bb.5
          ... %bb.7 ('if.then.i')
Updating terminators on %bb.6
          ... %bb.10 ('for.cond.cleanup')
Updating terminators on %bb.7
          ... %bb.11 ('if.then.i64')
Updating terminators on %bb.11

TryTailMergeBlocks: %bb.10, %bb.11
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.7, %bb.8
  with successor %bb.9
  which has fall-through from %bb.8
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.4, %bb.1
  with successor %bb.5
  which has fall-through from %bb.4
Looking for common tails of at least 3 instructions
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
$eip:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
$eiz:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
$es:	0	frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
$eip:	2	frame-setup PUSH64r killed $r15, implicit-def $rsp, implicit $rsp
$eiz:	2	frame-setup PUSH64r killed $r15, implicit-def $rsp, implicit $rsp
$es:	2	frame-setup PUSH64r killed $r15, implicit-def $rsp, implicit $rsp
$eip:	4	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eiz:	4	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$es:	4	frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
$eip:	6	frame-setup PUSH64r killed $r12, implicit-def $rsp, implicit $rsp
$eiz:	6	frame-setup PUSH64r killed $r12, implicit-def $rsp, implicit $rsp
$es:	6	frame-setup PUSH64r killed $r12, implicit-def $rsp, implicit $rsp
$eip:	8	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eiz:	8	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$es:	8	frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
$eip:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$eiz:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$es:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$dx:	10	$rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$mm2:	17	renamable $r15d = MOV32ri 2
$mm3:	17	renamable $r15d = MOV32ri 2
$mm4:	17	renamable $r15d = MOV32ri 2
$k1:	18	renamable $r12d = MOV32ri -261
$k2:	18	renamable $r12d = MOV32ri -261
$k3:	18	renamable $r12d = MOV32ri -261
%bb.1: incomplete
$noreg:	0	$eax = MOV32rr $r15d
$ah:	0	$eax = MOV32rr $r15d
$dh:	0	$eax = MOV32rr $r15d
$noreg:	1	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
$ah:	1	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
$dh:	1	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
$dx:	1	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
$bh:	2	$ebp = MOV32rr $eax
$bl:	2	$ebp = MOV32rr $eax
$di:	2	$ebp = MOV32rr $eax
$bh:	3	renamable $ebp = SHR32ri killed renamable $ebp(tied-def 0), 31, implicit-def dead $eflags
$bl:	3	renamable $ebp = SHR32ri killed renamable $ebp(tied-def 0), 31, implicit-def dead $eflags
$di:	3	renamable $ebp = SHR32ri killed renamable $ebp(tied-def 0), 31, implicit-def dead $eflags
$dx:	3	renamable $ebp = SHR32ri killed renamable $ebp(tied-def 0), 31, implicit-def dead $eflags
$bh:	4	renamable $ebp = ADD32rr killed renamable $ebp(tied-def 0), killed renamable $eax, implicit-def dead $eflags
$bl:	4	renamable $ebp = ADD32rr killed renamable $ebp(tied-def 0), killed renamable $eax, implicit-def dead $eflags
$di:	4	renamable $ebp = ADD32rr killed renamable $ebp(tied-def 0), killed renamable $eax, implicit-def dead $eflags
$dx:	4	renamable $ebp = ADD32rr killed renamable $ebp(tied-def 0), killed renamable $eax, implicit-def dead $eflags
$bh:	5	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$bl:	5	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$di:	5	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$dx:	5	renamable $ebp = AND32ri8 killed renamable $ebp(tied-def 0), -2, implicit-def dead $eflags
$st6:	6	renamable $xmm1 = CVTSI2SDrr renamable $ebp
$st5:	7	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
$st5:	9	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	10	renamable $xmm0 = nofpexcept DIVSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
$st5:	12	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	13	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$st6:	14	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$eip:	15	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	15	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	15	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	15	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	15	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	17	renamable $xmm0 = XORPSrr undef $xmm0(tied-def 0), undef $xmm0
$dx:	18	CMP32ri8 renamable $r15d, 3, implicit-def $eflags
%bb.2: incomplete
$al:	1	renamable $ebx = MOV32ri 2
$ax:	1	renamable $ebx = MOV32ri 2
$dih:	1	renamable $ebx = MOV32ri 2
$st5:	2	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
%bb.3: incomplete
$st5:	0	renamable $xmm0 = CVTSI2SDrr renamable $ebx
$st5:	1	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
$st5:	2	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$st6:	3	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$eip:	4	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	4	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	4	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	4	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	4	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st6:	5	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$st6:	6	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$st5:	8	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	9	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$st5:	10	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$st6:	11	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$eip:	12	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$eiz:	12	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$es:	12	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$hbp:	12	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st5:	12	CALL64pcrel32 @pow, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit-def $rsp, implicit-def $ssp, implicit-def $xmm0
$st6:	13	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$st6:	14	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$al:	16	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$ax:	16	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$dih:	16	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$dx:	16	renamable $ebx = nuw nsw ADD32ri8 killed renamable $ebx(tied-def 0), 2, implicit-def dead $eflags
$st5:	17	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 24, $noreg :: (load 8 from %stack.0)
$st5:	18	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$dx:	20	CMP32rr renamable $ebx, renamable $ebp, implicit-def $eflags
%bb.4: incomplete
$st5:	0	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$st5:	1	renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
%bb.5: incomplete
$st5:	1	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$st5:	2	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st5:	4	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$st5:	5	renamable $xmm0 = MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$st5:	7	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$st5:	8	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 8, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$st5:	10	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	11	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 16, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
$st5:	13	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$st5:	14	renamable $xmm0 = DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$cl:	16	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$cs:	16	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$dl:	16	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$cl:	16	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$cs:	16	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$dl:	16	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$edi:	17	$esi = MOV32ri @.str, implicit-def $rsi
$edx:	17	$esi = MOV32ri @.str, implicit-def $rsi
$eflags:	17	$esi = MOV32ri @.str, implicit-def $rsi
$edi:	17	$esi = MOV32ri @.str, implicit-def $rsi
$edx:	17	$esi = MOV32ri @.str, implicit-def $rsi
$eflags:	17	$esi = MOV32ri @.str, implicit-def $rsi
$ch:	18	$edx = MOV32ri 2, implicit-def $rdx
$cx:	18	$edx = MOV32ri 2, implicit-def $rdx
$ds:	18	$edx = MOV32ri 2, implicit-def $rdx
$ch:	18	$edx = MOV32ri 2, implicit-def $rdx
$cx:	18	$edx = MOV32ri 2, implicit-def $rdx
$ds:	18	$edx = MOV32ri 2, implicit-def $rdx
$eip:	19	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$eiz:	19	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$es:	19	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$hbp:	19	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$noreg:	19	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$ah:	19	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$dh:	19	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$noreg:	20	renamable $rax = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
$ah:	20	renamable $rax = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
$dh:	20	renamable $rax = MOV64rm $rip, 1, $noreg, @_ZSt4cout, $noreg :: (dereferenceable load 8 from `i8** bitcast (%"class.std::basic_ostream"* @_ZSt4cout to i8**)`, !tbaa !4)
$noreg:	21	renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
$ah:	21	renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
$dh:	21	renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.0)
$cl:	23	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$cs:	23	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$dl:	23	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$cl:	23	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$cs:	23	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$dl:	23	$edi = MOV32ri @_ZSt4cout, implicit-def $rdi
$edi:	24	$esi = MOV32rr $r15d
$edx:	24	$esi = MOV32rr $r15d
$eflags:	24	$esi = MOV32rr $r15d
$eip:	25	CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$eiz:	25	CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$es:	25	CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$hbp:	25	CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$noreg:	25	CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$ah:	25	CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$dh:	25	CALL64pcrel32 @_ZNSolsEi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$al:	26	$rbx = MOV64rr $rax
$ax:	26	$rbx = MOV64rr $rax
$dih:	26	$rbx = MOV64rr $rax
$edi:	27	$esi = MOV32ri @.str.1, implicit-def $rsi
$edx:	27	$esi = MOV32ri @.str.1, implicit-def $rsi
$eflags:	27	$esi = MOV32ri @.str.1, implicit-def $rsi
$edi:	27	$esi = MOV32ri @.str.1, implicit-def $rsi
$edx:	27	$esi = MOV32ri @.str.1, implicit-def $rsi
$eflags:	27	$esi = MOV32ri @.str.1, implicit-def $rsi
$ch:	28	$edx = MOV32ri 4, implicit-def $rdx
$cx:	28	$edx = MOV32ri 4, implicit-def $rdx
$ds:	28	$edx = MOV32ri 4, implicit-def $rdx
$ch:	28	$edx = MOV32ri 4, implicit-def $rdx
$cx:	28	$edx = MOV32ri 4, implicit-def $rdx
$ds:	28	$edx = MOV32ri 4, implicit-def $rdx
$cl:	29	$rdi = MOV64rr $rax
$cs:	29	$rdi = MOV64rr $rax
$dl:	29	$rdi = MOV64rr $rax
$eip:	30	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$eiz:	30	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$es:	30	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$hbp:	30	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$noreg:	30	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$ah:	30	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$dh:	30	CALL64pcrel32 @_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$bp:	31	renamable $rcx = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
$bph:	31	renamable $rcx = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
$dil:	31	renamable $rcx = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.2, !tbaa !4)
$ch:	32	renamable $rdx = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$cx:	32	renamable $rdx = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$ds:	32	renamable $rdx = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$noreg:	33	renamable $eax = MOV32rm renamable $rbx, 1, renamable $rdx, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
$ah:	33	renamable $eax = MOV32rm renamable $rbx, 1, renamable $rdx, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
$dh:	33	renamable $eax = MOV32rm renamable $rbx, 1, renamable $rdx, 24, $noreg :: (load 4 from %ir.5, !tbaa !17)
$noreg:	34	renamable $eax = AND32rr killed renamable $eax(tied-def 0), renamable $r12d, implicit-def dead $eflags
$ah:	34	renamable $eax = AND32rr killed renamable $eax(tied-def 0), renamable $r12d, implicit-def dead $eflags
$dh:	34	renamable $eax = AND32rr killed renamable $eax(tied-def 0), renamable $r12d, implicit-def dead $eflags
$dx:	34	renamable $eax = AND32rr killed renamable $eax(tied-def 0), renamable $r12d, implicit-def dead $eflags
$noreg:	35	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 4, implicit-def dead $eflags
$ah:	35	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 4, implicit-def dead $eflags
$dh:	35	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 4, implicit-def dead $eflags
$dx:	35	renamable $eax = OR32ri8 killed renamable $eax(tied-def 0), 4, implicit-def dead $eflags
$noreg:	37	renamable $rax = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$ah:	37	renamable $rax = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$dh:	37	renamable $rax = MOV64rm renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$noreg:	39	renamable $rax = MOV64rm killed renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$ah:	39	renamable $rax = MOV64rm killed renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$dh:	39	renamable $rax = MOV64rm killed renamable $rcx, 1, $noreg, -24, $noreg :: (load 8 from %ir.3)
$cl:	41	$rdi = MOV64rr killed $rbx
$cs:	41	$rdi = MOV64rr killed $rbx
$dl:	41	$rdi = MOV64rr killed $rbx
$st5:	42	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$eip:	43	CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$eiz:	43	CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$es:	43	CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$hbp:	43	CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$noreg:	43	CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$ah:	43	CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$dh:	43	CALL64pcrel32 @_ZNSo9_M_insertIdEERSoT_, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$k7:	44	$r14 = MOV64rr $rax
$mm0:	44	$r14 = MOV64rr $rax
$mm1:	44	$r14 = MOV64rr $rax
$noreg:	45	renamable $rax = MOV64rm $rax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
$ah:	45	renamable $rax = MOV64rm $rax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
$dh:	45	renamable $rax = MOV64rm $rax, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.11, !tbaa !4)
$noreg:	46	renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
$ah:	46	renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
$dh:	46	renamable $rax = MOV64rm killed renamable $rax, 1, $noreg, -24, $noreg :: (load 8 from %ir.12)
$al:	47	renamable $rbx = MOV64rm renamable $r14, 1, killed renamable $rax, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
$ax:	47	renamable $rbx = MOV64rm renamable $r14, 1, killed renamable $rax, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
$dih:	47	renamable $rbx = MOV64rm renamable $r14, 1, killed renamable $rax, 240, $noreg :: (load 8 from %ir.14, !tbaa !19)
$dx:	48	TEST64rr renamable $rbx, renamable $rbx, implicit-def $eflags
%bb.6: incomplete
$dx:	0	CMP8mi renamable $rbx, 1, $noreg, 56, $noreg, 0, implicit-def $eflags :: (load 1 from %ir._M_widen_ok.i, align 8, !tbaa !22)
%bb.7: incomplete
$ah:	0	renamable $al = MOV8rm killed renamable $rbx, 1, $noreg, 67, $noreg :: (load 1 from %ir.arrayidx.i, !tbaa !24)
%bb.8: incomplete
$cl:	0	$rdi = MOV64rr $rbx
$cs:	0	$rdi = MOV64rr $rbx
$dl:	0	$rdi = MOV64rr $rbx
$eip:	1	CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
$eiz:	1	CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
$es:	1	CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
$hbp:	1	CALL64pcrel32 @_ZNKSt5ctypeIcE13_M_widen_initEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
$noreg:	2	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
$ah:	2	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
$dh:	2	renamable $rax = MOV64rm renamable $rbx, 1, $noreg, 0, $noreg :: (load 8 from %ir.18, !tbaa !4)
$cl:	3	$rdi = MOV64rr killed $rbx
$cs:	3	$rdi = MOV64rr killed $rbx
$dl:	3	$rdi = MOV64rr killed $rbx
$edi:	4	$esi = MOV32ri 10
$edx:	4	$esi = MOV32ri 10
$eflags:	4	$esi = MOV32ri 10
$eip:	5	CALL64m killed renamable $rax, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
$eiz:	5	CALL64m killed renamable $rax, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
$es:	5	CALL64m killed renamable $rax, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
$hbp:	5	CALL64m killed renamable $rax, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
$ah:	5	CALL64m killed renamable $rax, 1, $noreg, 48, $noreg, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $al :: (load 8 from %ir.vfn.i)
%bb.9: incomplete
$edi:	0	renamable $esi = MOVSX32rr8 killed renamable $al
$edx:	0	renamable $esi = MOVSX32rr8 killed renamable $al
$eflags:	0	renamable $esi = MOVSX32rr8 killed renamable $al
$cl:	1	$rdi = MOV64rr killed $r14
$cs:	1	$rdi = MOV64rr killed $r14
$dl:	1	$rdi = MOV64rr killed $r14
$eip:	2	CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$eiz:	2	CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$es:	2	CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$hbp:	2	CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$noreg:	2	CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$ah:	2	CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$dh:	2	CALL64pcrel32 @_ZNSo3putEc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
$cl:	3	$rdi = MOV64rr killed $rax
$cs:	3	$rdi = MOV64rr killed $rax
$dl:	3	$rdi = MOV64rr killed $rax
$eip:	4	CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$eiz:	4	CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$es:	4	CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$hbp:	4	CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$noreg:	4	CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$ah:	4	CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$dh:	4	CALL64pcrel32 @_ZNSo5flushEv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def dead $rax
$mm2:	5	renamable $r15d = nsw ADD32rr killed renamable $r15d(tied-def 0), renamable $r15d, implicit-def dead $eflags
$mm3:	5	renamable $r15d = nsw ADD32rr killed renamable $r15d(tied-def 0), renamable $r15d, implicit-def dead $eflags
$mm4:	5	renamable $r15d = nsw ADD32rr killed renamable $r15d(tied-def 0), renamable $r15d, implicit-def dead $eflags
$dx:	5	renamable $r15d = nsw ADD32rr killed renamable $r15d(tied-def 0), renamable $r15d, implicit-def dead $eflags
$dx:	6	CMP32ri renamable $r15d, 65537, implicit-def $eflags
%bb.1: all preds known
%bb.2: all preds known
%bb.3: all preds known
%bb.4: all preds known
%bb.5: all preds known
%bb.6: all preds known
%bb.7: all preds known
%bb.8: all preds known
%bb.9: all preds known
%bb.10: all preds known
$noreg:	0	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$ah:	0	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$dh:	0	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$dx:	0	$eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
$eip:	1	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$eiz:	1	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$es:	1	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$dx:	1	$rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 32, implicit-def dead $eflags
$al:	3	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$ax:	3	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$dih:	3	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	3	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	3	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	3	$rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$k1:	5	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$k2:	5	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$k3:	5	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	5	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	5	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	5	$r12 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$k7:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm0:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm1:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	7	$r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm2:	9	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm3:	9	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$mm4:	9	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	9	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	9	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	9	$r15 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$bh:	11	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$bl:	11	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$di:	11	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	11	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	11	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	11	$rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
%bb.11: all preds known
$eip:	0	CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
$eiz:	0	CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
$es:	0	CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
$hbp:	0	CALL64pcrel32 @_ZSt16__throw_bad_castv, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
%bb.1: incomplete
$xmm1:	renamable $xmm1 = CVTSI2SDrr renamable $ebp
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = XORPDrr undef $xmm0(tied-def 0), undef $xmm0
%bb.2: incomplete
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
%bb.3: incomplete
$xmm0:	renamable $xmm0 = CVTSI2SDrr renamable $ebx
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 24, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
%bb.4: incomplete
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
%bb.5: incomplete
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 8, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 16, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
%bb.6: incomplete
%bb.7: incomplete
%bb.8: incomplete
%bb.9: incomplete
%bb.1: all preds known
$xmm1:	renamable $xmm1 = CVTSI2SDrr renamable $ebp
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept DIVSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = XORPDrr undef $xmm0(tied-def 0), undef $xmm0
%bb.2: all preds known
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
%bb.3: all preds known
$xmm0:	renamable $xmm0 = CVTSI2SDrr renamable $ebx
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 0, $noreg, implicit $mxcsr :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 24, $noreg, implicit $mxcsr :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $noreg, 1, $noreg, %const.4, $noreg, implicit $mxcsr
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
$xmm1:	renamable $xmm1 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$xmm1:	renamable $xmm1 = nofpexcept ADDSDrr killed renamable $xmm1(tied-def 0), killed renamable $xmm0, implicit $mxcsr
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 24, $noreg :: (load 8 from %stack.0)
$xmm0:	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.3, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
%bb.4: all preds known
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), renamable $xmm0, implicit $mxcsr
%bb.5: all preds known
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 8, $noreg :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = ADDSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = MULSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 16, $noreg :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = nofpexcept ADDSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 8, $noreg, implicit $mxcsr :: (load 8 from %stack.3)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = nofpexcept MULSDrm killed renamable $xmm0(tied-def 0), $rsp, 1, $noreg, 16, $noreg, implicit $mxcsr :: (load 8 from %stack.2)
$xmm0:	renamable $xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
$xmm0:	renamable $xmm0 = DIVSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.2, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
$xmm0:	$xmm0 = MOVSDrm_alt $rsp, 1, $noreg, 0, $noreg :: (load 8 from %stack.1)
%bb.6: all preds known
%bb.7: all preds known
%bb.8: all preds known
%bb.9: all preds known
%bb.10: all preds known
%bb.11: all preds known
********** BREAK FALSE DEPENDENCIES **********
Clearance: 74, want 64: OK .
Clearance: 2, want 64: Break dependency.
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: main **********

Debug Range Extension
X86 Indirect Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : main *****
[SafeStack] Function: _GLOBAL__sub_I_Simpson.cpp
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _GLOBAL__sub_I_Simpson.cpp ----

Computing probabilities for entry



=== _GLOBAL__sub_I_Simpson.cpp
Creating constant: t3: i64 = TargetConstant<0>
Creating new node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Creating new node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Creating new node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Creating new node: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Creating new node: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
Creating new node: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
Creating constant: t20: i32 = TargetConstant<0>
Creating new node: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1
Initial selection DAG: %bb.0 '_GLOBAL__sub_I_Simpson.cpp:entry'
SelectionDAG has 22 nodes:
  t1: i64 = GlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0
      t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
  t11: i64 = GlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0
    t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
  t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
  t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
  t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1



Combining: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1

Combining: t20: i32 = TargetConstant<0>

Combining: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0

Combining: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1

Combining: t17: i64 = Register $rdx

Combining: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1

Combining: t15: i64 = Register $rsi

Combining: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Combining: t13: i64 = GlobalAddress<i8* @__dso_handle> 0

Combining: t12: i64 = GlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Combining: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Combining: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Combining: t8: Untyped = RegisterMask

Combining: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Combining: t5: i64 = Register $rdi

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t3: i64 = TargetConstant<0>

Combining: t2: i64 = GlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 '_GLOBAL__sub_I_Simpson.cpp:entry'
SelectionDAG has 20 nodes:
      t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
    t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
  t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
  t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
  t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1


Legalizing node: t20: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t20: i32 = TargetConstant<0>

Legalizing node: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0

Legalizing node: t17: i64 = Register $rdx
Ignoring node results
Legally typed node: t17: i64 = Register $rdx

Legalizing node: t15: i64 = Register $rsi
Ignoring node results
Legally typed node: t15: i64 = Register $rsi

Legalizing node: t13: i64 = GlobalAddress<i8* @__dso_handle> 0
Analyzing result type: i64
Legal result type
Legally typed node: t13: i64 = GlobalAddress<i8* @__dso_handle> 0

Legalizing node: t12: i64 = GlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Analyzing result type: i64
Legal result type
Legally typed node: t12: i64 = GlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Legalizing node: t8: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t8: Untyped = RegisterMask

Legalizing node: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0

Legalizing node: t5: i64 = Register $rdi
Ignoring node results
Legally typed node: t5: i64 = Register $rdi

Legalizing node: t3: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t3: i64 = TargetConstant<0>

Legalizing node: t2: i64 = GlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = GlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t2: i64 = GlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal operand
Legally typed node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Legalizing node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal operand
Analyzing operand: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Analyzing operand: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal operand
Legally typed node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Analyzing operand: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal operand
Legally typed node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing node: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
Legal operand
Analyzing operand: t12: i64 = GlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal operand
Legally typed node: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Legalizing node: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal operand
Analyzing operand: t2: i64 = GlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal operand
Analyzing operand: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal operand
Legally typed node: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1

Legalizing node: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
Legal operand
Analyzing operand: t13: i64 = GlobalAddress<i8* @__dso_handle> 0
Legal operand
Analyzing operand: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
Legal operand
Legally typed node: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1

Legalizing node: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
Legal operand
Analyzing operand: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0
Legal operand
Analyzing operand: t8: Untyped = RegisterMask
Legal operand
Analyzing operand: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
Legal operand
Legally typed node: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1

Legalizing node: t65535: ch = handlenode t21
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1
Legal operand
Legally typed node: t65535: ch = handlenode t21

Type-legalized selection DAG: %bb.0 '_GLOBAL__sub_I_Simpson.cpp:entry'
SelectionDAG has 20 nodes:
      t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
    t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
  t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
  t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
  t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
  t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1



Legalizing: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1
Legal node: nothing to do

Legalizing: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, GlobalAddress:i64<i8* @__dso_handle> 0, t16:1
Legal node: nothing to do

Legalizing: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0, t14:1
Legal node: nothing to do

Legalizing: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, GlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal node: nothing to do

Legalizing: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, GlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal node: nothing to do

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t20: i32 = TargetConstant<0>

Legalizing: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0
Legal node: nothing to do

Legalizing: t17: i64 = Register $rdx

Legalizing: t15: i64 = Register $rsi

Legalizing: t13: i64 = GlobalAddress<i8* @__dso_handle> 0
Trying custom legalization
Creating new node: t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0
Successfully custom legalized node
 ... replacing: t13: i64 = GlobalAddress<i8* @__dso_handle> 0
     with:      t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0

Legalizing: t12: i64 = GlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Trying custom legalization
Creating new node: t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Successfully custom legalized node
 ... replacing: t12: i64 = GlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
     with:      t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0
Legal node: nothing to do

Legalizing: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Legalizing: t2: i64 = GlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Trying custom legalization
Creating new node: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Successfully custom legalized node
 ... replacing: t2: i64 = GlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
     with:      t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal node: nothing to do

Legalizing: t26: i64 = TargetGlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal node: nothing to do

Legalizing: t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal node: nothing to do

Legalizing: t24: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal node: nothing to do

Legalizing: t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0
Legal node: nothing to do

Legalizing: t22: i64 = TargetGlobalAddress<i8* @__dso_handle> 0
Legal node: nothing to do
Legalized selection DAG: %bb.0 '_GLOBAL__sub_I_Simpson.cpp:entry'
SelectionDAG has 23 nodes:
      t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, t27
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
    t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
    t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
  t14: ch,glue = CopyToReg t10, Register:i64 $rdi, t25
  t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1
    t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0
  t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1
  t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
  t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1



Legalizing: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal node: nothing to do

Combining: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Legalizing: t26: i64 = TargetGlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
Legal node: nothing to do

Combining: t26: i64 = TargetGlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Legalizing: t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal node: nothing to do

Combining: t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Legalizing: t24: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
Legal node: nothing to do

Combining: t24: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Legalizing: t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0
Legal node: nothing to do

Combining: t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0

Legalizing: t22: i64 = TargetGlobalAddress<i8* @__dso_handle> 0
Legal node: nothing to do

Combining: t22: i64 = TargetGlobalAddress<i8* @__dso_handle> 0

Legalizing: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1
Legal node: nothing to do

Combining: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1

Legalizing: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1
Legal node: nothing to do

Combining: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1

Legalizing: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1
Legal node: nothing to do

Combining: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1

Legalizing: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, t25
Legal node: nothing to do

Combining: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, t25

Legalizing: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Combining: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1

Legalizing: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
Legal node: nothing to do

Combining: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1

Legalizing: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, t27
Legal node: nothing to do

Combining: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, t27

Legalizing: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t20: i32 = TargetConstant<0>

Combining: t20: i32 = TargetConstant<0>

Legalizing: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0
Legal node: nothing to do

Combining: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0

Legalizing: t17: i64 = Register $rdx

Combining: t17: i64 = Register $rdx

Legalizing: t15: i64 = Register $rsi

Combining: t15: i64 = Register $rsi

Legalizing: t8: Untyped = RegisterMask
Legal node: nothing to do

Combining: t8: Untyped = RegisterMask

Legalizing: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0
Legal node: nothing to do

Combining: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0

Legalizing: t5: i64 = Register $rdi

Combining: t5: i64 = Register $rdi

Legalizing: t3: i64 = TargetConstant<0>

Combining: t3: i64 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 '_GLOBAL__sub_I_Simpson.cpp:entry'
SelectionDAG has 23 nodes:
      t0: ch = EntryToken
    t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t6: ch,glue = CopyToReg t4, Register:i64 $rdi, t27
  t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
    t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
    t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
  t14: ch,glue = CopyToReg t10, Register:i64 $rdi, t25
  t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1
    t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0
  t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1
  t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
  t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t21: ch,glue = X86ISD::TC_RETURN t18, TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18:1
ISEL: Starting pattern match
  Initial Opcode index to 43826
  Match failed at index 43831
  Continuing at 43895
  OpcodeSwitch from 43901 to 43905
  TypeSwitch[i64] from 43905 to 43927
  Morphed node: t21: ch = TCRETURNdi64 TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18, t18:1
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1

ISEL: Starting selection on root node: t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1

ISEL: Starting selection on root node: t14: ch,glue = CopyToReg t10, Register:i64 $rdi, t25

ISEL: Starting selection on root node: t10: ch,glue = callseq_end t9, TargetConstant:i64<0>, TargetConstant:i64<0>, t9:1
ISEL: Starting pattern match
  Initial Opcode index to 126478
  Skipped scope entry (due to false predicate) at index 126494, continuing at 126505
  Morphed node: t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1
ISEL: Match complete!

ISEL: Starting selection on root node: t9: ch,glue = X86ISD::CALL t6, TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6:1
ISEL: Starting pattern match
  Initial Opcode index to 91292
  Match failed at index 91297
  Continuing at 91380
  OpcodeSwitch from 91386 to 91390
  TypeSwitch[i64] from 91390 to 91393
  Morphed node: t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch,glue = CopyToReg t4, Register:i64 $rdi, t27

ISEL: Starting selection on root node: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
ISEL: Starting pattern match
  Initial Opcode index to 127392
  Morphed node: t27: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
ISEL: Starting pattern match
  Initial Opcode index to 127392
  Morphed node: t25: i64 = MOV32ri64 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<i8* @__dso_handle> 0
ISEL: Starting pattern match
  Initial Opcode index to 127392
  Morphed node: t23: i64 = MOV32ri64 TargetGlobalAddress:i64<i8* @__dso_handle> 0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 126521
  Skipped scope entry (due to false predicate) at index 126536, continuing at 126551
  Morphed node: t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t26: i64 = TargetGlobalAddress<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

ISEL: Starting selection on root node: t24: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

ISEL: Starting selection on root node: t22: i64 = TargetGlobalAddress<i8* @__dso_handle> 0

ISEL: Starting selection on root node: t20: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t19: i64 = TargetGlobalAddress<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0

ISEL: Starting selection on root node: t17: i64 = Register $rdx

ISEL: Starting selection on root node: t15: i64 = Register $rsi

ISEL: Starting selection on root node: t8: Untyped = RegisterMask

ISEL: Starting selection on root node: t7: i64 = TargetGlobalAddress<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0

ISEL: Starting selection on root node: t5: i64 = Register $rdi

ISEL: Starting selection on root node: t3: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 '_GLOBAL__sub_I_Simpson.cpp:entry'
SelectionDAG has 23 nodes:
  t27: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0
      t0: ch = EntryToken
    t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0
  t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t27
  t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1
    t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1
    t25: i64 = MOV32ri64 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0
  t14: ch,glue = CopyToReg t10:1, Register:i64 $rdi, t25
  t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1
    t23: i64 = MOV32ri64 TargetGlobalAddress:i64<i8* @__dso_handle> 0
  t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1
  t21: ch = TCRETURNdi64 TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18, t18:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t21: ch = TCRETURNdi64 TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18, t18:1

    t14: ch,glue = CopyToReg t10:1, Register:i64 $rdi, t25

    t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1

    t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1

  # preds left       : 4
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
    SU(2): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
    SU(3): Data Latency=1
SU(1): t23: i64 = MOV32ri64 TargetGlobalAddress:i64<i8* @__dso_handle> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(2): t27: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(0): Data Latency=1
    SU(4): Data Latency=1
SU(3): t25: i64 = MOV32ri64 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1
SU(4): t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t27

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(5): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t21: ch = TCRETURNdi64 TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18, t18:1

    t14: ch,glue = CopyToReg t10:1, Register:i64 $rdi, t25

    t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1

    t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1


*** Scheduling [0]: SU(0): t21: ch = TCRETURNdi64 TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18, t18:1

    t14: ch,glue = CopyToReg t10:1, Register:i64 $rdi, t25

    t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1

    t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1


Examining Available:
Height 1: SU(1): t23: i64 = MOV32ri64 TargetGlobalAddress:i64<i8* @__dso_handle> 0

Height 1: SU(3): t25: i64 = MOV32ri64 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Height 1: SU(4): t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t27

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1


*** Scheduling [1]: SU(1): t23: i64 = MOV32ri64 TargetGlobalAddress:i64<i8* @__dso_handle> 0


Examining Available:
Height 1: SU(3): t25: i64 = MOV32ri64 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

Height 1: SU(4): t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t27

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1


*** Scheduling [2]: SU(3): t25: i64 = MOV32ri64 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0


Examining Available:
Height 1: SU(4): t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t27

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1


*** Scheduling [3]: SU(4): t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t27

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1


Examining Available:
Height 4: SU(2): t27: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

Height 4: SU(5): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [4]: SU(2): t27: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0


Examining Available:
Height 4: SU(5): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0


*** Scheduling [5]: SU(5): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(5): t4: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t0

SU(2): t27: i64 = MOV32ri64 TargetGlobalAddress:i64<%"class.std::ios_base::Init"* @_ZStL8__ioinit> 0

SU(4): t10: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t9, t9:1

    t6: ch,glue = CopyToReg t4:1, Register:i64 $rdi, t27

    t9: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitC1Ev> 0, Register:i64 $rdi, RegisterMask:Untyped, t6, t6:1

SU(3): t25: i64 = MOV32ri64 TargetGlobalAddress:i64<void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev> 0

SU(1): t23: i64 = MOV32ri64 TargetGlobalAddress:i64<i8* @__dso_handle> 0

SU(0): t21: ch = TCRETURNdi64 TargetGlobalAddress:i64<i32 (void (i8*)*, i8*, i8*)* @__cxa_atexit> 0, TargetConstant:i32<0>, Register:i64 $rdi, Register:i64 $rsi, Register:i64 $rdx, RegisterMask:Untyped, t18, t18:1

    t14: ch,glue = CopyToReg t10:1, Register:i64 $rdi, t25

    t16: ch,glue = CopyToReg t14, Register:i64 $rsi, t27, t14:1

    t18: ch,glue = CopyToReg t16, Register:i64 $rdx, t23, t16:1


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function _GLOBAL__sub_I_Simpson.cpp: IsSSA, TracksLiveness

bb.0.entry:
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %0:gr64 = MOV32ri64 @_ZStL8__ioinit
  $rdi = COPY %0:gr64
  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
  %2:gr64 = MOV32ri64 @__dso_handle
  $rdi = COPY %1:gr64
  $rsi = COPY %0:gr64
  $rdx = COPY %2:gr64
  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.

***** Machine Function before Domain Reassignment *****
# Machine code for function _GLOBAL__sub_I_Simpson.cpp: IsSSA, TracksLiveness

bb.0.entry:
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %0:gr64 = MOV32ri64 @_ZStL8__ioinit
  $rdi = COPY %0:gr64
  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
  %2:gr64 = MOV32ri64 @__dso_handle
  $rdi = COPY %1:gr64
  $rsi = COPY %0:gr64
  $rdx = COPY %2:gr64
  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.

# Machine code for function _GLOBAL__sub_I_Simpson.cpp: IsSSA, TracksLiveness

0B	bb.0.entry:
16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %0:gr64 = MOV32ri64 @_ZStL8__ioinit
48B	  $rdi = COPY %0:gr64
64B	  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
96B	  %1:gr64 = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
112B	  %2:gr64 = MOV32ri64 @__dso_handle
128B	  $rdi = COPY %1:gr64
144B	  $rsi = COPY %0:gr64
160B	  $rdx = COPY %2:gr64
176B	  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.

********** Stack Coloring **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
********** EARLY IF-CONVERSION **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
Machine InstCombiner: _GLOBAL__sub_I_Simpson.cpp
Combining MBB entry
********** X86 cmov Conversion : _GLOBAL__sub_I_Simpson.cpp**********

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - BB0[entry]: float = 1.0, int = 8

******** Pre-regalloc Machine LICM: _GLOBAL__sub_I_Simpson.cpp ********

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - BB0[entry]: float = 1.0, int = 8

Entering: entry
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
Encountered load fold barrier on CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
Encountered load fold barrier on TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx
**** Analysing _GLOBAL__sub_I_Simpson.cpp
Start X86AvoidStoreForwardBlocks
End X86AvoidStoreForwardBlocks
********** X86 speculative load hardening : _GLOBAL__sub_I_Simpson.cpp **********
********** X86 EFLAGS copy lowering : _GLOBAL__sub_I_Simpson.cpp **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
********** REWRITING TWO-ADDR INSTRS **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
# Machine code for function _GLOBAL__sub_I_Simpson.cpp: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %0:gr64 = MOV32ri64 @_ZStL8__ioinit
48B	  $rdi = COPY %0:gr64
64B	  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
96B	  %1:gr64 = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
112B	  %2:gr64 = MOV32ri64 @__dso_handle
128B	  $rdi = COPY killed %1:gr64
144B	  $rsi = COPY killed %0:gr64
160B	  $rdx = COPY killed %2:gr64
176B	  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%0 [32r,144r:0)  0@32r weight:0.000000e+00
%1 [96r,128r:0)  0@96r weight:0.000000e+00
%2 [112r,160r:0)  0@112r weight:0.000000e+00
RegMasks: 64r 176r
********** MACHINEINSTRS **********
# Machine code for function _GLOBAL__sub_I_Simpson.cpp: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
32B	  %0:gr64 = MOV32ri64 @_ZStL8__ioinit
48B	  $rdi = COPY %0:gr64
64B	  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
96B	  %1:gr64 = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
112B	  %2:gr64 = MOV32ri64 @__dso_handle
128B	  $rdi = COPY %1:gr64
144B	  $rsi = COPY %0:gr64
160B	  $rdx = COPY %2:gr64
176B	  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.

********** SIMPLE REGISTER COALESCING **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
********** JOINING INTERVALS ***********
entry:
48B	$rdi = COPY %0:gr64
	Considering merging %0 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 @_ZStL8__ioinit
Shrink: %0 [32r,144r:0)  0@32r weight:0.000000e+00
Shrunk: %0 [32r,144r:0)  0@32r weight:0.000000e+00
128B	$rdi = COPY %1:gr64
	Considering merging %1 with $rdi
	Can only merge into reserved registers.
Remat: $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
Shrink: %1 [96r,128r:0)  0@96r weight:0.000000e+00
All defs dead: 96r	dead %1:gr64 = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
Shrunk: %1 [96r,96d:0)  0@96r weight:0.000000e+00
Deleting dead def 96r	dead %1:gr64 = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
144B	$rsi = COPY %0:gr64
	Considering merging %0 with $rsi
	Can only merge into reserved registers.
Remat: $rsi = MOV32ri64 @_ZStL8__ioinit
Shrink: %0 [32r,144r:0)  0@32r weight:0.000000e+00
All defs dead: 32r	dead %0:gr64 = MOV32ri64 @_ZStL8__ioinit
Shrunk: %0 [32r,32d:0)  0@32r weight:0.000000e+00
Deleting dead def 32r	dead %0:gr64 = MOV32ri64 @_ZStL8__ioinit
160B	$rdx = COPY %2:gr64
	Considering merging %2 with $rdx
	Can only merge into reserved registers.
Remat: $rdx = MOV32ri64 @__dso_handle
Shrink: %2 [112r,160r:0)  0@112r weight:0.000000e+00
All defs dead: 112r	dead %2:gr64 = MOV32ri64 @__dso_handle
Shrunk: %2 [112r,112d:0)  0@112r weight:0.000000e+00
Deleting dead def 112r	dead %2:gr64 = MOV32ri64 @__dso_handle
Trying to inflate 0 regs.
********** INTERVALS **********
RegMasks: 64r 176r
********** MACHINEINSTRS **********
# Machine code for function _GLOBAL__sub_I_Simpson.cpp: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  $rdi = MOV32ri64 @_ZStL8__ioinit
64B	  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
128B	  $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
144B	  $rsi = MOV32ri64 @_ZStL8__ioinit
160B	  $rdx = MOV32ri64 @__dso_handle
176B	  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.

Before MISched:
# Machine code for function _GLOBAL__sub_I_Simpson.cpp: NoPHIs, TracksLiveness, TiedOpsRewritten

bb.0.entry:
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @_ZStL8__ioinit
  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
  $rsi = MOV32ri64 @_ZStL8__ioinit
  $rdx = MOV32ri64 @__dso_handle
  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.

********** MI Scheduling **********
_GLOBAL__sub_I_Simpson.cpp:%bb.0 entry
  From: $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
    To: TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx
 RegionInstrs: 3
ScheduleDAGMILive::schedule starting
GenericScheduler RegionPolicy:  ShouldTrackPressure=0 OnlyTopDown=0 OnlyBottomUp=1
Disabled scoreboard hazard recognizer
Disabled scoreboard hazard recognizer
SU(0):   $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(1):   $rsi = MOV32ri64 @_ZStL8__ioinit
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
SU(2):   $rdx = MOV32ri64 @__dso_handle
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
  Single Issue       : false;
ExitSU:   TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Artificial
    SU(1): Ord  Latency=1 Artificial
    SU(0): Ord  Latency=1 Artificial
Critical Path(GS-RR ): 1
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 2 1 0 
  Cand SU(2) ORDER                              
Pick Bot ORDER     
Scheduling SU(2) $rdx = MOV32ri64 @__dso_handle
  Ready @1c
  SBPort015 +1x4u
  *** Critical resource SBPort015: 0c
  SBPortAny +1x2u
  BotQ.A BotLatency SU(2) 1c
BotQ.A @0c
  Retired: 1
  Executed: 0c
  Critical: 0c, 1 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 1 
  Cand SU(0) ORDER                              
  Cand SU(1) ORDER                              
Pick Bot ORDER     
Scheduling SU(1) $rsi = MOV32ri64 @_ZStL8__ioinit
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 2
  Executed: 0c
  Critical: 0c, 2 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
Queue BotQ.P: 
Queue BotQ.A: 0 
Scheduling SU(0) $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
  Ready @1c
  SBPort015 +1x4u
  SBPortAny +1x2u
BotQ.A @0c
  Retired: 3
  Executed: 1c
  Critical: 1c, 3 SBPort015
  ExpectedLatency: 1c
  - Latency limited.
** ScheduleDAGMILive::schedule picking next node
*** Final schedule for %bb.0 ***
SU(0):   $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
SU(1):   $rsi = MOV32ri64 @_ZStL8__ioinit
SU(2):   $rdx = MOV32ri64 @__dso_handle

********** INTERVALS **********
RegMasks: 64r 176r
********** MACHINEINSTRS **********
# Machine code for function _GLOBAL__sub_I_Simpson.cpp: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  $rdi = MOV32ri64 @_ZStL8__ioinit
64B	  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
128B	  $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
144B	  $rsi = MOV32ri64 @_ZStL8__ioinit
160B	  $rdx = MOV32ri64 @__dso_handle
176B	  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx

# End machine code for function _GLOBAL__sub_I_Simpson.cpp.


block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - BB0[entry]: float = 1.0, int = 8

********** BASIC REGISTER ALLOCATION **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
********** Compute Spill Weights **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
test!!! regcount = 0
Post alloc VirtRegMap:
********** REGISTER MAP **********


********** REWRITE VIRTUAL REGISTERS **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
********** REGISTER MAP **********

0B	bb.0.entry:
16B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  $rdi = MOV32ri64 @_ZStL8__ioinit
64B	  CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
128B	  $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
144B	  $rsi = MOV32ri64 @_ZStL8__ioinit
160B	  $rdx = MOV32ri64 @__dso_handle
176B	  TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 @_ZStL8__ioinit
> CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $rdi = MOV32ri64 @_ZNSt8ios_base4InitD1Ev
> $rsi = MOV32ri64 @_ZStL8__ioinit
> $rdx = MOV32ri64 @__dso_handle
> TCRETURNdi64 @__cxa_atexit, 0, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx
********** Stack Slot Coloring **********
********** Function: _GLOBAL__sub_I_Simpson.cpp
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
******** Post-regalloc Machine LICM: _GLOBAL__sub_I_Simpson.cpp ********
***** X86 Load Value Injection (LVI) Load Hardening : _GLOBAL__sub_I_Simpson.cpp *****

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
**** Analysing _GLOBAL__sub_I_Simpson.cpp
Look into: 0 entry
Frame instruction: ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp

No Shrink wrap candidate found
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: _GLOBAL__sub_I_Simpson.cpp

block-frequency: _GLOBAL__sub_I_Simpson.cpp
===========================================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: _GLOBAL__sub_I_Simpson.cpp
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
$eip:	0	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$eiz:	0	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$es:	0	frame-setup PUSH64r undef $rax, implicit-def $rsp, implicit $rsp
$cl:	2	$edi = MOV32ri @_ZStL8__ioinit, implicit-def $rdi
$cs:	2	$edi = MOV32ri @_ZStL8__ioinit, implicit-def $rdi
$dl:	2	$edi = MOV32ri @_ZStL8__ioinit, implicit-def $rdi
$cl:	2	$edi = MOV32ri @_ZStL8__ioinit, implicit-def $rdi
$cs:	2	$edi = MOV32ri @_ZStL8__ioinit, implicit-def $rdi
$dl:	2	$edi = MOV32ri @_ZStL8__ioinit, implicit-def $rdi
$eip:	3	CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
$eiz:	3	CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
$es:	3	CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
$hbp:	3	CALL64pcrel32 @_ZNSt8ios_base4InitC1Ev, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
$cl:	4	$edi = MOV32ri @_ZNSt8ios_base4InitD1Ev, implicit-def $rdi
$cs:	4	$edi = MOV32ri @_ZNSt8ios_base4InitD1Ev, implicit-def $rdi
$dl:	4	$edi = MOV32ri @_ZNSt8ios_base4InitD1Ev, implicit-def $rdi
$cl:	4	$edi = MOV32ri @_ZNSt8ios_base4InitD1Ev, implicit-def $rdi
$cs:	4	$edi = MOV32ri @_ZNSt8ios_base4InitD1Ev, implicit-def $rdi
$dl:	4	$edi = MOV32ri @_ZNSt8ios_base4InitD1Ev, implicit-def $rdi
$edi:	5	$esi = MOV32ri @_ZStL8__ioinit, implicit-def $rsi
$edx:	5	$esi = MOV32ri @_ZStL8__ioinit, implicit-def $rsi
$eflags:	5	$esi = MOV32ri @_ZStL8__ioinit, implicit-def $rsi
$edi:	5	$esi = MOV32ri @_ZStL8__ioinit, implicit-def $rsi
$edx:	5	$esi = MOV32ri @_ZStL8__ioinit, implicit-def $rsi
$eflags:	5	$esi = MOV32ri @_ZStL8__ioinit, implicit-def $rsi
$ch:	6	$edx = MOV32ri @__dso_handle, implicit-def $rdx
$cx:	6	$edx = MOV32ri @__dso_handle, implicit-def $rdx
$ds:	6	$edx = MOV32ri @__dso_handle, implicit-def $rdx
$ch:	6	$edx = MOV32ri @__dso_handle, implicit-def $rdx
$cx:	6	$edx = MOV32ri @__dso_handle, implicit-def $rdx
$ds:	6	$edx = MOV32ri @__dso_handle, implicit-def $rdx
$noreg:	7	$rax = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$ah:	7	$rax = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$dh:	7	$rax = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eip:	7	$rax = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$eiz:	7	$rax = frame-destroy POP64r implicit-def $rsp, implicit $rsp
$es:	7	$rax = frame-destroy POP64r implicit-def $rsp, implicit $rsp
********** FIX EXECUTION DOMAIN: VR128X **********
%bb.0: entry
********** BREAK FALSE DEPENDENCIES **********
Start X86FixupBWInsts
End X86FixupBWInsts
Start X86FixupLEAs
End X86FixupLEAs
********** COMPUTING STACKMAP LIVENESS: _GLOBAL__sub_I_Simpson.cpp **********

Debug Range Extension
X86 Indirect Thunks
***** X86 Load Value Injection (LVI) Ret-Hardening : _GLOBAL__sub_I_Simpson.cpp *****
assembler backend - pre-layout
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1c87a00 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc14f2520 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCAlignFragment<MCFragment 0x7fffc1defba0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc16972a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[55,41,56,53,48,83,EC,30,89,F3,F2,0F,11,4C,24,28,F2,0F,11,44,24,18,49,89,FE,8D,43,01,C1,E8,1F,8D,2C,03,83,C5,01,83,E5,FE,F2,0F,10,44,24,28,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5C,44,24,18,F2,0F,11,04,24,0F,57,C0,F2,0F,2A,C5,F2,0F,10,0C,24,F2,0F,5E,C8,F2,0F,11,0C,24,F2,0F,10,04,24,F2,0F,58,44,24,18,FF,D7,F2,0F,11,44,24,08,66,0F,57,C0,F2,0F,11,44,24,10,83,FB,03] (120 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d6d440 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB0_4)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1df3980 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[66,0F,57,C0,F2,0F,11,44,24,10,BB,02,00,00,00,F2,0F,10,05,00,00,00,00,F2,0F,11,44,24,20] (29 bytes),
        Fixups:[<MCFixup Offset:19 Value:.LCPI0_0-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1697390 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1df3a70 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,0F,2A,C3,F2,0F,59,04,24,F2,0F,58,44,24,18,41,FF,D6,F2,0F,10,4C,24,10,F2,0F,58,C8,F2,0F,11,4C,24,10,F2,0F,10,04,24,F2,0F,59,44,24,20,F2,0F,58,44,24,18,41,FF,D6,F2,0F,10,4C,24,08,F2,0F,58,C8,F2,0F,11,4C,24,08,83,C3,02,F2,0F,10,44,24,20,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,20,39,EB] (98 bytes),
        Fixups:[<MCFixup Offset:86 Value:.LCPI0_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d6b9c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB0_2)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfc4a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,44,24,10,F2,0F,58,C0,F2,0F,11,44,24,10,F2,0F,10,44,24,18,41,FF,D6,F2,0F,11,44,24,20,F2,0F,10,44,24,28,41,FF,D6,66,0F,28,C8,F2,0F,58,4C,24,20,F2,0F,58,4C,24,10,F2,0F,10,44,24,08,F2,0F,59,05,00,00,00,00,F2,0F,11,44,24,08,F2,0F,10,44,24,08,F2,0F,58,C1,F2,0F,11,44,24,08,F2,0F,10,04,24,F2,0F,59,44,24,08,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,F2,0F,10,04,24,48,83,C4,30,5B,41,5E,5D,C3] (140 bytes),
        Fixups:[<MCFixup Offset:66 Value:.LCPI0_2-4 Kind:128>,
                <MCFixup Offset:117 Value:.LCPI0_0-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1dece40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1db7040 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,0D,00,00,00,00] (8 bytes),
        Fixups:[<MCFixup Offset:4 Value:.LCPI1_0-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d68a80 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1247 <MCOperand Expr:(pow)>> (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d6d240 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1690fd0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[55,41,57,41,56,41,54,53,48,83,EC,20,41,BF,02,00,00,00,41,BC,FB,FE,FF,FF] (24 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d65780 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1247 <MCOperand Expr:(.LBB2_1)>> (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d7aac0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1c87490 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,E8,00,00,00,00,48,8B,03,48,89,DF,BE,0A,00,00,00,FF,50,30,0F,BE,F0,4C,89,F7,E8,00,00,00,00,48,89,C7,E8,00,00,00,00,45,01,FF,41,81,FF,01,00,01,00] (51 bytes),
        Fixups:[<MCFixup Offset:4 Value:_ZNKSt5ctypeIcE13_M_widen_initEv-4 Kind:136>,
                <MCFixup Offset:29 Value:_ZNSo3putEc-4 Kind:136>,
                <MCFixup Offset:37 Value:_ZNSo5flushEv-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dc2e90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_10)> <MCOperand Imm:3>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1e08080 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[44,89,F8,83,C8,01,89,C5,C1,ED,1F,01,C5,83,E5,FE,F2,0F,2A,CD,F2,0F,10,05,00,00,00,00,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,C1,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,11,44,24,10,66,0F,57,C0,41,83,FF,03] (88 bytes),
        Fixups:[<MCFixup Offset:24 Value:.LCPI2_0-4 Kind:128>,
                <MCFixup Offset:57 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:65 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:70 Value:pow-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d47210 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_5)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1e08220 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,11,44,24,08,BB,02,00,00,00,F2,0F,10,05,00,00,00,00,F2,0F,11,44,24,18] (25 bytes),
        Fixups:[<MCFixup Offset:15 Value:.LCPI2_2-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1decd80 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1e0c2a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,0F,2A,C3,F2,0F,59,04,24,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,10,4C,24,08,F2,0F,58,C8,F2,0F,11,4C,24,08,F2,0F,10,04,24,F2,0F,59,44,24,18,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,10,4C,24,10,F2,0F,58,C8,F2,0F,11,4C,24,10,83,C3,02,F2,0F,10,44,24,18,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,18,39,EB] (124 bytes),
        Fixups:[<MCFixup Offset:17 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:25 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:30 Value:pow-4 Kind:136>,
                <MCFixup Offset:66 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:74 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:79 Value:pow-4 Kind:136>,
                <MCFixup Offset:112 Value:.LCPI2_3-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d50570 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_3)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1debbb0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,44,24,08,F2,0F,58,C0,F2,0F,11,44,24,08,F2,0F,10,44,24,08,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,08,F2,0F,10,44,24,10,F2,0F,59,05,00,00,00,00,F2,0F,11,44,24,10,F2,0F,10,44,24,10,F2,0F,58,44,24,08,F2,0F,11,44,24,10,F2,0F,10,04,24,F2,0F,59,44,24,10,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,BF,00,00,00,00,BE,00,00,00,00,BA,02,00,00,00,E8,00,00,00,00,48,8B,05,00,00,00,00,48,8B,40,E8,48,C7,80,00,00,00,00,06,00,00,00,BF,00,00,00,00,44,89,FE,E8,00,00,00,00,48,89,C3,BE,00,00,00,00,BA,04,00,00,00,48,89,C7,E8,00,00,00,00,48,8B,0B,48,8B,51,E8,8B,44,13,18,44,21,E0,83,C8,04,89,44,13,18,48,8B,41,E8,48,C7,44,03,08,10,00,00,00,48,8B,41,E8,48,C7,44,03,10,14,00,00,00,48,89,DF,F2,0F,10,04,24,E8,00,00,00,00,49,89,C6,48,8B,00,48,8B,40,E8,49,8B,9C,06,F0,00,00,00,48,85,DB] (265 bytes),
        Fixups:[<MCFixup Offset:26 Value:.LCPI2_0-4 Kind:128>,
                <MCFixup Offset:46 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:99 Value:.LCPI2_2-4 Kind:128>,
                <MCFixup Offset:109 Value:_ZSt4cout Kind:3>,
                <MCFixup Offset:114 Value:.L.str Kind:3>,
                <MCFixup Offset:124 Value:_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l-4 Kind:136>,
                <MCFixup Offset:131 Value:_ZSt4cout-4 Kind:129>,
                <MCFixup Offset:142 Value:_ZSt4cout+16 Kind:132>,
                <MCFixup Offset:151 Value:_ZSt4cout Kind:3>,
                <MCFixup Offset:159 Value:_ZNSolsEi-4 Kind:136>,
                <MCFixup Offset:167 Value:.L.str.1 Kind:3>,
                <MCFixup Offset:180 Value:_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l-4 Kind:136>,
                <MCFixup Offset:240 Value:_ZNSo9_M_insertIdEERSoT_-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1daf4c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_11)> <MCOperand Imm:4>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfd410 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[80,7B,38,00] (4 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1bae030 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_8)> <MCOperand Imm:4>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1c91310 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[8A,43,43] (3 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dfc1e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1247 <MCOperand Expr:(.LBB2_9)>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfc320 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[31,C0,48,83,C4,20,5B,41,5C,41,5E,41,5F,5D,C3,E8,00,00,00,00] (20 bytes),
        Fixups:[<MCFixup Offset:16 Value:_ZSt16__throw_bad_castv-4 Kind:136>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1698520 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d409c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1697a40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1df0e60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1defcd0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,08,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1decd20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1da3b60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8aca0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1ba5360 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1def590 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1c875d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c912b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1defab0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d6cd90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0x7fffc1d68720 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1c8b760 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1deb010 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1da93c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1decea0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0x7fffc1db7130 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1deaf20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1dc3070 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1dea9c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc0cf8e20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1dfaff0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d68ca0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1ded310 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8c600 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1daf2a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c85390 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1d9f6e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,08,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d6d010 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1696a00 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8c9b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1df21f0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d742b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1df0ec0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d65630 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1def5f0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1697b30 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1e1a260 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc16919a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1ded410 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Contents:[50,BF,00,00,00,00,E8,00,00,00,00,BF,00,00,00,00,BE,00,00,00,00,BA,00,00,00,00,58] (27 bytes),
        Fixups:[<MCFixup Offset:2 Value:_ZStL8__ioinit Kind:3>,
                <MCFixup Offset:7 Value:_ZNSt8ios_base4InitC1Ev-4 Kind:136>,
                <MCFixup Offset:12 Value:_ZNSt8ios_base4InitD1Ev Kind:3>,
                <MCFixup Offset:17 Value:_ZStL8__ioinit Kind:3>,
                <MCFixup Offset:22 Value:__dso_handle Kind:3>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dfb1a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1247 <MCOperand Expr:(__cxa_atexit)>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dba3d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1d7a8c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1e187b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:1 Value:0 ValueSize:1 MaxBytesToEmit:1>>,
      <MCDataFragment<MCFragment 0x7fffc1694620 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1e14d70 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:1>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1d70da0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[6E,3D,00,20,20,73,3D,00] (8 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1c8b460 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc0cf8860 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1c855c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00] (8 bytes),
        Fixups:[<MCFixup Offset:0 Value:_GLOBAL__sub_I_Simpson.cpp Kind:4>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1696af0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,63,6C,61,6E,67,20,76,65,72,73,69,6F,6E,20,31,32,2E,30,2E,30,20,28,68,74,74,70,73,3A,2F,2F,67,69,74,68,75,62,2E,63,6F,6D,2F,6C,6C,76,6D,2F,6C,6C,76,6D,2D,70,72,6F,6A,65,63,74,2E,67,69,74,20,34,39,39,30,31,34,31,61,34,33,36,36,65,62,30,30,61,62,64,63,38,32,35,32,64,37,63,62,62,38,61,64,65,61,63,62,39,39,35,34,29,00] (106 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1e0c730 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1696410 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,1B,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-4 Kind:3>]>,
      <MCAlignFragment<MCFragment 0x7fffc1e1f620 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1c8a0a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e1f580 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc5d90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1def040 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d51b30 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1c85860 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d903a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08c10 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e1ca20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d6ce10 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e1cb10 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1df5d70 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d79380 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08b70 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d79470 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfcc30 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbb870 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e04e50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbb960 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2fd0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbba50 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08d40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbbb40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1deaab0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1e182b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCAlignFragment<MCFragment 0x7fffc1dea550 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1e183a0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1c91400 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e18490 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e18580 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e18620 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e18710 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2950 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2a40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2ae0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,28] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2bd0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2c70 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,30] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2d60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfb970 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfba60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfbb00 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfbbf0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfbc90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8C,05] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfbd80 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05970 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05a60 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05b00 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8F,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05bf0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05c90 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05d80 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05e20 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,30] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e1f4d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d532c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,28] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d533b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d53450 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d53540 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d535e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d536d0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d53770 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08170 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1db9d40 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1db9e30 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1db9ed0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1defc00 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1db9fc0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dba0b0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dba150 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dba240 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dba2e0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1c895c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1d95ba0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(.text, Index:0, ),
           (.rodata.cst8, Index:0, ),
           (.LCPI0_0, Index:0, ),
           (.LCPI0_1, Index:0, ),
           (.LCPI0_2, Index:0, ),
           (_Z7simpsonPFddEddi, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB0_4, Index:0, ),
           (.LBB0_2, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI1_0, Index:0, ),
           (_Z4funcd, Index:0, ),
           (, Index:0, ),
           (pow, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI2_0, Index:0, ),
           (.LCPI2_1, Index:0, ),
           (.LCPI2_2, Index:0, ),
           (.LCPI2_3, Index:0, ),
           (.LCPI2_4, Index:0, ),
           (main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB2_1, Index:0, ),
           (.LBB2_8, Index:0, ),
           (_ZNKSt5ctypeIcE13_M_widen_initEv, Index:0, ),
           (.LBB2_9, Index:0, ),
           (_ZNSo3putEc, Index:0, ),
           (_ZNSo5flushEv, Index:0, ),
           (.LBB2_10, Index:0, ),
           (.LBB2_5, Index:0, ),
           (.LBB2_3, Index:0, ),
           (_ZSt4cout, Index:0, ),
           (.L.str, Index:0, ),
           (_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, Index:0, ),
           (_ZNSolsEi, Index:0, ),
           (.L.str.1, Index:0, ),
           (_ZNSo9_M_insertIdEERSoT_, Index:0, ),
           (.LBB2_11, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_ZSt16__throw_bad_castv, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.text.startup, Index:0, ),
           (_GLOBAL__sub_I_Simpson.cpp, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_ZStL8__ioinit, Index:0, ),
           (_ZNSt8ios_base4InitC1Ev, Index:0, ),
           (_ZNSt8ios_base4InitD1Ev, Index:0, ),
           (__dso_handle, Index:0, ),
           (, Index:0, ),
           (__cxa_atexit, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.bss, Index:0, ),
           (.rodata.str1.1, Index:0, ),
           (.init_array, Index:0, ),
           (.comment, Index:0, ),
           (.note.GNU-stack, Index:0, ),
           (.eh_frame, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
assembler backend - post-relaxation
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1c87a00 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc14f2520 LayoutOrder:1 Offset:0 HasInstructions:0> (emit nops)
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCAlignFragment<MCFragment 0x7fffc1defba0 LayoutOrder:2 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc16972a0 LayoutOrder:3 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[55,41,56,53,48,83,EC,30,89,F3,F2,0F,11,4C,24,28,F2,0F,11,44,24,18,49,89,FE,8D,43,01,C1,E8,1F,8D,2C,03,83,C5,01,83,E5,FE,F2,0F,10,44,24,28,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5C,44,24,18,F2,0F,11,04,24,0F,57,C0,F2,0F,2A,C5,F2,0F,10,0C,24,F2,0F,5E,C8,F2,0F,11,0C,24,F2,0F,10,04,24,F2,0F,58,44,24,18,FF,D7,F2,0F,11,44,24,08,66,0F,57,C0,F2,0F,11,44,24,10,83,FB,03] (120 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d6d440 LayoutOrder:4 Offset:120 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB0_4)> <MCOperand Imm:12>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1df3980 LayoutOrder:5 Offset:126 HasInstructions:1 BundlePadding:0>
        Contents:[66,0F,57,C0,F2,0F,11,44,24,10,BB,02,00,00,00,F2,0F,10,05,00,00,00,00,F2,0F,11,44,24,20] (29 bytes),
        Fixups:[<MCFixup Offset:19 Value:.LCPI0_0-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1697390 LayoutOrder:6 Offset:155 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1df3a70 LayoutOrder:7 Offset:160 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,0F,2A,C3,F2,0F,59,04,24,F2,0F,58,44,24,18,41,FF,D6,F2,0F,10,4C,24,10,F2,0F,58,C8,F2,0F,11,4C,24,10,F2,0F,10,04,24,F2,0F,59,44,24,20,F2,0F,58,44,24,18,41,FF,D6,F2,0F,10,4C,24,08,F2,0F,58,C8,F2,0F,11,4C,24,08,83,C3,02,F2,0F,10,44,24,20,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,20,39,EB] (98 bytes),
        Fixups:[<MCFixup Offset:86 Value:.LCPI0_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d6b9c0 LayoutOrder:8 Offset:258 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB0_2)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfc4a0 LayoutOrder:9 Offset:260 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,44,24,10,F2,0F,58,C0,F2,0F,11,44,24,10,F2,0F,10,44,24,18,41,FF,D6,F2,0F,11,44,24,20,F2,0F,10,44,24,28,41,FF,D6,66,0F,28,C8,F2,0F,58,4C,24,20,F2,0F,58,4C,24,10,F2,0F,10,44,24,08,F2,0F,59,05,00,00,00,00,F2,0F,11,44,24,08,F2,0F,10,44,24,08,F2,0F,58,C1,F2,0F,11,44,24,08,F2,0F,10,04,24,F2,0F,59,44,24,08,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,F2,0F,10,04,24,48,83,C4,30,5B,41,5E,5D,C3] (140 bytes),
        Fixups:[<MCFixup Offset:66 Value:.LCPI0_2-4 Kind:128>,
                <MCFixup Offset:117 Value:.LCPI0_0-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1dece40 LayoutOrder:10 Offset:400 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1db7040 LayoutOrder:11 Offset:400 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,0D,00,00,00,00] (8 bytes),
        Fixups:[<MCFixup Offset:4 Value:.LCPI1_0-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d68a80 LayoutOrder:12 Offset:408 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1249 <MCOperand Expr:(pow)>> (5 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d6d240 LayoutOrder:13 Offset:413 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1690fd0 LayoutOrder:14 Offset:416 HasInstructions:1 BundlePadding:0>
        Contents:[55,41,57,41,56,41,54,53,48,83,EC,20,41,BF,02,00,00,00,41,BC,FB,FE,FF,FF] (24 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d65780 LayoutOrder:15 Offset:440 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1247 <MCOperand Expr:(.LBB2_1)>> (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d7aac0 LayoutOrder:16 Offset:442 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1c87490 LayoutOrder:17 Offset:448 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,E8,00,00,00,00,48,8B,03,48,89,DF,BE,0A,00,00,00,FF,50,30,0F,BE,F0,4C,89,F7,E8,00,00,00,00,48,89,C7,E8,00,00,00,00,45,01,FF,41,81,FF,01,00,01,00] (51 bytes),
        Fixups:[<MCFixup Offset:4 Value:_ZNKSt5ctypeIcE13_M_widen_initEv-4 Kind:136>,
                <MCFixup Offset:29 Value:_ZNSo3putEc-4 Kind:136>,
                <MCFixup Offset:37 Value:_ZNSo5flushEv-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dc2e90 LayoutOrder:18 Offset:499 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB2_10)> <MCOperand Imm:3>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1e08080 LayoutOrder:19 Offset:505 HasInstructions:1 BundlePadding:0>
        Contents:[44,89,F8,83,C8,01,89,C5,C1,ED,1F,01,C5,83,E5,FE,F2,0F,2A,CD,F2,0F,10,05,00,00,00,00,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,C1,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,11,44,24,10,66,0F,57,C0,41,83,FF,03] (88 bytes),
        Fixups:[<MCFixup Offset:24 Value:.LCPI2_0-4 Kind:128>,
                <MCFixup Offset:57 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:65 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:70 Value:pow-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d47210 LayoutOrder:20 Offset:593 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB2_5)> <MCOperand Imm:12>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1e08220 LayoutOrder:21 Offset:599 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,11,44,24,08,BB,02,00,00,00,F2,0F,10,05,00,00,00,00,F2,0F,11,44,24,18] (25 bytes),
        Fixups:[<MCFixup Offset:15 Value:.LCPI2_2-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1decd80 LayoutOrder:22 Offset:624 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1e0c2a0 LayoutOrder:23 Offset:624 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,0F,2A,C3,F2,0F,59,04,24,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,10,4C,24,08,F2,0F,58,C8,F2,0F,11,4C,24,08,F2,0F,10,04,24,F2,0F,59,44,24,18,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,10,4C,24,10,F2,0F,58,C8,F2,0F,11,4C,24,10,83,C3,02,F2,0F,10,44,24,18,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,18,39,EB] (124 bytes),
        Fixups:[<MCFixup Offset:17 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:25 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:30 Value:pow-4 Kind:136>,
                <MCFixup Offset:66 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:74 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:79 Value:pow-4 Kind:136>,
                <MCFixup Offset:112 Value:.LCPI2_3-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d50570 LayoutOrder:24 Offset:748 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_3)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1debbb0 LayoutOrder:25 Offset:750 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,44,24,08,F2,0F,58,C0,F2,0F,11,44,24,08,F2,0F,10,44,24,08,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,08,F2,0F,10,44,24,10,F2,0F,59,05,00,00,00,00,F2,0F,11,44,24,10,F2,0F,10,44,24,10,F2,0F,58,44,24,08,F2,0F,11,44,24,10,F2,0F,10,04,24,F2,0F,59,44,24,10,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,BF,00,00,00,00,BE,00,00,00,00,BA,02,00,00,00,E8,00,00,00,00,48,8B,05,00,00,00,00,48,8B,40,E8,48,C7,80,00,00,00,00,06,00,00,00,BF,00,00,00,00,44,89,FE,E8,00,00,00,00,48,89,C3,BE,00,00,00,00,BA,04,00,00,00,48,89,C7,E8,00,00,00,00,48,8B,0B,48,8B,51,E8,8B,44,13,18,44,21,E0,83,C8,04,89,44,13,18,48,8B,41,E8,48,C7,44,03,08,10,00,00,00,48,8B,41,E8,48,C7,44,03,10,14,00,00,00,48,89,DF,F2,0F,10,04,24,E8,00,00,00,00,49,89,C6,48,8B,00,48,8B,40,E8,49,8B,9C,06,F0,00,00,00,48,85,DB] (265 bytes),
        Fixups:[<MCFixup Offset:26 Value:.LCPI2_0-4 Kind:128>,
                <MCFixup Offset:46 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:99 Value:.LCPI2_2-4 Kind:128>,
                <MCFixup Offset:109 Value:_ZSt4cout Kind:3>,
                <MCFixup Offset:114 Value:.L.str Kind:3>,
                <MCFixup Offset:124 Value:_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l-4 Kind:136>,
                <MCFixup Offset:131 Value:_ZSt4cout-4 Kind:129>,
                <MCFixup Offset:142 Value:_ZSt4cout+16 Kind:132>,
                <MCFixup Offset:151 Value:_ZSt4cout Kind:3>,
                <MCFixup Offset:159 Value:_ZNSolsEi-4 Kind:136>,
                <MCFixup Offset:167 Value:.L.str.1 Kind:3>,
                <MCFixup Offset:180 Value:_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l-4 Kind:136>,
                <MCFixup Offset:240 Value:_ZNSo9_M_insertIdEERSoT_-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1daf4c0 LayoutOrder:26 Offset:1015 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_11)> <MCOperand Imm:4>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfd410 LayoutOrder:27 Offset:1017 HasInstructions:1 BundlePadding:0>
        Contents:[80,7B,38,00] (4 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1bae030 LayoutOrder:28 Offset:1021 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB2_8)> <MCOperand Imm:4>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1c91310 LayoutOrder:29 Offset:1027 HasInstructions:1 BundlePadding:0>
        Contents:[8A,43,43] (3 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dfc1e0 LayoutOrder:30 Offset:1030 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1249 <MCOperand Expr:(.LBB2_9)>> (5 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfc320 LayoutOrder:31 Offset:1035 HasInstructions:1 BundlePadding:0>
        Contents:[31,C0,48,83,C4,20,5B,41,5C,41,5E,41,5F,5D,C3,E8,00,00,00,00] (20 bytes),
        Fixups:[<MCFixup Offset:16 Value:_ZSt16__throw_bad_castv-4 Kind:136>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1698520 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d409c0 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1697a40 LayoutOrder:2 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1df0e60 LayoutOrder:3 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1defcd0 LayoutOrder:4 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,08,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1decd20 LayoutOrder:5 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1da3b60 LayoutOrder:6 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8aca0 LayoutOrder:7 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1ba5360 LayoutOrder:8 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1def590 LayoutOrder:9 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1c875d0 LayoutOrder:10 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c912b0 LayoutOrder:11 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1defab0 LayoutOrder:12 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d6cd90 LayoutOrder:13 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0x7fffc1d68720 LayoutOrder:14 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1c8b760 LayoutOrder:15 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1deb010 LayoutOrder:16 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1da93c0 LayoutOrder:17 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1decea0 LayoutOrder:18 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0x7fffc1db7130 LayoutOrder:19 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1deaf20 LayoutOrder:20 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1dc3070 LayoutOrder:21 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1dea9c0 LayoutOrder:22 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc0cf8e20 LayoutOrder:23 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1dfaff0 LayoutOrder:24 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d68ca0 LayoutOrder:25 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1ded310 LayoutOrder:26 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8c600 LayoutOrder:27 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1daf2a0 LayoutOrder:28 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c85390 LayoutOrder:29 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1d9f6e0 LayoutOrder:30 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,08,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d6d010 LayoutOrder:31 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1696a00 LayoutOrder:32 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8c9b0 LayoutOrder:33 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1df21f0 LayoutOrder:34 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d742b0 LayoutOrder:35 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1df0ec0 LayoutOrder:36 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d65630 LayoutOrder:37 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1def5f0 LayoutOrder:38 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1697b30 LayoutOrder:39 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1e1a260 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc16919a0 LayoutOrder:1 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1ded410 LayoutOrder:2 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[50,BF,00,00,00,00,E8,00,00,00,00,BF,00,00,00,00,BE,00,00,00,00,BA,00,00,00,00,58] (27 bytes),
        Fixups:[<MCFixup Offset:2 Value:_ZStL8__ioinit Kind:3>,
                <MCFixup Offset:7 Value:_ZNSt8ios_base4InitC1Ev-4 Kind:136>,
                <MCFixup Offset:12 Value:_ZNSt8ios_base4InitD1Ev Kind:3>,
                <MCFixup Offset:17 Value:_ZStL8__ioinit Kind:3>,
                <MCFixup Offset:22 Value:__dso_handle Kind:3>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dfb1a0 LayoutOrder:3 Offset:27 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1249 <MCOperand Expr:(__cxa_atexit)>> (5 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dba3d0 LayoutOrder:4 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1d7a8c0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1e187b0 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0>
        Alignment:1 Value:0 ValueSize:1 MaxBytesToEmit:1>>,
      <MCDataFragment<MCFragment 0x7fffc1694620 LayoutOrder:2 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1e14d70 LayoutOrder:3 Offset:18446744073709551615 HasInstructions:0> Value:0 ValueSize:1 NumValues:1>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1d70da0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[6E,3D,00,20,20,73,3D,00] (8 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1c8b460 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc0cf8860 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1c855c0 LayoutOrder:2 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00] (8 bytes),
        Fixups:[<MCFixup Offset:0 Value:_GLOBAL__sub_I_Simpson.cpp Kind:4>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1696af0 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,63,6C,61,6E,67,20,76,65,72,73,69,6F,6E,20,31,32,2E,30,2E,30,20,28,68,74,74,70,73,3A,2F,2F,67,69,74,68,75,62,2E,63,6F,6D,2F,6C,6C,76,6D,2F,6C,6C,76,6D,2D,70,72,6F,6A,65,63,74,2E,67,69,74,20,34,39,39,30,31,34,31,61,34,33,36,36,65,62,30,30,61,62,64,63,38,32,35,32,64,37,63,62,62,38,61,64,65,61,63,62,39,39,35,34,29,00] (106 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1e0c730 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1696410 LayoutOrder:0 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,1B,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-4 Kind:3>]>,
      <MCAlignFragment<MCFragment 0x7fffc1e1f620 LayoutOrder:1 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1c8a0a0 LayoutOrder:2 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e1f580 LayoutOrder:3 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc5d90 LayoutOrder:4 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1def040 LayoutOrder:5 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d51b30 LayoutOrder:6 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1c85860 LayoutOrder:7 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d903a0 LayoutOrder:8 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08c10 LayoutOrder:9 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e1ca20 LayoutOrder:10 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d6ce10 LayoutOrder:11 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e1cb10 LayoutOrder:12 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1df5d70 LayoutOrder:13 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d79380 LayoutOrder:14 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08b70 LayoutOrder:15 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d79470 LayoutOrder:16 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfcc30 LayoutOrder:17 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbb870 LayoutOrder:18 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e04e50 LayoutOrder:19 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbb960 LayoutOrder:20 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2fd0 LayoutOrder:21 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbba50 LayoutOrder:22 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08d40 LayoutOrder:23 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbbb40 LayoutOrder:24 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1deaab0 LayoutOrder:25 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1e182b0 LayoutOrder:26 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCAlignFragment<MCFragment 0x7fffc1dea550 LayoutOrder:27 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1e183a0 LayoutOrder:28 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1c91400 LayoutOrder:29 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e18490 LayoutOrder:30 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e18580 LayoutOrder:31 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e18620 LayoutOrder:32 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e18710 LayoutOrder:33 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2950 LayoutOrder:34 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2a40 LayoutOrder:35 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2ae0 LayoutOrder:36 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,28] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2bd0 LayoutOrder:37 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2c70 LayoutOrder:38 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,30] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2d60 LayoutOrder:39 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfb970 LayoutOrder:40 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfba60 LayoutOrder:41 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfbb00 LayoutOrder:42 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[83,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfbbf0 LayoutOrder:43 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfbc90 LayoutOrder:44 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8C,05] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfbd80 LayoutOrder:45 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05970 LayoutOrder:46 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8E,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05a60 LayoutOrder:47 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05b00 LayoutOrder:48 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[8F,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05bf0 LayoutOrder:49 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05c90 LayoutOrder:50 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05d80 LayoutOrder:51 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05e20 LayoutOrder:52 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,30] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e1f4d0 LayoutOrder:53 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d532c0 LayoutOrder:54 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,28] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d533b0 LayoutOrder:55 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d53450 LayoutOrder:56 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d53540 LayoutOrder:57 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d535e0 LayoutOrder:58 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d536d0 LayoutOrder:59 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d53770 LayoutOrder:60 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08170 LayoutOrder:61 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1db9d40 LayoutOrder:62 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1db9e30 LayoutOrder:63 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1db9ed0 LayoutOrder:64 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1defc00 LayoutOrder:65 Offset:18446744073709551615 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1db9fc0 LayoutOrder:66 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dba0b0 LayoutOrder:67 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dba150 LayoutOrder:68 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dba240 LayoutOrder:69 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dba2e0 LayoutOrder:70 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1c895c0 LayoutOrder:71 Offset:18446744073709551615 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1d95ba0 LayoutOrder:72 Offset:18446744073709551615 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(.text, Index:0, ),
           (.rodata.cst8, Index:0, ),
           (.LCPI0_0, Index:0, ),
           (.LCPI0_1, Index:0, ),
           (.LCPI0_2, Index:0, ),
           (_Z7simpsonPFddEddi, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB0_4, Index:0, ),
           (.LBB0_2, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI1_0, Index:0, ),
           (_Z4funcd, Index:0, ),
           (, Index:0, ),
           (pow, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI2_0, Index:0, ),
           (.LCPI2_1, Index:0, ),
           (.LCPI2_2, Index:0, ),
           (.LCPI2_3, Index:0, ),
           (.LCPI2_4, Index:0, ),
           (main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB2_1, Index:0, ),
           (.LBB2_8, Index:0, ),
           (_ZNKSt5ctypeIcE13_M_widen_initEv, Index:0, ),
           (.LBB2_9, Index:0, ),
           (_ZNSo3putEc, Index:0, ),
           (_ZNSo5flushEv, Index:0, ),
           (.LBB2_10, Index:0, ),
           (.LBB2_5, Index:0, ),
           (.LBB2_3, Index:0, ),
           (_ZSt4cout, Index:0, ),
           (.L.str, Index:0, ),
           (_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, Index:0, ),
           (_ZNSolsEi, Index:0, ),
           (.L.str.1, Index:0, ),
           (_ZNSo9_M_insertIdEERSoT_, Index:0, ),
           (.LBB2_11, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_ZSt16__throw_bad_castv, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.text.startup, Index:0, ),
           (_GLOBAL__sub_I_Simpson.cpp, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_ZStL8__ioinit, Index:0, ),
           (_ZNSt8ios_base4InitC1Ev, Index:0, ),
           (_ZNSt8ios_base4InitD1Ev, Index:0, ),
           (__dso_handle, Index:0, ),
           (, Index:0, ),
           (__cxa_atexit, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.bss, Index:0, ),
           (.rodata.str1.1, Index:0, ),
           (.init_array, Index:0, ),
           (.comment, Index:0, ),
           (.note.GNU-stack, Index:0, ),
           (.eh_frame, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
assembler backend - final-layout
--
<MCAssembler
  Sections:[
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1c87a00 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc14f2520 LayoutOrder:1 Offset:0 HasInstructions:0> (emit nops)
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCAlignFragment<MCFragment 0x7fffc1defba0 LayoutOrder:2 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc16972a0 LayoutOrder:3 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[55,41,56,53,48,83,EC,30,89,F3,F2,0F,11,4C,24,28,F2,0F,11,44,24,18,49,89,FE,8D,43,01,C1,E8,1F,8D,2C,03,83,C5,01,83,E5,FE,F2,0F,10,44,24,28,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5C,44,24,18,F2,0F,11,04,24,0F,57,C0,F2,0F,2A,C5,F2,0F,10,0C,24,F2,0F,5E,C8,F2,0F,11,0C,24,F2,0F,10,04,24,F2,0F,58,44,24,18,FF,D7,F2,0F,11,44,24,08,66,0F,57,C0,F2,0F,11,44,24,10,83,FB,03] (120 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d6d440 LayoutOrder:4 Offset:120 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB0_4)> <MCOperand Imm:12>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1df3980 LayoutOrder:5 Offset:126 HasInstructions:1 BundlePadding:0>
        Contents:[66,0F,57,C0,F2,0F,11,44,24,10,BB,02,00,00,00,F2,0F,10,05,00,00,00,00,F2,0F,11,44,24,20] (29 bytes),
        Fixups:[<MCFixup Offset:19 Value:.LCPI0_0-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1697390 LayoutOrder:6 Offset:155 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1df3a70 LayoutOrder:7 Offset:160 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,0F,2A,C3,F2,0F,59,04,24,F2,0F,58,44,24,18,41,FF,D6,F2,0F,10,4C,24,10,F2,0F,58,C8,F2,0F,11,4C,24,10,F2,0F,10,04,24,F2,0F,59,44,24,20,F2,0F,58,44,24,18,41,FF,D6,F2,0F,10,4C,24,08,F2,0F,58,C8,F2,0F,11,4C,24,08,83,C3,02,F2,0F,10,44,24,20,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,20,39,EB] (98 bytes),
        Fixups:[<MCFixup Offset:86 Value:.LCPI0_1-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d6b9c0 LayoutOrder:8 Offset:258 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB0_2)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfc4a0 LayoutOrder:9 Offset:260 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,44,24,10,F2,0F,58,C0,F2,0F,11,44,24,10,F2,0F,10,44,24,18,41,FF,D6,F2,0F,11,44,24,20,F2,0F,10,44,24,28,41,FF,D6,66,0F,28,C8,F2,0F,58,4C,24,20,F2,0F,58,4C,24,10,F2,0F,10,44,24,08,F2,0F,59,05,00,00,00,00,F2,0F,11,44,24,08,F2,0F,10,44,24,08,F2,0F,58,C1,F2,0F,11,44,24,08,F2,0F,10,04,24,F2,0F,59,44,24,08,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,F2,0F,10,04,24,48,83,C4,30,5B,41,5E,5D,C3] (140 bytes),
        Fixups:[<MCFixup Offset:66 Value:.LCPI0_2-4 Kind:128>,
                <MCFixup Offset:117 Value:.LCPI0_0-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1dece40 LayoutOrder:10 Offset:400 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1db7040 LayoutOrder:11 Offset:400 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,0D,00,00,00,00] (8 bytes),
        Fixups:[<MCFixup Offset:4 Value:.LCPI1_0-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d68a80 LayoutOrder:12 Offset:408 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1249 <MCOperand Expr:(pow)>> (5 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d6d240 LayoutOrder:13 Offset:413 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1690fd0 LayoutOrder:14 Offset:416 HasInstructions:1 BundlePadding:0>
        Contents:[55,41,57,41,56,41,54,53,48,83,EC,20,41,BF,02,00,00,00,41,BC,FB,FE,FF,FF] (24 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d65780 LayoutOrder:15 Offset:440 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1247 <MCOperand Expr:(.LBB2_1)>> (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d7aac0 LayoutOrder:16 Offset:442 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1c87490 LayoutOrder:17 Offset:448 HasInstructions:1 BundlePadding:0>
        Contents:[48,89,DF,E8,00,00,00,00,48,8B,03,48,89,DF,BE,0A,00,00,00,FF,50,30,0F,BE,F0,4C,89,F7,E8,00,00,00,00,48,89,C7,E8,00,00,00,00,45,01,FF,41,81,FF,01,00,01,00] (51 bytes),
        Fixups:[<MCFixup Offset:4 Value:_ZNKSt5ctypeIcE13_M_widen_initEv-4 Kind:136>,
                <MCFixup Offset:29 Value:_ZNSo3putEc-4 Kind:136>,
                <MCFixup Offset:37 Value:_ZNSo5flushEv-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dc2e90 LayoutOrder:18 Offset:499 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB2_10)> <MCOperand Imm:3>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1e08080 LayoutOrder:19 Offset:505 HasInstructions:1 BundlePadding:0>
        Contents:[44,89,F8,83,C8,01,89,C5,C1,ED,1F,01,C5,83,E5,FE,F2,0F,2A,CD,F2,0F,10,05,00,00,00,00,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,C1,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,11,44,24,10,66,0F,57,C0,41,83,FF,03] (88 bytes),
        Fixups:[<MCFixup Offset:24 Value:.LCPI2_0-4 Kind:128>,
                <MCFixup Offset:57 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:65 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:70 Value:pow-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d47210 LayoutOrder:20 Offset:593 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB2_5)> <MCOperand Imm:12>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1e08220 LayoutOrder:21 Offset:599 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,11,44,24,08,BB,02,00,00,00,F2,0F,10,05,00,00,00,00,F2,0F,11,44,24,18] (25 bytes),
        Fixups:[<MCFixup Offset:15 Value:.LCPI2_2-4 Kind:128>]>,
      <MCAlignFragment<MCFragment 0x7fffc1decd80 LayoutOrder:22 Offset:624 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1e0c2a0 LayoutOrder:23 Offset:624 HasInstructions:1 BundlePadding:0>
        Contents:[0F,57,C0,F2,0F,2A,C3,F2,0F,59,04,24,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,10,4C,24,08,F2,0F,58,C8,F2,0F,11,4C,24,08,F2,0F,10,04,24,F2,0F,59,44,24,18,F2,0F,58,04,25,00,00,00,00,F2,0F,10,0D,00,00,00,00,E8,00,00,00,00,F2,0F,10,4C,24,10,F2,0F,58,C8,F2,0F,11,4C,24,10,83,C3,02,F2,0F,10,44,24,18,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,18,39,EB] (124 bytes),
        Fixups:[<MCFixup Offset:17 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:25 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:30 Value:pow-4 Kind:136>,
                <MCFixup Offset:66 Value:.LCPI2_4 Kind:132>,
                <MCFixup Offset:74 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:79 Value:pow-4 Kind:136>,
                <MCFixup Offset:112 Value:.LCPI2_3-4 Kind:128>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1d50570 LayoutOrder:24 Offset:748 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_3)> <MCOperand Imm:12>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1debbb0 LayoutOrder:25 Offset:750 HasInstructions:1 BundlePadding:0>
        Contents:[F2,0F,10,44,24,08,F2,0F,58,C0,F2,0F,11,44,24,08,F2,0F,10,44,24,08,F2,0F,58,05,00,00,00,00,F2,0F,11,44,24,08,F2,0F,10,44,24,10,F2,0F,59,05,00,00,00,00,F2,0F,11,44,24,10,F2,0F,10,44,24,10,F2,0F,58,44,24,08,F2,0F,11,44,24,10,F2,0F,10,04,24,F2,0F,59,44,24,10,F2,0F,11,04,24,F2,0F,10,04,24,F2,0F,5E,05,00,00,00,00,F2,0F,11,04,24,BF,00,00,00,00,BE,00,00,00,00,BA,02,00,00,00,E8,00,00,00,00,48,8B,05,00,00,00,00,48,8B,40,E8,48,C7,80,00,00,00,00,06,00,00,00,BF,00,00,00,00,44,89,FE,E8,00,00,00,00,48,89,C3,BE,00,00,00,00,BA,04,00,00,00,48,89,C7,E8,00,00,00,00,48,8B,0B,48,8B,51,E8,8B,44,13,18,44,21,E0,83,C8,04,89,44,13,18,48,8B,41,E8,48,C7,44,03,08,10,00,00,00,48,8B,41,E8,48,C7,44,03,10,14,00,00,00,48,89,DF,F2,0F,10,04,24,E8,00,00,00,00,49,89,C6,48,8B,00,48,8B,40,E8,49,8B,9C,06,F0,00,00,00,48,85,DB] (265 bytes),
        Fixups:[<MCFixup Offset:26 Value:.LCPI2_0-4 Kind:128>,
                <MCFixup Offset:46 Value:.LCPI2_1-4 Kind:128>,
                <MCFixup Offset:99 Value:.LCPI2_2-4 Kind:128>,
                <MCFixup Offset:109 Value:_ZSt4cout Kind:3>,
                <MCFixup Offset:114 Value:.L.str Kind:3>,
                <MCFixup Offset:124 Value:_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l-4 Kind:136>,
                <MCFixup Offset:131 Value:_ZSt4cout-4 Kind:129>,
                <MCFixup Offset:142 Value:_ZSt4cout+16 Kind:132>,
                <MCFixup Offset:151 Value:_ZSt4cout Kind:3>,
                <MCFixup Offset:159 Value:_ZNSolsEi-4 Kind:136>,
                <MCFixup Offset:167 Value:.L.str.1 Kind:3>,
                <MCFixup Offset:180 Value:_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l-4 Kind:136>,
                <MCFixup Offset:240 Value:_ZNSo9_M_insertIdEERSoT_-4 Kind:136>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1daf4c0 LayoutOrder:26 Offset:1015 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1228 <MCOperand Expr:(.LBB2_11)> <MCOperand Imm:4>> (2 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfd410 LayoutOrder:27 Offset:1017 HasInstructions:1 BundlePadding:0>
        Contents:[80,7B,38,00] (4 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1bae030 LayoutOrder:28 Offset:1021 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1230 <MCOperand Expr:(.LBB2_8)> <MCOperand Imm:4>> (6 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1c91310 LayoutOrder:29 Offset:1027 HasInstructions:1 BundlePadding:0>
        Contents:[8A,43,43] (3 bytes)>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dfc1e0 LayoutOrder:30 Offset:1030 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1249 <MCOperand Expr:(.LBB2_9)>> (5 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dfc320 LayoutOrder:31 Offset:1035 HasInstructions:1 BundlePadding:0>
        Contents:[31,C0,48,83,C4,20,5B,41,5C,41,5E,41,5F,5D,C3,E8,00,00,00,00] (20 bytes),
        Fixups:[<MCFixup Offset:16 Value:_ZSt16__throw_bad_castv-4 Kind:136>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1698520 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1d409c0 LayoutOrder:1 Offset:0 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1697a40 LayoutOrder:2 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1df0e60 LayoutOrder:3 Offset:0 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1defcd0 LayoutOrder:4 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,08,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1decd20 LayoutOrder:5 Offset:8 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1da3b60 LayoutOrder:6 Offset:8 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8aca0 LayoutOrder:7 Offset:8 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1ba5360 LayoutOrder:8 Offset:8 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1def590 LayoutOrder:9 Offset:16 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1c875d0 LayoutOrder:10 Offset:16 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c912b0 LayoutOrder:11 Offset:16 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1defab0 LayoutOrder:12 Offset:16 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d6cd90 LayoutOrder:13 Offset:24 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0x7fffc1d68720 LayoutOrder:14 Offset:24 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1c8b760 LayoutOrder:15 Offset:24 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1deb010 LayoutOrder:16 Offset:24 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1da93c0 LayoutOrder:17 Offset:24 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1decea0 LayoutOrder:18 Offset:32 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCAlignFragment<MCFragment 0x7fffc1db7130 LayoutOrder:19 Offset:32 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1deaf20 LayoutOrder:20 Offset:32 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1dc3070 LayoutOrder:21 Offset:32 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1dea9c0 LayoutOrder:22 Offset:32 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,F0,3F] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc0cf8e20 LayoutOrder:23 Offset:40 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1dfaff0 LayoutOrder:24 Offset:40 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d68ca0 LayoutOrder:25 Offset:40 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1ded310 LayoutOrder:26 Offset:40 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,10,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8c600 LayoutOrder:27 Offset:48 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1daf2a0 LayoutOrder:28 Offset:48 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c85390 LayoutOrder:29 Offset:48 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1d9f6e0 LayoutOrder:30 Offset:48 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,08,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d6d010 LayoutOrder:31 Offset:56 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1696a00 LayoutOrder:32 Offset:56 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1c8c9b0 LayoutOrder:33 Offset:56 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1df21f0 LayoutOrder:34 Offset:56 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,40] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d742b0 LayoutOrder:35 Offset:64 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1df0ec0 LayoutOrder:36 Offset:64 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1d65630 LayoutOrder:37 Offset:64 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>,
      <MCDataFragment<MCFragment 0x7fffc1def5f0 LayoutOrder:38 Offset:64 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00] (8 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1697b30 LayoutOrder:39 Offset:72 HasInstructions:0> Value:0 ValueSize:1 NumValues:0>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1e1a260 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc16919a0 LayoutOrder:1 Offset:0 HasInstructions:0> (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16>>,
      <MCDataFragment<MCFragment 0x7fffc1ded410 LayoutOrder:2 Offset:0 HasInstructions:1 BundlePadding:0>
        Contents:[50,BF,00,00,00,00,E8,00,00,00,00,BF,00,00,00,00,BE,00,00,00,00,BA,00,00,00,00,58] (27 bytes),
        Fixups:[<MCFixup Offset:2 Value:_ZStL8__ioinit Kind:3>,
                <MCFixup Offset:7 Value:_ZNSt8ios_base4InitC1Ev-4 Kind:136>,
                <MCFixup Offset:12 Value:_ZNSt8ios_base4InitD1Ev Kind:3>,
                <MCFixup Offset:17 Value:_ZStL8__ioinit Kind:3>,
                <MCFixup Offset:22 Value:__dso_handle Kind:3>]>,
      <MCRelaxableFragment<MCFragment 0x7fffc1dfb1a0 LayoutOrder:3 Offset:27 HasInstructions:1 BundlePadding:0>
        Inst:<MCInst #1249 <MCOperand Expr:(__cxa_atexit)>> (5 bytes)>,
      <MCDataFragment<MCFragment 0x7fffc1dba3d0 LayoutOrder:4 Offset:32 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1d7a8c0 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1e187b0 LayoutOrder:1 Offset:0 HasInstructions:0>
        Alignment:1 Value:0 ValueSize:1 MaxBytesToEmit:1>>,
      <MCDataFragment<MCFragment 0x7fffc1694620 LayoutOrder:2 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCFillFragment<MCFragment 0x7fffc1e14d70 LayoutOrder:3 Offset:0 HasInstructions:0> Value:0 ValueSize:1 NumValues:1>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1d70da0 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[6E,3D,00,20,20,73,3D,00] (8 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1c8b460 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc0cf8860 LayoutOrder:1 Offset:0 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1c855c0 LayoutOrder:2 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00] (8 bytes),
        Fixups:[<MCFixup Offset:0 Value:_GLOBAL__sub_I_Simpson.cpp Kind:4>]>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1696af0 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,63,6C,61,6E,67,20,76,65,72,73,69,6F,6E,20,31,32,2E,30,2E,30,20,28,68,74,74,70,73,3A,2F,2F,67,69,74,68,75,62,2E,63,6F,6D,2F,6C,6C,76,6D,2F,6C,6C,76,6D,2D,70,72,6F,6A,65,63,74,2E,67,69,74,20,34,39,39,30,31,34,31,61,34,33,36,36,65,62,30,30,61,62,64,63,38,32,35,32,64,37,63,62,62,38,61,64,65,61,63,62,39,39,35,34,29,00] (106 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1e0c730 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>,
    <MCSection Fragments:[
      <MCDataFragment<MCFragment 0x7fffc1696410 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,01,7A,52,00,01,78,10,01,1B,0C,07,08,90,01] (22 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-4 Kind:3>]>,
      <MCAlignFragment<MCFragment 0x7fffc1e1f620 LayoutOrder:1 Offset:22 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1c8a0a0 LayoutOrder:2 Offset:24 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e1f580 LayoutOrder:3 Offset:41 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc5d90 LayoutOrder:4 Offset:42 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1def040 LayoutOrder:5 Offset:44 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d51b30 LayoutOrder:6 Offset:45 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1c85860 LayoutOrder:7 Offset:47 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d903a0 LayoutOrder:8 Offset:48 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08c10 LayoutOrder:9 Offset:50 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e1ca20 LayoutOrder:10 Offset:51 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d6ce10 LayoutOrder:11 Offset:53 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e1cb10 LayoutOrder:12 Offset:53 HasInstructions:0 BundlePadding:0>
        Contents:[83,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1df5d70 LayoutOrder:13 Offset:55 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d79380 LayoutOrder:14 Offset:55 HasInstructions:0 BundlePadding:0>
        Contents:[8E,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08b70 LayoutOrder:15 Offset:57 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d79470 LayoutOrder:16 Offset:57 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfcc30 LayoutOrder:17 Offset:59 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbb870 LayoutOrder:18 Offset:62 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e04e50 LayoutOrder:19 Offset:64 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbb960 LayoutOrder:20 Offset:65 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2fd0 LayoutOrder:21 Offset:67 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbba50 LayoutOrder:22 Offset:68 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08d40 LayoutOrder:23 Offset:70 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dbbb40 LayoutOrder:24 Offset:71 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1deaab0 LayoutOrder:25 Offset:73 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1e182b0 LayoutOrder:26 Offset:76 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCAlignFragment<MCFragment 0x7fffc1dea550 LayoutOrder:27 Offset:93 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1e183a0 LayoutOrder:28 Offset:96 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1c91400 LayoutOrder:29 Offset:113 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e18490 LayoutOrder:30 Offset:114 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e18580 LayoutOrder:31 Offset:116 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e18620 LayoutOrder:32 Offset:117 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e18710 LayoutOrder:33 Offset:119 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2950 LayoutOrder:34 Offset:120 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2a40 LayoutOrder:35 Offset:122 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2ae0 LayoutOrder:36 Offset:123 HasInstructions:0 BundlePadding:0>
        Contents:[0E,28] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2bd0 LayoutOrder:37 Offset:125 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dc2c70 LayoutOrder:38 Offset:126 HasInstructions:0 BundlePadding:0>
        Contents:[0E,30] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dc2d60 LayoutOrder:39 Offset:128 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfb970 LayoutOrder:40 Offset:129 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfba60 LayoutOrder:41 Offset:131 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfbb00 LayoutOrder:42 Offset:131 HasInstructions:0 BundlePadding:0>
        Contents:[83,06] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfbbf0 LayoutOrder:43 Offset:133 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dfbc90 LayoutOrder:44 Offset:133 HasInstructions:0 BundlePadding:0>
        Contents:[8C,05] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dfbd80 LayoutOrder:45 Offset:135 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05970 LayoutOrder:46 Offset:135 HasInstructions:0 BundlePadding:0>
        Contents:[8E,04] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05a60 LayoutOrder:47 Offset:137 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05b00 LayoutOrder:48 Offset:137 HasInstructions:0 BundlePadding:0>
        Contents:[8F,03] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05bf0 LayoutOrder:49 Offset:139 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05c90 LayoutOrder:50 Offset:139 HasInstructions:0 BundlePadding:0>
        Contents:[86,02] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e05d80 LayoutOrder:51 Offset:141 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1e05e20 LayoutOrder:52 Offset:144 HasInstructions:0 BundlePadding:0>
        Contents:[0E,30] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e1f4d0 LayoutOrder:53 Offset:146 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d532c0 LayoutOrder:54 Offset:147 HasInstructions:0 BundlePadding:0>
        Contents:[0E,28] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d533b0 LayoutOrder:55 Offset:149 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d53450 LayoutOrder:56 Offset:150 HasInstructions:0 BundlePadding:0>
        Contents:[0E,20] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d53540 LayoutOrder:57 Offset:152 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d535e0 LayoutOrder:58 Offset:153 HasInstructions:0 BundlePadding:0>
        Contents:[0E,18] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1d536d0 LayoutOrder:59 Offset:155 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1d53770 LayoutOrder:60 Offset:156 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1e08170 LayoutOrder:61 Offset:158 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1db9d40 LayoutOrder:62 Offset:159 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1db9e30 LayoutOrder:63 Offset:161 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1db9ed0 LayoutOrder:64 Offset:162 HasInstructions:0 BundlePadding:0>
        Contents:[0E,50] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1defc00 LayoutOrder:65 Offset:164 HasInstructions:0>
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4>>,
      <MCDataFragment<MCFragment 0x7fffc1db9fc0 LayoutOrder:66 Offset:164 HasInstructions:0 BundlePadding:0>
        Contents:[00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00] (17 bytes),
        Fixups:[<MCFixup Offset:0 Value:(-)-0 Kind:3>,
                <MCFixup Offset:4 Value:(-)-0 Kind:3>,
                <MCFixup Offset:8 Value:- Kind:3>,
                <MCFixup Offset:12 Value:(-)-0 Kind:3>]>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dba0b0 LayoutOrder:67 Offset:181 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dba150 LayoutOrder:68 Offset:182 HasInstructions:0 BundlePadding:0>
        Contents:[0E,10] (2 bytes)>,
      <MCDwarfCallFrameFragment<MCFragment 0x7fffc1dba240 LayoutOrder:69 Offset:184 HasInstructions:0 BundlePadding:0>
        AddrDelta:->,
      <MCDataFragment<MCFragment 0x7fffc1dba2e0 LayoutOrder:70 Offset:185 HasInstructions:0 BundlePadding:0>
        Contents:[0E,08] (2 bytes)>,
      <MCAlignFragment<MCFragment 0x7fffc1c895c0 LayoutOrder:71 Offset:187 HasInstructions:0>
        Alignment:8 Value:0 ValueSize:1 MaxBytesToEmit:8>>,
      <MCDataFragment<MCFragment 0x7fffc1d95ba0 LayoutOrder:72 Offset:192 HasInstructions:0 BundlePadding:0>
        Contents:[] (0 bytes)>]>],
  Symbols:[(.text, Index:0, ),
           (.rodata.cst8, Index:0, ),
           (.LCPI0_0, Index:0, ),
           (.LCPI0_1, Index:0, ),
           (.LCPI0_2, Index:0, ),
           (_Z7simpsonPFddEddi, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB0_4, Index:0, ),
           (.LBB0_2, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI1_0, Index:0, ),
           (_Z4funcd, Index:0, ),
           (, Index:0, ),
           (pow, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LCPI2_0, Index:0, ),
           (.LCPI2_1, Index:0, ),
           (.LCPI2_2, Index:0, ),
           (.LCPI2_3, Index:0, ),
           (.LCPI2_4, Index:0, ),
           (main, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.LBB2_1, Index:0, ),
           (.LBB2_8, Index:0, ),
           (_ZNKSt5ctypeIcE13_M_widen_initEv, Index:0, ),
           (.LBB2_9, Index:0, ),
           (_ZNSo3putEc, Index:0, ),
           (_ZNSo5flushEv, Index:0, ),
           (.LBB2_10, Index:0, ),
           (.LBB2_5, Index:0, ),
           (.LBB2_3, Index:0, ),
           (_ZSt4cout, Index:0, ),
           (.L.str, Index:0, ),
           (_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l, Index:0, ),
           (_ZNSolsEi, Index:0, ),
           (.L.str.1, Index:0, ),
           (_ZNSo9_M_insertIdEERSoT_, Index:0, ),
           (.LBB2_11, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_ZSt16__throw_bad_castv, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.text.startup, Index:0, ),
           (_GLOBAL__sub_I_Simpson.cpp, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (_ZStL8__ioinit, Index:0, ),
           (_ZNSt8ios_base4InitC1Ev, Index:0, ),
           (_ZNSt8ios_base4InitD1Ev, Index:0, ),
           (__dso_handle, Index:0, ),
           (, Index:0, ),
           (__cxa_atexit, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (.bss, Index:0, ),
           (.rodata.str1.1, Index:0, ),
           (.init_array, Index:0, ),
           (.comment, Index:0, ),
           (.note.GNU-stack, Index:0, ),
           (.eh_frame, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, ),
           (, Index:0, )]>
